/// <reference types="node" />
import * as Bluebird from 'bluebird';
import { BitGo } from '../bitgo';
import { NodeCallback } from './types';
import { RequestTracer } from './internal/util';
import { Wallet } from './wallet';
import { Wallets } from './wallets';
import { Markets } from './markets';
import { Webhooks } from './webhooks';
import { PendingApprovals } from './pendingApprovals';
import { Keychain, Keychains } from './keychains';
import { Enterprises } from './enterprises';
export interface TransactionRecipient {
    address: string;
    amount: string | number;
}
export interface TransactionFee {
    fee: string;
    feeRate?: number;
    size?: number;
}
export interface TransactionExplanation {
    displayOrder: string[];
    id: string;
    outputs: TransactionRecipient[];
    outputAmount: string;
    changeOutputs: TransactionRecipient[];
    changeAmount: string;
    fee: TransactionFee;
    proxy?: string;
    producers?: string[];
}
export interface KeyPair {
    pub?: string;
    prv: string;
}
export interface VerifyAddressOptions {
    address: string;
    addressType?: string;
    keychains?: {
        pub: string;
    }[];
    coinSpecific?: AddressCoinSpecific;
}
export interface TransactionParams {
    recipients?: TransactionRecipient[];
    walletPassphrase?: string;
    type?: string;
}
export interface VerificationOptions {
    disableNetworking?: boolean;
    keychains?: {
        user?: Keychain;
        backup?: Keychain;
    };
}
export interface VerifyTransactionOptions {
    txPrebuild: TransactionPrebuild;
    txParams: TransactionParams;
    wallet: Wallet;
    verification?: VerificationOptions;
    reqId?: RequestTracer;
}
export interface SupplementGenerateWalletOptions {
    label: string;
    m: number;
    n: number;
    enterprise?: string;
    disableTransactionNotifications?: boolean;
    gasPrice?: number;
    keys: string[];
    isCold: boolean;
    keySignatures?: {
        backup: string;
        bitgo: string;
    };
    rootPrivateKey?: string;
    disableKRSEmail?: boolean;
}
export interface FeeEstimateOptions {
    numBlocks?: number;
    hop?: boolean;
    recipient?: string;
    data?: string;
    amount?: string;
}
export declare type ExtraPrebuildParamsOptions = any;
export declare type PresignTransactionOptions = any;
export declare type PrecreateBitGoOptions = any;
export declare type VerifyRecoveryTransactionOptions = any;
export declare type ParseTransactionOptions = any;
export declare type ParsedTransaction = any;
export declare type SignTransactionOptions = any;
export interface InitiateRecoveryOptions {
    userKey: string;
    backupKey: string;
    bitgoKey?: string;
    recoveryDestination: string;
    walletPassphrase?: string;
}
export interface KeychainsTriplet {
    userKeychain: Keychain;
    backupKeychain: Keychain;
    bitgoKeychain: Keychain;
}
export interface TransactionPrebuild {
    txBase64?: string;
    txHex?: string;
    wallet?: Wallet;
    buildParams?: any;
    consolidateId?: string;
}
export interface AddressCoinSpecific {
    outputScript?: string;
    redeemScript?: string;
    witnessScript?: string;
    baseAddress?: string;
}
export interface FullySignedTransaction {
    txHex: string;
}
export interface HalfSignedTransaction {
    halfSigned?: {
        txHex?: string;
        payload?: string;
        txBase64?: string;
    };
}
export declare type SignedTransaction = HalfSignedTransaction | FullySignedTransaction;
export declare abstract class BaseCoin {
    protected readonly bitgo: BitGo;
    protected readonly _url: string;
    protected readonly _enterprises: Enterprises;
    protected readonly _wallets: Wallets;
    protected readonly _keychains: Keychains;
    protected readonly _webhooks: Webhooks;
    protected readonly _pendingApprovals: PendingApprovals;
    protected readonly _markets: Markets;
    protected static readonly _coinTokenPatternSeparator = ":";
    protected constructor(bitgo: BitGo);
    url(suffix: string): string;
    wallets(): Wallets;
    enterprises(): Enterprises;
    keychains(): Keychains;
    webhooks(): Webhooks;
    pendingApprovals(): PendingApprovals;
    markets(): Markets;
    static readonly coinTokenPatternSeparator: string;
    readonly type: string;
    /**
     * Name of the chain which supports this coin (eg, 'btc', 'eth')
     */
    abstract getChain(): string;
    /**
     * Name of the coin family (eg. for tbtc, this would be btc)
     */
    abstract getFamily(): string;
    /**
     * Human readable full name for the coin
     */
    abstract getFullName(): string;
    /**
     * Flag for sending value of 0.
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed(): boolean;
    /**
     * Flag for determining whether this coin supports account consolidations
     * from its receive addresses to the root address.
     * @returns {boolean} True if okay to consolidate over this coin; false, otherwise
     */
    allowsAccountConsolidations(): boolean;
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    abstract getBaseFactor(): number | string;
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, rmg, xrp, xlm)
     */
    baseUnitsToBigUnits(baseUnits: string | number): string;
    /**
     * Convert a currency amount represented in big units (btc, eth, rmg, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    bigUnitsToBaseUnits(bigUnits: string | number): string;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: {
        prv: string;
    }, message: string): Buffer;
    /**
     * Verify that a transaction prebuild complies with the original intention
     */
    abstract verifyTransaction(params: VerifyTransactionOptions, callback?: NodeCallback<boolean>): Bluebird<boolean>;
    /**
     * Verify that an address belongs to a wallet
     * @returns {boolean}
     */
    abstract verifyAddress(params: VerifyAddressOptions): boolean;
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    supportsBlockTarget(): boolean;
    /**
     * Hook to add additional parameters to the wallet generation
     * @param walletParams
     * @param keychains
     * @return {*}
     */
    supplementGenerateWallet(walletParams: SupplementGenerateWalletOptions, keychains: KeychainsTriplet): Bluebird<any>;
    /**
     * Get extra parameters for prebuilding a tx. Add things like hop transaction params
     */
    getExtraPrebuildParams(buildParams: ExtraPrebuildParamsOptions, callback?: NodeCallback<object>): Bluebird<object>;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(prebuildResponse: TransactionPrebuild, callback?: NodeCallback<TransactionPrebuild>): Bluebird<TransactionPrebuild>;
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     */
    presignTransaction(params: PresignTransactionOptions, callback?: NodeCallback<TransactionPrebuild>): Bluebird<TransactionPrebuild>;
    /**
     * Create a new wallet object from a wallet data object
     * @param walletParams
     */
    newWalletObject(walletParams: any): Wallet;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @param callback
     * @returns {Object} The info returned from the merchant server
     */
    feeEstimate(params: FeeEstimateOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: string, derivationPath: string}}
     */
    deriveKeyWithSeed({ key, seed }: {
        key: string;
        seed: string;
    }): {
        key: string;
        derivationPath: string;
    };
    /**
     * Specifies what key we will need for signing - right now we just need the
     * user key.
     */
    keyIdsForSigning(): number[];
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    initiateRecovery(params: InitiateRecoveryOptions): Bluebird<any>;
    verifyRecoveryTransaction(txInfo: VerifyRecoveryTransactionOptions): Bluebird<any>;
    abstract parseTransaction(params: ParseTransactionOptions, callback?: NodeCallback<ParsedTransaction>): Bluebird<ParsedTransaction>;
    /**
     * Generate a key pair on the curve used by the coin
     *
     * @param seed
     */
    abstract generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    abstract isValidPub(pub: string): boolean;
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    isValidMofNSetup({ m, n }: {
        m?: number;
        n?: number;
    }): boolean;
    /**
     * Check if `address` is a plausibly valid address for the given coin.
     *
     * Does not verify that the address belongs to a wallet. For that,
     * use [[verifyAddress]]
     * @param address
     */
    abstract isValidAddress(address: string): boolean;
    /**
     * Sign a transaction
     */
    abstract signTransaction(params: SignTransactionOptions): SignedTransaction;
}
//# sourceMappingURL=baseCoin.d.ts.map