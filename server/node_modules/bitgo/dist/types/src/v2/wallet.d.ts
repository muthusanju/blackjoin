import * as Bluebird from 'bluebird';
import { BitGo } from '../bitgo';
import { BaseCoin, SignedTransaction, TransactionPrebuild, VerificationOptions } from './baseCoin';
import { Keychain } from './keychains';
import { TradingAccount } from './trading/tradingAccount';
import { NodeCallback } from './types';
import { PendingApproval } from './pendingApproval';
import { RequestTracer } from './internal/util';
export interface MaximumSpendableOptions {
    minValue?: number;
    maxValue?: number;
    minHeight?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    feeRate?: number;
    maxFeeRate?: number;
    recipientAddress?: string;
    limit?: number;
    target?: number;
    plainTarget?: number;
}
export interface MaximumSpendable {
    maximumSpendable: number;
    coin: string;
}
export interface Memo {
    value: string;
    type: string;
}
/**
 * A small set of parameters should be used for building a consolidation transaction:
 * - walletPassphrase - necessary for signing
 * - feeRate
 * - maxFeeRate
 * - validFromBlock
 * - validToBlock
 *
 * What shouldn't be passed (these will be ignored):
 * - recipients
 */
export interface BuildConsolidationTransactionOptions extends PrebuildTransactionOptions {
    fromAddresses?: string[];
}
export interface PrebuildTransactionOptions {
    reqId?: RequestTracer;
    recipients?: {
        address: string;
        amount: string | number;
    }[];
    numBlocks?: number;
    feeRate?: number;
    maxFeeRate?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    targetWalletUnspents?: number;
    minValue?: number;
    maxValue?: number;
    sequenceId?: number;
    lastLedgerSequence?: number;
    ledgerSequenceDelta?: string;
    gasPrice?: number;
    noSplitChange?: boolean;
    unspents?: any[];
    changeAddress?: string;
    validFromBlock?: number;
    validToBlock?: number;
    instant?: boolean;
    memo?: Memo;
    addressType?: string;
    hop?: boolean;
    walletPassphrase?: string;
    reservation?: {
        expireTime?: string;
        pendingApprovalId?: string;
    };
}
export interface PrebuildAndSignTransactionOptions extends PrebuildTransactionOptions {
    prebuildTx?: string | PrebuildTransactionResult;
    verification?: VerificationOptions;
}
export interface PrebuildTransactionResult extends TransactionPrebuild {
    walletId: string;
    consolidateId?: string;
}
export interface WalletSignTransactionOptions {
    txPrebuild?: TransactionPrebuild;
    prv?: string;
    isLastSignature?: boolean;
}
export interface GetUserPrvOptions {
    keychain?: Keychain;
    key?: Keychain;
    prv?: string;
    coldDerivationSeed?: string;
    walletPassphrase?: string;
}
export interface WalletCoinSpecific {
    tokenFlushThresholds?: any;
    addressVersion?: number;
    baseAddress?: string;
    rootAddress?: string;
}
export interface PaginationOptions {
    prevId?: string;
    limit?: number;
}
export interface GetTransactionOptions extends PaginationOptions {
    txHash?: string;
}
export interface TransfersOptions extends PaginationOptions {
    txHash?: string;
    allTokens?: string;
    searchLabel?: string;
    address?: string[] | string;
    dateGte?: string;
    dateLt?: string;
    valueGte?: string;
    valueLt?: string;
    includeHex?: boolean;
    state?: string[] | string;
    type?: string;
}
export interface GetTransferOptions {
    id?: string;
}
export interface TransferBySequenceIdOptions {
    sequenceId?: string;
}
export interface UnspentsOptions extends PaginationOptions {
    minValue?: number;
    maxValue?: number;
    minHeight?: number;
    minConfirms?: number;
    target?: number;
    segwit?: boolean;
    chains?: number[];
}
export interface ConsolidateUnspentsOptions {
    walletPassphrase?: string;
    xprv?: string;
    minValue?: number;
    maxValue?: number;
    minHeight?: number;
    numUnspentsToMake?: number;
    feeTxConfirmTarget?: number;
    limit?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    feeRate?: number;
    maxFeeRate?: number;
    maxFeePercentage?: number;
    comment?: string;
    otp?: string;
}
export interface FanoutUnspentsOptions {
    walletPassphrase?: string;
    xprv?: string;
    minValue?: number;
    maxValue?: number;
    minHeight?: number;
    maxNumInputsToUse?: number;
    numUnspentsToMake?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    feeRate?: number;
    maxFeeRate?: number;
    maxFeePercentage?: number;
    feeTxConfirmTarget?: number;
    comment?: string;
    otp?: string;
}
export interface SweepOptions {
    address?: string;
    walletPassphrase?: string;
    xprv?: string;
    otp?: string;
    feeRate?: number;
    maxFeeRate?: number;
    feeTxConfirmTarget?: number;
    allowPartialSweep?: boolean;
}
export interface FreezeOptions {
    duration?: number;
}
export interface TransferCommentOptions {
    id?: string;
    comment?: string;
}
export interface AddressesOptions extends PaginationOptions {
    mine?: boolean;
    sort?: number;
    labelContains?: string;
    segwit?: boolean;
    chains?: number[];
}
export interface GetAddressOptions {
    address?: string;
    id?: string;
    reqId?: RequestTracer;
}
export interface CreateAddressOptions {
    chain?: number;
    gasPrice?: number | string;
    count?: number;
    label?: string;
    lowPriority?: boolean;
}
export interface UpdateAddressOptions {
    label?: string;
    address?: string;
}
export interface SimulateWebhookOptions {
    webhookId?: string;
    transferId?: string;
    pendingApprovalId?: string;
}
export interface ModifyWebhookOptions {
    url?: string;
    type?: string;
}
export interface GetPrvOptions {
    prv?: string;
    walletPassphrase?: string;
}
export interface CreateShareOptions {
    user?: string;
    permissions?: string;
    keychain?: {
        pub?: string;
        encryptedPrv?: string;
        fromPubKey?: string;
        toPubKey?: string;
        path?: string;
    };
    reshare?: boolean;
    message?: string;
    disableEmail?: boolean;
}
export interface ShareWalletOptions {
    email?: string;
    permissions?: string;
    walletPassphrase?: string;
    message?: string;
    reshare?: boolean;
    skipKeychain?: boolean;
    disableEmail?: boolean;
}
export interface RemoveUserOptions {
    userId?: string;
}
export interface AccelerateTransactionOptions {
    cpfpTxIds?: string[];
    cpfpFeeRate?: number;
    noCpfpFeeRate?: boolean;
    maxFee?: number;
    noMaxFee?: boolean;
    recipients?: {
        address: string;
        amount: string;
    }[];
}
export interface SubmitTransactionOptions {
    otp?: string;
    txHex?: string;
    halfSigned?: string;
}
export interface SendOptions {
    address?: string;
    amount?: number | string;
    data?: string;
    message?: string;
    walletPassphrase?: string;
    prv?: string;
    minConfirms?: number;
    enforceMinConfirmsForChange?: number;
}
export interface SendManyOptions {
    reqId?: RequestTracer;
    recipients?: {
        address: string;
        amount: string | number;
        data?: string;
    }[];
    numBlocks?: number;
    feeRate?: number;
    maxFeeRate?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    targetWalletUnspents?: number;
    message?: string;
    minValue?: number;
    maxValue?: number;
    sequenceId?: number;
    lastLedgerSequence?: number;
    ledgerSequenceDelta?: string;
    gasPrice?: number;
    noSplitChange?: boolean;
    unspents?: string[];
    comment?: string;
    otp?: string;
    changeAddress?: string;
    instant?: boolean;
    memo?: Memo;
}
export interface RecoverTokenOptions {
    tokenContractAddress?: string;
    recipient?: string;
    broadcast?: boolean;
    walletPassphrase?: string;
    prv?: string;
}
export interface ChangeFeeOptions {
    txid?: string;
    fee?: string;
}
export interface CreatePolicyRuleOptions {
    id?: string;
    type?: string;
    message?: string;
    condition?: unknown;
    action?: unknown;
}
export interface SetPolicyRuleOptions {
    id?: string;
    type?: string;
    message?: string;
    condition?: unknown;
    action?: unknown;
}
export interface RemovePolicyRuleOptions {
    id?: string;
    message?: string;
}
export interface DownloadKeycardOptions {
    jsPDF?: any;
    QRCode?: any;
    userKeychain?: Keychain;
    backupKeychain?: Keychain;
    bitgoKeychain?: Keychain;
    passphrase?: string;
    passcodeEncryptionCode?: string;
    activationCode?: string;
    walletKeyID?: string;
    backupKeyID?: string;
}
export declare class Wallet {
    readonly bitgo: BitGo;
    readonly baseCoin: BaseCoin;
    private _wallet;
    private readonly _permissions?;
    constructor(bitgo: BitGo, baseCoin: BaseCoin, walletData: any);
    /**
     * Build a URL using this wallet's id which can be used for BitGo API operations
     * @param extra API specific string to append to the wallet id
     */
    url(extra?: string): string;
    /**
     * Get this wallet's id
     */
    id(): string;
    /**
     * Get the number of approvals required for spending funds from this wallet
     */
    approvalsRequired(): number;
    /**
     * Get the current balance of this wallet
     */
    balance(): number;
    prebuildWhitelistedParams(): string[];
    /**
     * This is a strict sub-set of prebuildWhitelistedParams.
     */
    prebuildConsolidateTransactionParams(): string[];
    /**
     * Get the confirmed balance of this wallet
     */
    confirmedBalance(): number;
    /**
     * Get the spendable balance of this wallet
     */
    spendableBalance(): number;
    /**
     * Get a string representation of the balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    balanceString(): string;
    /**
     * Get a string representation of the confirmed balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    confirmedBalanceString(): string;
    /**
     * Get a string representation of the spendable balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    spendableBalanceString(): string;
    /**
     * Get the coin identifier for the type of coin this wallet holds
     */
    coin(): string;
    /**
     * Get the label (name) for this wallet
     */
    label(): string;
    /**
     * Get the public object ids for the keychains on this wallet.
     */
    keyIds(): string[];
    /**
     * Get a receive address for this wallet
     */
    receiveAddress(): string;
    /**
     * Get the wallet id of the wallet that this wallet was migrated from.
     *
     * For example, if this is a BCH wallet that was created from a BTC wallet,
     * the BCH wallet migrated from field would have the BTC wallet id.
     */
    migratedFrom(): string | undefined;
    /**
     * Return the token flush thresholds for this wallet
     * @return {*|Object} pairs of { [tokenName]: thresholds } base units
     */
    tokenFlushThresholds(): any;
    /**
     * Get wallet properties which are specific to certain coin implementations
     */
    coinSpecific(): WalletCoinSpecific | undefined;
    /**
     * Get all pending approvals on this wallet
     */
    pendingApprovals(): PendingApproval[];
    /**
     * Refresh the wallet object by syncing with the back-end
     * @param params
     * @param callback
     * @returns {Wallet}
     */
    refresh(params?: {}, callback?: NodeCallback<Wallet>): Bluebird<Wallet>;
    /**
     * List the transactions for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    transactions(params?: PaginationOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * List the transactions for a given wallet
     * @param params
     *  - txHash the transaction hash to search for
     * @param callback
     * @returns {*}
     */
    getTransaction(params?: GetTransactionOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * List the transfers for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    transfers(params?: TransfersOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get transfers on this wallet
     * @param params
     * @param callback
     */
    getTransfer(params?: GetTransferOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get a transaction by sequence id for a given wallet
     * @param params
     * @param callback
     */
    transferBySequenceId(params?: TransferBySequenceIdOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get the maximum amount you can spend in a single transaction
     *
     * @param {Object} params - parameters object
     * @param {Number} params.limit - maximum number of selectable unspents
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
     * @param callback
     * @returns {{maximumSpendable: Number, coin: String}}
     * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
     */
    maximumSpendable(params?: MaximumSpendableOptions, callback?: NodeCallback<MaximumSpendable>): Bluebird<MaximumSpendable>;
    /**
     * List the unspents for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    unspents(params?: UnspentsOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Consolidate or fanout unspents on a wallet
     *
     * @param {String} routeName - either `consolidate` or `fanout`
     *
     * @param {Object} params - parameters object
     *
     * Wallet parameters:
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     *
     * Fee parameters:
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     *
     * Input parameters:
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumUnspentsToUse  for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * Output parameters:
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     *
     * @param callback
     */
    private manageUnspents;
    /**
     * Consolidate unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumUnspentsToUse  for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param callback
     */
    consolidateUnspents(params?: ConsolidateUnspentsOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Fanout unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.minValue - the minimum value of unspents to use
     * @param {Number} params.maxValue - the maximum value of unspents to use
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
     * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param callback
     */
    fanoutUnspents(params?: FanoutUnspentsOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Set the token flush thresholds for the wallet. Updates the wallet.
     * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
     * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
     * @param [callback]
     */
    updateTokenFlushThresholds(thresholds?: any, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Sweep funds for a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.address - The address to send all the funds in the wallet to
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
     * @param {Boolean} [params.allowPartialSweep] - allows sweeping 200 unspents when the wallet has more than that
     * @param [callback]
     * @returns txHex {String} the txHex of the signed transaction
     */
    sweep(params?: SweepOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Freeze a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    freeze(params?: FreezeOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Update comment of a transfer
     * @param params
     * @param callback
     * @returns {*}
     */
    transferComment(params?: TransferCommentOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * List the addresses for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    addresses(params?: AddressesOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get a single wallet address by its id
     * @param params
     * @param callback
     * @returns {*}
     */
    getAddress(params?: GetAddressOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Create one or more new address(es) for use with this wallet.
     *
     * If the `count` field is defined and greater than 1, an object with a single
     * array property named `addresses` containing `count` address objects
     * will be returned. Otherwise, a single address object is returned.
     *
     * @param params
     * @param {Number} params.chain on which the new address should be created
     * @param {(Number|String)} params.gasPrice gas price for new address creation, if applicable
     * @param {String} params.label label for the new address(es)
     * @param {Number} params.count=1 number of new addresses which should be created (maximum 250)
     * @param {Boolean} params.lowPriority Ethereum-specific param to create address using low priority fee address
     * @param callback
     */
    createAddress(params?: CreateAddressOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Update properties on an address
     * @param params
     * @param callback
     * @returns {*}
     */
    updateAddress(params?: UpdateAddressOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * List webhooks on this wallet
     * @param params
     * @param callback
     */
    listWebhooks(params?: PaginationOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
     * @param params
     * - webhookId (required) id of the webhook to be simulated
     * - transferId (optional but required for transfer webhooks) id of the simulated transfer
     * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
     * @param callback
     * @returns {*}
     */
    simulateWebhook(params?: SimulateWebhookOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Add a webhook to this wallet
     * @param params
     * @param callback
     */
    addWebhook(params?: ModifyWebhookOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Remove a webhook from this wallet
     * @param params
     * @param callback
     */
    removeWebhook(params?: ModifyWebhookOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Gets the user key chain for this wallet
     *
     * The user key chain is the first keychain of the wallet and usually has the encrypted prv stored on BitGo.
     * Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
     * @param params
     * @param callback
     */
    getEncryptedUserKeychain(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Gets the unencrypted private key for this wallet (be careful!)
     * Requires wallet passphrase
     *
     * @param params
     * @param callback
     */
    getPrv(params?: GetPrvOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Send an encrypted wallet share to BitGo.
     * @param params
     * @param callback
     */
    createShare(params?: CreateShareOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Share this wallet with another BitGo user.
     * @param params
     * @param callback
     * @returns {*}
     */
    shareWallet(params?: ShareWalletOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Remove user from wallet
     * @param params
     * - userId Id of the user to remove
     * @param callback
     * @return {*}
     */
    removeUser(params?: RemoveUserOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Fetch a transaction prebuild (unsigned transaction) from BitGo
     *
     * @param {Object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
     * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the walletâ€™s current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of base units
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of base units
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Number} params.gasLimit - Custom gas limit to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Number} params.validFromBlock - (Algorand) The minimum round this will run on
     * @param {Number} params.validToBlock - (Algorand) The maximum round this will run on
     * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
     * @param {Boolean} params.hop - Build this as an Ethereum hop transaction
     * @param {Object} params.reservation - Object to reserve the unspents that this tx build uses. Format is reservation = { expireTime: ISODateString, pendingApprovalId: String }
     * @param {String} params.walletPassphrase The passphrase to the wallet user key, to sign commitment data for Ethereum hop transactions
     * @param callback
     * @returns {*}
     */
    prebuildTransaction(params?: PrebuildTransactionOptions, callback?: NodeCallback<PrebuildTransactionResult>): Bluebird<PrebuildTransactionResult>;
    /**
     * Sign a transaction
     * @param params
     * - txPrebuild
     * - [keychain / key] (object) or prv (string)
     * - walletPassphrase
     * @param callback
     * @return {*}
     */
    signTransaction(params?: WalletSignTransactionOptions, callback?: NodeCallback<SignedTransaction>): Bluebird<SignedTransaction>;
    /**
     * Get the user private key from either a derivation or an encrypted keychain
     * @param [params.keychain / params.key] (object) or params.prv (string)
     * @param params.walletPassphrase (string)
     */
    getUserPrv(params?: GetUserPrvOptions): string;
    /**
     * Get a transaction prebuild from BitGo, validate it, and then decrypt the user key and sign the transaction
     * @param params
     * @param callback
     */
    prebuildAndSignTransaction(params?: PrebuildAndSignTransactionOptions, callback?: NodeCallback<SignedTransaction>): Bluebird<SignedTransaction>;
    /**
     * Accelerate a transaction's confirmation using Child-Pays-For-Parent (CPFP)
     * @param params
     * @param callback
     */
    accelerateTransaction(params?: AccelerateTransactionOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Submit a half-signed transaction to BitGo
     * @param params
     * - txHex: transaction hex to submit
     * - halfSigned: object containing transaction (txHex or txBase64) to submit
     * @param callback
     */
    submitTransaction(params?: SubmitTransactionOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Send coins to a recipient
     * @param params
     * @param params.address - the destination address
     * @param params.amount - the amount in satoshis/wei/base value to be sent
     * @param params.message - optional message to attach to transaction
     * @param params.data - [Ethereum Specific] optional data to pass to transaction
     * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
     * @param params.prv - the private key in string form, if walletPassphrase is not available
     * @param params.minConfirms - the minimum confirmation threshold for inputs
     * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
     * @param callback
     * @returns {*}
     */
    send(params?: SendOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Send money to multiple recipients
     * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
     * 2. Decrypts user key
     * 3. Creates the transaction with default fee
     * 4. Signs transaction with decrypted user key
     * 5. Sends the transaction to BitGo
     * @param {object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
     * @param {String} params.message - optional message to attach to transaction
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of satoshis
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of satoshis
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.comment - Any additional comment to attach to the transaction
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.type - Type of the transaction (e.g. trustline)
     * @param {{token: params, action: String, limit: String}[]} options.trustlines - Array of trustlines to manage (supported by Stellar)
     * @param callback
     * @returns {*}
     */
    sendMany(params?: SendManyOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * params are validated in Eth.prototype.recoverToken
     * @param params
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param callback
     */
    recoverToken(params?: RecoverTokenOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get transaction metadata for the oldest transaction that is still pending or attempted
     * @param params
     * @param callback
     * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
     */
    getFirstPendingTransaction(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
     * @param params
     * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
     * @param {String} params.fee The new fee to apply to the denoted transaction
     * @param callback
     * @returns {String} The transaction ID of the new transaction that contains the new fee rate
     */
    changeFee(params?: ChangeFeeOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Fetch info from merchant server
     * @param {Object} params The params passed into the function
     * @param {String} params.url The Url to retrieve info from
     * @param callback
     * @returns {Object} The info returned from the merchant server
     * @deprecated
     */
    getPaymentInfo(params?: {
        url?: string;
    }, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Send json payment response
     * @param {Object} params The params passed into the function
     * @param {String} params.paymentUrl - The url to send the fully signed transaction to
     * @param {String} params.txHex - The transaction hex of the payment
     * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
     * @param {String} params.expires {String} - ISO Date format of when the payment request expires
     * @param callback
     * @returns {Object} The info returned from the merchant server Payment Ack
     * @deprecated
     */
    sendPaymentResponse(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Create a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @param callback
     * @returns {*}
     */
    createPolicyRule(params?: CreatePolicyRuleOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Update a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @param callback
     * @returns {*}
     */
    setPolicyRule(params?: any, callback?: NodeCallback<any>): Bluebird<unknown>;
    /**
     * Remove Policy Rule
     * @param params
     * @param callback
     * @returns {*}
     */
    removePolicyRule(params?: RemovePolicyRuleOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Remove this wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    remove(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Create a trading account from this wallet
     */
    toTradingAccount(): TradingAccount;
    /**
     * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
     *
     * Note: this is example code and is not the version used on bitgo.com
     *
     * @param params
     *   * jsPDF - an instance of the jsPDF library
     *   * QRCode - an instance of the QRious library
     *   * userKeychain - a wallet's private user keychain
     *   * backupKeychain - a wallet's private backup keychain
     *   * bitgoKeychain - a wallet's private bitgo keychain
     *   * passphrase - the wallet passphrase
     *   * passcodeEncryptionCode - the encryption secret used for Box D
     *   * activationCode - a randomly generated six-digit activation code
     *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
     *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
     * @returns {*}
     */
    downloadKeycard(params?: DownloadKeycardOptions): void;
    /**
     * Builds a set of consolidation transactions for a wallet.
     * @param params
     *     fromAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     * @param callback
     */
    buildAccountConsolidations(params?: BuildConsolidationTransactionOptions, callback?: NodeCallback<PrebuildTransactionResult[]>): Bluebird<PrebuildTransactionResult[]>;
    /**
     * Builds and sends a set of consolidation transactions for a wallet.
     * @param params
     *     fromAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    sendAccountConsolidation(params?: PrebuildAndSignTransactionOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Builds and sends a set of account consolidations. This is intended to flush many balances to the root wallet balance.
     * @param params
     * @param callback
     */
    sendAccountConsolidations(params?: BuildConsolidationTransactionOptions, callback?: NodeCallback<any>): Bluebird<any>;
}
//# sourceMappingURL=wallet.d.ts.map