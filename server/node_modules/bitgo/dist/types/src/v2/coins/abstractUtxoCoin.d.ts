/// <reference types="node" />
import * as Bluebird from 'bluebird';
import { UnspentType } from '@bitgo/unspents/dist/codes';
import { BitGo } from '../../bitgo';
import { BaseCoin, AddressCoinSpecific, ExtraPrebuildParamsOptions, KeychainsTriplet, PrecreateBitGoOptions, PresignTransactionOptions, SupplementGenerateWalletOptions, VerifyAddressOptions as BaseVerifyAddressOptions, VerifyRecoveryTransactionOptions, VerifyTransactionOptions, TransactionParams as BaseTransactionParams, TransactionPrebuild as BaseTransactionPrebuild, VerificationOptions } from '../baseCoin';
import { Keychain } from '../keychains';
import { NodeCallback } from '../types';
import { RequestTracer } from '../internal/util';
import { Wallet } from '../wallet';
export interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    chain: number;
    index: number;
}
export interface Output {
    address: string;
    amount: string | number;
    external?: boolean;
}
export interface TransactionFee {
    fee: number;
    feeRate?: number;
    size: number;
}
export interface TransactionExplanation {
    displayOrder: string[];
    id: string;
    outputs: Output[];
    changeOutputs: Output[];
    outputAmount: string;
    changeAmount: number;
    fee: TransactionFee;
}
export interface Unspent {
    id: string;
    value: string;
}
export interface ExplainTransactionOptions {
    txHex: string;
    txInfo?: {
        changeAddresses: string[];
        unspents: Unspent[];
    };
    feeInfo?: string;
}
export interface UtxoNetwork {
    pubKeyHash: number;
    scriptHash: number;
    altScriptHash?: number;
    bech32: string;
}
export interface ParsedSignatureScript {
    isSegwitInput: boolean;
    inputClassification: string;
    signatures?: Buffer[];
    publicKeys?: Buffer[];
    pubScript?: Buffer;
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    txInfo?: any;
    blockHeight?: number;
}
export interface TransactionParams extends BaseTransactionParams {
    walletPassphrase?: string;
    changeAddress?: string;
}
export interface ParseTransactionOptions {
    txParams: TransactionParams;
    txPrebuild: TransactionPrebuild;
    wallet: Wallet;
    verification?: VerificationOptions;
    reqId?: RequestTracer;
}
export interface ParsedTransaction {
    keychains: {
        user?: Keychain;
        backup?: Keychain;
        bitgo?: Keychain;
    };
    keySignatures: any[];
    outputs: Output[];
    missingOutputs: Output[];
    explicitExternalOutputs: Output[];
    implicitExternalOutputs: Output[];
    changeOutputs: Output[];
    explicitExternalSpendAmount: number;
    implicitExternalSpendAmount: number;
}
export interface GenerateAddressOptions {
    addressType?: string;
    keychains: {
        pub: string;
        aspKeyId?: string;
    }[];
    threshold: number;
    chain?: number;
    index: number;
    segwit?: boolean;
    bech32?: boolean;
}
export interface AddressDetails {
    address: string;
    chain: number;
    index: number;
    coin: string;
    coinSpecific: AddressCoinSpecific;
    addressType?: string;
}
export interface SignTransactionOptions {
    txPrebuild: {
        txHex: string;
        txInfo: {
            unspents: {
                chain?: number;
                index?: number;
                value?: number;
                address?: string;
                redeemScript?: string;
                witnessScript?: string;
            }[];
        };
    };
    prv: string;
    isLastSignature?: boolean;
}
export interface MultiSigAddress {
    outputScript: Buffer;
    redeemScript: Buffer;
    witnessScript: Buffer;
    address: string;
}
export interface OfflineVaultTxInfo {
    inputs: {
        chainPath: string;
    }[];
}
export interface RecoverFromWrongChainOptions {
    txid: string;
    recoveryAddress: string;
    wallet: string;
    walletPassphrase: string;
    xprv: string;
    coin?: AbstractUtxoCoin;
    recoveryCoin?: AbstractUtxoCoin;
    signed?: boolean;
}
export interface FormattedOfflineVaultTxInfo {
    txInfo: {
        unspents: {
            chainPath: string;
            index?: string;
            chain?: string;
        }[];
    };
    txHex: string;
    feeInfo: {};
    coin: string;
}
export interface AddressInfo {
    txCount: number;
    totalBalance: number;
}
export interface UnspentInfo {
    address: string;
}
export interface RecoverParams {
    scan?: number;
    userKey: string;
    backupKey: string;
    recoveryDestination: string;
    krsProvider: string;
    ignoreAddressTypes: string[];
    bitgoKey: string;
    walletPassphrase?: string;
}
export declare abstract class AbstractUtxoCoin extends BaseCoin {
    altScriptHash?: number;
    supportAltScriptDestination?: boolean;
    private readonly _network;
    protected constructor(bitgo: BitGo, network: UtxoNetwork);
    readonly network: UtxoNetwork;
    static readonly validAddressTypes: UnspentType[];
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor(): number;
    /**
     * Get an instance of the library which can be used to perform low-level operations for this coin
     */
    getCoinLibrary(): any;
    /**
     * Helper to get the version number for an address
     */
    protected getAddressVersion(address: string): number | undefined;
    /**
     * Helper to get the bech32 prefix for an address
     */
    protected getAddressPrefix(address: string): string | undefined;
    /**
     * Check if an address is valid
     * @param address
     * @param forceAltScriptSupport
     */
    isValidAddress(address: string, forceAltScriptSupport?: boolean): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Get the latest block height
     * @param reqId
     * @param callback
     */
    getLatestBlockHeight(reqId?: RequestTracer, callback?: NodeCallback<number>): Bluebird<number>;
    /**
     * Run custom coin logic after a transaction prebuild has been received from BitGo
     * @param prebuild
     * @param callback
     */
    postProcessPrebuild(prebuild: TransactionPrebuild, callback?: NodeCallback<TransactionPrebuild>): Bluebird<TransactionPrebuild>;
    /**
     * Find outputs that are within expected outputs but not within actual outputs, including duplicates
     * @param expectedOutputs
     * @param actualOutputs
     * @returns {Array}
     */
    protected static findMissingOutputs(expectedOutputs: Output[], actualOutputs: Output[]): Output[];
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    static inferAddressType(addressDetails: {
        coinSpecific: AddressCoinSpecific;
    }): string | null;
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param params
     * @param callback
     * @returns {*}
     */
    parseTransaction(params: ParseTransactionOptions, callback?: NodeCallback<ParsedTransaction>): Bluebird<ParsedTransaction>;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.txPrebuild.txHex prebuilt transaction's txHex form
     * @param params.wallet Wallet object to obtain keys to verify against
     * @param params.verification Object specifying some verification parameters
     * @param params.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param params.verification.keychains Pass keychains manually rather than fetching them by id
     * @param params.verification.addresses Address details to pass in for out-of-band verification
     * @param callback
     * @returns {boolean}
     */
    verifyTransaction(params: VerifyTransactionOptions, callback?: NodeCallback<boolean>): Bluebird<boolean>;
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param params.address The address string on the network
     * @param params.addressType
     * @param params.keychains Keychain objects with xpubs
     * @param params.coinSpecific Coin-specific details for the address such as a witness script
     * @param params.chain Derivation chain
     * @param params.index Derivation index
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressDerivationPropertyError}
     * @throws {UnexpectedAddressError}
     */
    verifyAddress(params: VerifyAddressOptions): boolean;
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    supportsBlockTarget(): boolean;
    /**
     * Indicates whether a coin supports wrapped segwit outputs
     * @returns {boolean}
     */
    supportsP2shP2wsh(): boolean;
    /**
     * Indicates whether a coin supports native segwit outputs
     * @returns {boolean}
     */
    supportsP2wsh(): boolean;
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param params.addressType {string}   Deprecated
     * @param params.keychains   {[object]} Array of objects with xpubs
     * @param params.threshold   {number}   Minimum number of signatures
     * @param params.chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param params.index       {number}   Derivation index
     * @param params.segwit      {boolean}  Deprecated
     * @param params.bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    generateAddress(params: GenerateAddressOptions): AddressDetails;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params.txPrebuild transaction prebuild from bitgo server
     * @param params.prv private key to be used for signing
     * @param params.isLastSignature True if `TransactionBuilder.build()` should be called and not `TransactionBuilder.buildIncomplete()`
     * @returns {{txHex}}
     */
    signTransaction(params: SignTransactionOptions): {
        txHex: string;
    };
    /**
     * Always false for coins other than BCH and TBCH.
     * @param unspent
     * @returns {boolean}
     */
    isBitGoTaintedUnspent(unspent: Unspent): boolean;
    /**
     * Modify the transaction builder to comply with the specific coin's requirements such as version and branch id
     * @param txBuilder
     * @returns {*}
     */
    prepareTransactionBuilder(txBuilder: any): any;
    /**
     * Get the default sighash type to be used when signing transactions
     * @returns {number}
     */
    readonly defaultSigHashType: number;
    /**
     * Parse a transaction's signature script to obtain public keys, signatures, the sig script, and other properties
     * @param transaction
     * @param inputIndex
     * @returns { isSegwitInput: boolean, inputClassification: string, signatures: [Buffer], publicKeys: [Buffer], pubScript: Buffer }
     */
    parseSignatureScript(transaction: any, inputIndex: number): ParsedSignatureScript;
    /**
     * Calculate the hash to verify the signature against
     * @param transaction Transaction object
     * @param inputIndex
     * @param pubScript
     * @param amount The previous output's amount
     * @param hashType
     * @param isSegwitInput
     * @returns {*}
     */
    calculateSignatureHash(transaction: any, inputIndex: number, pubScript: Buffer, amount: number, hashType: number, isSegwitInput: boolean): Buffer;
    /**
     * Verify the signature on a (half-signed) transaction
     * @param transaction bitcoinjs-lib tx object
     * @param inputIndex The input whererfore to check the signature
     * @param amount For segwit and BCH, the input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    verifySignature(transaction: any, inputIndex: number, amount: number, verificationSettings?: {
        signatureIndex?: number;
        publicKey?: string;
    }): boolean;
    /**
     * Decompose a raw transaction into useful information, such as the total amounts,
     * change amounts, and transaction outputs.
     * @param params
     * @param callback
     */
    explainTransaction(params: ExplainTransactionOptions, callback?: NodeCallback<TransactionExplanation>): Bluebird<TransactionExplanation>;
    /**
     * Create a multisig address of a given type from a list of keychains and a signing threshold
     * @param addressType
     * @param signatureThreshold
     * @param keys
     */
    createMultiSigAddress(addressType: string, signatureThreshold: number, keys: Buffer[]): MultiSigAddress;
    /**
     * @param scriptHashScript
     * @deprecated
     */
    calculateRecoveryAddress(scriptHashScript: Buffer): any;
    /**
     * Get a static fee rate which is used in recovery situations
     * @deprecated
     */
    getRecoveryFeePerBytes(): Bluebird<number>;
    /**
     * Get a url which can be used for determining recovery fee rates
     */
    getRecoveryFeeRecommendationApiBaseUrl(): Bluebird<string>;
    /**
     * Get the current market price from a third party to be used for recovery
     */
    getRecoveryMarketPrice(): Bluebird<string>;
    /**
     * Helper function for recover()
     * This transforms the txInfo from recover into the format that offline-signing-tool expects
     * @param txInfo
     * @param txHex
     * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
     */
    formatForOfflineVault(txInfo: OfflineVaultTxInfo, txHex: string): FormattedOfflineVaultTxInfo;
    protected abstract getAddressInfoFromExplorer(address: string): Bluebird<AddressInfo>;
    protected abstract getUnspentInfoFromExplorer(address: string): Bluebird<UnspentInfo[]>;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] xprv, or xpub
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * - scan: the amount of consecutive addresses without unspents to scan through before stopping
     * - ignoreAddressTypes: (optional) array of AddressTypes to ignore, these are strings defined in Codes.UnspentTypeTcomb
     *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
     * @param callback
     */
    recover(params: RecoverParams, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Apply signatures to a funds recovery transaction using user + backup key
     * @param txb {Object} a transaction builder object (with inputs and outputs)
     * @param unspents {Array} the unspents to use in the transaction
     * @param addresses {Array} the address and redeem script info for the unspents
     * @param cosign {Boolean} whether to cosign this transaction with the user's backup key (false if KRS recovery)
     * @returns the transaction builder originally passed in as the first argument
     */
    signRecoveryTransaction(txb: any, unspents: Output[], addresses: any, cosign: boolean): any;
    /**
     * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
     * @param params
     * @param params.provider {String} the KRS provider that holds the backup key
     * @param params.amount {Number} amount (in base units) to be recovered
     * @param callback
     * @returns {*}
     */
    calculateFeeAmount(params: {
        provider: string;
        amount?: number;
    }, callback?: NodeCallback<number>): Bluebird<number>;
    /**
     * Recover BTC that was sent to the wrong chain
     * @param params
     * @param params.txid The txid of the faulty transaction
     * @param params.recoveryAddress address to send recovered funds to
     * @param params.wallet the wallet that received the funds
     * @param params.recoveryCoin the coin type of the wallet that received the funds
     * @param params.signed return a half-signed transaction (default=true)
     * @param params.walletPassphrase the wallet passphrase
     * @param params.xprv the unencrypted xprv (used instead of wallet passphrase)
     * @param callback
     * @returns {*}
     */
    recoverFromWrongChain(params: RecoverFromWrongChainOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed: Buffer): {
        pub: string;
        prv: string;
    };
    getExtraPrebuildParams(buildParams: ExtraPrebuildParamsOptions, callback?: NodeCallback<any>): Bluebird<any>;
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    presignTransaction(params: PresignTransactionOptions, callback?: (err: Error, res: any) => void): Bluebird<any>;
    supplementGenerateWallet(walletParams: SupplementGenerateWalletOptions, keychains: KeychainsTriplet): Bluebird<any>;
    transactionDataAllowed(): boolean;
    valuelessTransferAllowed(): boolean;
    verifyRecoveryTransaction(txInfo: VerifyRecoveryTransactionOptions): Bluebird<any>;
    signMessage(key: {
        prv: string;
    }, message: string | Buffer): Buffer;
}
//# sourceMappingURL=abstractUtxoCoin.d.ts.map