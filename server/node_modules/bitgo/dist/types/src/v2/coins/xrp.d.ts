/// <reference types="node" />
import { HDNode } from 'bitgo-utxo-lib';
import * as Bluebird from 'bluebird';
import { BitGo } from '../../bitgo';
import { BaseCoin, TransactionExplanation, KeyPair, VerifyAddressOptions as BaseVerifyAddressOptions, ParseTransactionOptions, ParsedTransaction, TransactionPrebuild, VerifyTransactionOptions, InitiateRecoveryOptions as BaseInitiateRecoveryOptions } from '../baseCoin';
import { NodeCallback } from '../types';
interface Address {
    address: string;
    destinationTag?: number;
}
interface FeeInfo {
    date: string;
    height: number;
    baseReserve: string;
    baseFee: string;
}
interface SignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
interface ExplainTransactionOptions {
    txHex?: string;
}
interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    rootAddress: string;
}
interface RecoveryInfo extends TransactionExplanation {
    txHex: string;
    backupKey?: string;
    coin?: string;
}
export interface InitiateRecoveryOptions extends BaseInitiateRecoveryOptions {
    krsProvider?: string;
}
export interface RecoveryOptions {
    backupKey: string;
    userKey: string;
    rootAddress: string;
    recoveryDestination: string;
    bitgoKey?: string;
    walletPassphrase: string;
    krsProvider?: string;
}
interface HalfSignedTransaction {
    halfSigned: {
        txHex: string;
    };
}
export declare class Xrp extends BaseCoin {
    protected constructor(bitgo: BitGo);
    static createInstance(bitgo: BitGo): BaseCoin;
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    getBaseFactor(): number;
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain(): string;
    /**
     * Identifier for the coin family
     */
    getFamily(): string;
    /**
     * Complete human-readable name of this coin
     */
    getFullName(): string;
    /**
     * Parse an address string into address and destination tag
     */
    getAddressDetails(address: string): Address;
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    normalizeAddress({ address, destinationTag }: Address): string;
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    isValidAddress(address: string): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Get fee info from server
     */
    getFeeInfo(_?: any, callback?: any): Promise<FeeInfo>;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    signTransaction({ txPrebuild, prv }: SignTransactionOptions): HalfSignedTransaction;
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     * @param keychains
     */
    supplementGenerateWallet(walletParams: any, keychains: any): Bluebird<any>;
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    explainTransaction(params?: ExplainTransactionOptions, callback?: NodeCallback<TransactionExplanation>): Bluebird<TransactionExplanation>;
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @param callback
     * @returns {boolean}
     */
    verifyTransaction({ txParams, txPrebuild }: VerifyTransactionOptions, callback: any): Bluebird<boolean>;
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    verifyAddress({ address, rootAddress }: VerifyAddressOptions): boolean;
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    getRippledUrl(): string;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    recover(params: RecoveryOptions, callback?: NodeCallback<RecoveryInfo | string>): Bluebird<RecoveryInfo | string>;
    /**
     * Prepare and validate all keychains from the keycard for recovery
     */
    initiateRecovery(params: InitiateRecoveryOptions): Bluebird<HDNode[]>;
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    parseTransaction(params: ParseTransactionOptions, callback?: NodeCallback<ParsedTransaction>): Bluebird<ParsedTransaction>;
}
export {};
//# sourceMappingURL=xrp.d.ts.map