/// <reference types="node" />
/**
 * @prettier
 */
import { BitGo } from '../../bitgo';
import { BaseCoin, TransactionExplanation, KeyPair, ParseTransactionOptions, ParsedTransaction, VerifyTransactionOptions, VerifyAddressOptions as BaseVerifyAddressOptions, HalfSignedTransaction as BaseHalfSignedTransaction, SignTransactionOptions as BaseSignTransactionOptions } from '../baseCoin';
import { NodeCallback } from '../types';
import { HDNode } from 'bitgo-utxo-lib';
import * as EosJs from 'eosjs';
import * as Bluebird from 'bluebird';
interface AddressDetails {
    address: string;
    memoId?: string;
}
export interface EosTx {
    signatures: string[];
    packed_trx: string;
    compression: string;
}
export interface Recipient {
    address: string;
    amount: string;
}
interface EosTransactionHeaders {
    ref_block_prefix: number;
    ref_block_num: number;
    expiration?: string;
}
interface EosTransactionAction {
    account: string;
    name: string;
    authorization: [{
        actor: string;
        permission: string;
    }];
    data: {
        from: string;
        to: string;
        quantity: string;
        memo?: string;
    };
}
interface EosTransactionPrebuild {
    recipients: Recipient[];
    headers: EosTransactionHeaders;
    txHex: string;
    transaction: EosTx;
    txid: string;
}
export interface EosSignTransactionParams extends BaseSignTransactionOptions {
    prv: string;
    txPrebuild: EosTransactionPrebuild;
    recipients: Recipient[];
}
export interface EosHalfSigned {
    recipients: Recipient[];
    headers: EosTransactionHeaders;
    txHex: string;
    transaction: EosTx;
    txid: string;
}
export interface EosSignedTransaction extends BaseHalfSignedTransaction {
    halfSigned: EosHalfSigned;
}
interface ExplainTransactionOptions {
    transaction: {
        packed_trx: string;
    };
    headers: EosTransactionHeaders;
}
interface RecoveryTransaction {
    transaction: EosTx;
    txid: string;
    recoveryAmount: number;
}
interface RecoveryOptions {
    userKey: string;
    backupKey: string;
    bitgoKey?: string;
    recoveryDestination: string;
    krsProvider?: string;
    walletPassphrase?: string;
    rootAddress?: string;
}
interface ValidateKeyOptions {
    key: string;
    source: string;
    passphrase?: string;
    isUnsignedSweep: boolean;
    isKrsRecovery: boolean;
}
interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    rootAddress: string;
}
export declare class Eos extends BaseCoin {
    static VALID_ADDRESS_CHARS: string[];
    static ADDRESS_LENGTH: number;
    static createInstance(bitgo: BitGo): BaseCoin;
    getChainId(): string;
    getChain(): string;
    getFamily(): string;
    getFullName(): string;
    getBaseFactor(): number;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Get URLs of some active public nodes
     */
    getPublicNodeUrls(): string[];
    /**
     * Generate secp256k1 key pair
     *
     * @param seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub - the pub to be checked
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    isValidPrv(prv: string): boolean;
    /**
     * Evaluates whether a memo is valid
     *
     * @param value - the memo to be checked
     */
    isValidMemo({ value }: {
        value: string;
    }): boolean;
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId - the memo id to be checked
     */
    isValidMemoId(memoId: string): boolean;
    /**
     * Process address into address and memo id
     * @param address - the address
     */
    getAddressDetails(address: string): AddressDetails;
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, rmg, xrp, xlm)
     */
    baseUnitsToBigUnits(baseUnits: string | number): string;
    /**
     * Validate and return address with appended memo id
     *
     * @param address
     * @param memoId
     */
    normalizeAddress({ address, memoId }: AddressDetails): string;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address - the address to be checked
     */
    isValidAddress(address: string): boolean;
    /**
     * Check if address is a valid EOS address, then verify it matches the root address.
     *
     * @param address - the address to verify
     * @param rootAddress - the wallet's root address
     */
    verifyAddress({ address, rootAddress }: VerifyAddressOptions): boolean;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     */
    signTransaction(params: EosSignTransactionParams): EosSignedTransaction;
    private deserializeStakeAction;
    private static deserializeVoteAction;
    /**
     * Deserialize a transaction
     * @param transaction
     * @param headers
     */
    private deserializeTransaction;
    /**
     * Explain/parse transaction
     * @param params - ExplainTransactionOptions
     * @param callback
     */
    explainTransaction(params: ExplainTransactionOptions, callback?: NodeCallback<TransactionExplanation>): Bluebird<TransactionExplanation>;
    /**
     * Validate a public or private key
     * If passphrase is provided, try to decrypt the key with it
     * @param key
     * @param source
     * @param passphrase
     * @param isUnsignedSweep
     * @param isKrsRecovery
     */
    validateKey({ key, source, passphrase, isUnsignedSweep, isKrsRecovery }: ValidateKeyOptions): HDNode;
    /**
     * Prepare and validate all keychains from the keycard for recovery
     * @param userKey
     * @param backupKey
     * @param recoveryDestination
     * @param krsProvider
     * @param walletPassphrase
     */
    initiateRecovery({ userKey, backupKey, recoveryDestination, krsProvider, walletPassphrase, }: RecoveryOptions): Bluebird<HDNode[]>;
    /**
     * Make a request to one of the public EOS nodes available
     * @param endpoint
     * @param payload
     */
    protected getDataFromNode({ endpoint, payload }: {
        endpoint: string;
        payload?: object;
    }): Bluebird<any>;
    /**
     * Get EOS chain info from a public node
     */
    protected getChainInfoFromNode(): Bluebird<any>;
    /**
     * Get data specific to an account from a public node
     * @param address
     */
    protected getAccountFromNode({ address }: {
        address: string;
    }): Bluebird<any>;
    /**
     * Get block data from a public node using its block number or block id
     * @param blockNumOrId
     */
    protected getBlockFromNode({ blockNumOrId }: {
        blockNumOrId: string;
    }): Bluebird<any>;
    /**
     * Get headers for an EOS tx from a public node
     */
    protected getTransactionHeadersFromNode(): Bluebird<any>;
    protected getTransferAction({ recipient, sender, amount, memo }: {
        recipient: any;
        sender: any;
        amount: any;
        memo: any;
    }): EosTransactionAction;
    /**
     * Sign a transaction with a key
     * @param signableTx
     * @param signingKey
     */
    signTx(signableTx: string, signingKey: HDNode): string;
    /**
     * Serialize an EOS transaction, to the format that should be signed
     * @param eosClient an offline EOSClient that has the transaction structs
     * @param transaction The EOS transaction returned from `eosClient.transaction` to serialize
     * @return {String} serialized transaction in hex format
     */
    serializeTransaction(eosClient: EosJs, transaction: EosJs.transaction): string;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param callback
     */
    recover(params: RecoveryOptions, callback?: NodeCallback<RecoveryTransaction>): Bluebird<RecoveryTransaction>;
    parseTransaction(params: ParseTransactionOptions, callback?: NodeCallback<ParsedTransaction>): Bluebird<ParsedTransaction>;
    verifyTransaction(params: VerifyTransactionOptions, callback?: NodeCallback<boolean>): Bluebird<boolean>;
    /**
     * Generate a random EOS address.
     *
     * This is just a random string which abides by the EOS adddress constraints,
     * and is not actually checked for availability on the EOS blockchain.
     *
     * Current EOS address constraints are:
     * * Address must be exactly 12 characters
     * * Address must only contain lowercase letters and numbers 1-5
     * @returns a validly formatted EOS address, which may or may not actually be available on chain.
     */
    generateRandomAddress(params: {}): string;
}
export {};
//# sourceMappingURL=eos.d.ts.map