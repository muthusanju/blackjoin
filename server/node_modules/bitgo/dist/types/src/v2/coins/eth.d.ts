/// <reference types="node" />
import * as Bluebird from 'bluebird';
import { BaseCoin, FeeEstimateOptions, KeyPair, ParsedTransaction, ParseTransactionOptions, VerifyAddressOptions, VerifyTransactionOptions, TransactionPrebuild as BaseTransactionPrebuild, HalfSignedTransaction as BaseHalfSignedTransaction } from '../baseCoin';
import { BitGo } from '../../bitgo';
import { NodeCallback } from '../types';
import { Wallet } from '../wallet';
export declare const optionalDeps: {
    readonly ethAbi: any;
    readonly ethUtil: any;
    readonly EthTx: any;
};
/**
 * The extra parameters to send to platform build route for hop transactions
 */
interface HopParams {
    hopParams: {
        gasPriceMax: number;
        userReqSig: string;
        paymentId: string;
    };
    gasLimit: number;
}
/**
 * The prebuilt hop transaction returned from the HSM
 */
interface HopPrebuild {
    tx: string;
    id: string;
    signature: string;
}
interface Recipient {
    address: string;
    amount: string;
    data?: string;
}
interface SignFinalOptions {
    txPrebuild: {
        gasPrice: string;
        gasLimit: string;
        recipients: Recipient[];
        halfSigned: {
            expireTime: number;
            contractSequenceId: number;
            signature: string;
        };
        nextContractSequenceId?: number;
        hopTransaction?: string;
    };
    signingKeyNonce: number;
    walletContractAddress: string;
    prv: string;
    recipients: Recipient[];
}
interface SignTransactionOptions extends SignFinalOptions {
    isLastSignature?: boolean;
    expireTime: number;
    sequenceId: number;
    gasLimit: number;
    gasPrice: number;
}
export interface HalfSignedTransaction extends BaseHalfSignedTransaction {
    halfSigned: {
        recipients: Recipient[];
        expireTime: number;
        contractSequenceId: number;
        sequenceId: number;
        txHex?: never;
    };
}
export interface FullySignedTransaction {
    txHex: string;
}
export declare type SignedTransaction = HalfSignedTransaction | FullySignedTransaction;
interface PrecreateBitGoOptions {
    enterprise?: string;
    newFeeAddress?: string;
}
interface OfflineVaultTxInfo {
    nextContractSequenceId?: string;
    contractSequenceId?: string;
    tx: string;
    userKey: string;
    backupKey: string;
    coin: string;
    gasPrice: number;
    gasLimit: number;
    recipients: Recipient[];
    walletContractAddress: string;
    amount: string;
    backupKeyNonce: number;
}
interface UnformattedTxInfo {
    recipient: Recipient;
}
export interface RecoverOptions {
    userKey: string;
    backupKey: string;
    walletPassphrase?: string;
    walletContractAddress: string;
    recoveryDestination: string;
    krsProvider?: string;
}
export interface RecoveryInfo {
    id: string;
    tx: string;
    backupKey?: string;
    coin?: string;
}
interface RecoverTokenOptions {
    tokenContractAddress: string;
    wallet: Wallet;
    recipient: string;
    broadcast?: boolean;
    walletPassphrase?: string;
    prv?: string;
}
interface GetSendMethodArgsOptions {
    recipient: Recipient;
    expireTime: number;
    contractSequenceId: number;
    signature: string;
}
interface SendMethodArgs {
    name: string;
    type: string;
    value: any;
}
interface HopTransactionBuildOptions {
    wallet: Wallet;
    recipients: Recipient[];
    walletPassphrase: string;
}
interface BuildOptions {
    hop?: boolean;
    wallet?: Wallet;
    recipients?: Recipient[];
    walletPassphrase?: string;
}
interface FeeEstimate {
    gasLimitEstimate: number;
    feeEstimate: number;
}
interface TransactionPrebuild extends BaseTransactionPrebuild {
    hopTransaction?: HopPrebuild;
    buildParams: {
        recipients: Recipient[];
    };
}
interface RecoverTokenTransaction {
    halfSigned: {
        recipient: Recipient;
        expireTime: number;
        contractSequenceId: number;
        operationHash: string;
        signature: string;
        gasLimit: number;
        gasPrice: number;
        tokenContractAddress: string;
        walletId: string;
    };
}
export declare class Eth extends BaseCoin {
    static hopTransactionSalt: string;
    static createInstance(bitgo: BitGo): BaseCoin;
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor(): string;
    getChain(): string;
    getFamily(): string;
    getFullName(): string;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed(): boolean;
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    isValidAddress(address: string): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    getRecoveryGasPrice(): any;
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    getRecoveryGasLimit(): any;
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    getDefaultExpireTime(): number;
    /**
     * Query Etherscan for the balance of an address
     * @param address {String} the ETH address
     * @param callback
     * @returns {BigNumber} address balance
     */
    queryAddressBalance(address: string, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Query Etherscan for the balance of an address for a token
     * @param tokenContractAddress {String} address where the token smart contract is hosted
     * @param walletContractAddress {String} address of the wallet
     * @param callback
     * @returns {BigNumber} token balaance in base units
     */
    queryAddressTokenBalance(tokenContractAddress: string, walletContractAddress: string, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get transfer operation for coin
     * @param recipient recipient info
     * @param expireTime expiry time
     * @param contractSequenceId sequence id
     * @returns {Array} operation array
     */
    getOperation(recipient: Recipient, expireTime: number, contractSequenceId: number): (string | Buffer)[][];
    getOperationSha3ForExecuteAndConfirm(recipients: Recipient[], expireTime: number, contractSequenceId: number): string;
    /**
     * Queries the contract (via Etherscan) for the next sequence ID
     * @param address {String} address of the contract
     * @param callback
     * @returns {Number} sequence ID
     */
    querySequenceId(address: string, callback?: NodeCallback<number>): Bluebird<number>;
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.signingKeyNonce
     * @param params.walletContractAddress
     * @param params.prv
     * @returns {{txHex: *}}
     */
    signFinal(params: SignFinalOptions): FullySignedTransaction;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    signTransaction(params: SignTransactionOptions): SignedTransaction;
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @param callback
     * @returns {*}
     */
    getAddressNonce(address: string, callback?: NodeCallback<number>): Bluebird<number>;
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param txInfo
     * @param ethTx
     * @param userKey
     * @param backupKey
     * @param gasPrice
     * @param gasLimit
     * @param callback
     * @returns {{tx: *, userKey: *, backupKey: *, coin: string, amount: string, gasPrice: string, gasLimit: string, recipients: ({address, amount}|{address: ({address, amount}|string), amount: string}|string)[]}}
     */
    formatForOfflineVault(txInfo: UnformattedTxInfo, ethTx: any, userKey: string, backupKey: string, gasPrice: Buffer, gasLimit: number, callback?: NodeCallback<OfflineVaultTxInfo>): Bluebird<OfflineVaultTxInfo>;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.krsProvider {String} necessary if backup key is held by KRS
     * @param params.recoveryDestination {String} target address to send recovered funds to
     * @param callback
     */
    recover(params: RecoverOptions, callback?: NodeCallback<RecoveryInfo | OfflineVaultTxInfo>): Bluebird<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * This builds a half-signed transaction, for which there will be an admin route to co-sign and broadcast. Optionally
     * the user can set params.broadcast = true and the half-signed tx will be sent to BitGo for cosigning and broadcasting
     * @param params
     * @param params.wallet the wallet to recover the token from
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param params.broadcast if true, we will automatically submit the half-signed tx to BitGo for cosigning and broadcasting
     * @param callback
     */
    recoverToken(params: RecoverTokenOptions, callback?: NodeCallback<RecoverTokenTransaction>): Bluebird<RecoverTokenTransaction>;
    /**
     * Build arguments to call the send method on the wallet contract
     * @param txInfo
     */
    getSendMethodArgs(txInfo: GetSendMethodArgsOptions): SendMethodArgs[];
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @param callback
     * @returns {Object} response from Etherscan
     */
    recoveryBlockchainExplorerQuery(query: any, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @param callback
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    createHopTransactionParams(buildParams: HopTransactionBuildOptions, callback?: NodeCallback<HopParams>): Bluebird<HopParams>;
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @param callback
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    validateHopPrebuild(wallet: Wallet, hopPrebuild: HopPrebuild, originalParams?: {
        recipients: Recipient[];
    }, callback?: NodeCallback<void>): Bluebird<void>;
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    private static getHopDigest;
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     * @param callback
     */
    getExtraPrebuildParams(buildParams: BuildOptions, callback?: NodeCallback<BuildOptions>): Bluebird<BuildOptions>;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(params: TransactionPrebuild, callback?: NodeCallback<TransactionPrebuild>): Bluebird<TransactionPrebuild>;
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     * @param callback
     */
    presignTransaction(params: TransactionPrebuild, callback?: NodeCallback<TransactionPrebuild>): Bluebird<TransactionPrebuild>;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @param callback
     * @returns {Object} The fee info returned from the server
     */
    feeEstimate(params: FeeEstimateOptions, callback?: NodeCallback<FeeEstimate>): Bluebird<FeeEstimate>;
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed: Buffer): KeyPair;
    parseTransaction(params: ParseTransactionOptions, callback?: NodeCallback<ParsedTransaction>): Bluebird<ParsedTransaction>;
    verifyAddress(params: VerifyAddressOptions): boolean;
    verifyTransaction(params: VerifyTransactionOptions, callback?: NodeCallback<boolean>): Bluebird<boolean>;
}
export {};
//# sourceMappingURL=eth.d.ts.map