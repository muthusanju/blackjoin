import * as superagent from 'superagent';
import * as bitcoin from 'bitgo-utxo-lib';
import { BaseCoin } from './v2/baseCoin';
import { EnvironmentName } from './v2/environments';
import { NodeCallback, V1Network } from './v2/types';
import { RequestTracer as IRequestTracer } from './v2/types';
import * as Bluebird from 'bluebird';
export interface BitGoOptions {
    env?: EnvironmentName;
    clientId?: string;
    clientSecret?: string;
    accessToken?: string;
    userAgent?: string;
    customRootURI?: string;
    customBitcoinNetwork?: V1Network;
    customSigningAddress?: string;
    serverXpub?: string;
    stellarFederationServerUrl?: string;
    useProduction?: boolean;
    microservicesUri?: string;
    refreshToken?: string;
    validate?: boolean;
    proxy?: string;
}
export interface User {
    username: string;
}
export interface BitGoJson {
    user?: User;
    token?: string;
    extensionKey?: string;
}
/**
 * @deprecated
 */
export interface DeprecatedVerifyAddressOptions {
    address?: string;
}
export interface VerifyPasswordOptions {
    password?: string;
}
export interface EncryptOptions {
    input?: string;
    password?: string;
}
export interface DecryptOptions {
    input?: string;
    password?: string;
}
export interface SplitSecretOptions {
    seed: string;
    passwords: string[];
    m: number;
}
export interface SplitSecret {
    xpub: string;
    m: number;
    n: number;
    seedShares: any;
}
export interface ReconstituteSecretOptions {
    shards: string[];
    passwords: string[];
}
export interface ReconstitutedSecret {
    xpub: string;
    xprv: string;
    seed: string;
}
export interface VerifyShardsOptions {
    shards: string[];
    passwords: string[];
    m: number;
    xpub: string;
}
export interface GetEcdhSecretOptions {
    otherPubKeyHex: string;
    eckey: bitcoin.ECPair;
}
export interface AccessTokenOptions {
    accessToken: string;
}
export interface TokenIssuanceResponse {
    derivationPath: string;
    encryptedToken: string;
    encryptedECDHXprv?: string;
}
export interface TokenIssuance {
    token: string;
    ecdhXprv?: string;
}
export interface CalculateHmacSubjectOptions {
    urlPath: string;
    text: string;
    timestamp: number;
    statusCode?: number;
}
export interface CalculateRequestHmacOptions {
    url: string;
    text: string;
    timestamp: number;
    token: string;
}
export interface CalculateRequestHeadersOptions {
    url: string;
    text: string;
    token: string;
}
export interface RequestHeaders {
    hmac: string;
    timestamp: number;
    tokenHash: string;
}
export interface VerifyResponseOptions extends CalculateRequestHeadersOptions {
    hmac: string;
    url: string;
    text: string;
    timestamp: number;
    statusCode?: number;
}
export interface AuthenticateOptions {
    username: string;
    password: string;
    otp?: string;
    trust?: number;
    forceSMS?: boolean;
    extensible?: boolean;
    forceV1Auth?: boolean;
}
export interface ProcessedAuthenticationOptions {
    email: string;
    password: string;
    forceSMS: boolean;
    otp?: string;
    trust?: number;
    extensible?: boolean;
    extensionAddress?: string;
    forceV1Auth?: boolean;
}
export interface AddAccessTokenOptions {
    label: string;
    otp?: string;
    duration?: number;
    ipRestrict?: string[];
    txValueLimit?: number;
    scope: string[];
}
export interface RemoveAccessTokenOptions {
    id?: string;
    label?: string;
}
export interface GetUserOptions {
    id: string;
}
export interface ChangePasswordOptions {
    oldPassword: string;
    newPassword: string;
}
export interface UnlockOptions {
    otp?: string;
    duration?: number;
}
export interface ExtendTokenOptions {
    duration?: string;
}
export interface GetSharingKeyOptions {
    email: string;
}
export interface PingOptions {
    reqId?: IRequestTracer;
}
/**
 * @deprecated
 */
export interface EstimateFeeOptions {
    numBlocks?: number;
    maxFee?: number;
    inputs?: string[];
    txSize?: number;
    cpfpAware?: boolean;
}
/**
 * @deprecated
 */
export interface WebhookOptions {
    url: string;
    type: string;
}
export interface ListWebhookNotificationsOptions {
    prevId?: string;
    limit?: number;
}
export interface BitGoSimulateWebhookOptions {
    webhookId: string;
    blockId: string;
}
export interface AuthenticateWithAuthCodeOptions {
    authCode: string;
}
/**
 * @deprecated
 */
export interface VerifyPushTokenOptions {
    pushVerificationToken: string;
}
export interface BitGoRequest extends superagent.Request {
    result: (optionalField?: string) => Bluebird<any>;
    end: (callback?: NodeCallback<superagent.Response>) => Bluebird<superagent.Response>;
}
export interface BitGo {
    get(url: string, callback?: NodeCallback<superagent.Response>): BitGoRequest;
    post(url: string, callback?: NodeCallback<superagent.Response>): BitGoRequest;
    put(url: string, callback?: NodeCallback<superagent.Response>): BitGoRequest;
    del(url: string, callback?: NodeCallback<superagent.Response>): BitGoRequest;
    patch(url: string, callback?: NodeCallback<superagent.Response>): BitGoRequest;
}
export declare class BitGo {
    private static _testnetWarningMessage;
    private static _constants;
    private static _constantsExpire;
    private readonly _env;
    /**
     * Expose env property for backwards compatibility
     * @deprecated
     */
    readonly env: EnvironmentName;
    private readonly _baseUrl;
    private readonly _microservicesUrl?;
    private readonly _baseApiUrl;
    private readonly _baseApiUrlV2;
    private _user?;
    private _keychains;
    private _wallets;
    private readonly _clientId?;
    private readonly _clientSecret?;
    private _token?;
    private _refreshToken?;
    private readonly _userAgent;
    private readonly _promise;
    private _validate;
    private readonly _proxy?;
    private _reqId?;
    private _ecdhXprv?;
    private _extensionKey?;
    private _markets?;
    private _blockchain?;
    private _travelRule?;
    private _pendingApprovals?;
    /**
     * Constructor for BitGo Object
     */
    constructor(params?: BitGoOptions);
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    private createPatch;
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    calculateHMAC(key: string, message: string): string;
    /**
     * Create a basecoin object
     * @param coinName
     */
    coin(coinName: string): BaseCoin;
    /**
     * Create a basecoin object for a virtual token
     * @param tokenName
     * @param callback
     */
    token(tokenName: string, callback?: NodeCallback<BaseCoin>): Bluebird<BaseCoin>;
    /**
     *
     */
    getValidate(): boolean;
    /**
     *
     */
    setValidate(validate: boolean): void;
    /**
     * Return the current BitGo environment
     */
    getEnv(): EnvironmentName;
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    clear(): void;
    /**
     * Helper function to return a rejected promise or call callback with error
     *
     * @deprecated
     */
    reject(msg: string, callback?: NodeCallback<never>): Bluebird<never>;
    /**
     * Gets the version of the BitGoJS package
     */
    version(): string;
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    toJSON(): BitGoJson;
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    fromJSON(json: BitGoJson): void;
    /**
     * Get the current user
     */
    user(): User | undefined;
    /**
     * Verify a Bitcoin address is a valid base58 address
     * @deprecated
     */
    verifyAddress(params?: DeprecatedVerifyAddressOptions): boolean;
    /**
     */
    verifyPassword(params?: VerifyPasswordOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Utility function to encrypt locally.
     */
    encrypt(params?: EncryptOptions): string;
    /**
     * Decrypt an encrypted string locally.
     */
    decrypt(params?: DecryptOptions): string;
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    generateRandomPassword(numWords?: number): string;
    /**
     * Split a secret into shards using Shamir Secret Sharing.
     * @param seed A hexadecimal secret to split
     * @param passwords An array of the passwords used to encrypt each share
     * @param m The threshold number of shards necessary to reconstitute the secret
     */
    splitSecret({ seed, passwords, m }: SplitSecretOptions): SplitSecret;
    /**
     * Reconstitute a secret which was sharded with `splitSecret`.
     * @param shards
     * @param passwords
     */
    reconstituteSecret({ shards, passwords }: ReconstituteSecretOptions): ReconstitutedSecret;
    /**
     *
     * @param shards
     * @param passwords
     * @param m
     * @param xpub Optional xpub to verify the results against
     */
    verifyShards({ shards, passwords, m, xpub }: VerifyShardsOptions): boolean;
    /**
     * Construct an ECDH secret from a private key and other user's public key
     */
    getECDHSecret({ otherPubKeyHex, eckey }: GetEcdhSecretOptions): string;
    /**
     * Gets the user's private keychain, used for receiving shares
     */
    getECDHSharingKeychain(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get bitcoin market data
     */
    markets(): any;
    /**
     * Get the latest bitcoin prices
     * (Deprecated: Will be removed in the future) use `bitgo.markets().latest()`
     * @deprecated
     */
    market(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get market data from yesterday
     * (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
     */
    yesterday(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Synchronous method for activating an access token.
     */
    authenticateWithAccessToken({ accessToken }: AccessTokenOptions): void;
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    handleTokenIssuance(responseBody: TokenIssuanceResponse, password?: string): TokenIssuance;
    /**
     * Calculate the string that is to be HMACed for a certain HTTP request or response
     * @param urlPath
     * @param text
     * @param timestamp
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @returns {string}
     */
    calculateHMACSubject({ urlPath, text, timestamp, statusCode }: CalculateHmacSubjectOptions): string;
    /**
     * Calculate the HMAC for an HTTP request
     */
    calculateRequestHMAC({ url: urlPath, text, timestamp, token }: CalculateRequestHmacOptions): string;
    /**
     * Calculate request headers with HMAC
     */
    calculateRequestHeaders({ url, text, token }: CalculateRequestHeadersOptions): RequestHeaders;
    /**
     * Verify the HMAC for an HTTP response
     */
    verifyResponse({ url: urlPath, statusCode, text, timestamp, token, hmac }: VerifyResponseOptions): {
        isValid: boolean;
        expectedHmac: string;
        signatureSubject: string;
    };
    /**
     *
     */
    preprocessAuthenticationParams({ username, password, otp, forceSMS, extensible, trust }: AuthenticateOptions): ProcessedAuthenticationOptions;
    /**
     * Login to the bitgo platform.
     */
    authenticate(params: AuthenticateOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * @param params
     * - operatingSystem: one of ios, android
     * - pushToken: hex-formatted token for the respective native push notification service
     * @param callback
     * @returns {*}
     * @deprecated
     */
    registerPushToken(params: any, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     *
     * @param params
     * - pushVerificationToken: the token received via push notification to confirm the device's mobility
     * @param callback
     * @deprecated
     */
    verifyPushToken(params: VerifyPushTokenOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Login to the bitgo system using an authcode generated via Oauth
     */
    authenticateWithAuthCode(params: AuthenticateWithAuthCodeOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    refreshToken(params?: {
        refreshToken?: string;
    }, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    listAccessTokens(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @param callback
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    addAccessToken(params: AddAccessTokenOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     * @param callback
     */
    removeAccessToken({ id, label }: RemoveAccessTokenOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Logout of BitGo
     * @param params
     * @param callback
     */
    logout(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get a user by ID (name/email only)
     * @param id
     * @param callback
     */
    getUser({ id }: GetUserOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Change the password of the currently logged in user.
     * Also change all v1 and v2 keychain passwords if they match the
     * given oldPassword. Returns nothing on success.
     * @param oldPassword {String} - the current password
     * @param newPassword {String} - the new password
     * @param callback
     */
    changePassword({ oldPassword, newPassword }: ChangePasswordOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get the current logged in user
     * @param params
     * @param callback
     */
    me(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     * @param callback
     */
    unlock({ otp, duration }: UnlockOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Lock the session
     * @param params
     * @param callback
     */
    lock(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get the current session
     */
    session(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    sendOTP(params?: {
        forceSMS?: boolean;
    }, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     * @param callback
     */
    extendToken(params?: ExtendTokenOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     * @param callback
     */
    getSharingKey({ email }: GetSharingKeyOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Test connectivity to the server
     * @param params
     * @param callback
     */
    ping({ reqId }?: PingOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get the blockchain object.
     * @deprecated
     */
    blockchain(): any;
    /**
     * Get the user's keychains object.
     * @deprecated
     */
    keychains(): any;
    /**
     * Get the user's wallets object.
     * @deprecated
     */
    wallets(): any;
    /**
     * Get the travel rule object
     * @deprecated
     */
    travelRule(): any;
    /**
     * Get pending approvals that can be approved/ or rejected
     * @deprecated
     */
    pendingApprovals(): any;
    /**
     * A factory method to create a new Wallet object, initialized with the wallet params
     * Can be used to reconstitute a wallet from cached data
     * @param walletParams
     * @deprecated
     */
    newWalletObject(walletParams: any): any;
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    url(path: string, version?: number): string;
    /**
     * Create a url for calling BitGo microservice APIs
     */
    microservicesUrl(path: string): string;
    /**
     * Get all the address labels on all of the user's wallets
     */
    labels(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Estimates approximate fee per kb needed for a tx to get into a block
     * @param {number} params.numBlocks target blocks for the transaction to be confirmed
     * @param {number} params.maxFee maximum fee willing to be paid (for safety)
     * @param {array[string]} params.inputs list of unconfirmed txIds from which this transaction uses inputs
     * @param {number} params.txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
     * @param {boolean} params.cpfpAware flag indicating fee should take into account CPFP
     * @deprecated
     */
    estimateFee(params?: EstimateFeeOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get BitGo's guarantee using an instant id
     * @param params
     * @param callback
     * @deprecated
     */
    instantGuarantee(params: {
        id: string;
    }, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Get a target address for payment of a BitGo fee
     * @param params
     * @param callback
     * @deprecated
     */
    getBitGoFeeAddress(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Gets an address object (including the wallet id) for a given address.
     * @param {string} params.address The address to look up.
     * @deprecated
     */
    getWalletAddress({ address }: {
        address: string;
    }, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Fetch list of user webhooks
     *
     * @param callback
     * @returns {*}
     * @deprecated
     */
    listWebhooks(callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Add new user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     * @deprecated
     */
    addWebhook(params: WebhookOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Remove user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     * @deprecated
     */
    removeWebhook(params: WebhookOptions, callback: any): Bluebird<any>;
    /**
     * Fetch list of webhook notifications for the user
     *
     * @param params
     * @param callback
     * @returns {*}
     */
    listWebhookNotifications(params?: ListWebhookNotificationsOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Simulate a user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     */
    simulateWebhook(params: BitGoSimulateWebhookOptions, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Receives a TTL and refetches as necessary
     * @param params
     * @param callback
     */
    fetchConstants(params?: {}, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Synchronously get constants which are relevant to the client.
     *
     * Note: This function has a known race condition. It may return different values over time,
     * especially if called shortly after creation of the BitGo object.
     *
     * New code should call fetchConstants() directly instead.
     *
     * @deprecated
     * @param params
     * @return {Object} The client constants object
     */
    getConstants(params?: {}): any;
    /**
     * V1 method for calculating miner fee amounts, given the number and
     * type of transaction inputs, along with a fee rate in satoshis per vkB.
     *
     * This method should not be used for new code.
     *
     * @deprecated
     * @param params
     * @param callback
     * @return {any}
     */
    calculateMinerFeeInfo(params: any, callback?: NodeCallback<any>): Bluebird<any>;
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    setRequestTracer(reqTracer: IRequestTracer): void;
}
//# sourceMappingURL=bitgo.d.ts.map