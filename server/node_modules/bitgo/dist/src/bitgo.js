"use strict";
//
// BitGo JavaScript SDK
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var superagent = require("superagent");
var bitcoin = require("bitgo-utxo-lib");
var bitcoin_1 = require("./bitcoin");
var bitcoinMessage = require("bitcoinjs-message");
var sanitizeHtml = require("sanitize-html");
var eol = require("eol");
var PendingApprovals = require('./pendingapprovals');
var shamir = require("secrets.js-grempe");
var sjcl = require("./vendor/sjcl.min.js");
var bs58 = require("bs58");
var common = require("./common");
var util_1 = require("./v2/internal/util");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var pjson = require("../package.json");
var moment = require("moment");
var _ = require("lodash");
var url = require("url");
var querystring = require("querystring");
var config = require("./config");
var crypto = require("crypto");
var debugLib = require("debug");
var internal_1 = require("./v2/internal/internal");
var TransactionBuilder = require('./transactionBuilder');
var Blockchain = require('./blockchain');
var Keychains = require('./keychains');
var TravelRule = require('./travelRule');
var Wallet = require("./wallet");
var Wallets = require('./wallets');
var Markets = require('./markets');
var coinFactory_1 = require("./v2/coinFactory");
var debug = debugLib('bitgo:index');
if (!process.browser) {
    require('superagent-proxy')(superagent);
}
// Patch superagent to return bluebird promises
var _end = superagent.Request.prototype.end;
superagent.Request.prototype.end = function (cb) {
    var self = this;
    if (typeof cb === 'function') {
        return _end.call(self, cb);
    }
    return new Bluebird.Promise(function (resolve, reject) {
        var error;
        try {
            return _end.call(self, function (error, response) {
                if (error) {
                    return reject(error);
                }
                return resolve(response);
            });
        }
        catch (_error) {
            error = _error;
            return reject(error);
        }
    });
};
// Handle HTTP errors appropriately, returning the result body, or a named
// field from the body, if the optionalField parameter is provided.
superagent.Request.prototype.result = function (optionalField) {
    return this.then(handleResponseResult(optionalField), handleResponseError);
};
function handleResponseResult(optionalField) {
    return function (res) {
        if (_.isNumber(res.status) && res.status >= 200 && res.status < 300) {
            return optionalField ? res.body[optionalField] : res.body;
        }
        throw errFromResponse(res);
    };
}
function errFromResponse(res) {
    var errString = createResponseErrorString(res);
    var err = new Error(errString);
    err.status = res.status;
    if (res.body) {
        err.result = res.body;
    }
    if (_.has(res.header, 'x-auth-required') && (res.header['x-auth-required'] === 'true')) {
        err.invalidToken = true;
    }
    if (res.body.needsOTP) {
        err.needsOTP = true;
    }
    return err;
}
function handleResponseError(e) {
    if (e.response) {
        throw errFromResponse(e.response);
    }
    throw e;
}
/**
 * There are many ways a request can fail, and may ways information on that failure can be
 * communicated to the client. This function tries to handle those cases and create a sane error string
 * @param res Response from an HTTP request
 */
function createResponseErrorString(res) {
    var errString = res.status.toString(); // at the very least we'll have the status code
    if (res.body.error) {
        // this is the case we hope for, where the server gives us a nice error from the JSON body
        errString = res.body.error;
    }
    else {
        if (res.text) {
            // if the response came back as text, we try to parse it as HTML and remove all tags, leaving us
            // just the bare text, which we then trim of excessive newlines and limit to a certain length
            try {
                var sanitizedText = sanitizeHtml(res.text, { allowedTags: [] });
                sanitizedText = sanitizedText.trim();
                sanitizedText = eol.lf(sanitizedText); // use '\n' for all newlines
                sanitizedText = _.replace(sanitizedText, /\n[ |\t]{1,}\n/g, '\n\n'); // remove the spaces/tabs between newlines
                sanitizedText = _.replace(sanitizedText, /[\n]{3,}/g, '\n\n'); // have at most 2 consecutive newlines
                sanitizedText = sanitizedText.substring(0, 5000); // prevent message from getting too large
                errString = errString + '\n' + sanitizedText; // add it to our existing errString (at this point the more info the better!)
            }
            catch (e) {
                // do nothing, the response's HTML was too wacky to be parsed cleanly
            }
        }
    }
    return errString;
}
var BitGo = /** @class */ (function () {
    /**
     * Constructor for BitGo Object
     */
    function BitGo(params) {
        if (params === void 0) { params = {}; }
        if (!common.validateParams(params, [], ['clientId', 'clientSecret', 'refreshToken', 'accessToken', 'userAgent', 'customRootURI', 'customBitcoinNetwork', 'serverXpub', 'stellarFederationServerUrl']) ||
            (params.useProduction && !_.isBoolean(params.useProduction))) {
            throw new Error('invalid argument');
        }
        if ((!params.clientId) !== (!params.clientSecret)) {
            throw new Error('invalid argument - must provide both client id and secret');
        }
        // By default, we operate on the test server.
        // Deprecate useProduction in the future
        var env;
        if (params.useProduction) {
            if (params.env && params.env !== 'prod') {
                throw new Error('cannot use useProduction when env=' + params.env);
            }
            env = 'prod';
        }
        else if (params.customRootURI ||
            params.customBitcoinNetwork ||
            params.customSigningAddress ||
            params.serverXpub ||
            process.env.BITGO_CUSTOM_ROOT_URI ||
            process.env.BITGO_CUSTOM_BITCOIN_NETWORK) {
            env = 'custom';
            if (params.customRootURI) {
                common.Environments['custom'].uri = params.customRootURI;
            }
            if (params.customBitcoinNetwork) {
                common.Environments['custom'].network = params.customBitcoinNetwork;
            }
            if (params.customSigningAddress) {
                common.Environments['custom'].customSigningAddress = params.customSigningAddress;
            }
            if (params.serverXpub) {
                common.Environments['custom'].serverXpub = params.serverXpub;
            }
            if (params.stellarFederationServerUrl) {
                common.Environments['custom'].stellarFederationServerUrl = params.stellarFederationServerUrl;
            }
        }
        else {
            env = params.env || process.env.BITGO_ENV;
        }
        if (env === 'production') {
            env = 'prod'; // make life easier
        }
        if (env === 'custom' && _.isUndefined(common.Environments[env].uri)) {
            throw new Error('must use --customrooturi or set the BITGO_CUSTOM_ROOT_URI environment variable when using the custom environment');
        }
        if (env) {
            if (common.Environments[env]) {
                this._baseUrl = common.Environments[env].uri;
            }
            else {
                throw new Error('invalid environment ' + env + '. Supported environments: test, prod');
            }
        }
        else {
            env = 'test';
            if (!BitGo._testnetWarningMessage) {
                BitGo._testnetWarningMessage = true;
                console.log('BitGo SDK env not set - defaulting to test at test.bitgo.com.');
            }
            this._baseUrl = common.Environments[env].uri;
        }
        this._env = this.env = env;
        common.setNetwork(common.Environments[env].network);
        common.setRmgNetwork(common.Environments[env].rmgNetwork);
        this._microservicesUrl = params.microservicesUri;
        this._baseApiUrl = this._baseUrl + '/api/v1';
        this._baseApiUrlV2 = this._baseUrl + '/api/v2';
        this._keychains = null;
        this._wallets = null;
        this._clientId = params.clientId;
        this._clientSecret = params.clientSecret;
        this._token = params.accessToken;
        this._refreshToken = params.refreshToken;
        this._userAgent = params.userAgent || 'BitGoJS/' + this.version();
        this._promise = Bluebird;
        this._reqId = undefined;
        // whether to perform extra client-side validation for some things, such as
        // address validation or signature validation. defaults to true, but can be
        // turned off by setting to false. can also be overridden individually in the
        // functions that use it.
        this._validate = params.validate === undefined ? true : params.validate;
        // Create superagent methods specific to this BitGo instance.
        var methods = ['get', 'post', 'put', 'del', 'patch'];
        if (!params.proxy && process.env.BITGO_USE_PROXY) {
            params.proxy = process.env.BITGO_USE_PROXY;
        }
        if (process.browser && params.proxy) {
            throw new Error('cannot use https proxy params while in browser');
        }
        this._proxy = params.proxy;
        for (var index in methods) {
            var method = methods[index];
            this[method] = this.createPatch(method);
        }
        // capture outer stack so we have useful debug information if fetch constants fails
        var e = new Error();
        // Kick off first load of constants
        this.fetchConstants({}, function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch initial client constants from BitGo');
                debug(e.stack);
            }
        });
    }
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    BitGo.prototype.createPatch = function (method) {
        var self = this;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var req = superagent[method].apply(null, args);
            if (self._proxy) {
                req = req.proxy(self._proxy);
            }
            // Patch superagent to return promises
            var prototypicalEnd = req.end;
            req.end = function () {
                var thisReq = this;
                // intercept a request before it's submitted to the server for v2 authentication (based on token)
                thisReq.set('BitGo-SDK-Version', self.version());
                if (!_.isUndefined(self._reqId)) {
                    thisReq.set('Request-ID', self._reqId.toString());
                    // increment after setting the header so the sequence numbers start at 0
                    self._reqId.inc();
                    // request ids must be set before each request instead of being kept
                    // inside the bitgo object. This is to prevent reentrancy issues where
                    // multiple simultaneous requests could cause incorrect reqIds to be used
                    delete self._reqId;
                }
                // if there is no token, and we're not logged in, the request cannot be v2 authenticated
                thisReq.isV2Authenticated = true;
                thisReq.authenticationToken = self._token;
                // some of the older tokens appear to be only 40 characters long
                if ((self._token && self._token.length !== 67 && self._token.indexOf('v2x') !== 0)
                    || req.forceV1Auth) {
                    // use the old method
                    thisReq.isV2Authenticated = false;
                    thisReq.set('Authorization', 'Bearer ' + self._token);
                    return prototypicalEnd.apply(thisReq, arguments);
                }
                thisReq.set('BitGo-Auth-Version', '2.0');
                // prevent IE from caching requests
                thisReq.set('If-Modified-Since', 'Mon, 26 Jul 1997 05:00:00 GMT');
                if (self._token) {
                    // do a localized data serialization process
                    var data = thisReq._data;
                    if (typeof data !== 'string') {
                        var contentType = thisReq.get('Content-Type');
                        // Parse out just the content type from the header (ignore the charset)
                        if (contentType) {
                            contentType = contentType.split(';')[0];
                        }
                        var serialize = superagent.serialize[contentType];
                        if (!serialize && /[\/+]json\b/.test(contentType)) {
                            serialize = superagent.serialize['application/json'];
                        }
                        if (serialize) {
                            data = serialize(data);
                        }
                    }
                    thisReq._data = data;
                    var urlDetails = url.parse(req.url);
                    var queryString = void 0;
                    var query = req._query;
                    var qs = req.qs;
                    if (query && query.length > 0) {
                        // browser version
                        queryString = query.join('&');
                        req._query = [];
                    }
                    else if (qs) {
                        // node version
                        queryString = querystring.stringify(qs);
                        req.qs = null;
                    }
                    if (queryString) {
                        if (urlDetails.search) {
                            urlDetails.search += '&' + queryString;
                        }
                        else {
                            urlDetails.search = '?' + queryString;
                        }
                        req.url = url.format(urlDetails);
                    }
                    var requestProperties = self.calculateRequestHeaders({ url: req.url, token: self._token, text: data });
                    thisReq.set('Auth-Timestamp', requestProperties.timestamp.toString());
                    // we're not sending the actual token, but only its hash
                    thisReq.set('Authorization', 'Bearer ' + requestProperties.tokenHash);
                    // set the HMAC
                    thisReq.set('HMAC', requestProperties.hmac);
                }
                return prototypicalEnd.apply(thisReq, arguments);
            };
            // verify that the response received from the server is signed correctly
            // right now, it is very permissive with the timestamp variance
            req.verifyResponse = function (response) {
                if (!req.isV2Authenticated || !req.authenticationToken) {
                    return response;
                }
                var verificationResponse = self.verifyResponse({
                    url: req.url,
                    hmac: response.header.hmac,
                    statusCode: response.status,
                    text: response.text,
                    timestamp: response.header.timestamp,
                    token: req.authenticationToken
                });
                if (!verificationResponse.isValid) {
                    // calculate the HMAC
                    var receivedHmac = response.header.hmac;
                    var expectedHmac = verificationResponse.expectedHmac;
                    var signatureSubject = verificationResponse.signatureSubject;
                    // Log only the first 10 characters of the token to ensure the full token isn't logged.
                    var partialBitgoToken = self._token ? self._token.substring(0, 10) : '';
                    var errorDetails = {
                        expectedHmac: expectedHmac,
                        receivedHmac: receivedHmac,
                        hmacInput: signatureSubject,
                        requestToken: req.authenticationToken,
                        bitgoToken: partialBitgoToken
                    };
                    debug('Invalid response HMAC: %O', errorDetails);
                    var error = new Error('invalid response HMAC, possible man-in-the-middle-attack');
                    error.result = errorDetails;
                    error.status = 511;
                    throw error;
                }
                return response;
            };
            var lastPromise = null;
            req.then = function () {
                if (!lastPromise) {
                    // cannot redefine end() to return a Bluebird<any>, even though
                    // that gets monkey patched in at runtime, so this cast is required
                    var reference = req.end()
                        .then(req.verifyResponse);
                    lastPromise = reference.then.apply(reference, arguments);
                }
                else {
                    lastPromise = lastPromise.then.apply(lastPromise, arguments);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return lastPromise;
            };
            if (!process.browser) {
                // If not in the browser, set the User-Agent. Browsers don't allow
                // setting of User-Agent, so we must disable this when run in the
                // browser (browserify sets process.browser).
                req.set('User-Agent', self._userAgent);
            }
            // Set the request timeout to just above 5 minutes by default
            req.timeout(process.env.BITGO_TIMEOUT * 1000 || 305 * 1000);
            return req;
        };
    };
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    BitGo.prototype.calculateHMAC = function (key, message) {
        return crypto.createHmac('sha256', key).update(message).digest('hex');
    };
    /**
     * Create a basecoin object
     * @param coinName
     */
    BitGo.prototype.coin = function (coinName) {
        return coinFactory_1.GlobalCoinFactory.getInstance(this, coinName);
    };
    /**
     * Create a basecoin object for a virtual token
     * @param tokenName
     * @param callback
     */
    BitGo.prototype.token = function (tokenName, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.fetchConstants()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, self.coin(tokenName)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     *
     */
    BitGo.prototype.getValidate = function () {
        return this._validate;
    };
    /**
     *
     */
    BitGo.prototype.setValidate = function (validate) {
        if (!_.isBoolean(validate)) {
            throw new Error('invalid argument');
        }
        this._validate = validate;
    };
    /**
     * Return the current BitGo environment
     */
    BitGo.prototype.getEnv = function () {
        return this._env;
    };
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    BitGo.prototype.clear = function () {
        // TODO: are there any other fields which should be cleared?
        this._user = undefined;
        this._token = undefined;
        this._refreshToken = undefined;
        this._ecdhXprv = undefined;
    };
    /**
     * Helper function to return a rejected promise or call callback with error
     *
     * @deprecated
     */
    BitGo.prototype.reject = function (msg, callback) {
        return Bluebird.reject(new Error(msg)).nodeify(callback);
    };
    /**
     * Gets the version of the BitGoJS package
     */
    BitGo.prototype.version = function () {
        return pjson.version;
    };
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    BitGo.prototype.toJSON = function () {
        return {
            user: this._user,
            token: this._token,
            extensionKey: this._extensionKey ? this._extensionKey.toWIF() : undefined,
        };
    };
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    BitGo.prototype.fromJSON = function (json) {
        this._user = json.user;
        this._token = json.token;
        if (json.extensionKey) {
            var network = common.Environments[this.getEnv()].network;
            this._extensionKey = bitcoin.ECPair.fromWIF(json.extensionKey, bitcoin.networks[network]);
        }
    };
    /**
     * Get the current user
     */
    BitGo.prototype.user = function () {
        return this._user;
    };
    /**
     * Verify a Bitcoin address is a valid base58 address
     * @deprecated
     */
    BitGo.prototype.verifyAddress = function (params) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['address'], []);
        if (!_.isString(params.address)) {
            throw new Error('missing required string address');
        }
        var address;
        try {
            address = bitcoin.address.fromBase58Check(params.address);
        }
        catch (e) {
            return false;
        }
        var networkName = common.Environments[this.getEnv()].network;
        var network = bitcoin.networks[networkName];
        return address.version === network.pubKeyHash || address.version === network.scriptHash;
    };
    /**
     */
    BitGo.prototype.verifyPassword = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (!_.isString(params.password)) {
            throw new Error('missing required string password');
        }
        if (!this._user || !this._user.username) {
            throw new Error('no current user');
        }
        var hmacPassword = this.calculateHMAC(this._user.username, params.password);
        return this.post(this.url('/user/verifypassword'))
            .send({ password: hmacPassword })
            .result('valid')
            .nodeify(callback);
    };
    /**
     * Utility function to encrypt locally.
     */
    BitGo.prototype.encrypt = function (params) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['input', 'password'], []);
        var randomSalt = crypto.randomBytes(8);
        var randomIV = crypto.randomBytes(16);
        var encryptOptions = {
            iter: 10000,
            ks: 256,
            salt: [
                internal_1.bytesToWord(randomSalt.slice(0, 4)),
                internal_1.bytesToWord(randomSalt.slice(4))
            ],
            iv: [
                internal_1.bytesToWord(randomIV.slice(0, 4)),
                internal_1.bytesToWord(randomIV.slice(4, 8)),
                internal_1.bytesToWord(randomIV.slice(8, 12)),
                internal_1.bytesToWord(randomIV.slice(12, 16))
            ]
        };
        return sjcl.encrypt(params.password, params.input, encryptOptions);
    };
    /**
     * Decrypt an encrypted string locally.
     */
    BitGo.prototype.decrypt = function (params) {
        if (params === void 0) { params = {}; }
        params = params || {};
        common.validateParams(params, ['input', 'password'], []);
        try {
            return sjcl.decrypt(params.password, params.input);
        }
        catch (error) {
            if (error.message.includes('ccm: tag doesn\'t match')) {
                error.message = 'password error - ' + error.message;
            }
            throw error;
        }
    };
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    BitGo.prototype.generateRandomPassword = function (numWords) {
        if (numWords === void 0) { numWords = 5; }
        var bytes = sjcl.codec.bytes.fromBits(sjcl.random.randomWords(numWords));
        return bs58.encode(bytes);
    };
    /**
     * Split a secret into shards using Shamir Secret Sharing.
     * @param seed A hexadecimal secret to split
     * @param passwords An array of the passwords used to encrypt each share
     * @param m The threshold number of shards necessary to reconstitute the secret
     */
    BitGo.prototype.splitSecret = function (_a) {
        var _this = this;
        var seed = _a.seed, passwords = _a.passwords, m = _a.m;
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (!_.isInteger(m) || m < 2) {
            throw new Error('m must be a positive integer greater than or equal to 2');
        }
        if (passwords.length < m) {
            throw new Error('passwords array length cannot be less than m');
        }
        var n = passwords.length;
        var secrets = shamir.share(seed, n, m);
        var shards = _.zipWith(secrets, passwords, function (shard, password) {
            return _this.encrypt({ input: shard, password: password });
        });
        var node = bitcoin.HDNode.fromSeedHex(seed);
        return {
            xpub: node.neutered().toBase58(),
            m: m,
            n: n,
            seedShares: shards,
        };
    };
    /**
     * Reconstitute a secret which was sharded with `splitSecret`.
     * @param shards
     * @param passwords
     */
    BitGo.prototype.reconstituteSecret = function (_a) {
        var _this = this;
        var shards = _a.shards, passwords = _a.passwords;
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        var secrets = _.zipWith(shards, passwords, function (shard, password) {
            return _this.decrypt({ input: shard, password: password });
        });
        var seed = shamir.combine(secrets);
        var node = bitcoin.HDNode.fromSeedHex(seed);
        return {
            xpub: node.neutered().toBase58(),
            xprv: node.toBase58(),
            seed: seed,
        };
    };
    /**
     *
     * @param shards
     * @param passwords
     * @param m
     * @param xpub Optional xpub to verify the results against
     */
    BitGo.prototype.verifyShards = function (_a) {
        var _this = this;
        var shards = _a.shards, passwords = _a.passwords, m = _a.m, xpub = _a.xpub;
        /**
         * Generate all possible combinations of a given array's values given subset size m
         * @param array The array whose values are to be arranged in all combinations
         * @param m The size of each subset
         * @param entryIndices Recursively trailing set of currently chosen array indices for the combination subset under construction
         * @returns {Array}
         */
        var generateCombinations = function (array, m, entryIndices) {
            if (entryIndices === void 0) { entryIndices = []; }
            var combinations = [];
            if (entryIndices.length === m) {
                var currentCombination = _.at(array, entryIndices);
                return [currentCombination];
            }
            // The highest index
            var entryIndex = _.last(entryIndices);
            // If there are currently no indices, assume -1
            if (_.isUndefined(entryIndex)) {
                entryIndex = -1;
            }
            for (var i = entryIndex + 1; i < array.length; i++) {
                // append the current index to the trailing indices
                var currentEntryIndices = entryIndices.concat([i]);
                var newCombinations = generateCombinations(array, m, currentEntryIndices);
                combinations = combinations.concat(newCombinations);
            }
            return combinations;
        };
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        var secrets = _.zipWith(shards, passwords, function (shard, password) {
            return _this.decrypt({ input: shard, password: password });
        });
        var secretCombinations = generateCombinations(secrets, m);
        var seeds = secretCombinations.map(function (currentCombination) {
            return shamir.combine(currentCombination);
        });
        var uniqueSeeds = _.uniq(seeds);
        if (uniqueSeeds.length !== 1) {
            return false;
        }
        var seed = _.first(uniqueSeeds);
        var node = bitcoin.HDNode.fromSeedHex(seed);
        var restoredXpub = node.neutered().toBase58();
        if (!_.isUndefined(xpub)) {
            if (!_.isString(xpub)) {
                throw new Error('xpub must be a string');
            }
            if (restoredXpub !== xpub) {
                return false;
            }
        }
        return true;
    };
    /**
     * Construct an ECDH secret from a private key and other user's public key
     */
    BitGo.prototype.getECDHSecret = function (_a) {
        var otherPubKeyHex = _a.otherPubKeyHex, eckey = _a.eckey;
        if (!_.isString(otherPubKeyHex)) {
            throw new Error('otherPubKeyHex string required');
        }
        if (!_.isObject(eckey)) {
            throw new Error('eckey object required');
        }
        var otherKeyPub = bitcoin.ECPair.fromPublicKeyBuffer(new Buffer(otherPubKeyHex, 'hex'));
        var secretPoint = otherKeyPub.Q.multiply(eckey.d);
        var secret = util_1.Util.bnToByteArrayUnsigned(secretPoint.affineX);
        return new Buffer(secret).toString('hex');
    };
    /**
     * Gets the user's private keychain, used for receiving shares
     */
    BitGo.prototype.getECDHSharingKeychain = function (params, callback) {
        var self = this;
        return this.get(this.url('/user/settings'))
            .result()
            .then(function (result) {
            if (!result.settings.ecdhKeychain) {
                return self.reject('ecdh keychain not found for user', callback);
            }
            return self.keychains().get({ xpub: result.settings.ecdhKeychain });
        })
            .nodeify(callback);
    };
    /**
     * Get bitcoin market data
     */
    BitGo.prototype.markets = function () {
        if (!this._markets) {
            this._markets = new Markets(this);
        }
        return this._markets;
    };
    /**
     * Get the latest bitcoin prices
     * (Deprecated: Will be removed in the future) use `bitgo.markets().latest()`
     * @deprecated
     */
    BitGo.prototype.market = function (params, callback) {
        return this.get(this.url('/market/latest'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get market data from yesterday
     * (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
     */
    BitGo.prototype.yesterday = function (params, callback) {
        return this.get(this.url('/market/yesterday'))
            .result()
            .nodeify(callback);
    };
    /**
     * Synchronous method for activating an access token.
     */
    BitGo.prototype.authenticateWithAccessToken = function (_a) {
        var accessToken = _a.accessToken;
        this._token = accessToken;
    };
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    BitGo.prototype.handleTokenIssuance = function (responseBody, password) {
        // make sure the response body contains the necessary properties
        common.validateParams(responseBody, ['derivationPath'], ['encryptedECDHXprv']);
        var environment = this._env;
        var environmentConfig = common.Environments[environment];
        var serverXpub = environmentConfig.serverXpub;
        var ecdhXprv = this._ecdhXprv;
        if (!ecdhXprv) {
            if (!password || !responseBody.encryptedECDHXprv) {
                throw new Error('ecdhXprv property must be set or password and encrypted encryptedECDHXprv must be provided');
            }
            try {
                ecdhXprv = this.decrypt({
                    input: responseBody.encryptedECDHXprv,
                    password: password
                });
            }
            catch (e) {
                e.errorCode = 'ecdh_xprv_decryption_failure';
                console.error('Failed to decrypt encryptedECDHXprv.');
                throw e;
            }
        }
        // construct HDNode objects for client's xprv and server's xpub
        var clientHDNode = bitcoin.HDNode.fromBase58(ecdhXprv);
        var serverHDNode = bitcoin.HDNode.fromBase58(serverXpub);
        // BIP32 derivation path is applied to both client and server master keys
        var derivationPath = responseBody.derivationPath;
        var clientDerivedNode = bitcoin_1.hdPath(clientHDNode).derive(derivationPath);
        var serverDerivedNode = bitcoin_1.hdPath(serverHDNode).derive(derivationPath);
        // calculating one-time ECDH key
        var secretPoint = serverDerivedNode.keyPair.__Q.multiply(clientDerivedNode.keyPair.d);
        var secret = secretPoint.getEncoded().toString('hex');
        // decrypt token with symmetric ECDH key
        var response;
        try {
            response = {
                token: this.decrypt({
                    input: responseBody.encryptedToken,
                    password: secret
                })
            };
        }
        catch (e) {
            e.errorCode = 'token_decryption_failure';
            console.error('Failed to decrypt token.');
            throw e;
        }
        if (!this._ecdhXprv) {
            response.ecdhXprv = ecdhXprv;
        }
        return response;
    };
    /**
     * Calculate the string that is to be HMACed for a certain HTTP request or response
     * @param urlPath
     * @param text
     * @param timestamp
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @returns {string}
     */
    BitGo.prototype.calculateHMACSubject = function (_a) {
        var urlPath = _a.urlPath, text = _a.text, timestamp = _a.timestamp, statusCode = _a.statusCode;
        var urlDetails = url.parse(urlPath);
        var queryPath = (urlDetails.query && urlDetails.query.length > 0) ? urlDetails.path : urlDetails.pathname;
        if (!_.isUndefined(statusCode) && _.isInteger(statusCode) && _.isFinite(statusCode)) {
            return [timestamp, queryPath, statusCode, text].join('|');
        }
        return [timestamp, queryPath, text].join('|');
    };
    /**
     * Calculate the HMAC for an HTTP request
     */
    BitGo.prototype.calculateRequestHMAC = function (_a) {
        var urlPath = _a.url, text = _a.text, timestamp = _a.timestamp, token = _a.token;
        var signatureSubject = this.calculateHMACSubject({ urlPath: urlPath, text: text, timestamp: timestamp });
        // calculate the HMAC
        return this.calculateHMAC(token, signatureSubject);
    };
    /**
     * Calculate request headers with HMAC
     */
    BitGo.prototype.calculateRequestHeaders = function (_a) {
        var url = _a.url, text = _a.text, token = _a.token;
        var timestamp = Date.now();
        var hmac = this.calculateRequestHMAC({ url: url, text: text, timestamp: timestamp, token: token });
        // calculate the SHA256 hash of the token
        var hashDigest = sjcl.hash.sha256.hash(token);
        var tokenHash = sjcl.codec.hex.fromBits(hashDigest);
        return {
            hmac: hmac,
            timestamp: timestamp,
            tokenHash: tokenHash,
        };
    };
    /**
     * Verify the HMAC for an HTTP response
     */
    BitGo.prototype.verifyResponse = function (_a) {
        var urlPath = _a.url, statusCode = _a.statusCode, text = _a.text, timestamp = _a.timestamp, token = _a.token, hmac = _a.hmac;
        var signatureSubject = this.calculateHMACSubject({
            urlPath: urlPath,
            text: text,
            timestamp: timestamp,
            statusCode: statusCode,
        });
        // calculate the HMAC
        var expectedHmac = this.calculateHMAC(token, signatureSubject);
        // verify the HMAC and timestamp
        return {
            isValid: expectedHmac === hmac,
            expectedHmac: expectedHmac,
            signatureSubject: signatureSubject,
        };
    };
    /**
     *
     */
    BitGo.prototype.preprocessAuthenticationParams = function (_a) {
        var username = _a.username, password = _a.password, otp = _a.otp, forceSMS = _a.forceSMS, extensible = _a.extensible, trust = _a.trust;
        if (!_.isString('username')) {
            throw new Error('expected string username');
        }
        if (!_.isString('password')) {
            throw new Error('expected string password');
        }
        var lowerName = username.toLowerCase();
        // Calculate the password HMAC so we don't send clear-text passwords
        var hmacPassword = this.calculateHMAC(lowerName, password);
        var authParams = {
            email: lowerName,
            password: hmacPassword,
            forceSMS: !!forceSMS,
        };
        if (otp) {
            authParams.otp = otp;
            if (trust) {
                authParams.trust = 1;
            }
        }
        if (extensible) {
            this._extensionKey = bitcoin_1.makeRandomKey();
            authParams.extensible = true;
            authParams.extensionAddress = this._extensionKey.getAddress();
        }
        return authParams;
    };
    /**
     * Login to the bitgo platform.
     */
    BitGo.prototype.authenticate = function (params, callback) {
        var self = this;
        return co(function () {
            var forceV1Auth, authParams, password, authUrl, request, response, body, encryptedXprv, responseDetails;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error('required object params');
                        }
                        if (callback && !_.isFunction(callback)) {
                            throw new Error('callback parameter must be a function');
                        }
                        if (!_.isString(params.password)) {
                            throw new Error('expected string password');
                        }
                        forceV1Auth = !!params.forceV1Auth;
                        authParams = self.preprocessAuthenticationParams(params);
                        password = params.password;
                        if (self._token) {
                            return [2 /*return*/, self.reject('already logged in', callback)];
                        }
                        authUrl = self._microservicesUrl ?
                            self.microservicesUrl('/api/auth/v1/session') :
                            self.url('/user/login');
                        request = self.post(authUrl);
                        if (forceV1Auth) {
                            request.forceV1Auth = true;
                            // tell the server that the client was forced to downgrade the authentication protocol
                            authParams.forceV1Auth = true;
                        }
                        return [4 /*yield*/, request.send(authParams)];
                    case 1:
                        response = _a.sent();
                        body = response.body;
                        self._user = body.user;
                        if (body.access_token) {
                            self._token = body.access_token;
                            // if the downgrade was forced, adding a warning message might be prudent
                        }
                        else {
                            encryptedXprv = body.encryptedECDHXprv;
                            if (!encryptedXprv) {
                                throw new Error('Keychain needs encryptedXprv property');
                            }
                            responseDetails = self.handleTokenIssuance(response.body, password);
                            self._token = responseDetails.token;
                            self._ecdhXprv = responseDetails.ecdhXprv;
                            // verify the response's authenticity
                            request.verifyResponse(response);
                            // add the remaining component for easier access
                            response.body.access_token = self._token;
                        }
                        return [2 /*return*/, response];
                }
            });
        }).call(this)
            .then(handleResponseResult(), handleResponseError)
            .nodeify(callback);
    };
    /**
     * @param params
     * - operatingSystem: one of ios, android
     * - pushToken: hex-formatted token for the respective native push notification service
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.registerPushToken = function (params, callback) {
        params = params || {};
        common.validateParams(params, ['pushToken', 'operatingSystem'], [], callback);
        if (!this._token) {
            // this device has to be registered to an extensible session
            return this.reject('not logged in', callback);
        }
        var postParams = _.pick(params, ['pushToken', 'operatingSystem']);
        return this.post(this.url('/devices'))
            .send(postParams)
            .result()
            .nodeify(callback);
    };
    /**
     *
     * @param params
     * - pushVerificationToken: the token received via push notification to confirm the device's mobility
     * @param callback
     * @deprecated
     */
    BitGo.prototype.verifyPushToken = function (params, callback) {
        var self = this;
        return co(function () {
            var postParams;
            return __generator(this, function (_a) {
                if (!_.isObject(params)) {
                    throw new Error('required object params');
                }
                if (!_.isString(params.pushVerificationToken)) {
                    throw new Error('required string pushVerificationToken');
                }
                if (!self._token) {
                    // this device has to be registered to an extensible session
                    throw new Error('not logged in');
                }
                postParams = _.pick(params, 'pushVerificationToken');
                return [2 /*return*/, self.post(self.url('/devices/verify'))
                        .send(postParams)
                        .result()];
            });
        }).call(this)
            .nodeify(callback);
    };
    /**
     * Login to the bitgo system using an authcode generated via Oauth
     */
    BitGo.prototype.authenticateWithAuthCode = function (params, callback) {
        var self = this;
        return co(function () {
            var authCode, request, body, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error('required object params');
                        }
                        if (!_.isString(params.authCode)) {
                            throw new Error('required string authCode');
                        }
                        if (!self._clientId || !self._clientSecret) {
                            throw new Error('Need client id and secret set first to use this');
                        }
                        authCode = params.authCode;
                        if (self._token) {
                            return [2 /*return*/, self.reject('already logged in', callback)];
                        }
                        request = self.post(self._baseUrl + '/oauth/token');
                        request.forceV1Auth = true; // OAuth currently only supports v1 authentication
                        return [4 /*yield*/, request
                                .send({
                                grant_type: 'authorization_code',
                                code: authCode,
                                client_id: self._clientId,
                                client_secret: self._clientSecret,
                            })
                                .result()];
                    case 1:
                        body = _b.sent();
                        self._token = body.access_token;
                        self._refreshToken = body.refresh_token;
                        _a = self;
                        return [4 /*yield*/, self.me()];
                    case 2:
                        _a._user = _b.sent();
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    BitGo.prototype.refreshToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var refreshToken, body;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['refreshToken'], callback);
                        refreshToken = params.refreshToken || self._refreshToken;
                        if (!refreshToken) {
                            throw new Error('Must provide refresh token or have authenticated with Oauth before');
                        }
                        if (!self._clientId || !self._clientSecret) {
                            throw new Error('Need client id and secret set first to use this');
                        }
                        return [4 /*yield*/, self.post(self._baseUrl + '/oauth/token')
                                .send({
                                grant_type: 'refresh_token',
                                refresh_token: refreshToken,
                                client_id: self._clientId,
                                client_secret: self._clientSecret
                            })
                                .result()];
                    case 1:
                        body = _a.sent();
                        self._token = body.access_token;
                        self._refreshToken = body.refresh_token;
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    BitGo.prototype.listAccessTokens = function (params, callback) {
        return this.get(this.url('/user/accesstoken'))
            .send()
            .result('accessTokens')
            .nodeify(callback);
    };
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @param callback
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    BitGo.prototype.addAccessToken = function (params, callback) {
        var self = this;
        return co(function () {
            var authUrl, request, response, responseDetails;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(params.label)) {
                            throw new Error('required string label');
                        }
                        // check non-string params
                        if (params.duration) {
                            if (!_.isNumber(params.duration) || params.duration < 0) {
                                throw new Error('duration must be a non-negative number');
                            }
                        }
                        if (params.ipRestrict) {
                            if (!_.isArray(params.ipRestrict)) {
                                throw new Error('ipRestrict must be an array');
                            }
                            _.forEach(params.ipRestrict, function (ipAddr) {
                                if (!_.isString(ipAddr)) {
                                    throw new Error('ipRestrict must be an array of IP address strings');
                                }
                            });
                        }
                        if (params.txValueLimit) {
                            if (!_.isNumber(params.txValueLimit)) {
                                throw new Error('txValueLimit must be a number');
                            }
                            if (params.txValueLimit < 0) {
                                throw new Error('txValueLimit must be a non-negative number');
                            }
                        }
                        if (params.scope && params.scope.length > 0) {
                            if (!_.isArray(params.scope)) {
                                throw new Error('scope must be an array');
                            }
                        }
                        else {
                            throw new Error('must specify scope for token');
                        }
                        authUrl = self._microservicesUrl ?
                            self.microservicesUrl('/api/auth/v1/accesstoken') :
                            self.url('/user/accesstoken');
                        request = self.post(authUrl);
                        if (!self._ecdhXprv) {
                            // without a private key, the user cannot decrypt the new access token the server will send
                            request.forceV1Auth = true;
                        }
                        return [4 /*yield*/, request.send(params)];
                    case 1:
                        response = _a.sent();
                        if (request.forceV1Auth) {
                            response.body.warning = 'A protocol downgrade has occurred because this is a legacy account.';
                            return [2 /*return*/, response];
                        }
                        // verify the authenticity of the server's response before proceeding any further
                        request.verifyResponse(response);
                        responseDetails = self.handleTokenIssuance(response.body);
                        response.body.token = responseDetails.token;
                        return [2 /*return*/, response];
                }
            });
        }).call(this)
            .then(handleResponseResult(), handleResponseError)
            .nodeify(callback);
    };
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     * @param callback
     */
    BitGo.prototype.removeAccessToken = function (_a, callback) {
        var id = _a.id, label = _a.label;
        var self = this;
        return co(function () {
            var tokens, matchingTokens;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ((!id && !label) || (id && label)) {
                            throw new Error('must provide exactly one of id or label');
                        }
                        if (id) {
                            return [2 /*return*/, self.del(self.url("/user/accesstoken/" + id))
                                    .send()
                                    .result()];
                        }
                        return [4 /*yield*/, self.listAccessTokens()];
                    case 1:
                        tokens = _a.sent();
                        if (!tokens) {
                            throw new Error('token with this label does not exist');
                        }
                        matchingTokens = _.filter(tokens, { label: label });
                        if (matchingTokens.length > 1) {
                            throw new Error('ambiguous call: multiple tokens matching this label');
                        }
                        if (matchingTokens.length === 0) {
                            throw new Error('token with this label does not exist');
                        }
                        return [2 /*return*/, self.del(self.url("/user/accesstoken/" + matchingTokens[0].id))
                                .send()
                                .result()];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Logout of BitGo
     * @param params
     * @param callback
     */
    BitGo.prototype.logout = function (params, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.get(self.url('/user/logout')).result()];
                    case 1:
                        result = _a.sent();
                        self.clear();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Get a user by ID (name/email only)
     * @param id
     * @param callback
     */
    BitGo.prototype.getUser = function (_a, callback) {
        var id = _a.id;
        return co(function () {
            return __generator(this, function (_a) {
                if (!_.isString(id)) {
                    throw new Error('expected string id');
                }
                return [2 /*return*/, this.get(this.url("/user/" + id)).result('user')];
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Change the password of the currently logged in user.
     * Also change all v1 and v2 keychain passwords if they match the
     * given oldPassword. Returns nothing on success.
     * @param oldPassword {String} - the current password
     * @param newPassword {String} - the new password
     * @param callback
     */
    BitGo.prototype.changePassword = function (_a, callback) {
        var oldPassword = _a.oldPassword, newPassword = _a.newPassword;
        var self = this;
        return co(function coChangePassword() {
            var user, validation, coin, updateKeychainPasswordParams, v1KeychainUpdatePWResult, v2Keychains, updatePasswordParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(oldPassword)) {
                            throw new Error('expected string oldPassword');
                        }
                        if (!_.isString(newPassword)) {
                            throw new Error('expected string newPassword');
                        }
                        user = self.user();
                        if (typeof user !== 'object' || !user.username) {
                            throw new Error('missing required object user');
                        }
                        return [4 /*yield*/, self.verifyPassword({ password: oldPassword })];
                    case 1:
                        validation = _a.sent();
                        if (!validation) {
                            throw new Error('the provided oldPassword is incorrect');
                        }
                        coin = common.Environments[self.getEnv()].network === 'bitcoin' ? 'btc' : 'tbtc';
                        updateKeychainPasswordParams = { oldPassword: oldPassword, newPassword: newPassword };
                        return [4 /*yield*/, self.keychains().updatePassword(updateKeychainPasswordParams)];
                    case 2:
                        v1KeychainUpdatePWResult = _a.sent();
                        return [4 /*yield*/, self.coin(coin).keychains().updatePassword(updateKeychainPasswordParams)];
                    case 3:
                        v2Keychains = _a.sent();
                        updatePasswordParams = {
                            keychains: v1KeychainUpdatePWResult.keychains,
                            v2_keychains: v2Keychains,
                            version: v1KeychainUpdatePWResult.version,
                            oldPassword: self.calculateHMAC(user.username, oldPassword),
                            password: self.calculateHMAC(user.username, newPassword)
                        };
                        return [2 /*return*/, self.post(self.url('/user/changepassword'))
                                .send(updatePasswordParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get the current logged in user
     * @param params
     * @param callback
     */
    BitGo.prototype.me = function (params, callback) {
        return this.getUser({ id: 'me' }, callback);
    };
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     * @param callback
     */
    BitGo.prototype.unlock = function (_a, callback) {
        var otp = _a.otp, duration = _a.duration;
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (otp && !_.isString(otp)) {
                    throw new Error('expected string or undefined otp');
                }
                return [2 /*return*/, self.post(self.url('/user/unlock'))
                        .send({ otp: otp, duration: duration })
                        .result()];
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Lock the session
     * @param params
     * @param callback
     */
    BitGo.prototype.lock = function (params, callback) {
        return this.post(this.url('/user/lock'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the current session
     */
    BitGo.prototype.session = function (params, callback) {
        return this.get(this.url('/user/session'))
            .result('session')
            .nodeify(callback);
    };
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    BitGo.prototype.sendOTP = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.post(this.url('/user/sendotp'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     * @param callback
     */
    BitGo.prototype.extendToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (!this._extensionKey) {
            throw new Error('missing required property _extensionKey');
        }
        var timestamp = Date.now();
        var duration = params.duration;
        var message = timestamp + '|' + this._token + '|' + duration;
        var privateKey = this._extensionKey.d.toBuffer(32);
        var isCompressed = this._extensionKey.compressed;
        var prefix = bitcoin.networks.bitcoin.messagePrefix;
        var signature = bitcoinMessage.sign(message, privateKey, isCompressed, prefix).toString('hex');
        return this.post(this.url('/user/extendtoken'))
            .send(params)
            .set('timestamp', timestamp.toString())
            .set('signature', signature)
            .result()
            .nodeify(callback);
    };
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     * @param callback
     */
    BitGo.prototype.getSharingKey = function (_a, callback) {
        var email = _a.email;
        if (!_.isString(email)) {
            throw new Error('required string email');
        }
        return this.post(this.url('/user/sharingkey'))
            .send({ email: email })
            .result()
            .nodeify(callback);
    };
    /**
     * Test connectivity to the server
     * @param params
     * @param callback
     */
    BitGo.prototype.ping = function (_a, callback) {
        var reqId = (_a === void 0 ? {} : _a).reqId;
        if (reqId) {
            this._reqId = reqId;
        }
        return this.get(this.url('/ping'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the blockchain object.
     * @deprecated
     */
    BitGo.prototype.blockchain = function () {
        if (!this._blockchain) {
            this._blockchain = new Blockchain(this);
        }
        return this._blockchain;
    };
    /**
     * Get the user's keychains object.
     * @deprecated
     */
    BitGo.prototype.keychains = function () {
        if (!this._keychains) {
            this._keychains = new Keychains(this);
        }
        return this._keychains;
    };
    /**
     * Get the user's wallets object.
     * @deprecated
     */
    BitGo.prototype.wallets = function () {
        if (!this._wallets) {
            this._wallets = new Wallets(this);
        }
        return this._wallets;
    };
    /**
     * Get the travel rule object
     * @deprecated
     */
    BitGo.prototype.travelRule = function () {
        if (!this._travelRule) {
            this._travelRule = new TravelRule(this);
        }
        return this._travelRule;
    };
    /**
     * Get pending approvals that can be approved/ or rejected
     * @deprecated
     */
    BitGo.prototype.pendingApprovals = function () {
        if (!this._pendingApprovals) {
            this._pendingApprovals = new PendingApprovals(this);
        }
        return this._pendingApprovals;
    };
    /**
     * A factory method to create a new Wallet object, initialized with the wallet params
     * Can be used to reconstitute a wallet from cached data
     * @param walletParams
     * @deprecated
     */
    BitGo.prototype.newWalletObject = function (walletParams) {
        return new Wallet(this, walletParams);
    };
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    BitGo.prototype.url = function (path, version) {
        if (version === void 0) { version = 1; }
        var baseUrl = version === 2 ? this._baseApiUrlV2 : this._baseApiUrl;
        return baseUrl + path;
    };
    /**
     * Create a url for calling BitGo microservice APIs
     */
    BitGo.prototype.microservicesUrl = function (path) {
        return this._microservicesUrl + path;
    };
    /**
     * Get all the address labels on all of the user's wallets
     */
    BitGo.prototype.labels = function (params, callback) {
        return this.get(this.url('/labels'))
            .result('labels')
            .nodeify(callback);
    };
    /**
     * Estimates approximate fee per kb needed for a tx to get into a block
     * @param {number} params.numBlocks target blocks for the transaction to be confirmed
     * @param {number} params.maxFee maximum fee willing to be paid (for safety)
     * @param {array[string]} params.inputs list of unconfirmed txIds from which this transaction uses inputs
     * @param {number} params.txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
     * @param {boolean} params.cpfpAware flag indicating fee should take into account CPFP
     * @deprecated
     */
    BitGo.prototype.estimateFee = function (params, callback) {
        if (params === void 0) { params = {}; }
        var queryParams = { version: 12 };
        if (params.numBlocks) {
            if (!_.isNumber(params.numBlocks)) {
                throw new Error('invalid argument');
            }
            queryParams.numBlocks = params.numBlocks;
        }
        if (params.maxFee) {
            if (!_.isNumber(params.maxFee)) {
                throw new Error('invalid argument');
            }
            queryParams.maxFee = params.maxFee;
        }
        if (params.inputs) {
            if (!Array.isArray(params.inputs)) {
                throw new Error('invalid argument');
            }
            queryParams.inputs = params.inputs;
        }
        if (params.txSize) {
            if (!_.isNumber(params.txSize)) {
                throw new Error('invalid argument');
            }
            queryParams.txSize = params.txSize;
        }
        if (params.cpfpAware) {
            if (!_.isBoolean(params.cpfpAware)) {
                throw new Error('invalid argument');
            }
            queryParams.cpfpAware = params.cpfpAware;
        }
        return this.get(this.url('/tx/fee'))
            .query(queryParams)
            .result()
            .nodeify(callback);
    };
    /**
     * Get BitGo's guarantee using an instant id
     * @param params
     * @param callback
     * @deprecated
     */
    BitGo.prototype.instantGuarantee = function (params, callback) {
        var self = this;
        return co(function () {
            var body, signingAddress, signatureBuffer, prefix, isValidSignature;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(params.id)) {
                            throw new Error('required string id');
                        }
                        return [4 /*yield*/, self.get(self.url('/instant/' + params.id)).result()];
                    case 1:
                        body = _a.sent();
                        if (!body.guarantee) {
                            throw new Error('no guarantee found in response body');
                        }
                        if (!body.signature) {
                            throw new Error('no signature found in guarantee response body');
                        }
                        signingAddress = common.Environments[self.getEnv()].signingAddress;
                        signatureBuffer = new Buffer(body.signature, 'hex');
                        prefix = bitcoin.networks[common.Environments[self.getEnv()].network].messagePrefix;
                        isValidSignature = bitcoinMessage.verify(body.guarantee, signingAddress, signatureBuffer, prefix);
                        if (!isValidSignature) {
                            throw new Error('incorrect signature');
                        }
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Get a target address for payment of a BitGo fee
     * @param params
     * @param callback
     * @deprecated
     */
    BitGo.prototype.getBitGoFeeAddress = function (params, callback) {
        return this.post(this.url('/billing/address'))
            .send({})
            .result()
            .nodeify(callback);
    };
    /**
     * Gets an address object (including the wallet id) for a given address.
     * @param {string} params.address The address to look up.
     * @deprecated
     */
    BitGo.prototype.getWalletAddress = function (_a, callback) {
        var address = _a.address;
        return this.get(this.url("/walletaddress/" + address))
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch list of user webhooks
     *
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.listWebhooks = function (callback) {
        return this.get(this.url('/webhooks'))
            .result()
            .nodeify(callback);
    };
    /**
     * Add new user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.addWebhook = function (params, callback) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.post(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Remove user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.removeWebhook = function (params, callback) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.del(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch list of webhook notifications for the user
     *
     * @param params
     * @param callback
     * @returns {*}
     */
    BitGo.prototype.listWebhookNotifications = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.get(this.url('/webhooks/notifications'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Simulate a user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     */
    BitGo.prototype.simulateWebhook = function (params, callback) {
        common.validateParams(params, ['webhookId', 'blockId'], [], callback);
        if (!_.isString(params.webhookId)) {
            throw new Error('required string webhookId');
        }
        if (!_.isString(params.blockId)) {
            throw new Error('required string blockId');
        }
        return this.post(this.url("/webhooks/" + params.webhookId + "/simulate"))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Receives a TTL and refetches as necessary
     * @param params
     * @param callback
     */
    BitGo.prototype.fetchConstants = function (params, callback) {
        var self = this;
        return co(function () {
            var env, resultPromise, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        env = self.getEnv();
                        if (!BitGo._constants) {
                            BitGo._constants = {};
                        }
                        if (!BitGo._constantsExpire) {
                            BitGo._constantsExpire = {};
                        }
                        if (BitGo._constants[env] && BitGo._constantsExpire[env] && new Date() < BitGo._constantsExpire[env]) {
                            return [2 /*return*/, BitGo._constants[env]];
                        }
                        resultPromise = superagent.get(self.url('/client/constants'));
                        return [4 /*yield*/, (self._proxy ? resultPromise.proxy(self._proxy) : resultPromise)];
                    case 1:
                        result = _a.sent();
                        BitGo._constants[env] = result.body.constants;
                        BitGo._constantsExpire[env] = moment.utc().add(result.body.ttl, 'second').toDate();
                        return [2 /*return*/, BitGo._constants[env]];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Synchronously get constants which are relevant to the client.
     *
     * Note: This function has a known race condition. It may return different values over time,
     * especially if called shortly after creation of the BitGo object.
     *
     * New code should call fetchConstants() directly instead.
     *
     * @deprecated
     * @param params
     * @return {Object} The client constants object
     */
    BitGo.prototype.getConstants = function (params) {
        // kick off a fresh request for the client constants
        this.fetchConstants(params, function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch client constants from BitGo');
                console.trace(err);
            }
        });
        // use defaultConstants as the backup for keys that are not set in this._constants
        return _.merge({}, config.defaultConstants(this.getEnv()), BitGo._constants[this.getEnv()]);
    };
    /**
     * V1 method for calculating miner fee amounts, given the number and
     * type of transaction inputs, along with a fee rate in satoshis per vkB.
     *
     * This method should not be used for new code.
     *
     * @deprecated
     * @param params
     * @param callback
     * @return {any}
     */
    BitGo.prototype.calculateMinerFeeInfo = function (params, callback) {
        return co(function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, TransactionBuilder.calculateMinerFeeInfo(params)];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    BitGo.prototype.setRequestTracer = function (reqTracer) {
        if (reqTracer) {
            this._reqId = reqTracer;
        }
    };
    BitGo._testnetWarningMessage = false;
    return BitGo;
}());
exports.BitGo = BitGo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Z28uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYml0Z28udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLEVBQUU7QUFDRix1QkFBdUI7QUFDdkIsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVGLHVDQUF5QztBQUN6Qyx3Q0FBMEM7QUFDMUMscUNBQWtEO0FBQ2xELGtEQUFxRDtBQUNyRCw0Q0FBK0M7QUFDL0MseUJBQTRCO0FBRTVCLElBQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDdkQsMENBQTZDO0FBQzdDLDJDQUE4QztBQUM5QywyQkFBOEI7QUFDOUIsaUNBQW1DO0FBR25DLDJDQUF5RDtBQUV6RCxtQ0FBcUM7QUFDckMsSUFBTyxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUMvQix1Q0FBMEM7QUFDMUMsK0JBQWtDO0FBQ2xDLDBCQUE0QjtBQUM1Qix5QkFBMkI7QUFDM0IseUNBQTJDO0FBQzNDLGlDQUFtQztBQUNuQywrQkFBaUM7QUFDakMsZ0NBQWtDO0FBQ2xDLG1EQUFxRDtBQUVyRCxJQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQzNELElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUMzQyxJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDekMsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQzNDLGlDQUFvQztBQUNwQyxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDckMsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3JDLGdEQUFxRDtBQUVyRCxJQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7QUFFdEMsSUFBSSxDQUFFLE9BQWUsQ0FBQyxPQUFPLEVBQUU7SUFDN0IsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7Q0FDekM7QUFFRCwrQ0FBK0M7QUFDL0MsSUFBTSxJQUFJLEdBQUksVUFBa0IsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztBQUN0RCxVQUFrQixDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFVBQVMsRUFBRTtJQUNyRCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7SUFDbEIsSUFBSSxPQUFPLEVBQUUsS0FBSyxVQUFVLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztLQUM1QjtJQUVELE9BQU8sSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQVMsT0FBTyxFQUFFLE1BQU07UUFDbEQsSUFBSSxLQUFLLENBQUM7UUFDVixJQUFJO1lBQ0YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFTLEtBQUssRUFBRSxRQUFRO2dCQUM3QyxJQUFJLEtBQUssRUFBRTtvQkFDVCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDdEI7Z0JBQ0QsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0IsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUFDLE9BQU8sTUFBTSxFQUFFO1lBQ2YsS0FBSyxHQUFHLE1BQU0sQ0FBQztZQUNmLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3RCO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUM7QUFFRiwwRUFBMEU7QUFDMUUsbUVBQW1FO0FBQ2xFLFVBQWtCLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBUyxhQUFzQjtJQUM1RSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsYUFBYSxDQUFDLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztBQUM3RSxDQUFDLENBQUM7QUFFRixTQUFTLG9CQUFvQixDQUFDLGFBQXNCO0lBQ2xELE9BQU8sVUFBUyxHQUF3QjtRQUN0QyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFO1lBQ25FLE9BQU8sYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1NBQzNEO1FBQ0QsTUFBTSxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDN0IsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLEdBQXdCO0lBQy9DLElBQU0sU0FBUyxHQUFHLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pELElBQU0sR0FBRyxHQUFRLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRXRDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztJQUN4QixJQUFJLEdBQUcsQ0FBQyxJQUFJLEVBQUU7UUFDWixHQUFHLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7S0FDdkI7SUFDRCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxFQUFFO1FBQ3RGLEdBQUcsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO0tBQ3pCO0lBQ0QsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUNyQixHQUFHLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztLQUNyQjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQUMsQ0FBQztJQUM1QixJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUU7UUFDZCxNQUFNLGVBQWUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDbkM7SUFDRCxNQUFNLENBQUMsQ0FBQztBQUNWLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyx5QkFBeUIsQ0FBQyxHQUF3QjtJQUN6RCxJQUFJLFNBQVMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsK0NBQStDO0lBQ3RGLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDbEIsMEZBQTBGO1FBQzFGLFNBQVMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1QjtTQUFNO1FBQ0wsSUFBSSxHQUFHLENBQUMsSUFBSSxFQUFFO1lBQ1osZ0dBQWdHO1lBQ2hHLDZGQUE2RjtZQUM3RixJQUFJO2dCQUNGLElBQUksYUFBYSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ2hFLGFBQWEsR0FBRyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3JDLGFBQWEsR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsNEJBQTRCO2dCQUNuRSxhQUFhLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQywwQ0FBMEM7Z0JBQy9HLGFBQWEsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxzQ0FBc0M7Z0JBQ3JHLGFBQWEsR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLHlDQUF5QztnQkFDM0YsU0FBUyxHQUFHLFNBQVMsR0FBRyxJQUFJLEdBQUcsYUFBYSxDQUFDLENBQUMsNkVBQTZFO2FBQzVIO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YscUVBQXFFO2FBQ3RFO1NBQ0Y7S0FDRjtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUEwUEQ7SUFpQ0U7O09BRUc7SUFDSCxlQUFZLE1BQXlCO1FBQXpCLHVCQUFBLEVBQUEsV0FBeUI7UUFDbkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLFVBQVUsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLHNCQUFzQixFQUFFLFlBQVksRUFBRSw0QkFBNEIsQ0FBQyxDQUFDO1lBQ25NLENBQUMsTUFBTSxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUU7WUFDOUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1NBQ3JDO1FBRUQsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDakQsTUFBTSxJQUFJLEtBQUssQ0FBQywyREFBMkQsQ0FBQyxDQUFDO1NBQzlFO1FBRUQsNkNBQTZDO1FBQzdDLHdDQUF3QztRQUN4QyxJQUFJLEdBQW9CLENBQUM7UUFFekIsSUFBSSxNQUFNLENBQUMsYUFBYSxFQUFFO1lBQ3hCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxNQUFNLENBQUMsR0FBRyxLQUFLLE1BQU0sRUFBRTtnQkFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDcEU7WUFDRCxHQUFHLEdBQUcsTUFBTSxDQUFDO1NBQ2Q7YUFBTSxJQUFJLE1BQU0sQ0FBQyxhQUFhO1lBQzdCLE1BQU0sQ0FBQyxvQkFBb0I7WUFDM0IsTUFBTSxDQUFDLG9CQUFvQjtZQUMzQixNQUFNLENBQUMsVUFBVTtZQUNqQixPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQjtZQUNqQyxPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixFQUFFO1lBQzFDLEdBQUcsR0FBRyxRQUFRLENBQUM7WUFDZixJQUFJLE1BQU0sQ0FBQyxhQUFhLEVBQUU7Z0JBQ3hCLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUM7YUFDMUQ7WUFDRCxJQUFJLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRTtnQkFDL0IsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLG9CQUFvQixDQUFDO2FBQ3JFO1lBQ0QsSUFBSSxNQUFNLENBQUMsb0JBQW9CLEVBQUU7Z0JBQzlCLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFTLENBQUMsb0JBQW9CLEdBQUcsTUFBTSxDQUFDLG9CQUFvQixDQUFDO2FBQzNGO1lBQ0QsSUFBSSxNQUFNLENBQUMsVUFBVSxFQUFFO2dCQUNyQixNQUFNLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO2FBQzlEO1lBQ0QsSUFBSSxNQUFNLENBQUMsMEJBQTBCLEVBQUU7Z0JBQ3JDLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsMEJBQTBCLEdBQUcsTUFBTSxDQUFDLDBCQUEwQixDQUFDO2FBQzlGO1NBQ0Y7YUFBTTtZQUNMLEdBQUcsR0FBRyxNQUFNLENBQUMsR0FBRyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBNEIsQ0FBQztTQUM5RDtRQUVELElBQUksR0FBYSxLQUFLLFlBQVksRUFBRTtZQUNsQyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsbUJBQW1CO1NBQ2xDO1FBRUQsSUFBSSxHQUFHLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNuRSxNQUFNLElBQUksS0FBSyxDQUFDLGtIQUFrSCxDQUFDLENBQUM7U0FDckk7UUFFRCxJQUFJLEdBQUcsRUFBRTtZQUNQLElBQUksTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDNUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQzthQUM5QztpQkFBTTtnQkFDTCxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixHQUFHLEdBQUcsR0FBRyxzQ0FBc0MsQ0FBQyxDQUFDO2FBQ3hGO1NBQ0Y7YUFBTTtZQUNMLEdBQUcsR0FBRyxNQUFNLENBQUM7WUFDYixJQUFJLENBQUMsS0FBSyxDQUFDLHNCQUFzQixFQUFFO2dCQUNqQyxLQUFLLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDO2dCQUNwQyxPQUFPLENBQUMsR0FBRyxDQUFDLCtEQUErRCxDQUFDLENBQUM7YUFDOUU7WUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO1NBQzlDO1FBQ0QsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUUzQixNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEQsTUFBTSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTFELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7UUFDakQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztRQUM3QyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO1FBQy9DLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUNqQyxJQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUM7UUFDekMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQztRQUN6QyxJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxTQUFTLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNsRSxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztRQUV4QiwyRUFBMkU7UUFDM0UsMkVBQTJFO1FBQzNFLDZFQUE2RTtRQUM3RSx5QkFBeUI7UUFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1FBRXhFLDZEQUE2RDtRQUM3RCxJQUFNLE9BQU8sR0FBRyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztRQUV2RCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRTtZQUNoRCxNQUFNLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDO1NBQzVDO1FBRUQsSUFBSyxPQUFlLENBQUMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDNUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO1NBQ25FO1FBRUQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBRTNCLEtBQUssSUFBTSxLQUFLLElBQUksT0FBTyxFQUFFO1lBQzNCLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN6QztRQUVELG1GQUFtRjtRQUNuRixJQUFNLENBQUMsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBRXRCLG1DQUFtQztRQUNuQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxVQUFTLEdBQUc7WUFDbEMsSUFBSSxHQUFHLEVBQUU7Z0JBQ1AsMERBQTBEO2dCQUMxRCxPQUFPLENBQUMsS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7Z0JBQ3JFLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDaEI7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssMkJBQVcsR0FBbkIsVUFBb0IsTUFBYztRQUNoQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTztZQUFTLGNBQU87aUJBQVAsVUFBTyxFQUFQLHFCQUFPLEVBQVAsSUFBTztnQkFBUCx5QkFBTzs7WUFDckIsSUFBSSxHQUFHLEdBQWlDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzdFLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDZixHQUFHLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDOUI7WUFFRCxzQ0FBc0M7WUFDdEMsSUFBTSxlQUFlLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQztZQUNoQyxHQUFHLENBQUMsR0FBRyxHQUFHO2dCQUNSLElBQU0sT0FBTyxHQUFpQyxJQUFJLENBQUM7Z0JBQ25ELGlHQUFpRztnQkFDakcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztnQkFFakQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO29CQUMvQixPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7b0JBRWxELHdFQUF3RTtvQkFDeEUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztvQkFFbEIsb0VBQW9FO29CQUNwRSxzRUFBc0U7b0JBQ3RFLHlFQUF5RTtvQkFDekUsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO2lCQUNwQjtnQkFFRCx3RkFBd0Y7Z0JBQ3hGLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7Z0JBQ2pDLE9BQU8sQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUMxQyxnRUFBZ0U7Z0JBQ2hFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7dUJBQzdFLEdBQUcsQ0FBQyxXQUFXLEVBQUU7b0JBQ3BCLHFCQUFxQjtvQkFDckIsT0FBTyxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQztvQkFFbEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLEVBQUUsU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDdEQsT0FBTyxlQUFlLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFnQixDQUFDLENBQUM7aUJBQ3pEO2dCQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ3pDLG1DQUFtQztnQkFDbkMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRSwrQkFBK0IsQ0FBQyxDQUFDO2dCQUNsRSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBRWYsNENBQTRDO29CQUM1QyxJQUFJLElBQUksR0FBSSxPQUFlLENBQUMsS0FBSyxDQUFDO29CQUNsQyxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTt3QkFFNUIsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQzt3QkFDOUMsdUVBQXVFO3dCQUN2RSxJQUFJLFdBQVcsRUFBRTs0QkFDZixXQUFXLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDekM7d0JBQ0QsSUFBSSxTQUFTLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQzt3QkFDbEQsSUFBSSxDQUFDLFNBQVMsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFOzRCQUNqRCxTQUFTLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO3lCQUN0RDt3QkFDRCxJQUFJLFNBQVMsRUFBRTs0QkFDYixJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO3lCQUN4QjtxQkFDRjtvQkFDQSxPQUFlLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztvQkFFOUIsSUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBRXRDLElBQUksV0FBVyxTQUFvQixDQUFDO29CQUNwQyxJQUFNLEtBQUssR0FBYyxHQUFXLENBQUMsTUFBTSxDQUFDO29CQUM1QyxJQUFNLEVBQUUsR0FBK0IsR0FBVyxDQUFDLEVBQUUsQ0FBQztvQkFDdEQsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7d0JBQzdCLGtCQUFrQjt3QkFDbEIsV0FBVyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQzdCLEdBQVcsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO3FCQUMxQjt5QkFBTSxJQUFJLEVBQUUsRUFBRTt3QkFDYixlQUFlO3dCQUNmLFdBQVcsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO3dCQUN2QyxHQUFXLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQztxQkFDeEI7b0JBRUQsSUFBSSxXQUFXLEVBQUU7d0JBQ2YsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFOzRCQUNyQixVQUFVLENBQUMsTUFBTSxJQUFJLEdBQUcsR0FBRyxXQUFXLENBQUM7eUJBQ3hDOzZCQUFNOzRCQUNMLFVBQVUsQ0FBQyxNQUFNLEdBQUcsR0FBRyxHQUFHLFdBQVcsQ0FBQzt5QkFDdkM7d0JBQ0QsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO3FCQUNsQztvQkFFRCxJQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO29CQUN6RyxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO29CQUV0RSx3REFBd0Q7b0JBQ3hELE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFFdEUsZUFBZTtvQkFDZixPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDN0M7Z0JBRUQsT0FBTyxlQUFlLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFnQixDQUFDLENBQUM7WUFDMUQsQ0FBQyxDQUFDO1lBRUYsd0VBQXdFO1lBQ3hFLCtEQUErRDtZQUMvRCxHQUFHLENBQUMsY0FBYyxHQUFHLFVBQVMsUUFBUTtnQkFDcEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRTtvQkFDdEQsT0FBTyxRQUFRLENBQUM7aUJBQ2pCO2dCQUVELElBQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztvQkFDL0MsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHO29CQUNaLElBQUksRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUk7b0JBQzFCLFVBQVUsRUFBRSxRQUFRLENBQUMsTUFBTTtvQkFDM0IsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJO29CQUNuQixTQUFTLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxTQUFTO29CQUNwQyxLQUFLLEVBQUUsR0FBRyxDQUFDLG1CQUFtQjtpQkFDL0IsQ0FBQyxDQUFDO2dCQUVILElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLEVBQUU7b0JBQ2pDLHFCQUFxQjtvQkFDckIsSUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7b0JBQzFDLElBQU0sWUFBWSxHQUFHLG9CQUFvQixDQUFDLFlBQVksQ0FBQztvQkFDdkQsSUFBTSxnQkFBZ0IsR0FBRyxvQkFBb0IsQ0FBQyxnQkFBZ0IsQ0FBQztvQkFDL0QsdUZBQXVGO29CQUN2RixJQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO29CQUMxRSxJQUFNLFlBQVksR0FBRzt3QkFDbkIsWUFBWSxjQUFBO3dCQUNaLFlBQVksY0FBQTt3QkFDWixTQUFTLEVBQUUsZ0JBQWdCO3dCQUMzQixZQUFZLEVBQUUsR0FBRyxDQUFDLG1CQUFtQjt3QkFDckMsVUFBVSxFQUFFLGlCQUFpQjtxQkFDOUIsQ0FBQztvQkFDRixLQUFLLENBQUMsMkJBQTJCLEVBQUUsWUFBWSxDQUFDLENBQUM7b0JBQ2pELElBQU0sS0FBSyxHQUFRLElBQUksS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUM7b0JBQ3pGLEtBQUssQ0FBQyxNQUFNLEdBQUcsWUFBWSxDQUFDO29CQUM1QixLQUFLLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztvQkFDbkIsTUFBTSxLQUFLLENBQUM7aUJBQ2I7Z0JBQ0QsT0FBTyxRQUFRLENBQUM7WUFDbEIsQ0FBQyxDQUFDO1lBRUYsSUFBSSxXQUFXLEdBQXlCLElBQUksQ0FBQztZQUM3QyxHQUFHLENBQUMsSUFBSSxHQUFHO2dCQUNULElBQUksQ0FBQyxXQUFXLEVBQUU7b0JBQ2hCLCtEQUErRDtvQkFDL0QsbUVBQW1FO29CQUNuRSxJQUFNLFNBQVMsR0FBbUIsR0FBRyxDQUFDLEdBQUcsRUFBK0I7eUJBQ3JFLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBQzVCLFdBQVcsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsU0FBZ0IsQ0FBQyxDQUFDO2lCQUNqRTtxQkFBTTtvQkFDTCxXQUFXLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLFNBQWdCLENBQUMsQ0FBQztpQkFDckU7Z0JBRUQsb0VBQW9FO2dCQUNwRSxPQUFPLFdBQVksQ0FBQztZQUN0QixDQUFDLENBQUM7WUFFRixJQUFJLENBQUUsT0FBZSxDQUFDLE9BQU8sRUFBRTtnQkFDN0Isa0VBQWtFO2dCQUNsRSxpRUFBaUU7Z0JBQ2pFLDZDQUE2QztnQkFDN0MsR0FBRyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ3hDO1lBRUQsNkRBQTZEO1lBQzdELEdBQUcsQ0FBQyxPQUFPLENBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFxQixHQUFHLElBQUksSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDckUsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw2QkFBYSxHQUFiLFVBQWMsR0FBVyxFQUFFLE9BQWU7UUFDeEMsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxvQkFBSSxHQUFKLFVBQUssUUFBZ0I7UUFDbkIsT0FBTywrQkFBaUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gscUJBQUssR0FBTCxVQUFNLFNBQWlCLEVBQUUsUUFBaUM7UUFDeEQsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFXOzs7NEJBQ2xCLHFCQUFNLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBQTs7d0JBQTNCLFNBQTJCLENBQUM7d0JBQzVCLHNCQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUM7OztTQUM3QixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCwyQkFBVyxHQUFYO1FBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7T0FFRztJQUNILDJCQUFXLEdBQVgsVUFBWSxRQUFpQjtRQUMzQixJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7U0FDckM7UUFDRCxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztJQUM1QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxzQkFBTSxHQUFOO1FBQ0UsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7T0FFRztJQUNILHFCQUFLLEdBQUw7UUFDRSw0REFBNEQ7UUFDNUQsSUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUM7UUFDdkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7UUFDeEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7UUFDL0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7SUFDN0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxzQkFBTSxHQUFOLFVBQU8sR0FBVyxFQUFFLFFBQThCO1FBQ2hELE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCx1QkFBTyxHQUFQO1FBQ0UsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsc0JBQU0sR0FBTjtRQUNFLE9BQU87WUFDTCxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDaEIsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ2xCLFlBQVksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTO1NBQzFFLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILHdCQUFRLEdBQVIsVUFBUyxJQUFlO1FBQ3RCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDekIsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDO1lBQzNELElBQUksQ0FBQyxhQUFhLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQ3pDLElBQUksQ0FBQyxZQUFZLEVBQ2pCLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQzFCLENBQUM7U0FDSDtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILG9CQUFJLEdBQUo7UUFDRSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILDZCQUFhLEdBQWIsVUFBYyxNQUEyQztRQUEzQyx1QkFBQSxFQUFBLFdBQTJDO1FBQ3ZELE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFL0MsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNwRDtRQUVELElBQUksT0FBTyxDQUFDO1FBQ1osSUFBSTtZQUNGLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDM0Q7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFFRCxJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQztRQUMvRCxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLE9BQU8sT0FBTyxDQUFDLE9BQU8sS0FBSyxPQUFPLENBQUMsVUFBVSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssT0FBTyxDQUFDLFVBQVUsQ0FBQztJQUMxRixDQUFDO0lBRUQ7T0FDRztJQUNILDhCQUFjLEdBQWQsVUFBZSxNQUFrQyxFQUFFLFFBQTRCO1FBQWhFLHVCQUFBLEVBQUEsV0FBa0M7UUFDL0MsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztTQUNyRDtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7WUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFOUUsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQzthQUMvQyxJQUFJLENBQUMsRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLENBQUM7YUFDaEMsTUFBTSxDQUFDLE9BQU8sQ0FBQzthQUNmLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7O09BRUc7SUFDSCx1QkFBTyxHQUFQLFVBQVEsTUFBMkI7UUFBM0IsdUJBQUEsRUFBQSxXQUEyQjtRQUNqQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV6RCxJQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLElBQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDeEMsSUFBTSxjQUFjLEdBQUc7WUFDckIsSUFBSSxFQUFFLEtBQUs7WUFDWCxFQUFFLEVBQUUsR0FBRztZQUNQLElBQUksRUFBRTtnQkFDSixzQkFBVyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNuQyxzQkFBVyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDakM7WUFDRCxFQUFFLEVBQUU7Z0JBQ0Ysc0JBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDakMsc0JBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDakMsc0JBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDbEMsc0JBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQzthQUNwQztTQUNGLENBQUM7UUFFRixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRDs7T0FFRztJQUNILHVCQUFPLEdBQVAsVUFBUSxNQUEyQjtRQUEzQix1QkFBQSxFQUFBLFdBQTJCO1FBQ2pDLE1BQU0sR0FBRyxNQUFNLElBQUksRUFBRSxDQUFDO1FBQ3RCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3pELElBQUk7WUFDRixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDcEQ7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNkLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMseUJBQXlCLENBQUMsRUFBRTtnQkFDckQsS0FBSyxDQUFDLE9BQU8sR0FBRyxtQkFBbUIsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO2FBQ3JEO1lBQ0QsTUFBTSxLQUFLLENBQUM7U0FDYjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsc0NBQXNCLEdBQXRCLFVBQXVCLFFBQW9CO1FBQXBCLHlCQUFBLEVBQUEsWUFBb0I7UUFDekMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDM0UsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDJCQUFXLEdBQVgsVUFBWSxFQUEwQztRQUF0RCxpQkF3QkM7WUF4QmEsY0FBSSxFQUFFLHdCQUFTLEVBQUUsUUFBQztRQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7U0FDL0M7UUFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMseURBQXlELENBQUMsQ0FBQztTQUM1RTtRQUVELElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO1NBQ2pFO1FBRUQsSUFBTSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUMzQixJQUFNLE9BQU8sR0FBYSxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkQsSUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQUMsS0FBSyxFQUFFLFFBQVE7WUFDM0QsT0FBTyxLQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxRQUFRLFVBQUEsRUFBRSxDQUFDLENBQUM7UUFDbEQsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5QyxPQUFPO1lBQ0wsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUU7WUFDaEMsQ0FBQyxHQUFBO1lBQ0QsQ0FBQyxHQUFBO1lBQ0QsVUFBVSxFQUFFLE1BQU07U0FDbkIsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsa0NBQWtCLEdBQWxCLFVBQW1CLEVBQWdEO1FBQW5FLGlCQXNCQztZQXRCb0Isa0JBQU0sRUFBRSx3QkFBUztRQUNwQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDNUM7UUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7U0FDL0M7UUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDdEU7UUFFRCxJQUFNLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBQyxLQUFLLEVBQUUsUUFBUTtZQUMzRCxPQUFPLEtBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFFBQVEsVUFBQSxFQUFFLENBQUMsQ0FBQztRQUNsRCxDQUFDLENBQUMsQ0FBQztRQUNILElBQU0sSUFBSSxHQUFXLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0MsSUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUMsT0FBTztZQUNMLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFZO1lBQzFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFZO1lBQy9CLElBQUksTUFBQTtTQUNMLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsNEJBQVksR0FBWixVQUFhLEVBQW1EO1FBQWhFLGlCQW9FQztZQXBFYyxrQkFBTSxFQUFFLHdCQUFTLEVBQUUsUUFBQyxFQUFFLGNBQUk7UUFDdkM7Ozs7OztXQU1HO1FBQ0gsSUFBTSxvQkFBb0IsR0FBRyxVQUFDLEtBQWUsRUFBRSxDQUFTLEVBQUUsWUFBMkI7WUFBM0IsNkJBQUEsRUFBQSxpQkFBMkI7WUFDbkYsSUFBSSxZQUFZLEdBQWUsRUFBRSxDQUFDO1lBRWxDLElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQzdCLElBQU0sa0JBQWtCLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0JBQ3JELE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQzdCO1lBRUQsb0JBQW9CO1lBQ3BCLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDdEMsK0NBQStDO1lBQy9DLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDN0IsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQ2pCO1lBQ0QsS0FBSyxJQUFJLENBQUMsR0FBRyxVQUFVLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNsRCxtREFBbUQ7Z0JBQ25ELElBQU0sbUJBQW1CLEdBQU8sWUFBWSxTQUFFLENBQUMsRUFBQyxDQUFDO2dCQUNqRCxJQUFNLGVBQWUsR0FBRyxvQkFBb0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLG1CQUFtQixDQUFDLENBQUM7Z0JBQzVFLFlBQVksR0FBTyxZQUFZLFFBQUssZUFBZSxDQUFDLENBQUM7YUFDdEQ7WUFFRCxPQUFPLFlBQVksQ0FBQztRQUN0QixDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDNUM7UUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7U0FDL0M7UUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDdEU7UUFFRCxJQUFNLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBQyxLQUFLLEVBQUUsUUFBUTtZQUMzRCxPQUFPLEtBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFFBQVEsVUFBQSxFQUFFLENBQUMsQ0FBQztRQUNsRCxDQUFDLENBQUMsQ0FBQztRQUNILElBQU0sa0JBQWtCLEdBQUcsb0JBQW9CLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzVELElBQU0sS0FBSyxHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxVQUFBLGtCQUFrQjtZQUNyRCxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUMsQ0FBQztRQUNILElBQU0sV0FBVyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEMsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM1QixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsSUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNsQyxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5QyxJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFaEQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDeEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQzthQUMxQztZQUNELElBQUksWUFBWSxLQUFLLElBQUksRUFBRTtnQkFDekIsT0FBTyxLQUFLLENBQUM7YUFDZDtTQUNGO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7O09BRUc7SUFDSCw2QkFBYSxHQUFiLFVBQWMsRUFBK0M7WUFBN0Msa0NBQWMsRUFBRSxnQkFBSztRQUNuQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7U0FDbkQ7UUFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUM7U0FDMUM7UUFFRCxJQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLElBQUksTUFBTSxDQUFDLGNBQWMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFGLElBQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFFLEtBQXdCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEUsSUFBTSxNQUFNLEdBQUcsV0FBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvRCxPQUFPLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxzQ0FBc0IsR0FBdEIsVUFBdUIsTUFBVyxFQUFFLFFBQTRCO1FBQzlELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO2FBQ3hDLE1BQU0sRUFBRTthQUNSLElBQUksQ0FBQyxVQUFTLE1BQU07WUFDbkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFO2dCQUNqQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsa0NBQWtDLEVBQUUsUUFBUSxDQUFDLENBQUM7YUFDbEU7WUFFRCxPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1FBQ3RFLENBQUMsQ0FBQzthQUNELE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7O09BRUc7SUFDSCx1QkFBTyxHQUFQO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNuQztRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHNCQUFNLEdBQU4sVUFBTyxNQUFXLEVBQUUsUUFBNEI7UUFDOUMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzthQUN4QyxNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILHlCQUFTLEdBQVQsVUFBVSxNQUFXLEVBQUUsUUFBNEI7UUFDakQsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQzthQUMzQyxNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsMkNBQTJCLEdBQTNCLFVBQTRCLEVBQW1DO1lBQWpDLDRCQUFXO1FBQ3ZDLElBQUksQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDO0lBQzVCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsbUNBQW1CLEdBQW5CLFVBQW9CLFlBQW1DLEVBQUUsUUFBaUI7UUFDeEUsZ0VBQWdFO1FBQ2hFLE1BQU0sQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztRQUUvRSxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQzlCLElBQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzRCxJQUFNLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQyxVQUFVLENBQUM7UUFDaEQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUM5QixJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2IsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsRUFBRTtnQkFDaEQsTUFBTSxJQUFJLEtBQUssQ0FBQyw0RkFBNEYsQ0FBQyxDQUFDO2FBQy9HO1lBQ0QsSUFBSTtnQkFDRixRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztvQkFDdEIsS0FBSyxFQUFFLFlBQVksQ0FBQyxpQkFBaUI7b0JBQ3JDLFFBQVEsRUFBRSxRQUFRO2lCQUNuQixDQUFDLENBQUM7YUFDSjtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLENBQUMsQ0FBQyxTQUFTLEdBQUcsOEJBQThCLENBQUM7Z0JBQzdDLE9BQU8sQ0FBQyxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztnQkFDdEQsTUFBTSxDQUFDLENBQUM7YUFDVDtTQUNGO1FBRUQsK0RBQStEO1FBQy9ELElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3pELElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTNELHlFQUF5RTtRQUN6RSxJQUFNLGNBQWMsR0FBRyxZQUFZLENBQUMsY0FBYyxDQUFDO1FBQ25ELElBQU0saUJBQWlCLEdBQUcsZ0JBQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDdEUsSUFBTSxpQkFBaUIsR0FBRyxnQkFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUV0RSxnQ0FBZ0M7UUFDaEMsSUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hGLElBQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFeEQsd0NBQXdDO1FBQ3hDLElBQUksUUFBdUIsQ0FBQztRQUM1QixJQUFJO1lBQ0YsUUFBUSxHQUFHO2dCQUNULEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDO29CQUNsQixLQUFLLEVBQUUsWUFBWSxDQUFDLGNBQWM7b0JBQ2xDLFFBQVEsRUFBRSxNQUFNO2lCQUNqQixDQUFDO2FBQ0gsQ0FBQztTQUNIO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixDQUFDLENBQUMsU0FBUyxHQUFHLDBCQUEwQixDQUFDO1lBQ3pDLE9BQU8sQ0FBQyxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztZQUMxQyxNQUFNLENBQUMsQ0FBQztTQUNUO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsUUFBUSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7U0FDOUI7UUFDRCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILG9DQUFvQixHQUFwQixVQUFxQixFQUFxRTtZQUFuRSxvQkFBTyxFQUFFLGNBQUksRUFBRSx3QkFBUyxFQUFFLDBCQUFVO1FBQ3pELElBQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEMsSUFBTSxTQUFTLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDO1FBQzVHLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNuRixPQUFPLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNEO1FBQ0QsT0FBTyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7T0FFRztJQUNILG9DQUFvQixHQUFwQixVQUFxQixFQUFxRTtZQUFuRSxnQkFBWSxFQUFFLGNBQUksRUFBRSx3QkFBUyxFQUFFLGdCQUFLO1FBQ3pELElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsT0FBTyxTQUFBLEVBQUUsSUFBSSxNQUFBLEVBQUUsU0FBUyxXQUFBLEVBQUUsQ0FBQyxDQUFDO1FBRWpGLHFCQUFxQjtRQUNyQixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsdUNBQXVCLEdBQXZCLFVBQXdCLEVBQW9EO1lBQWxELFlBQUcsRUFBRSxjQUFJLEVBQUUsZ0JBQUs7UUFDeEMsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzdCLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLEdBQUcsS0FBQSxFQUFFLElBQUksTUFBQSxFQUFFLFNBQVMsV0FBQSxFQUFFLEtBQUssT0FBQSxFQUFFLENBQUMsQ0FBQztRQUV4RSx5Q0FBeUM7UUFDekMsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hELElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN0RCxPQUFPO1lBQ0wsSUFBSSxNQUFBO1lBQ0osU0FBUyxXQUFBO1lBQ1QsU0FBUyxXQUFBO1NBQ1YsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILDhCQUFjLEdBQWQsVUFBZSxFQUFpRjtZQUEvRSxnQkFBWSxFQUFFLDBCQUFVLEVBQUUsY0FBSSxFQUFFLHdCQUFTLEVBQUUsZ0JBQUssRUFBRSxjQUFJO1FBQ3JFLElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1lBQ2pELE9BQU8sU0FBQTtZQUNQLElBQUksTUFBQTtZQUNKLFNBQVMsV0FBQTtZQUNULFVBQVUsWUFBQTtTQUNYLENBQUMsQ0FBQztRQUVILHFCQUFxQjtRQUNyQixJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBRWpFLGdDQUFnQztRQUNoQyxPQUFPO1lBQ0wsT0FBTyxFQUFFLFlBQVksS0FBSyxJQUFJO1lBQzlCLFlBQVksY0FBQTtZQUNaLGdCQUFnQixrQkFBQTtTQUNqQixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0gsOENBQThCLEdBQTlCLFVBQStCLEVBQTZFO1lBQTNFLHNCQUFRLEVBQUUsc0JBQVEsRUFBRSxZQUFHLEVBQUUsc0JBQVEsRUFBRSwwQkFBVSxFQUFFLGdCQUFLO1FBQ25GLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztTQUM3QztRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztTQUM3QztRQUVELElBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QyxvRUFBb0U7UUFDcEUsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFN0QsSUFBTSxVQUFVLEdBQW1DO1lBQ2pELEtBQUssRUFBRSxTQUFTO1lBQ2hCLFFBQVEsRUFBRSxZQUFZO1lBQ3RCLFFBQVEsRUFBRSxDQUFDLENBQUMsUUFBUTtTQUNyQixDQUFDO1FBRUYsSUFBSSxHQUFHLEVBQUU7WUFDUCxVQUFVLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUNyQixJQUFJLEtBQUssRUFBRTtnQkFDVCxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQzthQUN0QjtTQUNGO1FBRUQsSUFBSSxVQUFVLEVBQUU7WUFDZCxJQUFJLENBQUMsYUFBYSxHQUFHLHVCQUFhLEVBQUUsQ0FBQztZQUNyQyxVQUFVLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztZQUM3QixVQUFVLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUMvRDtRQUVELE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7T0FFRztJQUNILDRCQUFZLEdBQVosVUFBYSxNQUEyQixFQUFFLFFBQTRCO1FBQ3BFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBc0I7Ozs7O3dCQUM3QixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTs0QkFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO3lCQUMzQzt3QkFFRCxJQUFJLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7NEJBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQzt5QkFDMUQ7d0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFOzRCQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7eUJBQzdDO3dCQUVLLFdBQVcsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQzt3QkFDbkMsVUFBVSxHQUFHLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDekQsUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7d0JBRWpDLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTs0QkFDZixzQkFBTyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxFQUFDO3lCQUNuRDt3QkFFSyxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7NEJBQ3RDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7NEJBQy9DLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7d0JBQ3BCLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUVuQyxJQUFJLFdBQVcsRUFBRTs0QkFDZCxPQUFlLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQzs0QkFDcEMsc0ZBQXNGOzRCQUN0RixVQUFVLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQzt5QkFDL0I7d0JBQ3FDLHFCQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUE7O3dCQUE5RCxRQUFRLEdBQXdCLFNBQThCO3dCQUU5RCxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQzt3QkFDM0IsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO3dCQUV2QixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7NEJBQ3JCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQzs0QkFDaEMseUVBQXlFO3lCQUMxRTs2QkFBTTs0QkFHQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDOzRCQUM3QyxJQUFJLENBQUMsYUFBYSxFQUFFO2dDQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7NkJBQzFEOzRCQUVLLGVBQWUsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQzs0QkFDMUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDOzRCQUNwQyxJQUFJLENBQUMsU0FBUyxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUM7NEJBRTFDLHFDQUFxQzs0QkFDckMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFFakMsZ0RBQWdEOzRCQUNoRCxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO3lCQUMxQzt3QkFFRCxzQkFBTyxRQUFRLEVBQUM7OztTQUNqQixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzthQUNWLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxFQUFFLG1CQUFtQixDQUFDO2FBQ2pELE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILGlDQUFpQixHQUFqQixVQUFrQixNQUFNLEVBQUUsUUFBNEI7UUFDcEQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxXQUFXLEVBQUUsaUJBQWlCLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFOUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDaEIsNERBQTREO1lBQzVELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDL0M7UUFFRCxJQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7UUFFcEUsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDbkMsSUFBSSxDQUFDLFVBQVUsQ0FBQzthQUNoQixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUdEOzs7Ozs7T0FNRztJQUNILCtCQUFlLEdBQWYsVUFBZ0IsTUFBOEIsRUFBRSxRQUE0QjtRQUMxRSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7OztnQkFDUixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtvQkFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO2lCQUMzQztnQkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMscUJBQXFCLENBQUMsRUFBRTtvQkFDN0MsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO2lCQUMxRDtnQkFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtvQkFDaEIsNERBQTREO29CQUM1RCxNQUFNLElBQUksS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO2lCQUNsQztnQkFFSyxVQUFVLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztnQkFFM0Qsc0JBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7eUJBQzFDLElBQUksQ0FBQyxVQUFVLENBQUM7eUJBQ2hCLE1BQU0sRUFBRSxFQUFDOztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7T0FFRztJQUNILHdDQUF3QixHQUF4QixVQUF5QixNQUF1QyxFQUFFLFFBQTRCO1FBQzVGLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Ozs7d0JBQ1IsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7NEJBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQzt5QkFDM0M7d0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFOzRCQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7eUJBQzdDO3dCQUVELElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTs0QkFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO3lCQUNwRTt3QkFFSyxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQzt3QkFFakMsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFOzRCQUNmLHNCQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsUUFBUSxDQUFDLEVBQUM7eUJBQ25EO3dCQUVLLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsY0FBYyxDQUFDLENBQUM7d0JBQzFELE9BQU8sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUMsa0RBQWtEO3dCQUNqRSxxQkFBTSxPQUFPO2lDQUN2QixJQUFJLENBQUM7Z0NBQ0osVUFBVSxFQUFFLG9CQUFvQjtnQ0FDaEMsSUFBSSxFQUFFLFFBQVE7Z0NBQ2QsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO2dDQUN6QixhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWE7NkJBQ2xDLENBQUM7aUNBQ0QsTUFBTSxFQUFFLEVBQUE7O3dCQVBMLElBQUksR0FBRyxTQU9GO3dCQUVYLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQzt3QkFDaEMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO3dCQUN4QyxLQUFBLElBQUksQ0FBQTt3QkFBUyxxQkFBTSxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUE7O3dCQUE1QixHQUFLLEtBQUssR0FBRyxTQUFlLENBQUM7d0JBQzdCLHNCQUFPLElBQUksRUFBQzs7O1NBQ2IsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILDRCQUFZLEdBQVosVUFBYSxNQUFzQyxFQUFFLFFBQTRCO1FBQXBFLHVCQUFBLEVBQUEsV0FBc0M7UUFDakQsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOzs7Ozt3QkFDUixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFeEQsWUFBWSxHQUFHLE1BQU0sQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQzt3QkFFL0QsSUFBSSxDQUFDLFlBQVksRUFBRTs0QkFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvRUFBb0UsQ0FBQyxDQUFDO3lCQUN2Rjt3QkFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUU7NEJBQzFDLE1BQU0sSUFBSSxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FBQzt5QkFDcEU7d0JBRVkscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLGNBQWMsQ0FBQztpQ0FDekQsSUFBSSxDQUFDO2dDQUNKLFVBQVUsRUFBRSxlQUFlO2dDQUMzQixhQUFhLEVBQUUsWUFBWTtnQ0FDM0IsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO2dDQUN6QixhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWE7NkJBQ2xDLENBQUM7aUNBQ0QsTUFBTSxFQUFFLEVBQUE7O3dCQVBMLElBQUksR0FBRyxTQU9GO3dCQUNYLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQzt3QkFDaEMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO3dCQUN4QyxzQkFBTyxJQUFJLEVBQUM7OztTQUNiLENBQUM7YUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JHO0lBQ0gsZ0NBQWdCLEdBQWhCLFVBQWlCLE1BQVcsRUFBRSxRQUE0QjtRQUN4RCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2FBQzNDLElBQUksRUFBRTthQUNOLE1BQU0sQ0FBQyxjQUFjLENBQUM7YUFDdEIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMkJHO0lBQ0gsOEJBQWMsR0FBZCxVQUFlLE1BQTZCLEVBQUUsUUFBNEI7UUFDeEUsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFzQjs7Ozs7d0JBQzdCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTs0QkFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO3lCQUMxQzt3QkFFRCwwQkFBMEI7d0JBQzFCLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRTs0QkFDbkIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxFQUFFO2dDQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7NkJBQzNEO3lCQUNGO3dCQUNELElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRTs0QkFDckIsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dDQUNqQyxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7NkJBQ2hEOzRCQUNELENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxVQUFTLE1BQU07Z0NBQzFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO29DQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7aUNBQ3RFOzRCQUNILENBQUMsQ0FBQyxDQUFDO3lCQUNKO3dCQUNELElBQUksTUFBTSxDQUFDLFlBQVksRUFBRTs0QkFDdkIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFO2dDQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixDQUFDLENBQUM7NkJBQ2xEOzRCQUNELElBQUksTUFBTSxDQUFDLFlBQVksR0FBRyxDQUFDLEVBQUU7Z0NBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsNENBQTRDLENBQUMsQ0FBQzs2QkFDL0Q7eUJBQ0Y7d0JBQ0QsSUFBSSxNQUFNLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTs0QkFDM0MsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dDQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7NkJBQzNDO3lCQUNGOzZCQUFNOzRCQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQzt5QkFDakQ7d0JBRUssT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDOzRCQUN0QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDOzRCQUNuRCxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7d0JBQzFCLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUVuQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTs0QkFDbkIsMkZBQTJGOzRCQUMzRixPQUFPLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQzt5QkFDNUI7d0JBRWdCLHFCQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUE7O3dCQUFyQyxRQUFRLEdBQUcsU0FBMEI7d0JBQzNDLElBQUksT0FBTyxDQUFDLFdBQVcsRUFBRTs0QkFDdkIsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcscUVBQXFFLENBQUM7NEJBQzlGLHNCQUFPLFFBQVEsRUFBQzt5QkFDakI7d0JBRUQsaUZBQWlGO3dCQUNqRixPQUFPLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3dCQUUzQixlQUFlLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDaEUsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQzt3QkFFNUMsc0JBQU8sUUFBUSxFQUFDOzs7U0FDakIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBRSxtQkFBbUIsQ0FBQzthQUNqRCxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JHO0lBQ0gsaUNBQWlCLEdBQWpCLFVBQWtCLEVBQXVDLEVBQUUsUUFBNEI7WUFBbkUsVUFBRSxFQUFFLGdCQUFLO1FBQzNCLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Ozs7d0JBQ1IsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksS0FBSyxDQUFDLEVBQUU7NEJBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQzt5QkFDNUQ7d0JBQ0QsSUFBSSxFQUFFLEVBQUU7NEJBQ04sc0JBQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHVCQUFxQixFQUFJLENBQUMsQ0FBQztxQ0FDakQsSUFBSSxFQUFFO3FDQUNOLE1BQU0sRUFBRSxFQUFDO3lCQUNiO3dCQUVjLHFCQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFBOzt3QkFBdEMsTUFBTSxHQUFHLFNBQTZCO3dCQUU1QyxJQUFJLENBQUMsTUFBTSxFQUFFOzRCQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQzt5QkFDekQ7d0JBRUssY0FBYyxHQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsS0FBSyxPQUFBLEVBQUUsQ0FBQyxDQUFDO3dCQUN4RCxJQUFJLGNBQWMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOzRCQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7eUJBQ3hFO3dCQUNELElBQUksY0FBYyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7NEJBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQzt5QkFDekQ7d0JBRUQsc0JBQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHVCQUFxQixjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBSSxDQUFDLENBQUM7aUNBQ25FLElBQUksRUFBRTtpQ0FDTixNQUFNLEVBQUUsRUFBQzs7O1NBQ2IsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxzQkFBTSxHQUFOLFVBQU8sTUFBVyxFQUFFLFFBQTRCO1FBQzlDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Ozs0QkFDTyxxQkFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBQTs7d0JBQTFELE1BQU0sR0FBRyxTQUFpRDt3QkFDaEUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO3dCQUNiLHNCQUFPLE1BQU0sRUFBQzs7O1NBQ2YsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx1QkFBTyxHQUFQLFVBQVEsRUFBc0IsRUFBRSxRQUE0QjtZQUFsRCxVQUFFO1FBQ1YsT0FBTyxFQUFFLENBQUM7O2dCQUNSLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7aUJBQ3ZDO2dCQUNELHNCQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFTLEVBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFDOztTQUN6RCxDQUFDO2FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQzthQUNWLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILDhCQUFjLEdBQWQsVUFBZSxFQUFtRCxFQUFFLFFBQTRCO1lBQS9FLDRCQUFXLEVBQUUsNEJBQVc7UUFDdkMsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDLFNBQVUsZ0JBQWdCOzs7Ozt3QkFDbEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUU7NEJBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQzt5QkFDaEQ7d0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUU7NEJBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQzt5QkFDaEQ7d0JBRUssSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQzt3QkFDekIsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFOzRCQUM5QyxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7eUJBQ2pEO3dCQUVrQixxQkFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxDQUFDLEVBQUE7O3dCQUFqRSxVQUFVLEdBQUcsU0FBb0Q7d0JBQ3ZFLElBQUksQ0FBQyxVQUFVLEVBQUU7NEJBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO3lCQUMxRDt3QkFJSyxJQUFJLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQzt3QkFFakYsNEJBQTRCLEdBQUcsRUFBRSxXQUFXLGFBQUEsRUFBRSxXQUFXLGFBQUEsRUFBRSxDQUFDO3dCQUNqQyxxQkFBTSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsY0FBYyxDQUFDLDRCQUE0QixDQUFDLEVBQUE7O3dCQUE5Rix3QkFBd0IsR0FBRyxTQUFtRTt3QkFDaEYscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsNEJBQTRCLENBQUMsRUFBQTs7d0JBQTVGLFdBQVcsR0FBRyxTQUE4RTt3QkFFNUYsb0JBQW9CLEdBQUc7NEJBQzNCLFNBQVMsRUFBRSx3QkFBd0IsQ0FBQyxTQUFTOzRCQUM3QyxZQUFZLEVBQUUsV0FBVzs0QkFDekIsT0FBTyxFQUFFLHdCQUF3QixDQUFDLE9BQU87NEJBQ3pDLFdBQVcsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDOzRCQUMzRCxRQUFRLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQzt5QkFDekQsQ0FBQzt3QkFFRixzQkFBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQztpQ0FDL0MsSUFBSSxDQUFDLG9CQUFvQixDQUFDO2lDQUMxQixNQUFNLEVBQUUsRUFBQzs7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxrQkFBRSxHQUFGLFVBQUcsTUFBVyxFQUFFLFFBQTRCO1FBQzFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxzQkFBTSxHQUFOLFVBQU8sRUFBZ0MsRUFBRSxRQUE0QjtZQUE1RCxZQUFHLEVBQUUsc0JBQVE7UUFDcEIsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOztnQkFDUixJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztpQkFDckQ7Z0JBQ0Qsc0JBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO3lCQUN2QyxJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUEsRUFBRSxRQUFRLFVBQUEsRUFBRSxDQUFDO3lCQUN2QixNQUFNLEVBQUUsRUFBQzs7U0FDYixDQUFDO2FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQzthQUNWLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILG9CQUFJLEdBQUosVUFBSyxNQUFXLEVBQUUsUUFBNEI7UUFDNUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDckMsTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7T0FFRztJQUNILHVCQUFPLEdBQVAsVUFBUSxNQUFXLEVBQUUsUUFBNEI7UUFDL0MsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7YUFDdkMsTUFBTSxDQUFDLFNBQVMsQ0FBQzthQUNqQixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx1QkFBTyxHQUFQLFVBQVEsTUFBbUMsRUFBRSxRQUE0QjtRQUFqRSx1QkFBQSxFQUFBLFdBQW1DO1FBQ3pDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDO2FBQ3hDLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMkJBQVcsR0FBWCxVQUFZLE1BQStCLEVBQUUsUUFBNEI7UUFBN0QsdUJBQUEsRUFBQSxXQUErQjtRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7U0FDNUQ7UUFFRCxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDN0IsSUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUNqQyxJQUFNLE9BQU8sR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxHQUFHLFFBQVEsQ0FBQztRQUMvRCxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckQsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7UUFDbkQsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO1FBQ3RELElBQU0sU0FBUyxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWpHLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7YUFDNUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUNaLEdBQUcsQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQ3RDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDO2FBQzNCLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDZCQUFhLEdBQWIsVUFBYyxFQUErQixFQUFFLFFBQTRCO1lBQTNELGdCQUFLO1FBQ25CLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQztTQUMxQztRQUVELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDM0MsSUFBSSxDQUFDLEVBQUUsS0FBSyxPQUFBLEVBQUUsQ0FBQzthQUNmLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILG9CQUFJLEdBQUosVUFBSyxFQUEyQixFQUFFLFFBQTRCO1lBQXZELHVDQUFLO1FBQ1YsSUFBSSxLQUFLLEVBQUU7WUFDVCxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztTQUNyQjtRQUVELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQy9CLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsMEJBQVUsR0FBVjtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDekM7UUFDRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILHlCQUFTLEdBQVQ7UUFDRSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNwQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3ZDO1FBQ0QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7O09BR0c7SUFDSCx1QkFBTyxHQUFQO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNuQztRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsMEJBQVUsR0FBVjtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDekM7UUFDRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILGdDQUFnQixHQUFoQjtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDM0IsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckQ7UUFDRCxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwrQkFBZSxHQUFmLFVBQWdCLFlBQVk7UUFDMUIsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxtQkFBRyxHQUFILFVBQUksSUFBWSxFQUFFLE9BQVc7UUFBWCx3QkFBQSxFQUFBLFdBQVc7UUFDM0IsSUFBTSxPQUFPLEdBQUcsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUN0RSxPQUFPLE9BQU8sR0FBRyxJQUFJLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZ0NBQWdCLEdBQWhCLFVBQWlCLElBQVk7UUFDM0IsT0FBTyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7T0FFRztJQUNILHNCQUFNLEdBQU4sVUFBTyxNQUFXLEVBQUUsUUFBNEI7UUFDOUMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDakMsTUFBTSxDQUFDLFFBQVEsQ0FBQzthQUNoQixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsMkJBQVcsR0FBWCxVQUFZLE1BQStCLEVBQUUsUUFBNEI7UUFBN0QsdUJBQUEsRUFBQSxXQUErQjtRQUN6QyxJQUFNLFdBQVcsR0FBUSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUN6QyxJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUU7WUFDcEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNqQyxNQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDckM7WUFDRCxXQUFXLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7U0FDMUM7UUFDRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDakIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDckM7WUFDRCxXQUFXLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDcEM7UUFDRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDakIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNqQyxNQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDckM7WUFDRCxXQUFXLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDcEM7UUFDRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDakIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDckM7WUFDRCxXQUFXLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDcEM7UUFDRCxJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUU7WUFDcEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDckM7WUFDRCxXQUFXLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7U0FDMUM7UUFFRCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNqQyxLQUFLLENBQUMsV0FBVyxDQUFDO2FBQ2xCLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxnQ0FBZ0IsR0FBaEIsVUFBaUIsTUFBc0IsRUFBRSxRQUE0QjtRQUNuRSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNSLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRTs0QkFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO3lCQUN2Qzt3QkFFWSxxQkFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFBOzt3QkFBakUsSUFBSSxHQUFHLFNBQTBEO3dCQUN2RSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTs0QkFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO3lCQUN4RDt3QkFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTs0QkFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO3lCQUNsRTt3QkFDSyxjQUFjLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUM7d0JBQ25FLGVBQWUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO3dCQUNwRCxNQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGFBQWEsQ0FBQzt3QkFDcEYsZ0JBQWdCLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsTUFBTSxDQUFDLENBQUM7d0JBQ3hHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTs0QkFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO3lCQUN4Qzt3QkFDRCxzQkFBTyxJQUFJLEVBQUM7OztTQUNiLENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGtDQUFrQixHQUFsQixVQUFtQixNQUFXLEVBQUUsUUFBNEI7UUFDMUQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUMzQyxJQUFJLENBQUMsRUFBRSxDQUFDO2FBQ1IsTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsZ0NBQWdCLEdBQWhCLFVBQWlCLEVBQWdDLEVBQUUsUUFBNEI7WUFBNUQsb0JBQU87UUFDeEIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQWtCLE9BQVMsQ0FBQyxDQUFDO2FBQ25ELE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsNEJBQVksR0FBWixVQUFhLFFBQTRCO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ25DLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILDBCQUFVLEdBQVYsVUFBVyxNQUFzQixFQUFFLFFBQTRCO1FBQzdELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7U0FDeEM7UUFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1NBQ3pDO1FBRUQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDcEMsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILDZCQUFhLEdBQWIsVUFBYyxNQUFzQixFQUFFLFFBQVE7UUFDNUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUN4QztRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7U0FDekM7UUFFRCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDO2FBQ1osTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCx3Q0FBd0IsR0FBeEIsVUFBeUIsTUFBNEMsRUFBRSxRQUE0QjtRQUExRSx1QkFBQSxFQUFBLFdBQTRDO1FBQ25FLElBQU0sS0FBSyxHQUFRLEVBQUUsQ0FBQztRQUN0QixJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDakIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7YUFDOUQ7WUFDRCxLQUFLLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDOUI7UUFDRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7YUFDN0Q7WUFDRCxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDNUI7UUFFRCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO2FBQ2pELEtBQUssQ0FBQyxLQUFLLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILCtCQUFlLEdBQWYsVUFBZ0IsTUFBbUMsRUFBRSxRQUE0QjtRQUMvRSxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdEUsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUM5QztRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDNUM7UUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFhLE1BQU0sQ0FBQyxTQUFTLGNBQVcsQ0FBQyxDQUFDO2FBQ2pFLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw4QkFBYyxHQUFkLFVBQWUsTUFBVyxFQUFFLFFBQTRCO1FBQ3RELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Ozs7d0JBQ0YsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQzt3QkFFMUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUU7NEJBQ3JCLEtBQUssQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO3lCQUN2Qjt3QkFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixFQUFFOzRCQUMzQixLQUFLLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO3lCQUM3Qjt3QkFFRCxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxFQUFFOzRCQUNwRyxzQkFBTyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFDO3lCQUM5Qjt3QkFLSyxhQUFhLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQzt3QkFDckQscUJBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUE7O3dCQUEvRSxNQUFNLEdBQUcsU0FBc0U7d0JBQ3JGLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7d0JBRTlDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO3dCQUNuRixzQkFBTyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFDOzs7U0FDOUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ0gsNEJBQVksR0FBWixVQUFhLE1BQVc7UUFDdEIsb0RBQW9EO1FBQ3BELElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVMsR0FBRztZQUN0QyxJQUFJLEdBQUcsRUFBRTtnQkFDUCwwREFBMEQ7Z0JBQzFELE9BQU8sQ0FBQyxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztnQkFDN0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNwQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsa0ZBQWtGO1FBQ2xGLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM5RixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILHFDQUFxQixHQUFyQixVQUFzQixNQUFXLEVBQUUsUUFBNEI7UUFDN0QsT0FBTyxFQUFFLENBQUM7O2dCQUNSLHNCQUFPLGtCQUFrQixDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxFQUFDOztTQUN6RCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxnQ0FBZ0IsR0FBaEIsVUFBaUIsU0FBeUI7UUFDeEMsSUFBSSxTQUFTLEVBQUU7WUFDYixJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztTQUN6QjtJQUNILENBQUM7SUF6MkRjLDRCQUFzQixHQUFHLEtBQUssQ0FBQztJQTAyRGhELFlBQUM7Q0FBQSxBQTMyREQsSUEyMkRDO0FBMzJEWSxzQkFBSyIsInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBCaXRHbyBKYXZhU2NyaXB0IFNES1xuLy9cbi8vIENvcHlyaWdodCAyMDE0LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5cbmltcG9ydCAqIGFzIHN1cGVyYWdlbnQgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ2JpdGdvLXV0eG8tbGliJztcbmltcG9ydCB7IG1ha2VSYW5kb21LZXksIGhkUGF0aCB9IGZyb20gJy4vYml0Y29pbic7XG5pbXBvcnQgYml0Y29pbk1lc3NhZ2UgPSByZXF1aXJlKCdiaXRjb2luanMtbWVzc2FnZScpO1xuaW1wb3J0IHNhbml0aXplSHRtbCA9IHJlcXVpcmUoJ3Nhbml0aXplLWh0bWwnKTtcbmltcG9ydCBlb2wgPSByZXF1aXJlKCdlb2wnKTtcbmltcG9ydCB7IEJhc2VDb2luIH0gZnJvbSAnLi92Mi9iYXNlQ29pbic7XG5jb25zdCBQZW5kaW5nQXBwcm92YWxzID0gcmVxdWlyZSgnLi9wZW5kaW5nYXBwcm92YWxzJyk7XG5pbXBvcnQgc2hhbWlyID0gcmVxdWlyZSgnc2VjcmV0cy5qcy1ncmVtcGUnKTtcbmltcG9ydCBzamNsID0gcmVxdWlyZSgnLi92ZW5kb3Ivc2pjbC5taW4uanMnKTtcbmltcG9ydCBiczU4ID0gcmVxdWlyZSgnYnM1OCcpO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IEVudmlyb25tZW50TmFtZSB9IGZyb20gJy4vdjIvZW52aXJvbm1lbnRzJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjaywgVjFOZXR3b3JrIH0gZnJvbSAnLi92Mi90eXBlcyc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyLCBVdGlsIH0gZnJvbSAnLi92Mi9pbnRlcm5hbC91dGlsJztcbmltcG9ydCB7IFJlcXVlc3RUcmFjZXIgYXMgSVJlcXVlc3RUcmFjZXIgfSBmcm9tICcuL3YyL3R5cGVzJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcbmltcG9ydCBwanNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuaW1wb3J0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBkZWJ1Z0xpYiBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBieXRlc1RvV29yZCB9IGZyb20gJy4vdjIvaW50ZXJuYWwvaW50ZXJuYWwnO1xuXG5jb25zdCBUcmFuc2FjdGlvbkJ1aWxkZXIgPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uQnVpbGRlcicpO1xuY29uc3QgQmxvY2tjaGFpbiA9IHJlcXVpcmUoJy4vYmxvY2tjaGFpbicpO1xuY29uc3QgS2V5Y2hhaW5zID0gcmVxdWlyZSgnLi9rZXljaGFpbnMnKTtcbmNvbnN0IFRyYXZlbFJ1bGUgPSByZXF1aXJlKCcuL3RyYXZlbFJ1bGUnKTtcbmltcG9ydCBXYWxsZXQgPSByZXF1aXJlKCcuL3dhbGxldCcpO1xuY29uc3QgV2FsbGV0cyA9IHJlcXVpcmUoJy4vd2FsbGV0cycpO1xuY29uc3QgTWFya2V0cyA9IHJlcXVpcmUoJy4vbWFya2V0cycpO1xuaW1wb3J0IHsgR2xvYmFsQ29pbkZhY3RvcnkgfSBmcm9tICcuL3YyL2NvaW5GYWN0b3J5JztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286aW5kZXgnKTtcblxuaWYgKCEocHJvY2VzcyBhcyBhbnkpLmJyb3dzZXIpIHtcbiAgcmVxdWlyZSgnc3VwZXJhZ2VudC1wcm94eScpKHN1cGVyYWdlbnQpO1xufVxuXG4vLyBQYXRjaCBzdXBlcmFnZW50IHRvIHJldHVybiBibHVlYmlyZCBwcm9taXNlc1xuY29uc3QgX2VuZCA9IChzdXBlcmFnZW50IGFzIGFueSkuUmVxdWVzdC5wcm90b3R5cGUuZW5kO1xuKHN1cGVyYWdlbnQgYXMgYW55KS5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjYikge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBfZW5kLmNhbGwoc2VsZiwgY2IpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCbHVlYmlyZC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxldCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIF9lbmQuY2FsbChzZWxmLCBmdW5jdGlvbihlcnJvciwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBIYW5kbGUgSFRUUCBlcnJvcnMgYXBwcm9wcmlhdGVseSwgcmV0dXJuaW5nIHRoZSByZXN1bHQgYm9keSwgb3IgYSBuYW1lZFxuLy8gZmllbGQgZnJvbSB0aGUgYm9keSwgaWYgdGhlIG9wdGlvbmFsRmllbGQgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlxuKHN1cGVyYWdlbnQgYXMgYW55KS5SZXF1ZXN0LnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbihvcHRpb25hbEZpZWxkPzogc3RyaW5nKSB7XG4gIHJldHVybiB0aGlzLnRoZW4oaGFuZGxlUmVzcG9uc2VSZXN1bHQob3B0aW9uYWxGaWVsZCksIGhhbmRsZVJlc3BvbnNlRXJyb3IpO1xufTtcblxuZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2VSZXN1bHQob3B0aW9uYWxGaWVsZD86IHN0cmluZyk6IChyZXM6IHN1cGVyYWdlbnQuUmVzcG9uc2UpID0+IGFueSB7XG4gIHJldHVybiBmdW5jdGlvbihyZXM6IHN1cGVyYWdlbnQuUmVzcG9uc2UpIHtcbiAgICBpZiAoXy5pc051bWJlcihyZXMuc3RhdHVzKSAmJiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwKSB7XG4gICAgICByZXR1cm4gb3B0aW9uYWxGaWVsZCA/IHJlcy5ib2R5W29wdGlvbmFsRmllbGRdIDogcmVzLmJvZHk7XG4gICAgfVxuICAgIHRocm93IGVyckZyb21SZXNwb25zZShyZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlcnJGcm9tUmVzcG9uc2UocmVzOiBzdXBlcmFnZW50LlJlc3BvbnNlKTogRXJyb3Ige1xuICBjb25zdCBlcnJTdHJpbmcgPSBjcmVhdGVSZXNwb25zZUVycm9yU3RyaW5nKHJlcyk7XG4gIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKGVyclN0cmluZyk7XG5cbiAgZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gIGlmIChyZXMuYm9keSkge1xuICAgIGVyci5yZXN1bHQgPSByZXMuYm9keTtcbiAgfVxuICBpZiAoXy5oYXMocmVzLmhlYWRlciwgJ3gtYXV0aC1yZXF1aXJlZCcpICYmIChyZXMuaGVhZGVyWyd4LWF1dGgtcmVxdWlyZWQnXSA9PT0gJ3RydWUnKSkge1xuICAgIGVyci5pbnZhbGlkVG9rZW4gPSB0cnVlO1xuICB9XG4gIGlmIChyZXMuYm9keS5uZWVkc09UUCkge1xuICAgIGVyci5uZWVkc09UUCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2VFcnJvcihlKTogbmV2ZXIge1xuICBpZiAoZS5yZXNwb25zZSkge1xuICAgIHRocm93IGVyckZyb21SZXNwb25zZShlLnJlc3BvbnNlKTtcbiAgfVxuICB0aHJvdyBlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSBtYW55IHdheXMgYSByZXF1ZXN0IGNhbiBmYWlsLCBhbmQgbWF5IHdheXMgaW5mb3JtYXRpb24gb24gdGhhdCBmYWlsdXJlIGNhbiBiZVxuICogY29tbXVuaWNhdGVkIHRvIHRoZSBjbGllbnQuIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gaGFuZGxlIHRob3NlIGNhc2VzIGFuZCBjcmVhdGUgYSBzYW5lIGVycm9yIHN0cmluZ1xuICogQHBhcmFtIHJlcyBSZXNwb25zZSBmcm9tIGFuIEhUVFAgcmVxdWVzdFxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUVycm9yU3RyaW5nKHJlczogc3VwZXJhZ2VudC5SZXNwb25zZSk6IHN0cmluZyB7XG4gIGxldCBlcnJTdHJpbmcgPSByZXMuc3RhdHVzLnRvU3RyaW5nKCk7IC8vIGF0IHRoZSB2ZXJ5IGxlYXN0IHdlJ2xsIGhhdmUgdGhlIHN0YXR1cyBjb2RlXG4gIGlmIChyZXMuYm9keS5lcnJvcikge1xuICAgIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2UgaG9wZSBmb3IsIHdoZXJlIHRoZSBzZXJ2ZXIgZ2l2ZXMgdXMgYSBuaWNlIGVycm9yIGZyb20gdGhlIEpTT04gYm9keVxuICAgIGVyclN0cmluZyA9IHJlcy5ib2R5LmVycm9yO1xuICB9IGVsc2Uge1xuICAgIGlmIChyZXMudGV4dCkge1xuICAgICAgLy8gaWYgdGhlIHJlc3BvbnNlIGNhbWUgYmFjayBhcyB0ZXh0LCB3ZSB0cnkgdG8gcGFyc2UgaXQgYXMgSFRNTCBhbmQgcmVtb3ZlIGFsbCB0YWdzLCBsZWF2aW5nIHVzXG4gICAgICAvLyBqdXN0IHRoZSBiYXJlIHRleHQsIHdoaWNoIHdlIHRoZW4gdHJpbSBvZiBleGNlc3NpdmUgbmV3bGluZXMgYW5kIGxpbWl0IHRvIGEgY2VydGFpbiBsZW5ndGhcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzYW5pdGl6ZWRUZXh0ID0gc2FuaXRpemVIdG1sKHJlcy50ZXh0LCB7IGFsbG93ZWRUYWdzOiBbXSB9KTtcbiAgICAgICAgc2FuaXRpemVkVGV4dCA9IHNhbml0aXplZFRleHQudHJpbSgpO1xuICAgICAgICBzYW5pdGl6ZWRUZXh0ID0gZW9sLmxmKHNhbml0aXplZFRleHQpOyAvLyB1c2UgJ1xcbicgZm9yIGFsbCBuZXdsaW5lc1xuICAgICAgICBzYW5pdGl6ZWRUZXh0ID0gXy5yZXBsYWNlKHNhbml0aXplZFRleHQsIC9cXG5bIHxcXHRdezEsfVxcbi9nLCAnXFxuXFxuJyk7IC8vIHJlbW92ZSB0aGUgc3BhY2VzL3RhYnMgYmV0d2VlbiBuZXdsaW5lc1xuICAgICAgICBzYW5pdGl6ZWRUZXh0ID0gXy5yZXBsYWNlKHNhbml0aXplZFRleHQsIC9bXFxuXXszLH0vZywgJ1xcblxcbicpOyAvLyBoYXZlIGF0IG1vc3QgMiBjb25zZWN1dGl2ZSBuZXdsaW5lc1xuICAgICAgICBzYW5pdGl6ZWRUZXh0ID0gc2FuaXRpemVkVGV4dC5zdWJzdHJpbmcoMCwgNTAwMCk7IC8vIHByZXZlbnQgbWVzc2FnZSBmcm9tIGdldHRpbmcgdG9vIGxhcmdlXG4gICAgICAgIGVyclN0cmluZyA9IGVyclN0cmluZyArICdcXG4nICsgc2FuaXRpemVkVGV4dDsgLy8gYWRkIGl0IHRvIG91ciBleGlzdGluZyBlcnJTdHJpbmcgKGF0IHRoaXMgcG9pbnQgdGhlIG1vcmUgaW5mbyB0aGUgYmV0dGVyISlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZywgdGhlIHJlc3BvbnNlJ3MgSFRNTCB3YXMgdG9vIHdhY2t5IHRvIGJlIHBhcnNlZCBjbGVhbmx5XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVyclN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaXRHb09wdGlvbnMge1xuICBlbnY/OiBFbnZpcm9ubWVudE5hbWU7XG4gIGNsaWVudElkPzogc3RyaW5nO1xuICBjbGllbnRTZWNyZXQ/OiBzdHJpbmc7XG4gIGFjY2Vzc1Rva2VuPzogc3RyaW5nO1xuICB1c2VyQWdlbnQ/OiBzdHJpbmc7XG4gIGN1c3RvbVJvb3RVUkk/OiBzdHJpbmc7XG4gIGN1c3RvbUJpdGNvaW5OZXR3b3JrPzogVjFOZXR3b3JrO1xuICBjdXN0b21TaWduaW5nQWRkcmVzcz86IHN0cmluZztcbiAgc2VydmVyWHB1Yj86IHN0cmluZztcbiAgc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmw/OiBzdHJpbmc7XG4gIHVzZVByb2R1Y3Rpb24/OiBib29sZWFuO1xuICBtaWNyb3NlcnZpY2VzVXJpPzogc3RyaW5nO1xuICByZWZyZXNoVG9rZW4/OiBzdHJpbmc7XG4gIHZhbGlkYXRlPzogYm9vbGVhbjtcbiAgcHJveHk/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQml0R29Kc29uIHtcbiAgdXNlcj86IFVzZXI7XG4gIHRva2VuPzogc3RyaW5nO1xuICBleHRlbnNpb25LZXk/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXByZWNhdGVkVmVyaWZ5QWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeVBhc3N3b3JkT3B0aW9ucyB7XG4gIHBhc3N3b3JkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVuY3J5cHRPcHRpb25zIHtcbiAgaW5wdXQ/OiBzdHJpbmc7XG4gIHBhc3N3b3JkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlY3J5cHRPcHRpb25zIHtcbiAgaW5wdXQ/OiBzdHJpbmc7XG4gIHBhc3N3b3JkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0U2VjcmV0T3B0aW9ucyB7XG4gIHNlZWQ6IHN0cmluZztcbiAgcGFzc3dvcmRzOiBzdHJpbmdbXTtcbiAgbTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0U2VjcmV0IHtcbiAgeHB1Yjogc3RyaW5nO1xuICBtOiBudW1iZXI7XG4gIG46IG51bWJlcjtcbiAgc2VlZFNoYXJlczogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY29uc3RpdHV0ZVNlY3JldE9wdGlvbnMge1xuICBzaGFyZHM6IHN0cmluZ1tdO1xuICBwYXNzd29yZHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY29uc3RpdHV0ZWRTZWNyZXQge1xuICB4cHViOiBzdHJpbmc7XG4gIHhwcnY6IHN0cmluZztcbiAgc2VlZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeVNoYXJkc09wdGlvbnMge1xuICBzaGFyZHM6IHN0cmluZ1tdO1xuICBwYXNzd29yZHM6IHN0cmluZ1tdO1xuICBtOiBudW1iZXI7XG4gIHhwdWI6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRFY2RoU2VjcmV0T3B0aW9ucyB7XG4gIG90aGVyUHViS2V5SGV4OiBzdHJpbmc7XG4gIGVja2V5OiBiaXRjb2luLkVDUGFpcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBY2Nlc3NUb2tlbk9wdGlvbnMge1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuSXNzdWFuY2VSZXNwb25zZSB7XG4gIGRlcml2YXRpb25QYXRoOiBzdHJpbmc7XG4gIGVuY3J5cHRlZFRva2VuOiBzdHJpbmc7XG4gIGVuY3J5cHRlZEVDREhYcHJ2Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuSXNzdWFuY2Uge1xuICB0b2tlbjogc3RyaW5nO1xuICBlY2RoWHBydj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWxjdWxhdGVIbWFjU3ViamVjdE9wdGlvbnMge1xuICB1cmxQYXRoOiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsY3VsYXRlUmVxdWVzdEhtYWNPcHRpb25zIHtcbiAgdXJsOiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIHRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsY3VsYXRlUmVxdWVzdEhlYWRlcnNPcHRpb25zIHtcbiAgdXJsOiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbiAgdG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXF1ZXN0SGVhZGVycyB7XG4gIGhtYWM6IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIHRva2VuSGFzaDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeVJlc3BvbnNlT3B0aW9ucyBleHRlbmRzIENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyB7XG4gIGhtYWM6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aGVudGljYXRlT3B0aW9ucyB7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIG90cD86IHN0cmluZztcbiAgdHJ1c3Q/OiBudW1iZXI7XG4gIGZvcmNlU01TPzogYm9vbGVhbjtcbiAgZXh0ZW5zaWJsZT86IGJvb2xlYW47XG4gIGZvcmNlVjFBdXRoPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzZWRBdXRoZW50aWNhdGlvbk9wdGlvbnMge1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBmb3JjZVNNUzogYm9vbGVhbjtcbiAgb3RwPzogc3RyaW5nO1xuICB0cnVzdD86IG51bWJlcjtcbiAgZXh0ZW5zaWJsZT86IGJvb2xlYW47XG4gIGV4dGVuc2lvbkFkZHJlc3M/OiBzdHJpbmc7XG4gIGZvcmNlVjFBdXRoPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGRBY2Nlc3NUb2tlbk9wdGlvbnMge1xuICBsYWJlbDogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG4gIGR1cmF0aW9uPzogbnVtYmVyO1xuICBpcFJlc3RyaWN0Pzogc3RyaW5nW107XG4gIHR4VmFsdWVMaW1pdD86IG51bWJlcjtcbiAgc2NvcGU6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbW92ZUFjY2Vzc1Rva2VuT3B0aW9ucyB7XG4gIGlkPzogc3RyaW5nO1xuICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRVc2VyT3B0aW9ucyB7XG4gIGlkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhbmdlUGFzc3dvcmRPcHRpb25zIHtcbiAgb2xkUGFzc3dvcmQ6IHN0cmluZztcbiAgbmV3UGFzc3dvcmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbmxvY2tPcHRpb25zIHtcbiAgb3RwPzogc3RyaW5nO1xuICBkdXJhdGlvbj86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVuZFRva2VuT3B0aW9ucyB7XG4gIGR1cmF0aW9uPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFNoYXJpbmdLZXlPcHRpb25zIHtcbiAgZW1haWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaW5nT3B0aW9ucyB7XG4gIHJlcUlkPzogSVJlcXVlc3RUcmFjZXI7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFc3RpbWF0ZUZlZU9wdGlvbnMge1xuICBudW1CbG9ja3M/OiBudW1iZXI7XG4gIG1heEZlZT86IG51bWJlcjtcbiAgaW5wdXRzPzogc3RyaW5nW107XG4gIHR4U2l6ZT86IG51bWJlcjtcbiAgY3BmcEF3YXJlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdlYmhvb2tPcHRpb25zIHtcbiAgdXJsOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0V2ViaG9va05vdGlmaWNhdGlvbnNPcHRpb25zIHtcbiAgcHJldklkPzogc3RyaW5nO1xuICBsaW1pdD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaXRHb1NpbXVsYXRlV2ViaG9va09wdGlvbnMge1xuICB3ZWJob29rSWQ6IHN0cmluZztcbiAgYmxvY2tJZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhlbnRpY2F0ZVdpdGhBdXRoQ29kZU9wdGlvbnMge1xuICBhdXRoQ29kZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5UHVzaFRva2VuT3B0aW9ucyB7XG4gIHB1c2hWZXJpZmljYXRpb25Ub2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpdEdvUmVxdWVzdCBleHRlbmRzIHN1cGVyYWdlbnQuUmVxdWVzdCB7XG4gIHJlc3VsdDogKG9wdGlvbmFsRmllbGQ/OiBzdHJpbmcpID0+IEJsdWViaXJkPGFueT47XG4gIGVuZDogKGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHN1cGVyYWdlbnQuUmVzcG9uc2U+KSA9PiBCbHVlYmlyZDxzdXBlcmFnZW50LlJlc3BvbnNlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaXRHbyB7XG4gIGdldCh1cmw6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8c3VwZXJhZ2VudC5SZXNwb25zZT4pOiBCaXRHb1JlcXVlc3Q7XG4gIHBvc3QodXJsOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHN1cGVyYWdlbnQuUmVzcG9uc2U+KTogQml0R29SZXF1ZXN0O1xuICBwdXQodXJsOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHN1cGVyYWdlbnQuUmVzcG9uc2U+KTogQml0R29SZXF1ZXN0O1xuICBkZWwodXJsOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHN1cGVyYWdlbnQuUmVzcG9uc2U+KTogQml0R29SZXF1ZXN0O1xuICBwYXRjaCh1cmw6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8c3VwZXJhZ2VudC5SZXNwb25zZT4pOiBCaXRHb1JlcXVlc3Q7XG59XG5cbmV4cG9ydCBjbGFzcyBCaXRHbyB7XG4gIHByaXZhdGUgc3RhdGljIF90ZXN0bmV0V2FybmluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdGF0aWMgX2NvbnN0YW50czogYW55O1xuICBwcml2YXRlIHN0YXRpYyBfY29uc3RhbnRzRXhwaXJlOiBhbnk7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2VudjogRW52aXJvbm1lbnROYW1lO1xuICAvKipcbiAgICogRXhwb3NlIGVudiBwcm9wZXJ0eSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBlbnY6IEVudmlyb25tZW50TmFtZTtcbiAgcHJpdmF0ZSByZWFkb25seSBfYmFzZVVybDogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IF9taWNyb3NlcnZpY2VzVXJsPzogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IF9iYXNlQXBpVXJsOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2Jhc2VBcGlVcmxWMjogc3RyaW5nO1xuICBwcml2YXRlIF91c2VyPzogVXNlcjtcbiAgcHJpdmF0ZSBfa2V5Y2hhaW5zOiBhbnk7XG4gIHByaXZhdGUgX3dhbGxldHM6IGFueTtcbiAgcHJpdmF0ZSByZWFkb25seSBfY2xpZW50SWQ/OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2NsaWVudFNlY3JldD86IHN0cmluZztcbiAgcHJpdmF0ZSBfdG9rZW4/OiBzdHJpbmc7XG4gIHByaXZhdGUgX3JlZnJlc2hUb2tlbj86IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBfdXNlckFnZW50OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3Byb21pc2U6IHR5cGVvZiBCbHVlYmlyZDtcbiAgcHJpdmF0ZSBfdmFsaWRhdGU6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgX3Byb3h5Pzogc3RyaW5nO1xuICBwcml2YXRlIF9yZXFJZD86IElSZXF1ZXN0VHJhY2VyO1xuICBwcml2YXRlIF9lY2RoWHBydj86IHN0cmluZztcbiAgcHJpdmF0ZSBfZXh0ZW5zaW9uS2V5PzogYml0Y29pbi5FQ1BhaXI7XG4gIHByaXZhdGUgX21hcmtldHM/OiBhbnk7XG4gIHByaXZhdGUgX2Jsb2NrY2hhaW4/OiBhbnk7XG4gIHByaXZhdGUgX3RyYXZlbFJ1bGU/OiBhbnk7XG4gIHByaXZhdGUgX3BlbmRpbmdBcHByb3ZhbHM/OiBhbnk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciBCaXRHbyBPYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogQml0R29PcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ2NsaWVudElkJywgJ2NsaWVudFNlY3JldCcsICdyZWZyZXNoVG9rZW4nLCAnYWNjZXNzVG9rZW4nLCAndXNlckFnZW50JywgJ2N1c3RvbVJvb3RVUkknLCAnY3VzdG9tQml0Y29pbk5ldHdvcmsnLCAnc2VydmVyWHB1YicsICdzdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybCddKSB8fFxuICAgICAgKHBhcmFtcy51c2VQcm9kdWN0aW9uICYmICFfLmlzQm9vbGVhbihwYXJhbXMudXNlUHJvZHVjdGlvbikpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoKCFwYXJhbXMuY2xpZW50SWQpICE9PSAoIXBhcmFtcy5jbGllbnRTZWNyZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgLSBtdXN0IHByb3ZpZGUgYm90aCBjbGllbnQgaWQgYW5kIHNlY3JldCcpO1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIG9wZXJhdGUgb24gdGhlIHRlc3Qgc2VydmVyLlxuICAgIC8vIERlcHJlY2F0ZSB1c2VQcm9kdWN0aW9uIGluIHRoZSBmdXR1cmVcbiAgICBsZXQgZW52OiBFbnZpcm9ubWVudE5hbWU7XG5cbiAgICBpZiAocGFyYW1zLnVzZVByb2R1Y3Rpb24pIHtcbiAgICAgIGlmIChwYXJhbXMuZW52ICYmIHBhcmFtcy5lbnYgIT09ICdwcm9kJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB1c2UgdXNlUHJvZHVjdGlvbiB3aGVuIGVudj0nICsgcGFyYW1zLmVudik7XG4gICAgICB9XG4gICAgICBlbnYgPSAncHJvZCc7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMuY3VzdG9tUm9vdFVSSSB8fFxuICAgICAgcGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrIHx8XG4gICAgICBwYXJhbXMuY3VzdG9tU2lnbmluZ0FkZHJlc3MgfHxcbiAgICAgIHBhcmFtcy5zZXJ2ZXJYcHViIHx8XG4gICAgICBwcm9jZXNzLmVudi5CSVRHT19DVVNUT01fUk9PVF9VUkkgfHxcbiAgICAgIHByb2Nlc3MuZW52LkJJVEdPX0NVU1RPTV9CSVRDT0lOX05FVFdPUkspIHtcbiAgICAgIGVudiA9ICdjdXN0b20nO1xuICAgICAgaWYgKHBhcmFtcy5jdXN0b21Sb290VVJJKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbJ2N1c3RvbSddLnVyaSA9IHBhcmFtcy5jdXN0b21Sb290VVJJO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yaykge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzWydjdXN0b20nXS5uZXR3b3JrID0gcGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jdXN0b21TaWduaW5nQWRkcmVzcykge1xuICAgICAgICAoY29tbW9uLkVudmlyb25tZW50c1snY3VzdG9tJ10gYXMgYW55KS5jdXN0b21TaWduaW5nQWRkcmVzcyA9IHBhcmFtcy5jdXN0b21TaWduaW5nQWRkcmVzcztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuc2VydmVyWHB1Yikge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzWydjdXN0b20nXS5zZXJ2ZXJYcHViID0gcGFyYW1zLnNlcnZlclhwdWI7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbJ2N1c3RvbSddLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsID0gcGFyYW1zLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnYgPSBwYXJhbXMuZW52IHx8IHByb2Nlc3MuZW52LkJJVEdPX0VOViBhcyBFbnZpcm9ubWVudE5hbWU7XG4gICAgfVxuXG4gICAgaWYgKGVudiBhcyBzdHJpbmcgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZW52ID0gJ3Byb2QnOyAvLyBtYWtlIGxpZmUgZWFzaWVyXG4gICAgfVxuXG4gICAgaWYgKGVudiA9PT0gJ2N1c3RvbScgJiYgXy5pc1VuZGVmaW5lZChjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHVzZSAtLWN1c3RvbXJvb3R1cmkgb3Igc2V0IHRoZSBCSVRHT19DVVNUT01fUk9PVF9VUkkgZW52aXJvbm1lbnQgdmFyaWFibGUgd2hlbiB1c2luZyB0aGUgY3VzdG9tIGVudmlyb25tZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGVudikge1xuICAgICAgaWYgKGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XSkge1xuICAgICAgICB0aGlzLl9iYXNlVXJsID0gY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbnZpcm9ubWVudCAnICsgZW52ICsgJy4gU3VwcG9ydGVkIGVudmlyb25tZW50czogdGVzdCwgcHJvZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnYgPSAndGVzdCc7XG4gICAgICBpZiAoIUJpdEdvLl90ZXN0bmV0V2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgQml0R28uX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCdCaXRHbyBTREsgZW52IG5vdCBzZXQgLSBkZWZhdWx0aW5nIHRvIHRlc3QgYXQgdGVzdC5iaXRnby5jb20uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9iYXNlVXJsID0gY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaTtcbiAgICB9XG4gICAgdGhpcy5fZW52ID0gdGhpcy5lbnYgPSBlbnY7XG5cbiAgICBjb21tb24uc2V0TmV0d29yayhjb21tb24uRW52aXJvbm1lbnRzW2Vudl0ubmV0d29yayk7XG4gICAgY29tbW9uLnNldFJtZ05ldHdvcmsoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnJtZ05ldHdvcmspO1xuXG4gICAgdGhpcy5fbWljcm9zZXJ2aWNlc1VybCA9IHBhcmFtcy5taWNyb3NlcnZpY2VzVXJpO1xuICAgIHRoaXMuX2Jhc2VBcGlVcmwgPSB0aGlzLl9iYXNlVXJsICsgJy9hcGkvdjEnO1xuICAgIHRoaXMuX2Jhc2VBcGlVcmxWMiA9IHRoaXMuX2Jhc2VVcmwgKyAnL2FwaS92Mic7XG4gICAgdGhpcy5fa2V5Y2hhaW5zID0gbnVsbDtcbiAgICB0aGlzLl93YWxsZXRzID0gbnVsbDtcbiAgICB0aGlzLl9jbGllbnRJZCA9IHBhcmFtcy5jbGllbnRJZDtcbiAgICB0aGlzLl9jbGllbnRTZWNyZXQgPSBwYXJhbXMuY2xpZW50U2VjcmV0O1xuICAgIHRoaXMuX3Rva2VuID0gcGFyYW1zLmFjY2Vzc1Rva2VuO1xuICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IHBhcmFtcy5yZWZyZXNoVG9rZW47XG4gICAgdGhpcy5fdXNlckFnZW50ID0gcGFyYW1zLnVzZXJBZ2VudCB8fCAnQml0R29KUy8nICsgdGhpcy52ZXJzaW9uKCk7XG4gICAgdGhpcy5fcHJvbWlzZSA9IEJsdWViaXJkO1xuICAgIHRoaXMuX3JlcUlkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gd2hldGhlciB0byBwZXJmb3JtIGV4dHJhIGNsaWVudC1zaWRlIHZhbGlkYXRpb24gZm9yIHNvbWUgdGhpbmdzLCBzdWNoIGFzXG4gICAgLy8gYWRkcmVzcyB2YWxpZGF0aW9uIG9yIHNpZ25hdHVyZSB2YWxpZGF0aW9uLiBkZWZhdWx0cyB0byB0cnVlLCBidXQgY2FuIGJlXG4gICAgLy8gdHVybmVkIG9mZiBieSBzZXR0aW5nIHRvIGZhbHNlLiBjYW4gYWxzbyBiZSBvdmVycmlkZGVuIGluZGl2aWR1YWxseSBpbiB0aGVcbiAgICAvLyBmdW5jdGlvbnMgdGhhdCB1c2UgaXQuXG4gICAgdGhpcy5fdmFsaWRhdGUgPSBwYXJhbXMudmFsaWRhdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMudmFsaWRhdGU7XG5cbiAgICAvLyBDcmVhdGUgc3VwZXJhZ2VudCBtZXRob2RzIHNwZWNpZmljIHRvIHRoaXMgQml0R28gaW5zdGFuY2UuXG4gICAgY29uc3QgbWV0aG9kcyA9IFsnZ2V0JywgJ3Bvc3QnLCAncHV0JywgJ2RlbCcsICdwYXRjaCddO1xuXG4gICAgaWYgKCFwYXJhbXMucHJveHkgJiYgcHJvY2Vzcy5lbnYuQklUR09fVVNFX1BST1hZKSB7XG4gICAgICBwYXJhbXMucHJveHkgPSBwcm9jZXNzLmVudi5CSVRHT19VU0VfUFJPWFk7XG4gICAgfVxuXG4gICAgaWYgKChwcm9jZXNzIGFzIGFueSkuYnJvd3NlciAmJiBwYXJhbXMucHJveHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSBodHRwcyBwcm94eSBwYXJhbXMgd2hpbGUgaW4gYnJvd3NlcicpO1xuICAgIH1cblxuICAgIHRoaXMuX3Byb3h5ID0gcGFyYW1zLnByb3h5O1xuXG4gICAgZm9yIChjb25zdCBpbmRleCBpbiBtZXRob2RzKSB7XG4gICAgICBjb25zdCBtZXRob2QgPSBtZXRob2RzW2luZGV4XTtcbiAgICAgIHRoaXNbbWV0aG9kXSA9IHRoaXMuY3JlYXRlUGF0Y2gobWV0aG9kKTtcbiAgICB9XG5cbiAgICAvLyBjYXB0dXJlIG91dGVyIHN0YWNrIHNvIHdlIGhhdmUgdXNlZnVsIGRlYnVnIGluZm9ybWF0aW9uIGlmIGZldGNoIGNvbnN0YW50cyBmYWlsc1xuICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoKTtcblxuICAgIC8vIEtpY2sgb2ZmIGZpcnN0IGxvYWQgb2YgY29uc3RhbnRzXG4gICAgdGhpcy5mZXRjaENvbnN0YW50cyh7fSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhbiBlcnJvciBkb2VzIG5vdCB0ZXJtaW5hdGUgdGhlIGVudGlyZSBzY3JpcHRcbiAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIGZldGNoIGluaXRpYWwgY2xpZW50IGNvbnN0YW50cyBmcm9tIEJpdEdvJyk7XG4gICAgICAgIGRlYnVnKGUuc3RhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBwYXRjaGluZyBmdW5jdGlvbiB3aGljaCBjYW4gYXBwbHkgb3VyIGF1dGhvcml6YXRpb25cbiAgICogaGVhZGVycyB0byBhbnkgb3V0Ym91bmQgcmVxdWVzdC5cbiAgICogQHBhcmFtIG1ldGhvZFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVQYXRjaChtZXRob2Q6IHN0cmluZyk6ICh1cmw6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8c3VwZXJhZ2VudC5SZXNwb25zZT4pID0+IHN1cGVyYWdlbnQuUmVxdWVzdCB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGxldCByZXE6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3QgPSBzdXBlcmFnZW50W21ldGhvZF0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICBpZiAoc2VsZi5fcHJveHkpIHtcbiAgICAgICAgcmVxID0gcmVxLnByb3h5KHNlbGYuX3Byb3h5KTtcbiAgICAgIH1cblxuICAgICAgLy8gUGF0Y2ggc3VwZXJhZ2VudCB0byByZXR1cm4gcHJvbWlzZXNcbiAgICAgIGNvbnN0IHByb3RvdHlwaWNhbEVuZCA9IHJlcS5lbmQ7XG4gICAgICByZXEuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHRoaXNSZXE6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3QgPSB0aGlzO1xuICAgICAgICAvLyBpbnRlcmNlcHQgYSByZXF1ZXN0IGJlZm9yZSBpdCdzIHN1Ym1pdHRlZCB0byB0aGUgc2VydmVyIGZvciB2MiBhdXRoZW50aWNhdGlvbiAoYmFzZWQgb24gdG9rZW4pXG4gICAgICAgIHRoaXNSZXEuc2V0KCdCaXRHby1TREstVmVyc2lvbicsIHNlbGYudmVyc2lvbigpKTtcblxuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoc2VsZi5fcmVxSWQpKSB7XG4gICAgICAgICAgdGhpc1JlcS5zZXQoJ1JlcXVlc3QtSUQnLCBzZWxmLl9yZXFJZC50b1N0cmluZygpKTtcblxuICAgICAgICAgIC8vIGluY3JlbWVudCBhZnRlciBzZXR0aW5nIHRoZSBoZWFkZXIgc28gdGhlIHNlcXVlbmNlIG51bWJlcnMgc3RhcnQgYXQgMFxuICAgICAgICAgIHNlbGYuX3JlcUlkLmluYygpO1xuXG4gICAgICAgICAgLy8gcmVxdWVzdCBpZHMgbXVzdCBiZSBzZXQgYmVmb3JlIGVhY2ggcmVxdWVzdCBpbnN0ZWFkIG9mIGJlaW5nIGtlcHRcbiAgICAgICAgICAvLyBpbnNpZGUgdGhlIGJpdGdvIG9iamVjdC4gVGhpcyBpcyB0byBwcmV2ZW50IHJlZW50cmFuY3kgaXNzdWVzIHdoZXJlXG4gICAgICAgICAgLy8gbXVsdGlwbGUgc2ltdWx0YW5lb3VzIHJlcXVlc3RzIGNvdWxkIGNhdXNlIGluY29ycmVjdCByZXFJZHMgdG8gYmUgdXNlZFxuICAgICAgICAgIGRlbGV0ZSBzZWxmLl9yZXFJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHRva2VuLCBhbmQgd2UncmUgbm90IGxvZ2dlZCBpbiwgdGhlIHJlcXVlc3QgY2Fubm90IGJlIHYyIGF1dGhlbnRpY2F0ZWRcbiAgICAgICAgdGhpc1JlcS5pc1YyQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXNSZXEuYXV0aGVudGljYXRpb25Ub2tlbiA9IHNlbGYuX3Rva2VuO1xuICAgICAgICAvLyBzb21lIG9mIHRoZSBvbGRlciB0b2tlbnMgYXBwZWFyIHRvIGJlIG9ubHkgNDAgY2hhcmFjdGVycyBsb25nXG4gICAgICAgIGlmICgoc2VsZi5fdG9rZW4gJiYgc2VsZi5fdG9rZW4ubGVuZ3RoICE9PSA2NyAmJiBzZWxmLl90b2tlbi5pbmRleE9mKCd2MngnKSAhPT0gMClcbiAgICAgICAgICB8fCByZXEuZm9yY2VWMUF1dGgpIHtcbiAgICAgICAgICAvLyB1c2UgdGhlIG9sZCBtZXRob2RcbiAgICAgICAgICB0aGlzUmVxLmlzVjJBdXRoZW50aWNhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICB0aGlzUmVxLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHNlbGYuX3Rva2VuKTtcbiAgICAgICAgICByZXR1cm4gcHJvdG90eXBpY2FsRW5kLmFwcGx5KHRoaXNSZXEsIGFyZ3VtZW50cyBhcyBhbnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1JlcS5zZXQoJ0JpdEdvLUF1dGgtVmVyc2lvbicsICcyLjAnKTtcbiAgICAgICAgLy8gcHJldmVudCBJRSBmcm9tIGNhY2hpbmcgcmVxdWVzdHNcbiAgICAgICAgdGhpc1JlcS5zZXQoJ0lmLU1vZGlmaWVkLVNpbmNlJywgJ01vbiwgMjYgSnVsIDE5OTcgMDU6MDA6MDAgR01UJyk7XG4gICAgICAgIGlmIChzZWxmLl90b2tlbikge1xuXG4gICAgICAgICAgLy8gZG8gYSBsb2NhbGl6ZWQgZGF0YSBzZXJpYWxpemF0aW9uIHByb2Nlc3NcbiAgICAgICAgICBsZXQgZGF0YSA9ICh0aGlzUmVxIGFzIGFueSkuX2RhdGE7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICBsZXQgY29udGVudFR5cGUgPSB0aGlzUmVxLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICAvLyBQYXJzZSBvdXQganVzdCB0aGUgY29udGVudCB0eXBlIGZyb20gdGhlIGhlYWRlciAoaWdub3JlIHRoZSBjaGFyc2V0KVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZXJpYWxpemUgPSBzdXBlcmFnZW50LnNlcmlhbGl6ZVtjb250ZW50VHlwZV07XG4gICAgICAgICAgICBpZiAoIXNlcmlhbGl6ZSAmJiAvW1xcLytdanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgc2VyaWFsaXplID0gc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXJpYWxpemUpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKHRoaXNSZXEgYXMgYW55KS5fZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICBjb25zdCB1cmxEZXRhaWxzID0gdXJsLnBhcnNlKHJlcS51cmwpO1xuXG4gICAgICAgICAgbGV0IHF1ZXJ5U3RyaW5nOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgcXVlcnk6IHN0cmluZ1tdID0gKHJlcSBhcyBhbnkpLl9xdWVyeTtcbiAgICAgICAgICBjb25zdCBxczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IChyZXEgYXMgYW55KS5xcztcbiAgICAgICAgICBpZiAocXVlcnkgJiYgcXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gYnJvd3NlciB2ZXJzaW9uXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5LmpvaW4oJyYnKTtcbiAgICAgICAgICAgIChyZXEgYXMgYW55KS5fcXVlcnkgPSBbXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHFzKSB7XG4gICAgICAgICAgICAvLyBub2RlIHZlcnNpb25cbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHFzKTtcbiAgICAgICAgICAgIChyZXEgYXMgYW55KS5xcyA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodXJsRGV0YWlscy5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgdXJsRGV0YWlscy5zZWFyY2ggKz0gJyYnICsgcXVlcnlTdHJpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cmxEZXRhaWxzLnNlYXJjaCA9ICc/JyArIHF1ZXJ5U3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnVybCA9IHVybC5mb3JtYXQodXJsRGV0YWlscyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVxdWVzdFByb3BlcnRpZXMgPSBzZWxmLmNhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzKHsgdXJsOiByZXEudXJsLCB0b2tlbjogc2VsZi5fdG9rZW4sIHRleHQ6IGRhdGEgfSk7XG4gICAgICAgICAgdGhpc1JlcS5zZXQoJ0F1dGgtVGltZXN0YW1wJywgcmVxdWVzdFByb3BlcnRpZXMudGltZXN0YW1wLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgLy8gd2UncmUgbm90IHNlbmRpbmcgdGhlIGFjdHVhbCB0b2tlbiwgYnV0IG9ubHkgaXRzIGhhc2hcbiAgICAgICAgICB0aGlzUmVxLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHJlcXVlc3RQcm9wZXJ0aWVzLnRva2VuSGFzaCk7XG5cbiAgICAgICAgICAvLyBzZXQgdGhlIEhNQUNcbiAgICAgICAgICB0aGlzUmVxLnNldCgnSE1BQycsIHJlcXVlc3RQcm9wZXJ0aWVzLmhtYWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3RvdHlwaWNhbEVuZC5hcHBseSh0aGlzUmVxLCBhcmd1bWVudHMgYXMgYW55KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHZlcmlmeSB0aGF0IHRoZSByZXNwb25zZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgc2lnbmVkIGNvcnJlY3RseVxuICAgICAgLy8gcmlnaHQgbm93LCBpdCBpcyB2ZXJ5IHBlcm1pc3NpdmUgd2l0aCB0aGUgdGltZXN0YW1wIHZhcmlhbmNlXG4gICAgICByZXEudmVyaWZ5UmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlcS5pc1YyQXV0aGVudGljYXRlZCB8fCAhcmVxLmF1dGhlbnRpY2F0aW9uVG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2ZXJpZmljYXRpb25SZXNwb25zZSA9IHNlbGYudmVyaWZ5UmVzcG9uc2Uoe1xuICAgICAgICAgIHVybDogcmVxLnVybCxcbiAgICAgICAgICBobWFjOiByZXNwb25zZS5oZWFkZXIuaG1hYyxcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgdGV4dDogcmVzcG9uc2UudGV4dCxcbiAgICAgICAgICB0aW1lc3RhbXA6IHJlc3BvbnNlLmhlYWRlci50aW1lc3RhbXAsXG4gICAgICAgICAgdG9rZW46IHJlcS5hdXRoZW50aWNhdGlvblRva2VuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdmVyaWZpY2F0aW9uUmVzcG9uc2UuaXNWYWxpZCkge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgSE1BQ1xuICAgICAgICAgIGNvbnN0IHJlY2VpdmVkSG1hYyA9IHJlc3BvbnNlLmhlYWRlci5obWFjO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSG1hYyA9IHZlcmlmaWNhdGlvblJlc3BvbnNlLmV4cGVjdGVkSG1hYztcbiAgICAgICAgICBjb25zdCBzaWduYXR1cmVTdWJqZWN0ID0gdmVyaWZpY2F0aW9uUmVzcG9uc2Uuc2lnbmF0dXJlU3ViamVjdDtcbiAgICAgICAgICAvLyBMb2cgb25seSB0aGUgZmlyc3QgMTAgY2hhcmFjdGVycyBvZiB0aGUgdG9rZW4gdG8gZW5zdXJlIHRoZSBmdWxsIHRva2VuIGlzbid0IGxvZ2dlZC5cbiAgICAgICAgICBjb25zdCBwYXJ0aWFsQml0Z29Ub2tlbiA9IHNlbGYuX3Rva2VuID8gc2VsZi5fdG9rZW4uc3Vic3RyaW5nKDAsIDEwKSA6ICcnO1xuICAgICAgICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IHtcbiAgICAgICAgICAgIGV4cGVjdGVkSG1hYyxcbiAgICAgICAgICAgIHJlY2VpdmVkSG1hYyxcbiAgICAgICAgICAgIGhtYWNJbnB1dDogc2lnbmF0dXJlU3ViamVjdCxcbiAgICAgICAgICAgIHJlcXVlc3RUb2tlbjogcmVxLmF1dGhlbnRpY2F0aW9uVG9rZW4sXG4gICAgICAgICAgICBiaXRnb1Rva2VuOiBwYXJ0aWFsQml0Z29Ub2tlblxuICAgICAgICAgIH07XG4gICAgICAgICAgZGVidWcoJ0ludmFsaWQgcmVzcG9uc2UgSE1BQzogJU8nLCBlcnJvckRldGFpbHMpO1xuICAgICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ2ludmFsaWQgcmVzcG9uc2UgSE1BQywgcG9zc2libGUgbWFuLWluLXRoZS1taWRkbGUtYXR0YWNrJyk7XG4gICAgICAgICAgZXJyb3IucmVzdWx0ID0gZXJyb3JEZXRhaWxzO1xuICAgICAgICAgIGVycm9yLnN0YXR1cyA9IDUxMTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9O1xuXG4gICAgICBsZXQgbGFzdFByb21pc2U6IEJsdWViaXJkPGFueT4gfCBudWxsID0gbnVsbDtcbiAgICAgIHJlcS50aGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghbGFzdFByb21pc2UpIHtcbiAgICAgICAgICAvLyBjYW5ub3QgcmVkZWZpbmUgZW5kKCkgdG8gcmV0dXJuIGEgQmx1ZWJpcmQ8YW55PiwgZXZlbiB0aG91Z2hcbiAgICAgICAgICAvLyB0aGF0IGdldHMgbW9ua2V5IHBhdGNoZWQgaW4gYXQgcnVudGltZSwgc28gdGhpcyBjYXN0IGlzIHJlcXVpcmVkXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlOiBCbHVlYmlyZDxhbnk+ID0gKHJlcS5lbmQoKSBhcyB1bmtub3duIGFzIEJsdWViaXJkPGFueT4pXG4gICAgICAgICAgICAudGhlbihyZXEudmVyaWZ5UmVzcG9uc2UpO1xuICAgICAgICAgIGxhc3RQcm9taXNlID0gcmVmZXJlbmNlLnRoZW4uYXBwbHkocmVmZXJlbmNlLCBhcmd1bWVudHMgYXMgYW55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UHJvbWlzZSA9IGxhc3RQcm9taXNlLnRoZW4uYXBwbHkobGFzdFByb21pc2UsIGFyZ3VtZW50cyBhcyBhbnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgcmV0dXJuIGxhc3RQcm9taXNlITtcbiAgICAgIH07XG5cbiAgICAgIGlmICghKHByb2Nlc3MgYXMgYW55KS5icm93c2VyKSB7XG4gICAgICAgIC8vIElmIG5vdCBpbiB0aGUgYnJvd3Nlciwgc2V0IHRoZSBVc2VyLUFnZW50LiBCcm93c2VycyBkb24ndCBhbGxvd1xuICAgICAgICAvLyBzZXR0aW5nIG9mIFVzZXItQWdlbnQsIHNvIHdlIG11c3QgZGlzYWJsZSB0aGlzIHdoZW4gcnVuIGluIHRoZVxuICAgICAgICAvLyBicm93c2VyIChicm93c2VyaWZ5IHNldHMgcHJvY2Vzcy5icm93c2VyKS5cbiAgICAgICAgcmVxLnNldCgnVXNlci1BZ2VudCcsIHNlbGYuX3VzZXJBZ2VudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IHRvIGp1c3QgYWJvdmUgNSBtaW51dGVzIGJ5IGRlZmF1bHRcbiAgICAgIHJlcS50aW1lb3V0KChwcm9jZXNzLmVudi5CSVRHT19USU1FT1VUIGFzIGFueSkgKiAxMDAwIHx8IDMwNSAqIDEwMDApO1xuICAgICAgcmV0dXJuIHJlcTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgSE1BQyBmb3IgdGhlIGdpdmVuIGtleSBhbmQgbWVzc2FnZVxuICAgKiBAcGFyYW0ga2V5IHtTdHJpbmd9IC0gdGhlIGtleSB0byB1c2UgZm9yIHRoZSBITUFDXG4gICAqIEBwYXJhbSBtZXNzYWdlIHtTdHJpbmd9IC0gdGhlIGFjdHVhbCBtZXNzYWdlIHRvIEhNQUNcbiAgICogQHJldHVybnMgeyp9IC0gdGhlIHJlc3VsdCBvZiB0aGUgSE1BQyBvcGVyYXRpb25cbiAgICovXG4gIGNhbGN1bGF0ZUhNQUMoa2V5OiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhc2Vjb2luIG9iamVjdFxuICAgKiBAcGFyYW0gY29pbk5hbWVcbiAgICovXG4gIGNvaW4oY29pbk5hbWU6IHN0cmluZyk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gR2xvYmFsQ29pbkZhY3RvcnkuZ2V0SW5zdGFuY2UodGhpcywgY29pbk5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhc2Vjb2luIG9iamVjdCBmb3IgYSB2aXJ0dWFsIHRva2VuXG4gICAqIEBwYXJhbSB0b2tlbk5hbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB0b2tlbih0b2tlbk5hbWU6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8QmFzZUNvaW4+KTogQmx1ZWJpcmQ8QmFzZUNvaW4+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288QmFzZUNvaW4+KGZ1bmN0aW9uICooKSB7XG4gICAgICB5aWVsZCBzZWxmLmZldGNoQ29uc3RhbnRzKCk7XG4gICAgICByZXR1cm4gc2VsZi5jb2luKHRva2VuTmFtZSk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZ2V0VmFsaWRhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBzZXRWYWxpZGF0ZSh2YWxpZGF0ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICghXy5pc0Jvb2xlYW4odmFsaWRhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgdGhpcy5fdmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgQml0R28gZW52aXJvbm1lbnRcbiAgICovXG4gIGdldEVudigpOiBFbnZpcm9ubWVudE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9lbnY7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgb3V0IGFsbCBzdGF0ZSBmcm9tIHRoaXMgQml0R28gb2JqZWN0LCBlZmZlY3RpdmVseSBsb2dnaW5nIG91dCB0aGUgY3VycmVudCB1c2VyLlxuICAgKi9cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgLy8gVE9ETzogYXJlIHRoZXJlIGFueSBvdGhlciBmaWVsZHMgd2hpY2ggc2hvdWxkIGJlIGNsZWFyZWQ/XG4gICAgdGhpcy5fdXNlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b2tlbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZWNkaFhwcnYgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldHVybiBhIHJlamVjdGVkIHByb21pc2Ugb3IgY2FsbCBjYWxsYmFjayB3aXRoIGVycm9yXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICByZWplY3QobXNnOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPG5ldmVyPik6IEJsdWViaXJkPG5ldmVyPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChuZXcgRXJyb3IobXNnKSkubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmVyc2lvbiBvZiB0aGUgQml0R29KUyBwYWNrYWdlXG4gICAqL1xuICB2ZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBqc29uLnZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoaXMgQml0R28gb2JqZWN0IHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIENhdXRpb246IGNvbnRhaW5zIHNlbnNpdGl2ZSBkYXRhXG4gICAqL1xuICB0b0pTT04oKTogQml0R29Kc29uIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcjogdGhpcy5fdXNlcixcbiAgICAgIHRva2VuOiB0aGlzLl90b2tlbixcbiAgICAgIGV4dGVuc2lvbktleTogdGhpcy5fZXh0ZW5zaW9uS2V5ID8gdGhpcy5fZXh0ZW5zaW9uS2V5LnRvV0lGKCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gc2VyaWFsaXplZCBCaXRHbyBvYmplY3QuXG4gICAqXG4gICAqIE92ZXJ3cml0ZXMgdGhlIHByb3BlcnRpZXMgb24gdGhlIGN1cnJlbnQgQml0R28gb2JqZWN0IHdpdGhcbiAgICogdGhvc2Ugb2YgdGhlIGRlc2VyaWFsemVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGpzb25cbiAgICovXG4gIGZyb21KU09OKGpzb246IEJpdEdvSnNvbik6IHZvaWQge1xuICAgIHRoaXMuX3VzZXIgPSBqc29uLnVzZXI7XG4gICAgdGhpcy5fdG9rZW4gPSBqc29uLnRva2VuO1xuICAgIGlmIChqc29uLmV4dGVuc2lvbktleSkge1xuICAgICAgY29uc3QgbmV0d29yayA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29yaztcbiAgICAgIHRoaXMuX2V4dGVuc2lvbktleSA9IGJpdGNvaW4uRUNQYWlyLmZyb21XSUYoXG4gICAgICAgIGpzb24uZXh0ZW5zaW9uS2V5LFxuICAgICAgICBiaXRjb2luLm5ldHdvcmtzW25ldHdvcmtdXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdXNlclxuICAgKi9cbiAgdXNlcigpOiBVc2VyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgYSBCaXRjb2luIGFkZHJlc3MgaXMgYSB2YWxpZCBiYXNlNTggYWRkcmVzc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IERlcHJlY2F0ZWRWZXJpZnlBZGRyZXNzT3B0aW9ucyA9IHt9KTogYm9vbGVhbiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFtdKTtcblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgYWRkcmVzcycpO1xuICAgIH1cblxuICAgIGxldCBhZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICBhZGRyZXNzID0gYml0Y29pbi5hZGRyZXNzLmZyb21CYXNlNThDaGVjayhwYXJhbXMuYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ldHdvcmtOYW1lID0gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5uZXR3b3JrO1xuICAgIGNvbnN0IG5ldHdvcmsgPSBiaXRjb2luLm5ldHdvcmtzW25ldHdvcmtOYW1lXTtcbiAgICByZXR1cm4gYWRkcmVzcy52ZXJzaW9uID09PSBuZXR3b3JrLnB1YktleUhhc2ggfHwgYWRkcmVzcy52ZXJzaW9uID09PSBuZXR3b3JrLnNjcmlwdEhhc2g7XG4gIH1cblxuICAvKipcbiAgICovXG4gIHZlcmlmeVBhc3N3b3JkKHBhcmFtczogVmVyaWZ5UGFzc3dvcmRPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdXNlciB8fCAhdGhpcy5fdXNlci51c2VybmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBjdXJyZW50IHVzZXInKTtcbiAgICB9XG4gICAgY29uc3QgaG1hY1Bhc3N3b3JkID0gdGhpcy5jYWxjdWxhdGVITUFDKHRoaXMuX3VzZXIudXNlcm5hbWUsIHBhcmFtcy5wYXNzd29yZCk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci92ZXJpZnlwYXNzd29yZCcpKVxuICAgICAgLnNlbmQoeyBwYXNzd29yZDogaG1hY1Bhc3N3b3JkIH0pXG4gICAgICAucmVzdWx0KCd2YWxpZCcpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBlbmNyeXB0IGxvY2FsbHkuXG4gICAqL1xuICBlbmNyeXB0KHBhcmFtczogRW5jcnlwdE9wdGlvbnMgPSB7fSk6IHN0cmluZyB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpbnB1dCcsICdwYXNzd29yZCddLCBbXSk7XG5cbiAgICBjb25zdCByYW5kb21TYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDgpO1xuICAgIGNvbnN0IHJhbmRvbUlWID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbiAgICBjb25zdCBlbmNyeXB0T3B0aW9ucyA9IHtcbiAgICAgIGl0ZXI6IDEwMDAwLFxuICAgICAga3M6IDI1NixcbiAgICAgIHNhbHQ6IFtcbiAgICAgICAgYnl0ZXNUb1dvcmQocmFuZG9tU2FsdC5zbGljZSgwLCA0KSksXG4gICAgICAgIGJ5dGVzVG9Xb3JkKHJhbmRvbVNhbHQuc2xpY2UoNCkpXG4gICAgICBdLFxuICAgICAgaXY6IFtcbiAgICAgICAgYnl0ZXNUb1dvcmQocmFuZG9tSVYuc2xpY2UoMCwgNCkpLFxuICAgICAgICBieXRlc1RvV29yZChyYW5kb21JVi5zbGljZSg0LCA4KSksXG4gICAgICAgIGJ5dGVzVG9Xb3JkKHJhbmRvbUlWLnNsaWNlKDgsIDEyKSksXG4gICAgICAgIGJ5dGVzVG9Xb3JkKHJhbmRvbUlWLnNsaWNlKDEyLCAxNikpXG4gICAgICBdXG4gICAgfTtcblxuICAgIHJldHVybiBzamNsLmVuY3J5cHQocGFyYW1zLnBhc3N3b3JkLCBwYXJhbXMuaW5wdXQsIGVuY3J5cHRPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0IGFuIGVuY3J5cHRlZCBzdHJpbmcgbG9jYWxseS5cbiAgICovXG4gIGRlY3J5cHQocGFyYW1zOiBEZWNyeXB0T3B0aW9ucyA9IHt9KTogc3RyaW5nIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpbnB1dCcsICdwYXNzd29yZCddLCBbXSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzamNsLmRlY3J5cHQocGFyYW1zLnBhc3N3b3JkLCBwYXJhbXMuaW5wdXQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnY2NtOiB0YWcgZG9lc25cXCd0IG1hdGNoJykpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9ICdwYXNzd29yZCBlcnJvciAtICcgKyBlcnJvci5tZXNzYWdlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIHBhc3N3b3JkXG4gICAqIEBwYXJhbSAgIHtOdW1iZXJ9IG51bVdvcmRzICAgICBOdW1iZXIgb2YgMzItYml0IHdvcmRzXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9ICAgICAgICAgIGJhc2U1OCByYW5kb20gcGFzc3dvcmRcbiAgICovXG4gIGdlbmVyYXRlUmFuZG9tUGFzc3dvcmQobnVtV29yZHM6IG51bWJlciA9IDUpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJ5dGVzID0gc2pjbC5jb2RlYy5ieXRlcy5mcm9tQml0cyhzamNsLnJhbmRvbS5yYW5kb21Xb3JkcyhudW1Xb3JkcykpO1xuICAgIHJldHVybiBiczU4LmVuY29kZShieXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgYSBzZWNyZXQgaW50byBzaGFyZHMgdXNpbmcgU2hhbWlyIFNlY3JldCBTaGFyaW5nLlxuICAgKiBAcGFyYW0gc2VlZCBBIGhleGFkZWNpbWFsIHNlY3JldCB0byBzcGxpdFxuICAgKiBAcGFyYW0gcGFzc3dvcmRzIEFuIGFycmF5IG9mIHRoZSBwYXNzd29yZHMgdXNlZCB0byBlbmNyeXB0IGVhY2ggc2hhcmVcbiAgICogQHBhcmFtIG0gVGhlIHRocmVzaG9sZCBudW1iZXIgb2Ygc2hhcmRzIG5lY2Vzc2FyeSB0byByZWNvbnN0aXR1dGUgdGhlIHNlY3JldFxuICAgKi9cbiAgc3BsaXRTZWNyZXQoeyBzZWVkLCBwYXNzd29yZHMsIG0gfTogU3BsaXRTZWNyZXRPcHRpb25zKTogU3BsaXRTZWNyZXQge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXNzd29yZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghXy5pc0ludGVnZXIobSkgfHwgbSA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMicpO1xuICAgIH1cblxuICAgIGlmIChwYXNzd29yZHMubGVuZ3RoIDwgbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgYXJyYXkgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYW4gbScpO1xuICAgIH1cblxuICAgIGNvbnN0IG4gPSBwYXNzd29yZHMubGVuZ3RoO1xuICAgIGNvbnN0IHNlY3JldHM6IHN0cmluZ1tdID0gc2hhbWlyLnNoYXJlKHNlZWQsIG4sIG0pO1xuICAgIGNvbnN0IHNoYXJkcyA9IF8uemlwV2l0aChzZWNyZXRzLCBwYXNzd29yZHMsIChzaGFyZCwgcGFzc3dvcmQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoeyBpbnB1dDogc2hhcmQsIHBhc3N3b3JkIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IG5vZGUgPSBiaXRjb2luLkhETm9kZS5mcm9tU2VlZEhleChzZWVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgeHB1Yjogbm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXG4gICAgICBtLFxuICAgICAgbixcbiAgICAgIHNlZWRTaGFyZXM6IHNoYXJkcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29uc3RpdHV0ZSBhIHNlY3JldCB3aGljaCB3YXMgc2hhcmRlZCB3aXRoIGBzcGxpdFNlY3JldGAuXG4gICAqIEBwYXJhbSBzaGFyZHNcbiAgICogQHBhcmFtIHBhc3N3b3Jkc1xuICAgKi9cbiAgcmVjb25zdGl0dXRlU2VjcmV0KHsgc2hhcmRzLCBwYXNzd29yZHMgfTogUmVjb25zdGl0dXRlU2VjcmV0T3B0aW9ucyk6IFJlY29uc3RpdHV0ZWRTZWNyZXQge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFyZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXNzd29yZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKHNoYXJkcy5sZW5ndGggIT09IHBhc3N3b3Jkcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIGFuZCBwYXNzd29yZHMgYXJyYXlzIG11c3QgaGF2ZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY3JldHMgPSBfLnppcFdpdGgoc2hhcmRzLCBwYXNzd29yZHMsIChzaGFyZCwgcGFzc3dvcmQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQoeyBpbnB1dDogc2hhcmQsIHBhc3N3b3JkIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlZWQ6IHN0cmluZyA9IHNoYW1pci5jb21iaW5lKHNlY3JldHMpO1xuICAgIGNvbnN0IG5vZGUgPSBiaXRjb2luLkhETm9kZS5mcm9tU2VlZEhleChzZWVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgeHB1Yjogbm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCkgYXMgc3RyaW5nLFxuICAgICAgeHBydjogbm9kZS50b0Jhc2U1OCgpIGFzIHN0cmluZyxcbiAgICAgIHNlZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gc2hhcmRzXG4gICAqIEBwYXJhbSBwYXNzd29yZHNcbiAgICogQHBhcmFtIG1cbiAgICogQHBhcmFtIHhwdWIgT3B0aW9uYWwgeHB1YiB0byB2ZXJpZnkgdGhlIHJlc3VsdHMgYWdhaW5zdFxuICAgKi9cbiAgdmVyaWZ5U2hhcmRzKHsgc2hhcmRzLCBwYXNzd29yZHMsIG0sIHhwdWIgfTogVmVyaWZ5U2hhcmRzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFsbCBwb3NzaWJsZSBjb21iaW5hdGlvbnMgb2YgYSBnaXZlbiBhcnJheSdzIHZhbHVlcyBnaXZlbiBzdWJzZXQgc2l6ZSBtXG4gICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB3aG9zZSB2YWx1ZXMgYXJlIHRvIGJlIGFycmFuZ2VkIGluIGFsbCBjb21iaW5hdGlvbnNcbiAgICAgKiBAcGFyYW0gbSBUaGUgc2l6ZSBvZiBlYWNoIHN1YnNldFxuICAgICAqIEBwYXJhbSBlbnRyeUluZGljZXMgUmVjdXJzaXZlbHkgdHJhaWxpbmcgc2V0IG9mIGN1cnJlbnRseSBjaG9zZW4gYXJyYXkgaW5kaWNlcyBmb3IgdGhlIGNvbWJpbmF0aW9uIHN1YnNldCB1bmRlciBjb25zdHJ1Y3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgY29uc3QgZ2VuZXJhdGVDb21iaW5hdGlvbnMgPSAoYXJyYXk6IHN0cmluZ1tdLCBtOiBudW1iZXIsIGVudHJ5SW5kaWNlczogbnVtYmVyW10gPSBbXSk6IHN0cmluZ1tdW10gPT4ge1xuICAgICAgbGV0IGNvbWJpbmF0aW9uczogc3RyaW5nW11bXSA9IFtdO1xuXG4gICAgICBpZiAoZW50cnlJbmRpY2VzLmxlbmd0aCA9PT0gbSkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29tYmluYXRpb24gPSBfLmF0KGFycmF5LCBlbnRyeUluZGljZXMpO1xuICAgICAgICByZXR1cm4gW2N1cnJlbnRDb21iaW5hdGlvbl07XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBoaWdoZXN0IGluZGV4XG4gICAgICBsZXQgZW50cnlJbmRleCA9IF8ubGFzdChlbnRyeUluZGljZXMpO1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIGN1cnJlbnRseSBubyBpbmRpY2VzLCBhc3N1bWUgLTFcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGVudHJ5SW5kZXgpKSB7XG4gICAgICAgIGVudHJ5SW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBlbnRyeUluZGV4ICsgMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgY3VycmVudCBpbmRleCB0byB0aGUgdHJhaWxpbmcgaW5kaWNlc1xuICAgICAgICBjb25zdCBjdXJyZW50RW50cnlJbmRpY2VzID0gWy4uLmVudHJ5SW5kaWNlcywgaV07XG4gICAgICAgIGNvbnN0IG5ld0NvbWJpbmF0aW9ucyA9IGdlbmVyYXRlQ29tYmluYXRpb25zKGFycmF5LCBtLCBjdXJyZW50RW50cnlJbmRpY2VzKTtcbiAgICAgICAgY29tYmluYXRpb25zID0gWy4uLmNvbWJpbmF0aW9ucywgLi4ubmV3Q29tYmluYXRpb25zXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbWJpbmF0aW9ucztcbiAgICB9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNoYXJkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhc3N3b3JkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBpZiAoc2hhcmRzLmxlbmd0aCAhPT0gcGFzc3dvcmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgYW5kIHBhc3N3b3JkcyBhcnJheXMgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjcmV0cyA9IF8uemlwV2l0aChzaGFyZHMsIHBhc3N3b3JkcywgKHNoYXJkLCBwYXNzd29yZCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdCh7IGlucHV0OiBzaGFyZCwgcGFzc3dvcmQgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VjcmV0Q29tYmluYXRpb25zID0gZ2VuZXJhdGVDb21iaW5hdGlvbnMoc2VjcmV0cywgbSk7XG4gICAgY29uc3Qgc2VlZHMgPSBzZWNyZXRDb21iaW5hdGlvbnMubWFwKGN1cnJlbnRDb21iaW5hdGlvbiA9PiB7XG4gICAgICByZXR1cm4gc2hhbWlyLmNvbWJpbmUoY3VycmVudENvbWJpbmF0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCB1bmlxdWVTZWVkcyA9IF8udW5pcShzZWVkcyk7XG4gICAgaWYgKHVuaXF1ZVNlZWRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWVkID0gXy5maXJzdCh1bmlxdWVTZWVkcyk7XG4gICAgY29uc3Qgbm9kZSA9IGJpdGNvaW4uSEROb2RlLmZyb21TZWVkSGV4KHNlZWQpO1xuICAgIGNvbnN0IHJlc3RvcmVkWHB1YiA9IG5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHhwdWIpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcoeHB1YikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4cHViIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN0b3JlZFhwdWIgIT09IHhwdWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBFQ0RIIHNlY3JldCBmcm9tIGEgcHJpdmF0ZSBrZXkgYW5kIG90aGVyIHVzZXIncyBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRFQ0RIU2VjcmV0KHsgb3RoZXJQdWJLZXlIZXgsIGVja2V5IH06IEdldEVjZGhTZWNyZXRPcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKG90aGVyUHViS2V5SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdGhlclB1YktleUhleCBzdHJpbmcgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzT2JqZWN0KGVja2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlY2tleSBvYmplY3QgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdGhlcktleVB1YiA9IGJpdGNvaW4uRUNQYWlyLmZyb21QdWJsaWNLZXlCdWZmZXIobmV3IEJ1ZmZlcihvdGhlclB1YktleUhleCwgJ2hleCcpKTtcbiAgICBjb25zdCBzZWNyZXRQb2ludCA9IG90aGVyS2V5UHViLlEubXVsdGlwbHkoKGVja2V5IGFzIGJpdGNvaW4uRUNQYWlyKS5kKTtcbiAgICBjb25zdCBzZWNyZXQgPSBVdGlsLmJuVG9CeXRlQXJyYXlVbnNpZ25lZChzZWNyZXRQb2ludC5hZmZpbmVYKTtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzZWNyZXQpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1c2VyJ3MgcHJpdmF0ZSBrZXljaGFpbiwgdXNlZCBmb3IgcmVjZWl2aW5nIHNoYXJlc1xuICAgKi9cbiAgZ2V0RUNESFNoYXJpbmdLZXljaGFpbihwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2V0dGluZ3MnKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIGlmICghcmVzdWx0LnNldHRpbmdzLmVjZGhLZXljaGFpbikge1xuICAgICAgICAgIHJldHVybiBzZWxmLnJlamVjdCgnZWNkaCBrZXljaGFpbiBub3QgZm91bmQgZm9yIHVzZXInLCBjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi5rZXljaGFpbnMoKS5nZXQoeyB4cHViOiByZXN1bHQuc2V0dGluZ3MuZWNkaEtleWNoYWluIH0pO1xuICAgICAgfSlcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYml0Y29pbiBtYXJrZXQgZGF0YVxuICAgKi9cbiAgbWFya2V0cygpIHtcbiAgICBpZiAoIXRoaXMuX21hcmtldHMpIHtcbiAgICAgIHRoaXMuX21hcmtldHMgPSBuZXcgTWFya2V0cyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21hcmtldHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXRlc3QgYml0Y29pbiBwcmljZXNcbiAgICogKERlcHJlY2F0ZWQ6IFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlKSB1c2UgYGJpdGdvLm1hcmtldHMoKS5sYXRlc3QoKWBcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG1hcmtldChwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL21hcmtldC9sYXRlc3QnKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtYXJrZXQgZGF0YSBmcm9tIHllc3RlcmRheVxuICAgKiAoRGVwcmVjYXRlZDogV2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUpIHVzZSBiaXRnby5tYXJrZXRzKCkueWVzdGVyZGF5KClcbiAgICovXG4gIHllc3RlcmRheShwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL21hcmtldC95ZXN0ZXJkYXknKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIG1ldGhvZCBmb3IgYWN0aXZhdGluZyBhbiBhY2Nlc3MgdG9rZW4uXG4gICAqL1xuICBhdXRoZW50aWNhdGVXaXRoQWNjZXNzVG9rZW4oeyBhY2Nlc3NUb2tlbiB9OiBBY2Nlc3NUb2tlbk9wdGlvbnMpOiB2b2lkIHtcbiAgICB0aGlzLl90b2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZXNwb25zZUJvZHkgUmVzcG9uc2UgYm9keSBvYmplY3RcbiAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIGZvciB0aGUgc3ltbWV0cmljIGRlY3J5cHRpb25cbiAgICovXG4gIGhhbmRsZVRva2VuSXNzdWFuY2UocmVzcG9uc2VCb2R5OiBUb2tlbklzc3VhbmNlUmVzcG9uc2UsIHBhc3N3b3JkPzogc3RyaW5nKTogVG9rZW5Jc3N1YW5jZSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSByZXNwb25zZSBib2R5IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhyZXNwb25zZUJvZHksIFsnZGVyaXZhdGlvblBhdGgnXSwgWydlbmNyeXB0ZWRFQ0RIWHBydiddKTtcblxuICAgIGNvbnN0IGVudmlyb25tZW50ID0gdGhpcy5fZW52O1xuICAgIGNvbnN0IGVudmlyb25tZW50Q29uZmlnID0gY29tbW9uLkVudmlyb25tZW50c1tlbnZpcm9ubWVudF07XG4gICAgY29uc3Qgc2VydmVyWHB1YiA9IGVudmlyb25tZW50Q29uZmlnLnNlcnZlclhwdWI7XG4gICAgbGV0IGVjZGhYcHJ2ID0gdGhpcy5fZWNkaFhwcnY7XG4gICAgaWYgKCFlY2RoWHBydikge1xuICAgICAgaWYgKCFwYXNzd29yZCB8fCAhcmVzcG9uc2VCb2R5LmVuY3J5cHRlZEVDREhYcHJ2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZWNkaFhwcnYgcHJvcGVydHkgbXVzdCBiZSBzZXQgb3IgcGFzc3dvcmQgYW5kIGVuY3J5cHRlZCBlbmNyeXB0ZWRFQ0RIWHBydiBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBlY2RoWHBydiA9IHRoaXMuZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IHJlc3BvbnNlQm9keS5lbmNyeXB0ZWRFQ0RIWHBydixcbiAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGUuZXJyb3JDb2RlID0gJ2VjZGhfeHBydl9kZWNyeXB0aW9uX2ZhaWx1cmUnO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBlbmNyeXB0ZWRFQ0RIWHBydi4nKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3QgSEROb2RlIG9iamVjdHMgZm9yIGNsaWVudCdzIHhwcnYgYW5kIHNlcnZlcidzIHhwdWJcbiAgICBjb25zdCBjbGllbnRIRE5vZGUgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KGVjZGhYcHJ2KTtcbiAgICBjb25zdCBzZXJ2ZXJIRE5vZGUgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHNlcnZlclhwdWIpO1xuXG4gICAgLy8gQklQMzIgZGVyaXZhdGlvbiBwYXRoIGlzIGFwcGxpZWQgdG8gYm90aCBjbGllbnQgYW5kIHNlcnZlciBtYXN0ZXIga2V5c1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gcmVzcG9uc2VCb2R5LmRlcml2YXRpb25QYXRoO1xuICAgIGNvbnN0IGNsaWVudERlcml2ZWROb2RlID0gaGRQYXRoKGNsaWVudEhETm9kZSkuZGVyaXZlKGRlcml2YXRpb25QYXRoKTtcbiAgICBjb25zdCBzZXJ2ZXJEZXJpdmVkTm9kZSA9IGhkUGF0aChzZXJ2ZXJIRE5vZGUpLmRlcml2ZShkZXJpdmF0aW9uUGF0aCk7XG5cbiAgICAvLyBjYWxjdWxhdGluZyBvbmUtdGltZSBFQ0RIIGtleVxuICAgIGNvbnN0IHNlY3JldFBvaW50ID0gc2VydmVyRGVyaXZlZE5vZGUua2V5UGFpci5fX1EubXVsdGlwbHkoY2xpZW50RGVyaXZlZE5vZGUua2V5UGFpci5kKTtcbiAgICBjb25zdCBzZWNyZXQgPSBzZWNyZXRQb2ludC5nZXRFbmNvZGVkKCkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgLy8gZGVjcnlwdCB0b2tlbiB3aXRoIHN5bW1ldHJpYyBFQ0RIIGtleVxuICAgIGxldCByZXNwb25zZTogVG9rZW5Jc3N1YW5jZTtcbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgIHRva2VuOiB0aGlzLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiByZXNwb25zZUJvZHkuZW5jcnlwdGVkVG9rZW4sXG4gICAgICAgICAgcGFzc3dvcmQ6IHNlY3JldFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLmVycm9yQ29kZSA9ICd0b2tlbl9kZWNyeXB0aW9uX2ZhaWx1cmUnO1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgdG9rZW4uJyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2VjZGhYcHJ2KSB7XG4gICAgICByZXNwb25zZS5lY2RoWHBydiA9IGVjZGhYcHJ2O1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBITUFDZWQgZm9yIGEgY2VydGFpbiBIVFRQIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAgICogQHBhcmFtIHVybFBhdGhcbiAgICogQHBhcmFtIHRleHRcbiAgICogQHBhcmFtIHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gc3RhdHVzQ29kZSBPbmx5IHNldCBmb3IgSFRUUCByZXNwb25zZXMsIGxlYXZlIGJsYW5rIGZvciByZXF1ZXN0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY2FsY3VsYXRlSE1BQ1N1YmplY3QoeyB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAsIHN0YXR1c0NvZGUgfTogQ2FsY3VsYXRlSG1hY1N1YmplY3RPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCB1cmxEZXRhaWxzID0gdXJsLnBhcnNlKHVybFBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5UGF0aCA9ICh1cmxEZXRhaWxzLnF1ZXJ5ICYmIHVybERldGFpbHMucXVlcnkubGVuZ3RoID4gMCkgPyB1cmxEZXRhaWxzLnBhdGggOiB1cmxEZXRhaWxzLnBhdGhuYW1lO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChzdGF0dXNDb2RlKSAmJiBfLmlzSW50ZWdlcihzdGF0dXNDb2RlKSAmJiBfLmlzRmluaXRlKHN0YXR1c0NvZGUpKSB7XG4gICAgICByZXR1cm4gW3RpbWVzdGFtcCwgcXVlcnlQYXRoLCBzdGF0dXNDb2RlLCB0ZXh0XS5qb2luKCd8Jyk7XG4gICAgfVxuICAgIHJldHVybiBbdGltZXN0YW1wLCBxdWVyeVBhdGgsIHRleHRdLmpvaW4oJ3wnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIEhNQUMgZm9yIGFuIEhUVFAgcmVxdWVzdFxuICAgKi9cbiAgY2FsY3VsYXRlUmVxdWVzdEhNQUMoeyB1cmw6IHVybFBhdGgsIHRleHQsIHRpbWVzdGFtcCwgdG9rZW4gfTogQ2FsY3VsYXRlUmVxdWVzdEhtYWNPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBzaWduYXR1cmVTdWJqZWN0ID0gdGhpcy5jYWxjdWxhdGVITUFDU3ViamVjdCh7IHVybFBhdGgsIHRleHQsIHRpbWVzdGFtcCB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgSE1BQ1xuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUhNQUModG9rZW4sIHNpZ25hdHVyZVN1YmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSByZXF1ZXN0IGhlYWRlcnMgd2l0aCBITUFDXG4gICAqL1xuICBjYWxjdWxhdGVSZXF1ZXN0SGVhZGVycyh7IHVybCwgdGV4dCwgdG9rZW4gfTogQ2FsY3VsYXRlUmVxdWVzdEhlYWRlcnNPcHRpb25zKTogUmVxdWVzdEhlYWRlcnMge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaG1hYyA9IHRoaXMuY2FsY3VsYXRlUmVxdWVzdEhNQUMoeyB1cmwsIHRleHQsIHRpbWVzdGFtcCwgdG9rZW4gfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIFNIQTI1NiBoYXNoIG9mIHRoZSB0b2tlblxuICAgIGNvbnN0IGhhc2hEaWdlc3QgPSBzamNsLmhhc2guc2hhMjU2Lmhhc2godG9rZW4pO1xuICAgIGNvbnN0IHRva2VuSGFzaCA9IHNqY2wuY29kZWMuaGV4LmZyb21CaXRzKGhhc2hEaWdlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICBobWFjLFxuICAgICAgdGltZXN0YW1wLFxuICAgICAgdG9rZW5IYXNoLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBITUFDIGZvciBhbiBIVFRQIHJlc3BvbnNlXG4gICAqL1xuICB2ZXJpZnlSZXNwb25zZSh7IHVybDogdXJsUGF0aCwgc3RhdHVzQ29kZSwgdGV4dCwgdGltZXN0YW1wLCB0b2tlbiwgaG1hYyB9OiBWZXJpZnlSZXNwb25zZU9wdGlvbnMpIHtcbiAgICBjb25zdCBzaWduYXR1cmVTdWJqZWN0ID0gdGhpcy5jYWxjdWxhdGVITUFDU3ViamVjdCh7XG4gICAgICB1cmxQYXRoLFxuICAgICAgdGV4dCxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIEhNQUNcbiAgICBjb25zdCBleHBlY3RlZEhtYWMgPSB0aGlzLmNhbGN1bGF0ZUhNQUModG9rZW4sIHNpZ25hdHVyZVN1YmplY3QpO1xuXG4gICAgLy8gdmVyaWZ5IHRoZSBITUFDIGFuZCB0aW1lc3RhbXBcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXhwZWN0ZWRIbWFjID09PSBobWFjLFxuICAgICAgZXhwZWN0ZWRIbWFjLFxuICAgICAgc2lnbmF0dXJlU3ViamVjdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBwcmVwcm9jZXNzQXV0aGVudGljYXRpb25QYXJhbXMoeyB1c2VybmFtZSwgcGFzc3dvcmQsIG90cCwgZm9yY2VTTVMsIGV4dGVuc2libGUsIHRydXN0IH06IEF1dGhlbnRpY2F0ZU9wdGlvbnMpOiBQcm9jZXNzZWRBdXRoZW50aWNhdGlvbk9wdGlvbnMge1xuICAgIGlmICghXy5pc1N0cmluZygndXNlcm5hbWUnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgdXNlcm5hbWUnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcoJ3Bhc3N3b3JkJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIHBhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbG93ZXJOYW1lID0gdXNlcm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBhc3N3b3JkIEhNQUMgc28gd2UgZG9uJ3Qgc2VuZCBjbGVhci10ZXh0IHBhc3N3b3Jkc1xuICAgIGNvbnN0IGhtYWNQYXNzd29yZCA9IHRoaXMuY2FsY3VsYXRlSE1BQyhsb3dlck5hbWUsIHBhc3N3b3JkKTtcblxuICAgIGNvbnN0IGF1dGhQYXJhbXM6IFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyA9IHtcbiAgICAgIGVtYWlsOiBsb3dlck5hbWUsXG4gICAgICBwYXNzd29yZDogaG1hY1Bhc3N3b3JkLFxuICAgICAgZm9yY2VTTVM6ICEhZm9yY2VTTVMsXG4gICAgfTtcblxuICAgIGlmIChvdHApIHtcbiAgICAgIGF1dGhQYXJhbXMub3RwID0gb3RwO1xuICAgICAgaWYgKHRydXN0KSB7XG4gICAgICAgIGF1dGhQYXJhbXMudHJ1c3QgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpYmxlKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25LZXkgPSBtYWtlUmFuZG9tS2V5KCk7XG4gICAgICBhdXRoUGFyYW1zLmV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgYXV0aFBhcmFtcy5leHRlbnNpb25BZGRyZXNzID0gdGhpcy5fZXh0ZW5zaW9uS2V5LmdldEFkZHJlc3MoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXV0aFBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dpbiB0byB0aGUgYml0Z28gcGxhdGZvcm0uXG4gICAqL1xuICBhdXRoZW50aWNhdGUocGFyYW1zOiBBdXRoZW50aWNhdGVPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHN1cGVyYWdlbnQuUmVzcG9uc2U+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIG9iamVjdCBwYXJhbXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrICYmICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgcGFyYW1ldGVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnBhc3N3b3JkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JjZVYxQXV0aCA9ICEhcGFyYW1zLmZvcmNlVjFBdXRoO1xuICAgICAgY29uc3QgYXV0aFBhcmFtcyA9IHNlbGYucHJlcHJvY2Vzc0F1dGhlbnRpY2F0aW9uUGFyYW1zKHBhcmFtcyk7XG4gICAgICBjb25zdCBwYXNzd29yZCA9IHBhcmFtcy5wYXNzd29yZDtcblxuICAgICAgaWYgKHNlbGYuX3Rva2VuKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJlamVjdCgnYWxyZWFkeSBsb2dnZWQgaW4nLCBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF1dGhVcmwgPSBzZWxmLl9taWNyb3NlcnZpY2VzVXJsID9cbiAgICAgICAgc2VsZi5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL2F1dGgvdjEvc2Vzc2lvbicpIDpcbiAgICAgICAgc2VsZi51cmwoJy91c2VyL2xvZ2luJyk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5wb3N0KGF1dGhVcmwpO1xuXG4gICAgICBpZiAoZm9yY2VWMUF1dGgpIHtcbiAgICAgICAgKHJlcXVlc3QgYXMgYW55KS5mb3JjZVYxQXV0aCA9IHRydWU7XG4gICAgICAgIC8vIHRlbGwgdGhlIHNlcnZlciB0aGF0IHRoZSBjbGllbnQgd2FzIGZvcmNlZCB0byBkb3duZ3JhZGUgdGhlIGF1dGhlbnRpY2F0aW9uIHByb3RvY29sXG4gICAgICAgIGF1dGhQYXJhbXMuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2U6IHN1cGVyYWdlbnQuUmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0LnNlbmQoYXV0aFBhcmFtcyk7XG4gICAgICAvLyBleHRyYWN0IGJvZHkgYW5kIHVzZXIgaW5mb3JtYXRpb25cbiAgICAgIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xuICAgICAgc2VsZi5fdXNlciA9IGJvZHkudXNlcjtcblxuICAgICAgaWYgKGJvZHkuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIHNlbGYuX3Rva2VuID0gYm9keS5hY2Nlc3NfdG9rZW47XG4gICAgICAgIC8vIGlmIHRoZSBkb3duZ3JhZGUgd2FzIGZvcmNlZCwgYWRkaW5nIGEgd2FybmluZyBtZXNzYWdlIG1pZ2h0IGJlIHBydWRlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoZWNrIHRoZSBwcmVzZW5jZSBvZiBhbiBlbmNyeXB0ZWQgRUNESCB4cHJ2XG4gICAgICAgIC8vIGlmIG5vdCBwcmVzZW50LCBsZWdhY3kgYWNjb3VudFxuICAgICAgICBjb25zdCBlbmNyeXB0ZWRYcHJ2ID0gYm9keS5lbmNyeXB0ZWRFQ0RIWHBydjtcbiAgICAgICAgaWYgKCFlbmNyeXB0ZWRYcHJ2KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXljaGFpbiBuZWVkcyBlbmNyeXB0ZWRYcHJ2IHByb3BlcnR5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNwb25zZURldGFpbHMgPSBzZWxmLmhhbmRsZVRva2VuSXNzdWFuY2UocmVzcG9uc2UuYm9keSwgcGFzc3dvcmQpO1xuICAgICAgICBzZWxmLl90b2tlbiA9IHJlc3BvbnNlRGV0YWlscy50b2tlbjtcbiAgICAgICAgc2VsZi5fZWNkaFhwcnYgPSByZXNwb25zZURldGFpbHMuZWNkaFhwcnY7XG5cbiAgICAgICAgLy8gdmVyaWZ5IHRoZSByZXNwb25zZSdzIGF1dGhlbnRpY2l0eVxuICAgICAgICByZXF1ZXN0LnZlcmlmeVJlc3BvbnNlKHJlc3BvbnNlKTtcblxuICAgICAgICAvLyBhZGQgdGhlIHJlbWFpbmluZyBjb21wb25lbnQgZm9yIGVhc2llciBhY2Nlc3NcbiAgICAgICAgcmVzcG9uc2UuYm9keS5hY2Nlc3NfdG9rZW4gPSBzZWxmLl90b2tlbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pLmNhbGwodGhpcylcbiAgICAgIC50aGVuKGhhbmRsZVJlc3BvbnNlUmVzdWx0KCksIGhhbmRsZVJlc3BvbnNlRXJyb3IpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIG9wZXJhdGluZ1N5c3RlbTogb25lIG9mIGlvcywgYW5kcm9pZFxuICAgKiAtIHB1c2hUb2tlbjogaGV4LWZvcm1hdHRlZCB0b2tlbiBmb3IgdGhlIHJlc3BlY3RpdmUgbmF0aXZlIHB1c2ggbm90aWZpY2F0aW9uIHNlcnZpY2VcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVnaXN0ZXJQdXNoVG9rZW4ocGFyYW1zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsncHVzaFRva2VuJywgJ29wZXJhdGluZ1N5c3RlbSddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgLy8gdGhpcyBkZXZpY2UgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgdG8gYW4gZXh0ZW5zaWJsZSBzZXNzaW9uXG4gICAgICByZXR1cm4gdGhpcy5yZWplY3QoJ25vdCBsb2dnZWQgaW4nLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zdFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFsncHVzaFRva2VuJywgJ29wZXJhdGluZ1N5c3RlbSddKTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy9kZXZpY2VzJykpXG4gICAgICAuc2VuZChwb3N0UGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gcHVzaFZlcmlmaWNhdGlvblRva2VuOiB0aGUgdG9rZW4gcmVjZWl2ZWQgdmlhIHB1c2ggbm90aWZpY2F0aW9uIHRvIGNvbmZpcm0gdGhlIGRldmljZSdzIG1vYmlsaXR5XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgdmVyaWZ5UHVzaFRva2VuKHBhcmFtczogVmVyaWZ5UHVzaFRva2VuT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBvYmplY3QgcGFyYW1zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHVzaFZlcmlmaWNhdGlvblRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBwdXNoVmVyaWZpY2F0aW9uVG9rZW4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLl90b2tlbikge1xuICAgICAgICAvLyB0aGlzIGRldmljZSBoYXMgdG8gYmUgcmVnaXN0ZXJlZCB0byBhbiBleHRlbnNpYmxlIHNlc3Npb25cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgbG9nZ2VkIGluJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCAncHVzaFZlcmlmaWNhdGlvblRva2VuJyk7XG5cbiAgICAgIHJldHVybiBzZWxmLnBvc3Qoc2VsZi51cmwoJy9kZXZpY2VzL3ZlcmlmeScpKVxuICAgICAgICAuc2VuZChwb3N0UGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ2luIHRvIHRoZSBiaXRnbyBzeXN0ZW0gdXNpbmcgYW4gYXV0aGNvZGUgZ2VuZXJhdGVkIHZpYSBPYXV0aFxuICAgKi9cbiAgYXV0aGVudGljYXRlV2l0aEF1dGhDb2RlKHBhcmFtczogQXV0aGVudGljYXRlV2l0aEF1dGhDb2RlT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBvYmplY3QgcGFyYW1zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuYXV0aENvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGF1dGhDb2RlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5fY2xpZW50SWQgfHwgIXNlbGYuX2NsaWVudFNlY3JldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgY2xpZW50IGlkIGFuZCBzZWNyZXQgc2V0IGZpcnN0IHRvIHVzZSB0aGlzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF1dGhDb2RlID0gcGFyYW1zLmF1dGhDb2RlO1xuXG4gICAgICBpZiAoc2VsZi5fdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucmVqZWN0KCdhbHJlYWR5IGxvZ2dlZCBpbicsIGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYucG9zdChzZWxmLl9iYXNlVXJsICsgJy9vYXV0aC90b2tlbicpO1xuICAgICAgcmVxdWVzdC5mb3JjZVYxQXV0aCA9IHRydWU7IC8vIE9BdXRoIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHYxIGF1dGhlbnRpY2F0aW9uXG4gICAgICBjb25zdCBib2R5ID0geWllbGQgcmVxdWVzdFxuICAgICAgICAuc2VuZCh7XG4gICAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAgICAgY29kZTogYXV0aENvZGUsXG4gICAgICAgICAgY2xpZW50X2lkOiBzZWxmLl9jbGllbnRJZCxcbiAgICAgICAgICBjbGllbnRfc2VjcmV0OiBzZWxmLl9jbGllbnRTZWNyZXQsXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bHQoKTtcblxuICAgICAgc2VsZi5fdG9rZW4gPSBib2R5LmFjY2Vzc190b2tlbjtcbiAgICAgIHNlbGYuX3JlZnJlc2hUb2tlbiA9IGJvZHkucmVmcmVzaF90b2tlbjtcbiAgICAgIHNlbGYuX3VzZXIgPSB5aWVsZCBzZWxmLm1lKCk7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgcmVmcmVzaCB0b2tlbiB0byBnZXQgbmV3IGFjY2VzcyB0b2tlbi5cbiAgICogSWYgdGhlIHJlZnJlc2ggdG9rZW4gaXMgbnVsbC9kZWZpbmVkLCB0aGVuIHdlIHVzZSB0aGUgc3RvcmVkIHRva2VuIGZyb20gYXV0aFxuICAgKi9cbiAgcmVmcmVzaFRva2VuKHBhcmFtczogeyByZWZyZXNoVG9rZW4/OiBzdHJpbmcgfSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydyZWZyZXNoVG9rZW4nXSwgY2FsbGJhY2spO1xuXG4gICAgICBjb25zdCByZWZyZXNoVG9rZW4gPSBwYXJhbXMucmVmcmVzaFRva2VuIHx8IHNlbGYuX3JlZnJlc2hUb2tlbjtcblxuICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgcmVmcmVzaCB0b2tlbiBvciBoYXZlIGF1dGhlbnRpY2F0ZWQgd2l0aCBPYXV0aCBiZWZvcmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLl9jbGllbnRJZCB8fCAhc2VsZi5fY2xpZW50U2VjcmV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBjbGllbnQgaWQgYW5kIHNlY3JldCBzZXQgZmlyc3QgdG8gdXNlIHRoaXMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHNlbGYucG9zdChzZWxmLl9iYXNlVXJsICsgJy9vYXV0aC90b2tlbicpXG4gICAgICAgIC5zZW5kKHtcbiAgICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgICAgIGNsaWVudF9pZDogc2VsZi5fY2xpZW50SWQsXG4gICAgICAgICAgY2xpZW50X3NlY3JldDogc2VsZi5fY2xpZW50U2VjcmV0XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICAgIHNlbGYuX3Rva2VuID0gYm9keS5hY2Nlc3NfdG9rZW47XG4gICAgICBzZWxmLl9yZWZyZXNoVG9rZW4gPSBib2R5LnJlZnJlc2hfdG9rZW47XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9KVxuICAgIC5jYWxsKHRoaXMpXG4gICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIGxpc3RBY2Nlc3NUb2tlbnNcbiAgICogR2V0IGluZm9ybWF0aW9uIG9uIGFsbCBvZiB0aGUgQml0R28gYWNjZXNzIHRva2VucyBvbiB0aGUgdXNlclxuICAgKiBAcmV0dXJuIHtcbiAgICogIGlkOiA8aWQgb2YgdGhlIHRva2VuPlxuICAgKiAgbGFiZWw6IDx0aGUgdXNlci1wcm92aWRlZCBsYWJlbCBmb3IgdGhpcyB0b2tlbj5cbiAgICogIHVzZXI6IDxpZCBvZiB0aGUgdXNlciBvbiB0aGUgdG9rZW4+XG4gICAqICBlbnRlcnByaXNlIDxpZCBvZiB0aGUgZW50ZXJwcmlzZSB0aGlzIHRva2VuIGlzIHZhbGlkIGZvcj5cbiAgICogIGNsaWVudDogPHRoZSBhdXRoIGNsaWVudCB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0bz5cbiAgICogIHNjb3BlOiA8bGlzdCBvZiBhbGxvd2VkIE9BdXRoIHNjb3BlIHZhbHVlcz5cbiAgICogIGNyZWF0ZWQ6IDxkYXRlIHRoZSB0b2tlbiB3YXMgY3JlYXRlZD5cbiAgICogIGV4cGlyZXM6IDxkYXRlIHRoZSB0b2tlbiB3aWxsIGV4cGlyZT5cbiAgICogIG9yaWdpbjogPHRoZSBvcmlnaW4gZm9yIHdoaWNoIHRoaXMgdG9rZW4gaXMgdmFsaWQ+XG4gICAqICBpc0V4dGVuc2libGU6IDxmbGFnIGluZGljYXRpbmcgaWYgdGhlIHRva2VuIGNhbiBiZSBleHRlbmRlZD5cbiAgICogIGV4dGVuc2lvbkFkZHJlc3M6IDxhZGRyZXNzIHdob3NlIHByaXZhdGUga2V5J3Mgc2lnbmF0dXJlIGlzIG5lY2Vzc2FyeSBmb3IgZXh0ZW5zaW9ucz5cbiAgICogIHVubG9jazogPGluZm8gZm9yIGFjdGlvbnMgdGhhdCByZXF1aXJlIGFuIHVubG9jayBiZWZvcmUgZmlyaW5nPlxuICAgKiB9XG4gICAqL1xuICBsaXN0QWNjZXNzVG9rZW5zKHBhcmFtcz86IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvdXNlci9hY2Nlc3N0b2tlbicpKVxuICAgICAgLnNlbmQoKVxuICAgICAgLnJlc3VsdCgnYWNjZXNzVG9rZW5zJylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhZGRBY2Nlc3NUb2tlblxuICAgKiBBZGQgYSBCaXRHbyBBUEkgQWNjZXNzIFRva2VuIHRvIHRoZSBjdXJyZW50IHVzZXIgYWNjb3VudFxuICAgKiBAcGFyYW0gcGFyYW1zIHtcbiAgICogICAgb3RwOiAocmVxdWlyZWQpIDx2YWxpZCBvdHAgY29kZT5cbiAgICogICAgbGFiZWw6IChyZXF1aXJlZCkgPGxhYmVsIGZvciB0aGUgdG9rZW4+XG4gICAqICAgIGR1cmF0aW9uOiA8bGVuZ3RoIG9mIHRpbWUgaW4gc2Vjb25kcyB0aGUgdG9rZW4gd2lsbCBiZSB2YWxpZCBmb3I+XG4gICAqICAgIGlwUmVzdHJpY3Q6IDxhcnJheSBvZiBJUCBhZGRyZXNzIHN0cmluZ3MgdG8gd2hpdGVsaXN0PlxuICAgKiAgICB0eFZhbHVlTGltaXQ6IDxudW1iZXIgb2Ygb3V0Z29pbmcgc2F0b3NoaXMgYWxsb3dlZCBvbiB0aGlzIHRva2VuPlxuICAgKiAgICBzY29wZTogKHJlcXVpcmVkKSA8YXV0aG9yaXphdGlvbiBzY29wZSBvZiB0aGUgcmVxdWVzdGVkIHRva2VuPlxuICAgKiB9XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHtcbiAgICogICAgaWQ6IDxpZCBvZiB0aGUgdG9rZW4+XG4gICAqICAgIHRva2VuOiA8YWNjZXNzIHRva2VuIGhleCBzdHJpbmcgdG8gYmUgdXNlZCBmb3IgQml0R28gQVBJIHJlcXVlc3QgdmVyaWZpY2F0aW9uPlxuICAgKiAgICBsYWJlbDogPHVzZXItcHJvdmlkZWQgbGFiZWwgZm9yIHRoaXMgdG9rZW4+XG4gICAqICAgIHVzZXI6IDxpZCBvZiB0aGUgdXNlciBvbiB0aGUgdG9rZW4+XG4gICAqICAgIGVudGVycHJpc2UgPGlkIG9mIHRoZSBlbnRlcnByaXNlIHRoaXMgdG9rZW4gaXMgdmFsaWQgZm9yPlxuICAgKiAgICBjbGllbnQ6IDx0aGUgYXV0aCBjbGllbnQgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8+XG4gICAqICAgIHNjb3BlOiA8bGlzdCBvZiBhbGxvd2VkIE9BdXRoIHNjb3BlIHZhbHVlcz5cbiAgICogICAgY3JlYXRlZDogPGRhdGUgdGhlIHRva2VuIHdhcyBjcmVhdGVkPlxuICAgKiAgICBleHBpcmVzOiA8ZGF0ZSB0aGUgdG9rZW4gd2lsbCBleHBpcmU+XG4gICAqICAgIG9yaWdpbjogPHRoZSBvcmlnaW4gZm9yIHdoaWNoIHRoaXMgdG9rZW4gaXMgdmFsaWQ+XG4gICAqICAgIGlzRXh0ZW5zaWJsZTogPGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgdG9rZW4gY2FuIGJlIGV4dGVuZGVkPlxuICAgKiAgICBleHRlbnNpb25BZGRyZXNzOiA8YWRkcmVzcyB3aG9zZSBwcml2YXRlIGtleSdzIHNpZ25hdHVyZSBpcyBuZWNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqICAgIHVubG9jazogPGluZm8gZm9yIGFjdGlvbnMgdGhhdCByZXF1aXJlIGFuIHVubG9jayBiZWZvcmUgZmlyaW5nPlxuICAgKiB9XG4gICAqL1xuICBhZGRBY2Nlc3NUb2tlbihwYXJhbXM6IEFkZEFjY2Vzc1Rva2VuT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdXBlcmFnZW50LlJlc3BvbnNlPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5sYWJlbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgbGFiZWwnKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgbm9uLXN0cmluZyBwYXJhbXNcbiAgICAgIGlmIChwYXJhbXMuZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5kdXJhdGlvbikgfHwgcGFyYW1zLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHVyYXRpb24gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5pcFJlc3RyaWN0KSB7XG4gICAgICAgIGlmICghXy5pc0FycmF5KHBhcmFtcy5pcFJlc3RyaWN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBSZXN0cmljdCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXy5mb3JFYWNoKHBhcmFtcy5pcFJlc3RyaWN0LCBmdW5jdGlvbihpcEFkZHIpIHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoaXBBZGRyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcFJlc3RyaWN0IG11c3QgYmUgYW4gYXJyYXkgb2YgSVAgYWRkcmVzcyBzdHJpbmdzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMudHhWYWx1ZUxpbWl0KSB7XG4gICAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMudHhWYWx1ZUxpbWl0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHhWYWx1ZUxpbWl0IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnR4VmFsdWVMaW1pdCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4VmFsdWVMaW1pdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNjb3BlICYmIHBhcmFtcy5zY29wZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICghXy5pc0FycmF5KHBhcmFtcy5zY29wZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Njb3BlIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgc2NvcGUgZm9yIHRva2VuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF1dGhVcmwgPSBzZWxmLl9taWNyb3NlcnZpY2VzVXJsID9cbiAgICAgICAgc2VsZi5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL2F1dGgvdjEvYWNjZXNzdG9rZW4nKSA6XG4gICAgICAgIHNlbGYudXJsKCcvdXNlci9hY2Nlc3N0b2tlbicpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYucG9zdChhdXRoVXJsKTtcblxuICAgICAgaWYgKCFzZWxmLl9lY2RoWHBydikge1xuICAgICAgICAvLyB3aXRob3V0IGEgcHJpdmF0ZSBrZXksIHRoZSB1c2VyIGNhbm5vdCBkZWNyeXB0IHRoZSBuZXcgYWNjZXNzIHRva2VuIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kXG4gICAgICAgIHJlcXVlc3QuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3Quc2VuZChwYXJhbXMpO1xuICAgICAgaWYgKHJlcXVlc3QuZm9yY2VWMUF1dGgpIHtcbiAgICAgICAgcmVzcG9uc2UuYm9keS53YXJuaW5nID0gJ0EgcHJvdG9jb2wgZG93bmdyYWRlIGhhcyBvY2N1cnJlZCBiZWNhdXNlIHRoaXMgaXMgYSBsZWdhY3kgYWNjb3VudC4nO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmlmeSB0aGUgYXV0aGVudGljaXR5IG9mIHRoZSBzZXJ2ZXIncyByZXNwb25zZSBiZWZvcmUgcHJvY2VlZGluZyBhbnkgZnVydGhlclxuICAgICAgcmVxdWVzdC52ZXJpZnlSZXNwb25zZShyZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlRGV0YWlscyA9IHNlbGYuaGFuZGxlVG9rZW5Jc3N1YW5jZShyZXNwb25zZS5ib2R5KTtcbiAgICAgIHJlc3BvbnNlLmJvZHkudG9rZW4gPSByZXNwb25zZURldGFpbHMudG9rZW47XG5cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KS5jYWxsKHRoaXMpXG4gICAgICAudGhlbihoYW5kbGVSZXNwb25zZVJlc3VsdCgpLCBoYW5kbGVSZXNwb25zZUVycm9yKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGV4cGlyZSB0aW1lIG9mIGFuIGFjY2VzcyB0b2tlbiBtYXRjaGluZyBlaXRoZXIgdGhlIGlkIG9yIGxhYmVsIHRvIHRoZSBjdXJyZW50IGRhdGUsIGVmZmVjdGl2ZWx5IGRlbGV0aW5nIGl0XG4gICAqXG4gICAqIFBhcmFtczpcbiAgICogaWQ6IDxpZCBvZiB0aGUgYWNjZXNzIHRva2VuIHRvIGJlIGRlbGV0ZWQ+XG4gICAqIGxhYmVsOiA8bGFiZWwgb2YgdGhlIGFjY2VzcyB0b2tlbiB0byBiZSBkZWxldGVkPlxuICAgKlxuICAgKiBSZXR1cm5zOlxuICAgKiBpZDogPGlkIG9mIHRoZSB0b2tlbj5cbiAgICogbGFiZWw6IDx1c2VyLXByb3ZpZGVkIGxhYmVsIGZvciB0aGlzIHRva2VuPlxuICAgKiB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiBlbnRlcnByaXNlIDxpZCBvZiB0aGUgZW50ZXJwcmlzZSB0aGlzIHRva2VuIGlzIHZhbGlkIGZvcj5cbiAgICogY2xpZW50OiA8dGhlIGF1dGggY2xpZW50IHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvPlxuICAgKiBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqIGNyZWF0ZWQ6IDxkYXRlIHRoZSB0b2tlbiB3YXMgY3JlYXRlZD5cbiAgICogZXhwaXJlczogPGRhdGUgdGhlIHRva2VuIHdpbGwgZXhwaXJlPlxuICAgKiBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiBpc0V4dGVuc2libGU6IDxmbGFnIGluZGljYXRpbmcgaWYgdGhlIHRva2VuIGNhbiBiZSBleHRlbmRlZD5cbiAgICogZXh0ZW5zaW9uQWRkcmVzczogPGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkncyBzaWduYXR1cmUgaXMgbmUqY2Vzc2FyeSBmb3IgZXh0ZW5zaW9ucz5cbiAgICogdW5sb2NrOiA8aW5mbyBmb3IgYWN0aW9ucyB0aGF0IHJlcXVpcmUgYW4gdW5sb2NrIGJlZm9yZSBmaXJpbmc+XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZW1vdmVBY2Nlc3NUb2tlbih7IGlkLCBsYWJlbCB9OiBSZW1vdmVBY2Nlc3NUb2tlbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgaWYgKCghaWQgJiYgIWxhYmVsKSB8fCAoaWQgJiYgbGFiZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGV4YWN0bHkgb25lIG9mIGlkIG9yIGxhYmVsJyk7XG4gICAgICB9XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZGVsKHNlbGYudXJsKGAvdXNlci9hY2Nlc3N0b2tlbi8ke2lkfWApKVxuICAgICAgICAgIC5zZW5kKClcbiAgICAgICAgICAucmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRva2VucyA9IHlpZWxkIHNlbGYubGlzdEFjY2Vzc1Rva2VucygpO1xuXG4gICAgICBpZiAoIXRva2Vucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuIHdpdGggdGhpcyBsYWJlbCBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaGluZ1Rva2VuczogYW55ID0gXy5maWx0ZXIodG9rZW5zLCB7IGxhYmVsIH0pO1xuICAgICAgaWYgKG1hdGNoaW5nVG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWJpZ3VvdXMgY2FsbDogbXVsdGlwbGUgdG9rZW5zIG1hdGNoaW5nIHRoaXMgbGFiZWwnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaGluZ1Rva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlbiB3aXRoIHRoaXMgbGFiZWwgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuZGVsKHNlbGYudXJsKGAvdXNlci9hY2Nlc3N0b2tlbi8ke21hdGNoaW5nVG9rZW5zWzBdLmlkfWApKVxuICAgICAgICAuc2VuZCgpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dvdXQgb2YgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvZ291dChwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5nZXQoc2VsZi51cmwoJy91c2VyL2xvZ291dCcpKS5yZXN1bHQoKTtcbiAgICAgIHNlbGYuY2xlYXIoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdXNlciBieSBJRCAobmFtZS9lbWFpbCBvbmx5KVxuICAgKiBAcGFyYW0gaWRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRVc2VyKHsgaWQgfTogR2V0VXNlck9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKGlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBpZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKGAvdXNlci8ke2lkfWApKS5yZXN1bHQoJ3VzZXInKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHBhc3N3b3JkIG9mIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAqIEFsc28gY2hhbmdlIGFsbCB2MSBhbmQgdjIga2V5Y2hhaW4gcGFzc3dvcmRzIGlmIHRoZXkgbWF0Y2ggdGhlXG4gICAqIGdpdmVuIG9sZFBhc3N3b3JkLiBSZXR1cm5zIG5vdGhpbmcgb24gc3VjY2Vzcy5cbiAgICogQHBhcmFtIG9sZFBhc3N3b3JkIHtTdHJpbmd9IC0gdGhlIGN1cnJlbnQgcGFzc3dvcmRcbiAgICogQHBhcmFtIG5ld1Bhc3N3b3JkIHtTdHJpbmd9IC0gdGhlIG5ldyBwYXNzd29yZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNoYW5nZVBhc3N3b3JkKHsgb2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkIH06IENoYW5nZVBhc3N3b3JkT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqY29DaGFuZ2VQYXNzd29yZCgpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhvbGRQYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgb2xkUGFzc3dvcmQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKG5ld1Bhc3N3b3JkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBuZXdQYXNzd29yZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1c2VyID0gc2VsZi51c2VyKCk7XG4gICAgICBpZiAodHlwZW9mIHVzZXIgIT09ICdvYmplY3QnIHx8ICF1c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBvYmplY3QgdXNlcicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0geWllbGQgc2VsZi52ZXJpZnlQYXNzd29yZCh7IHBhc3N3b3JkOiBvbGRQYXNzd29yZCB9KTtcbiAgICAgIGlmICghdmFsaWRhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBwcm92aWRlZCBvbGRQYXNzd29yZCBpcyBpbmNvcnJlY3QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gaXQgZG9lc24ndCBtYXR0ZXIgd2hpY2ggY29pbiB3ZSBjaG9vc2UgYmVjYXVzZSB0aGUgdjIgdXBkYXRlUGFzc3dvcmQgZnVuY3Rpb25zIHVwZGF0ZXMgYWxsIHYyIGtleWNoYWluc1xuICAgICAgLy8gd2UganVzdCBuZWVkIHRvIGNob29zZSBhIGNvaW4gdGhhdCBleGlzdHMgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgICAgIGNvbnN0IGNvaW4gPSBjb21tb24uRW52aXJvbm1lbnRzW3NlbGYuZ2V0RW52KCldLm5ldHdvcmsgPT09ICdiaXRjb2luJyA/ICdidGMnIDogJ3RidGMnO1xuXG4gICAgICBjb25zdCB1cGRhdGVLZXljaGFpblBhc3N3b3JkUGFyYW1zID0geyBvbGRQYXNzd29yZCwgbmV3UGFzc3dvcmQgfTtcbiAgICAgIGNvbnN0IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdCA9IHlpZWxkIHNlbGYua2V5Y2hhaW5zKCkudXBkYXRlUGFzc3dvcmQodXBkYXRlS2V5Y2hhaW5QYXNzd29yZFBhcmFtcyk7XG4gICAgICBjb25zdCB2MktleWNoYWlucyA9IHlpZWxkIHNlbGYuY29pbihjb2luKS5rZXljaGFpbnMoKS51cGRhdGVQYXNzd29yZCh1cGRhdGVLZXljaGFpblBhc3N3b3JkUGFyYW1zKTtcblxuICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmRQYXJhbXMgPSB7XG4gICAgICAgIGtleWNoYWluczogdjFLZXljaGFpblVwZGF0ZVBXUmVzdWx0LmtleWNoYWlucyxcbiAgICAgICAgdjJfa2V5Y2hhaW5zOiB2MktleWNoYWlucyxcbiAgICAgICAgdmVyc2lvbjogdjFLZXljaGFpblVwZGF0ZVBXUmVzdWx0LnZlcnNpb24sXG4gICAgICAgIG9sZFBhc3N3b3JkOiBzZWxmLmNhbGN1bGF0ZUhNQUModXNlci51c2VybmFtZSwgb2xkUGFzc3dvcmQpLFxuICAgICAgICBwYXNzd29yZDogc2VsZi5jYWxjdWxhdGVITUFDKHVzZXIudXNlcm5hbWUsIG5ld1Bhc3N3b3JkKVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlbGYucG9zdChzZWxmLnVybCgnL3VzZXIvY2hhbmdlcGFzc3dvcmQnKSlcbiAgICAgICAgLnNlbmQodXBkYXRlUGFzc3dvcmRQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlclxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbWUocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRVc2VyKHsgaWQ6ICdtZScgfSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVubG9jayB0aGUgc2Vzc2lvbiBieSBwcm92aWRpbmcgT1RQXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvdHAgUmVxdWlyZWQgT1RQIGNvZGUgZm9yIHRoZSBhY2NvdW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRGVzaXJlZCBkdXJhdGlvbiBvZiB0aGUgdW5sb2NrIGluIHNlY29uZHMgKGRlZmF1bHQ9NjAwLCBtYXg9MzYwMCkuXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgdW5sb2NrKHsgb3RwLCBkdXJhdGlvbiB9OiBVbmxvY2tPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAob3RwICYmICFfLmlzU3RyaW5nKG90cCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgb3IgdW5kZWZpbmVkIG90cCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYucG9zdChzZWxmLnVybCgnL3VzZXIvdW5sb2NrJykpXG4gICAgICAgIC5zZW5kKHsgb3RwLCBkdXJhdGlvbiB9KVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTG9jayB0aGUgc2Vzc2lvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbG9jayhwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL2xvY2snKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAqL1xuICBzZXNzaW9uKHBhcmFtcz86IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvdXNlci9zZXNzaW9uJykpXG4gICAgICAucmVzdWx0KCdzZXNzaW9uJylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgcHVzaC9zbXMgZm9yIHRoZSBPVFAgY29kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5mb3JjZVNNUyBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCB1c2UgU01TIHRvIHNlbmQgdGhlIE9UUCB0byB0aGUgdXNlciBldmVuIGlmIHRoZXkgaGF2ZSBvdGhlciAyRkEgbWV0aG9kIHNldCB1cC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHNlbmRPVFAocGFyYW1zOiB7IGZvcmNlU01TPzogYm9vbGVhbiB9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9zZW5kb3RwJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdG9rZW4sIHByb3ZpZGVkIHRoZSBjdXJyZW50IHRva2VuIGlzIGV4dGVuZGFibGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIGR1cmF0aW9uOiBkdXJhdGlvbiBpbiBzZWNvbmRzIGJ5IHdoaWNoIHRvIGV4dGVuZCB0aGUgdG9rZW4sIHN0YXJ0aW5nIGF0IHRoZSBjdXJyZW50IHRpbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHRlbmRUb2tlbihwYXJhbXM6IEV4dGVuZFRva2VuT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBfZXh0ZW5zaW9uS2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcmFtcy5kdXJhdGlvbjtcbiAgICBjb25zdCBtZXNzYWdlID0gdGltZXN0YW1wICsgJ3wnICsgdGhpcy5fdG9rZW4gKyAnfCcgKyBkdXJhdGlvbjtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gdGhpcy5fZXh0ZW5zaW9uS2V5LmQudG9CdWZmZXIoMzIpO1xuICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IHRoaXMuX2V4dGVuc2lvbktleS5jb21wcmVzc2VkO1xuICAgIGNvbnN0IHByZWZpeCA9IGJpdGNvaW4ubmV0d29ya3MuYml0Y29pbi5tZXNzYWdlUHJlZml4O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJpdGNvaW5NZXNzYWdlLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkLCBwcmVmaXgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL2V4dGVuZHRva2VuJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAuc2V0KCd0aW1lc3RhbXAnLCB0aW1lc3RhbXAudG9TdHJpbmcoKSlcbiAgICAgIC5zZXQoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGtleSBmb3Igc2hhcmluZyBhIHdhbGxldCB3aXRoIGEgdXNlclxuICAgKiBAcGFyYW0gZW1haWwgZW1haWwgb2YgdXNlciB0byBzaGFyZSB3YWxsZXQgd2l0aFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldFNoYXJpbmdLZXkoeyBlbWFpbCB9OiBHZXRTaGFyaW5nS2V5T3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhlbWFpbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGVtYWlsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvc2hhcmluZ2tleScpKVxuICAgICAgLnNlbmQoeyBlbWFpbCB9KVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBjb25uZWN0aXZpdHkgdG8gdGhlIHNlcnZlclxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcGluZyh7IHJlcUlkIH06IFBpbmdPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBpZiAocmVxSWQpIHtcbiAgICAgIHRoaXMuX3JlcUlkID0gcmVxSWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvcGluZycpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBibG9ja2NoYWluIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGJsb2NrY2hhaW4oKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX2Jsb2NrY2hhaW4pIHtcbiAgICAgIHRoaXMuX2Jsb2NrY2hhaW4gPSBuZXcgQmxvY2tjaGFpbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2NrY2hhaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyJ3Mga2V5Y2hhaW5zIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGtleWNoYWlucygpOiBhbnkge1xuICAgIGlmICghdGhpcy5fa2V5Y2hhaW5zKSB7XG4gICAgICB0aGlzLl9rZXljaGFpbnMgPSBuZXcgS2V5Y2hhaW5zKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2V5Y2hhaW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIHdhbGxldHMgb2JqZWN0LlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgd2FsbGV0cygpIHtcbiAgICBpZiAoIXRoaXMuX3dhbGxldHMpIHtcbiAgICAgIHRoaXMuX3dhbGxldHMgPSBuZXcgV2FsbGV0cyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmF2ZWwgcnVsZSBvYmplY3RcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHRyYXZlbFJ1bGUoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX3RyYXZlbFJ1bGUpIHtcbiAgICAgIHRoaXMuX3RyYXZlbFJ1bGUgPSBuZXcgVHJhdmVsUnVsZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RyYXZlbFJ1bGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBlbmRpbmcgYXBwcm92YWxzIHRoYXQgY2FuIGJlIGFwcHJvdmVkLyBvciByZWplY3RlZFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcGVuZGluZ0FwcHJvdmFscygpOiBhbnkge1xuICAgIGlmICghdGhpcy5fcGVuZGluZ0FwcHJvdmFscykge1xuICAgICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFscyA9IG5ldyBQZW5kaW5nQXBwcm92YWxzKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFscztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBXYWxsZXQgb2JqZWN0LCBpbml0aWFsaXplZCB3aXRoIHRoZSB3YWxsZXQgcGFyYW1zXG4gICAqIENhbiBiZSB1c2VkIHRvIHJlY29uc3RpdHV0ZSBhIHdhbGxldCBmcm9tIGNhY2hlZCBkYXRhXG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG5ld1dhbGxldE9iamVjdCh3YWxsZXRQYXJhbXMpOiBhbnkge1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMsIHdhbGxldFBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdXJsIGZvciBjYWxsaW5nIEJpdEdvIHBsYXRmb3JtIEFQSXNcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIHZlcnNpb25cbiAgICovXG4gIHVybChwYXRoOiBzdHJpbmcsIHZlcnNpb24gPSAxKTogc3RyaW5nIHtcbiAgICBjb25zdCBiYXNlVXJsID0gdmVyc2lvbiA9PT0gMiA/IHRoaXMuX2Jhc2VBcGlVcmxWMiA6IHRoaXMuX2Jhc2VBcGlVcmw7XG4gICAgcmV0dXJuIGJhc2VVcmwgKyBwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHVybCBmb3IgY2FsbGluZyBCaXRHbyBtaWNyb3NlcnZpY2UgQVBJc1xuICAgKi9cbiAgbWljcm9zZXJ2aWNlc1VybChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9taWNyb3NlcnZpY2VzVXJsICsgcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBhZGRyZXNzIGxhYmVscyBvbiBhbGwgb2YgdGhlIHVzZXIncyB3YWxsZXRzXG4gICAqL1xuICBsYWJlbHMocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9sYWJlbHMnKSlcbiAgICAgIC5yZXN1bHQoJ2xhYmVscycpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRXN0aW1hdGVzIGFwcHJveGltYXRlIGZlZSBwZXIga2IgbmVlZGVkIGZvciBhIHR4IHRvIGdldCBpbnRvIGEgYmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5udW1CbG9ja3MgdGFyZ2V0IGJsb2NrcyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIGNvbmZpcm1lZFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEZlZSBtYXhpbXVtIGZlZSB3aWxsaW5nIHRvIGJlIHBhaWQgKGZvciBzYWZldHkpXG4gICAqIEBwYXJhbSB7YXJyYXlbc3RyaW5nXX0gcGFyYW1zLmlucHV0cyBsaXN0IG9mIHVuY29uZmlybWVkIHR4SWRzIGZyb20gd2hpY2ggdGhpcyB0cmFuc2FjdGlvbiB1c2VzIGlucHV0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnR4U2l6ZSBlc3RpbWF0ZWQgdHJhbnNhY3Rpb24gc2l6ZSBpbiBieXRlcywgb3B0aW9uYWwgcGFyYW1ldGVyIHVzZWQgZm9yIENQRlAgZXN0aW1hdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuY3BmcEF3YXJlIGZsYWcgaW5kaWNhdGluZyBmZWUgc2hvdWxkIHRha2UgaW50byBhY2NvdW50IENQRlBcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGVzdGltYXRlRmVlKHBhcmFtczogRXN0aW1hdGVGZWVPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBxdWVyeVBhcmFtczogYW55ID0geyB2ZXJzaW9uOiAxMiB9O1xuICAgIGlmIChwYXJhbXMubnVtQmxvY2tzKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLm51bUJsb2NrcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5udW1CbG9ja3MgPSBwYXJhbXMubnVtQmxvY2tzO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLm1heEZlZSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5tYXhGZWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMubWF4RmVlID0gcGFyYW1zLm1heEZlZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5pbnB1dHMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuaW5wdXRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLmlucHV0cyA9IHBhcmFtcy5pbnB1dHM7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudHhTaXplKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnR4U2l6ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy50eFNpemUgPSBwYXJhbXMudHhTaXplO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmNwZnBBd2FyZSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuY3BmcEF3YXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLmNwZnBBd2FyZSA9IHBhcmFtcy5jcGZwQXdhcmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvdHgvZmVlJykpXG4gICAgICAucXVlcnkocXVlcnlQYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQml0R28ncyBndWFyYW50ZWUgdXNpbmcgYW4gaW5zdGFudCBpZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgaW5zdGFudEd1YXJhbnRlZShwYXJhbXM6IHsgaWQ6IHN0cmluZyB9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBpZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBib2R5ID0geWllbGQgc2VsZi5nZXQoc2VsZi51cmwoJy9pbnN0YW50LycgKyBwYXJhbXMuaWQpKS5yZXN1bHQoKTtcbiAgICAgIGlmICghYm9keS5ndWFyYW50ZWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBndWFyYW50ZWUgZm91bmQgaW4gcmVzcG9uc2UgYm9keScpO1xuICAgICAgfVxuICAgICAgaWYgKCFib2R5LnNpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHNpZ25hdHVyZSBmb3VuZCBpbiBndWFyYW50ZWUgcmVzcG9uc2UgYm9keScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmluZ0FkZHJlc3MgPSBjb21tb24uRW52aXJvbm1lbnRzW3NlbGYuZ2V0RW52KCldLnNpZ25pbmdBZGRyZXNzO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gbmV3IEJ1ZmZlcihib2R5LnNpZ25hdHVyZSwgJ2hleCcpO1xuICAgICAgY29uc3QgcHJlZml4ID0gYml0Y29pbi5uZXR3b3Jrc1tjb21tb24uRW52aXJvbm1lbnRzW3NlbGYuZ2V0RW52KCldLm5ldHdvcmtdLm1lc3NhZ2VQcmVmaXg7XG4gICAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlID0gYml0Y29pbk1lc3NhZ2UudmVyaWZ5KGJvZHkuZ3VhcmFudGVlLCBzaWduaW5nQWRkcmVzcywgc2lnbmF0dXJlQnVmZmVyLCBwcmVmaXgpO1xuICAgICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb3JyZWN0IHNpZ25hdHVyZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGFyZ2V0IGFkZHJlc3MgZm9yIHBheW1lbnQgb2YgYSBCaXRHbyBmZWVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldEJpdEdvRmVlQWRkcmVzcyhwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy9iaWxsaW5nL2FkZHJlc3MnKSlcbiAgICAgIC5zZW5kKHt9KVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhZGRyZXNzIG9iamVjdCAoaW5jbHVkaW5nIHRoZSB3YWxsZXQgaWQpIGZvciBhIGdpdmVuIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBsb29rIHVwLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0V2FsbGV0QWRkcmVzcyh7IGFkZHJlc3MgfTogeyBhZGRyZXNzOiBzdHJpbmcgfSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybChgL3dhbGxldGFkZHJlc3MvJHthZGRyZXNzfWApKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGlzdCBvZiB1c2VyIHdlYmhvb2tzXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGxpc3RXZWJob29rcyhjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvd2ViaG9va3MnKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgdXNlciB3ZWJob29rXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYWRkV2ViaG9vayhwYXJhbXM6IFdlYmhvb2tPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy51cmwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB1cmwnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB0eXBlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3dlYmhvb2tzJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdXNlciB3ZWJob29rXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVtb3ZlV2ViaG9vayhwYXJhbXM6IFdlYmhvb2tPcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudXJsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgdXJsJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgdHlwZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRlbCh0aGlzLnVybCgnL3dlYmhvb2tzJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsaXN0IG9mIHdlYmhvb2sgbm90aWZpY2F0aW9ucyBmb3IgdGhlIHVzZXJcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBsaXN0V2ViaG9va05vdGlmaWNhdGlvbnMocGFyYW1zOiBMaXN0V2ViaG9va05vdGlmaWNhdGlvbnNPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBxdWVyeTogYW55ID0ge307XG4gICAgaWYgKHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3dlYmhvb2tzL25vdGlmaWNhdGlvbnMnKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdXNlciB3ZWJob29rXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc2ltdWxhdGVXZWJob29rKHBhcmFtczogQml0R29TaW11bGF0ZVdlYmhvb2tPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3ZWJob29rSWQnLCAnYmxvY2tJZCddLCBbXSwgY2FsbGJhY2spO1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMud2ViaG9va0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgd2ViaG9va0lkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5ibG9ja0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgYmxvY2tJZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoYC93ZWJob29rcy8ke3BhcmFtcy53ZWJob29rSWR9L3NpbXVsYXRlYCkpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIFRUTCBhbmQgcmVmZXRjaGVzIGFzIG5lY2Vzc2FyeVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZmV0Y2hDb25zdGFudHMocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IGVudiA9IHNlbGYuZ2V0RW52KCk7XG5cbiAgICAgIGlmICghQml0R28uX2NvbnN0YW50cykge1xuICAgICAgICBCaXRHby5fY29uc3RhbnRzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoIUJpdEdvLl9jb25zdGFudHNFeHBpcmUpIHtcbiAgICAgICAgQml0R28uX2NvbnN0YW50c0V4cGlyZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoQml0R28uX2NvbnN0YW50c1tlbnZdICYmIEJpdEdvLl9jb25zdGFudHNFeHBpcmVbZW52XSAmJiBuZXcgRGF0ZSgpIDwgQml0R28uX2NvbnN0YW50c0V4cGlyZVtlbnZdKSB7XG4gICAgICAgIHJldHVybiBCaXRHby5fY29uc3RhbnRzW2Vudl07XG4gICAgICB9XG5cbiAgICAgIC8vIGNsaWVudCBjb25zdGFudHMgY2FsbCBjYW5ub3QgYmUgYXV0aGVudGljYXRlZCB1c2luZyB0aGUgbm9ybWFsIEhNQUMgdmFsaWRhdGlvblxuICAgICAgLy8gc2NoZW1lLCBzbyB3ZSBuZWVkIHRvIHVzZSBhIHJhdyBzdXBlcmFnZW50IGluc3RhbmNlIHRvIGRvIHRoaXMgcmVxdWVzdC5cbiAgICAgIC8vIFByb3h5IHNldHRpbmdzIG11c3Qgc3RpbGwgYmUgcmVzcGVjdGVkIGhvd2V2ZXJcbiAgICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBzdXBlcmFnZW50LmdldChzZWxmLnVybCgnL2NsaWVudC9jb25zdGFudHMnKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCAoc2VsZi5fcHJveHkgPyByZXN1bHRQcm9taXNlLnByb3h5KHNlbGYuX3Byb3h5KSA6IHJlc3VsdFByb21pc2UpO1xuICAgICAgQml0R28uX2NvbnN0YW50c1tlbnZdID0gcmVzdWx0LmJvZHkuY29uc3RhbnRzO1xuXG4gICAgICBCaXRHby5fY29uc3RhbnRzRXhwaXJlW2Vudl0gPSBtb21lbnQudXRjKCkuYWRkKHJlc3VsdC5ib2R5LnR0bCwgJ3NlY29uZCcpLnRvRGF0ZSgpO1xuICAgICAgcmV0dXJuIEJpdEdvLl9jb25zdGFudHNbZW52XTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzbHkgZ2V0IGNvbnN0YW50cyB3aGljaCBhcmUgcmVsZXZhbnQgdG8gdGhlIGNsaWVudC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBoYXMgYSBrbm93biByYWNlIGNvbmRpdGlvbi4gSXQgbWF5IHJldHVybiBkaWZmZXJlbnQgdmFsdWVzIG92ZXIgdGltZSxcbiAgICogZXNwZWNpYWxseSBpZiBjYWxsZWQgc2hvcnRseSBhZnRlciBjcmVhdGlvbiBvZiB0aGUgQml0R28gb2JqZWN0LlxuICAgKlxuICAgKiBOZXcgY29kZSBzaG91bGQgY2FsbCBmZXRjaENvbnN0YW50cygpIGRpcmVjdGx5IGluc3RlYWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xpZW50IGNvbnN0YW50cyBvYmplY3RcbiAgICovXG4gIGdldENvbnN0YW50cyhwYXJhbXM/OiB7fSkge1xuICAgIC8vIGtpY2sgb2ZmIGEgZnJlc2ggcmVxdWVzdCBmb3IgdGhlIGNsaWVudCBjb25zdGFudHNcbiAgICB0aGlzLmZldGNoQ29uc3RhbnRzKHBhcmFtcywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhbiBlcnJvciBkb2VzIG5vdCB0ZXJtaW5hdGUgdGhlIGVudGlyZSBzY3JpcHRcbiAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIGZldGNoIGNsaWVudCBjb25zdGFudHMgZnJvbSBCaXRHbycpO1xuICAgICAgICBjb25zb2xlLnRyYWNlKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB1c2UgZGVmYXVsdENvbnN0YW50cyBhcyB0aGUgYmFja3VwIGZvciBrZXlzIHRoYXQgYXJlIG5vdCBzZXQgaW4gdGhpcy5fY29uc3RhbnRzXG4gICAgcmV0dXJuIF8ubWVyZ2Uoe30sIGNvbmZpZy5kZWZhdWx0Q29uc3RhbnRzKHRoaXMuZ2V0RW52KCkpLCBCaXRHby5fY29uc3RhbnRzW3RoaXMuZ2V0RW52KCldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWMSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIG1pbmVyIGZlZSBhbW91bnRzLCBnaXZlbiB0aGUgbnVtYmVyIGFuZFxuICAgKiB0eXBlIG9mIHRyYW5zYWN0aW9uIGlucHV0cywgYWxvbmcgd2l0aCBhIGZlZSByYXRlIGluIHNhdG9zaGlzIHBlciB2a0IuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBmb3IgbmV3IGNvZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGNhbGN1bGF0ZU1pbmVyRmVlSW5mbyhwYXJhbXM6IGFueSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uQnVpbGRlci5jYWxjdWxhdGVNaW5lckZlZUluZm8ocGFyYW1zKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHJlcXVlc3QgdHJhY2VyIHRvIHByb3ZpZGUgcmVxdWVzdCBJRHMgZHVyaW5nIG11bHRpLXJlcXVlc3Qgd29ya2Zsb3dzXG4gICAqL1xuICBzZXRSZXF1ZXN0VHJhY2VyKHJlcVRyYWNlcjogSVJlcXVlc3RUcmFjZXIpIHtcbiAgICBpZiAocmVxVHJhY2VyKSB7XG4gICAgICB0aGlzLl9yZXFJZCA9IHJlcVRyYWNlcjtcbiAgICB9XG4gIH1cbn1cbiJdfQ==