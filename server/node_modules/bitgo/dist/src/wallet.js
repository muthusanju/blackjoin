"use strict";
/**
 * @hidden
 */
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 */
//
// Wallet Object
// BitGo accessor for a specific wallet
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var unspents_1 = require("@bitgo/unspents");
var TransactionBuilder = require('./transactionBuilder');
var bitcoin = require("bitgo-utxo-lib");
// TODO: switch to bitcoinjs-lib eventually once we upgrade it to version 3.x.x
var PendingApproval = require('./pendingapproval');
var common = require("./common");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var _ = require("lodash");
var bitcoin_1 = require("./bitcoin");
var request = require('superagent');
//
// Constructor
//
var Wallet = function (bitgo, wallet) {
    this.bitgo = bitgo;
    this.wallet = wallet;
    this.keychains = [];
    if (wallet.private) {
        this.keychains = wallet.private.keychains;
    }
};
Wallet.prototype.toJSON = function () {
    return this.wallet;
};
//
// id
// Get the id of this wallet.
//
Wallet.prototype.id = function () {
    return this.wallet.id;
};
//
// label
// Get the label of this wallet.
//
Wallet.prototype.label = function () {
    return this.wallet.label;
};
//
// balance
// Get the balance of this wallet.
//
Wallet.prototype.balance = function () {
    return this.wallet.balance;
};
//
// balance
// Get the spendable balance of this wallet.
// This is the total of all unspents except those that are unconfirmed and external
//
Wallet.prototype.spendableBalance = function () {
    return this.wallet.spendableBalance;
};
//
// confirmedBalance
// Get the confirmedBalance of this wallet.
//
Wallet.prototype.confirmedBalance = function () {
    return this.wallet.confirmedBalance;
};
//
// canSendInstant
// Returns if the wallet can send instant transactions
// This is impacted by the choice of backup key provider
//
Wallet.prototype.canSendInstant = function () {
    return this.wallet && this.wallet.canSendInstant;
};
//
// instant balance
// Get the instant balance of this wallet.
// This is the total of all unspents that may be spent instantly.
//
Wallet.prototype.instantBalance = function () {
    if (!this.canSendInstant()) {
        throw new Error('not an instant wallet');
    }
    return this.wallet.instantBalance;
};
//
// unconfirmedSends
// Get the balance of unconfirmedSends of this wallet.
//
Wallet.prototype.unconfirmedSends = function () {
    return this.wallet.unconfirmedSends;
};
//
// unconfirmedReceives
// Get the balance of unconfirmedReceives balance of this wallet.
//
Wallet.prototype.unconfirmedReceives = function () {
    return this.wallet.unconfirmedReceives;
};
//
// type
// Get the type of this wallet, e.g. 'safehd'
//
Wallet.prototype.type = function () {
    return this.wallet.type;
};
Wallet.prototype.url = function (extra) {
    extra = extra || '';
    return this.bitgo.url('/wallet/' + this.id() + extra);
};
//
// pendingApprovals
// returns the pending approvals list for this wallet as pending approval objects
//
Wallet.prototype.pendingApprovals = function () {
    var self = this;
    return this.wallet.pendingApprovals.map(function (p) {
        return new PendingApproval(self.bitgo, p, self);
    });
};
//
// approvalsRequired
// returns the number of approvals required to approve pending approvals involving this wallet
//
Wallet.prototype.approvalsRequired = function () {
    return this.wallet.approvalsRequired || 1;
};
//
// get
// Refetches this wallet and returns it
//
Wallet.prototype.get = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var self = this;
    return this.bitgo.get(this.url())
        .result()
        .then(function (res) {
        self.wallet = res;
        return self;
    })
        .nodeify(callback);
};
//
// updateApprovalsRequired
// Updates the number of approvals required on a pending approval involving this wallet.
// The approvals required is by default 1, but this function allows you to update the
// number such that 1 <= approvalsRequired <= walletAdmins.length - 1
//
Wallet.prototype.updateApprovalsRequired = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (params.approvalsRequired === undefined ||
        !_.isInteger(params.approvalsRequired) ||
        params.approvalsRequired < 1) {
        throw new Error('invalid approvalsRequired: must be a nonzero positive number');
    }
    var self = this;
    var currentApprovalsRequired = this.approvalsRequired();
    if (currentApprovalsRequired === params.approvalsRequired) {
        // no-op, just return the current wallet
        return Bluebird.try(function () {
            return self.wallet;
        })
            .nodeify(callback);
    }
    return this.bitgo.put(this.url())
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * Returns the correct chain for change, taking into consideration segwit
 */
Wallet.prototype.getChangeChain = function (params) {
    var useSegwitChange = !!this.bitgo.getConstants().enableSegwit;
    if (!_.isUndefined(params.segwitChange)) {
        if (!_.isBoolean(params.segwitChange)) {
            throw new Error('segwitChange must be a boolean');
        }
        // if segwit is disabled through the constants, segwit change should still not be created
        useSegwitChange = this.bitgo.getConstants().enableSegwit && params.segwitChange;
    }
    return useSegwitChange ? unspents_1.Codes.internal.p2shP2wsh : unspents_1.Codes.internal.p2sh;
};
//
// createAddress
// Creates a new address for use with this wallet.
//
Wallet.prototype.createAddress = function (params, callback) {
    var self = this;
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (this.type() === 'safe') {
        throw new Error('You are using a legacy wallet that cannot create a new address');
    }
    // Default to client-side address validation on, for safety. Use validate=false to disable.
    var shouldValidate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    var allowExisting = params.allowExisting;
    if (typeof allowExisting !== 'boolean') {
        params.allowExisting = (allowExisting === 'true');
    }
    var isSegwit = this.bitgo.getConstants().enableSegwit;
    var defaultChain = isSegwit ? unspents_1.Codes.external.p2shP2wsh : unspents_1.Codes.external.p2sh;
    var chain = params.chain;
    if (chain === null || chain === undefined) {
        chain = defaultChain;
    }
    return this.bitgo.post(this.url('/address/' + chain))
        .send(params)
        .result()
        .then(function (addr) {
        if (shouldValidate) {
            self.validateAddress(addr);
        }
        return addr;
    })
        .nodeify(callback);
};
/**
 * Generate address locally without calling server
 * @param params
 *
 */
Wallet.prototype.generateAddress = function (_a) {
    var segwit = _a.segwit, path = _a.path, keychains = _a.keychains, threshold = _a.threshold;
    var isSegwit = !!segwit;
    var signatureThreshold = 2;
    if (_.isInteger(threshold)) {
        signatureThreshold = threshold;
        if (signatureThreshold <= 0) {
            throw new Error('threshold has to be positive');
        }
    }
    var pathRegex = /^\/1?[01]\/\d+$/;
    if (!path.match(pathRegex)) {
        throw new Error('unsupported path: ' + path);
    }
    var rootKeys = this.keychains;
    if (Array.isArray(keychains)) {
        rootKeys = keychains;
    }
    var network = common.Environments[this.bitgo.getEnv()].network;
    var derivedKeys = rootKeys.map(function (k) {
        var hdnode = bitcoin.HDNode.fromBase58(k.xpub);
        var derivationPath = k.path + path;
        if (k.walletSubPath) {
            // if a keychain has a wallet subpath, it should be used as an infix
            derivationPath = k.path + k.walletSubPath + path;
        }
        if (!derivationPath.startsWith('m')) {
            // all derivation paths need to start with m, but k.path may already contain that
            derivationPath = "m/" + derivationPath;
        }
        return bitcoin_1.hdPath(hdnode).deriveKey(derivationPath).getPublicKeyBuffer();
    });
    var pathComponents = path.split('/');
    var normalizedPathComponents = _.map(pathComponents, function (component) {
        if (component && component.length > 0) {
            return parseInt(component, 10);
        }
    });
    var pathDetails = _.filter(normalizedPathComponents, _.isInteger);
    var addressDetails = {
        chainPath: path,
        path: path,
        chain: pathDetails[0],
        index: pathDetails[1],
        wallet: this.id()
    };
    // redeem script normally, witness script for segwit
    var inputScript = bitcoin.script.multisig.output.encode(signatureThreshold, derivedKeys);
    var inputScriptHash = bitcoin.crypto.hash160(inputScript);
    var outputScript = bitcoin.script.scriptHash.output.encode(inputScriptHash);
    addressDetails.redeemScript = inputScript.toString('hex');
    if (isSegwit) {
        var witnessScriptHash = bitcoin.crypto.sha256(inputScript);
        var redeemScript = bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
        var redeemScriptHash = bitcoin.crypto.hash160(redeemScript);
        outputScript = bitcoin.script.scriptHash.output.encode(redeemScriptHash);
        addressDetails.witnessScript = inputScript.toString('hex');
        addressDetails.redeemScript = redeemScript.toString('hex');
    }
    addressDetails.outputScript = outputScript.toString('hex');
    addressDetails.address = bitcoin.address.fromOutputScript(outputScript, bitcoin_1.getNetwork(network));
    return addressDetails;
};
//
// validateAddress
// Validates an address and path by calculating it locally from the keychain xpubs
//
Wallet.prototype.validateAddress = function (params) {
    common.validateParams(params, ['address', 'path'], []);
    var isSegwit = !!params.witnessScript && params.witnessScript.length > 0;
    var generatedAddress = this.generateAddress({ path: params.path, segwit: isSegwit });
    if (generatedAddress.address !== params.address) {
        throw new Error('address validation failure: ' + params.address + ' vs. ' + generatedAddress.address);
    }
};
//
// addresses
// Gets the addresses of a HD wallet.
// Options include:
//  limit: the number of addresses to get
//
Wallet.prototype.addresses = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var query = {};
    if (params.details) {
        query.details = 1;
    }
    var chain = params.chain;
    if (chain !== null && chain !== undefined) {
        if (Array.isArray(chain)) {
            query.chain = _.uniq(_.filter(chain, _.isInteger));
        }
        else {
            if (chain !== 0 && chain !== 1) {
                throw new Error('invalid chain argument, expecting 0 or 1');
            }
            query.chain = chain;
        }
    }
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        query.limit = params.limit;
    }
    if (params.skip) {
        if (!_.isInteger(params.skip)) {
            throw new Error('invalid skip argument, expecting number');
        }
        query.skip = params.skip;
    }
    if (params.sort) {
        if (!_.isNumber(params.sort)) {
            throw new Error('invalid sort argument, expecting number');
        }
        query.sort = params.sort;
    }
    var url = this.url('/addresses');
    return this.bitgo.get(url)
        .query(query)
        .result()
        .nodeify(callback);
};
Wallet.prototype.stats = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var args = [];
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        args.push('limit=' + params.limit);
    }
    var query = '';
    if (args.length) {
        query = '?' + args.join('&');
    }
    var url = this.url('/stats' + query);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
/**
 * Refresh the wallet object by syncing with the back-end
 * @param callback
 * @returns {Wallet}
 */
Wallet.prototype.refresh = function (params, callback) {
    return co(function () {
        var query, res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    query = _.extend({}, _.pick(params, ['gpk']));
                    return [4 /*yield*/, this.bitgo.get(this.url()).query(query).result()];
                case 1:
                    res = _a.sent();
                    this.wallet = res;
                    return [2 /*return*/, this];
            }
        });
    }).call(this).asCallback(callback);
};
//
// address
// Gets information about a single address on a HD wallet.
// Information includes index, path, redeemScript, sent, received, txCount and balance
// Options include:
//  address: the address on this wallet to get
//
Wallet.prototype.address = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], [], callback);
    var url = this.url('/addresses/' + params.address);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
/**
 * Freeze the wallet for a duration of choice, stopping BitGo from signing any transactions.
 * @param {number} limit The duration to freeze the wallet for in seconds, defaults to 3600.
 */
Wallet.prototype.freeze = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (params.duration) {
        if (!_.isNumber(params.duration)) {
            throw new Error('invalid duration - should be number of seconds');
        }
    }
    return this.bitgo.post(this.url('/freeze'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// delete
// Deletes the wallet
//
Wallet.prototype.delete = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.del(this.url())
        .result()
        .nodeify(callback);
};
//
// labels
// List the labels for the addresses in a given wallet
//
Wallet.prototype.labels = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var url = this.bitgo.url('/labels/' + this.id());
    return this.bitgo.get(url)
        .result('labels')
        .nodeify(callback);
};
/**
 * Rename a wallet
 * @param params
 *  - label: the wallet's intended new name
 * @param callback
 * @returns {*}
 */
Wallet.prototype.setWalletName = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['label'], [], callback);
    var url = this.bitgo.url('/wallet/' + this.id());
    return this.bitgo.put(url)
        .send({ label: params.label })
        .result()
        .nodeify(callback);
};
//
// setLabel
// Sets a label on the provided address
//
Wallet.prototype.setLabel = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address', 'label'], [], callback);
    var self = this;
    if (!self.bitgo.verifyAddress({ address: params.address })) {
        throw new Error('Invalid bitcoin address: ' + params.address);
    }
    var url = this.bitgo.url('/labels/' + this.id() + '/' + params.address);
    return this.bitgo.put(url)
        .send({ label: params.label })
        .result()
        .nodeify(callback);
};
//
// deleteLabel
// Deletes the label associated with the provided address
//
Wallet.prototype.deleteLabel = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], [], callback);
    var self = this;
    if (!self.bitgo.verifyAddress({ address: params.address })) {
        throw new Error('Invalid bitcoin address: ' + params.address);
    }
    var url = this.bitgo.url('/labels/' + this.id() + '/' + params.address);
    return this.bitgo.del(url)
        .result()
        .nodeify(callback);
};
//
// unspents
// List ALL the unspents for a given wallet
// This method will return a paged list of all unspents
//
// Parameters include:
//   limit:  the optional limit of unspents to collect in BTC
//   minConf: only include results with this number of confirmations
//   target: the amount of btc to find to spend
//   instant: only find instant transactions (must specify a target)
//
Wallet.prototype.unspents = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var allUnspents = [];
    var self = this;
    var getUnspentsBatch = function (skip, limit) {
        var queryObject = _.cloneDeep(params);
        if (skip > 0) {
            queryObject.skip = skip;
        }
        if (limit && limit > 0) {
            queryObject.limit = limit;
        }
        return self.unspentsPaged(queryObject)
            .then(function (result) {
            // The API has its own limit handling. For example, the API does not support limits bigger than 500. If the limit
            // specified here is bigger than that, we will have to do multiple requests with necessary limit adjustment.
            for (var i = 0; i < result.unspents.length; i++) {
                var unspent = result.unspents[i];
                allUnspents.push(unspent);
            }
            // Our limit adjustment makes sure that we never fetch more unspents than we need, meaning that if we hit the
            // limit, we hit it precisely
            if (allUnspents.length >= params.limit) {
                return allUnspents; // we aren't interested in any further unspents
            }
            var totalUnspentCount = result.total;
            // if no target is specified and the SDK indicates that there has been a limit, we need to fetch another batch
            if (!params.target && totalUnspentCount && totalUnspentCount > allUnspents.length) {
                // we need to fetch the next batch
                // let's just offset the current skip by the count
                var newSkip = skip + result.count;
                var newLimit = void 0;
                if (limit > 0) {
                    // we set the new limit to be precisely the number of missing unspents to hit our own limit
                    newLimit = limit - allUnspents.length;
                }
                return getUnspentsBatch(newSkip, newLimit);
            }
            return allUnspents;
        });
    };
    return getUnspentsBatch(0, params.limit)
        .nodeify(callback);
};
/**
 * List the unspents (paged) for a given wallet, returning the result as an object of unspents, count, skip and total
 * This method may not return all the unspents as the list is paged by the API
 * @param params
 * @param params.limit the optional limit of unspents to collect in BTC
 * @param params.skip index in list of unspents to start paging from
 * @param params.minConfirms only include results with this number of confirmations
 * @param params.target the amount of btc to find to spend
 * @param params.instant only find instant transactions (must specify a target)
 * @param params.targetWalletUnspents desired number of unspents to have in the wallet after the tx goes through (requires target)
 * @param params.minSize minimum unspent size in satoshis
 * @param params.segwit request segwit unspents (defaults to true if undefined)
 * @param params.allowLedgerSegwit allow segwit unspents for ledger devices (defaults to false if undefined)
 * @param callback
 * @returns {*}
 */
Wallet.prototype.unspentsPaged = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (!_.isUndefined(params.limit) && !_.isInteger(params.limit)) {
        throw new Error('invalid limit - should be number');
    }
    if (!_.isUndefined(params.skip) && !_.isInteger(params.skip)) {
        throw new Error('invalid skip - should be number');
    }
    if (!_.isUndefined(params.minConfirms) && !_.isInteger(params.minConfirms)) {
        throw new Error('invalid minConfirms - should be number');
    }
    if (!_.isUndefined(params.target) && !_.isNumber(params.target)) {
        throw new Error('invalid target - should be number');
    }
    if (!_.isUndefined(params.instant) && !_.isBoolean(params.instant)) {
        throw new Error('invalid instant flag - should be boolean');
    }
    if (!_.isUndefined(params.segwit) && !_.isBoolean(params.segwit)) {
        throw new Error('invalid segwit flag - should be boolean');
    }
    if (!_.isUndefined(params.targetWalletUnspents) && !_.isInteger(params.targetWalletUnspents)) {
        throw new Error('invalid targetWalletUnspents flag - should be number');
    }
    if (!_.isUndefined(params.minSize) && !_.isNumber(params.minSize)) {
        throw new Error('invalid argument: minSize must be a number');
    }
    if (!_.isUndefined(params.instant) && !_.isUndefined(params.minConfirms)) {
        throw new Error('only one of instant and minConfirms may be defined');
    }
    if (!_.isUndefined(params.targetWalletUnspents) && _.isUndefined(params.target)) {
        throw new Error('targetWalletUnspents can only be specified in conjunction with a target');
    }
    if (!_.isUndefined(params.allowLedgerSegwit) && !_.isBoolean(params.allowLedgerSegwit)) {
        throw new Error('invalid argument: allowLedgerSegwit must be a boolean');
    }
    var queryObject = _.cloneDeep(params);
    if (!_.isUndefined(params.target)) {
        // skip and limit are unavailable when a target is specified
        delete queryObject.skip;
        delete queryObject.limit;
    }
    queryObject.segwit = true;
    if (!_.isUndefined(params.segwit)) {
        queryObject.segwit = params.segwit;
    }
    if (!_.isUndefined(params.allowLedgerSegwit)) {
        queryObject.allowLedgerSegwit = params.allowLedgerSegwit;
    }
    return this.bitgo.get(this.url('/unspents'))
        .query(queryObject)
        .result()
        .nodeify(callback);
};
//
// transactions
// List the transactions for a given wallet
// Options include:
//     TODO:  Add iterators for start/count/etc
Wallet.prototype.transactions = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var args = [];
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        args.push('limit=' + params.limit);
    }
    if (params.skip) {
        if (!_.isInteger(params.skip)) {
            throw new Error('invalid skip argument, expecting number');
        }
        args.push('skip=' + params.skip);
    }
    if (params.minHeight) {
        if (!_.isInteger(params.minHeight)) {
            throw new Error('invalid minHeight argument, expecting number');
        }
        args.push('minHeight=' + params.minHeight);
    }
    if (params.maxHeight) {
        if (!_.isInteger(params.maxHeight) || params.maxHeight < 0) {
            throw new Error('invalid maxHeight argument, expecting positive integer');
        }
        args.push('maxHeight=' + params.maxHeight);
    }
    if (params.minConfirms) {
        if (!_.isInteger(params.minConfirms) || params.minConfirms < 0) {
            throw new Error('invalid minConfirms argument, expecting positive integer');
        }
        args.push('minConfirms=' + params.minConfirms);
    }
    if (!_.isUndefined(params.compact)) {
        if (!_.isBoolean(params.compact)) {
            throw new Error('invalid compact argument, expecting boolean');
        }
        args.push('compact=' + params.compact);
    }
    var query = '';
    if (args.length) {
        query = '?' + args.join('&');
    }
    var url = this.url('/tx' + query);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// transaction
// Get a transaction by ID for a given wallet
Wallet.prototype.getTransaction = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    var url = this.url('/tx/' + params.id);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// pollForTransaction
// Poll a transaction until successful or times out
// Parameters:
//   id: the txid
//   delay: delay between polls in ms (default: 1000)
//   timeout: timeout in ms (default: 10000)
Wallet.prototype.pollForTransaction = function (params, callback) {
    var self = this;
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    if (params.delay && !_.isNumber(params.delay)) {
        throw new Error('invalid delay parameter');
    }
    if (params.timeout && !_.isNumber(params.timeout)) {
        throw new Error('invalid timeout parameter');
    }
    params.delay = params.delay || 1000;
    params.timeout = params.timeout || 10000;
    var start = new Date();
    var doNextPoll = function () {
        return self.getTransaction(params)
            .then(function (res) {
            return res;
        })
            .catch(function (err) {
            if (err.status !== 404 || new Date().valueOf() - start.valueOf() > params.timeout) {
                throw err;
            }
            return Bluebird.delay(params.delay)
                .then(function () {
                return doNextPoll();
            });
        });
    };
    return doNextPoll();
};
//
// transaction by sequence id
// Get a transaction by sequence id for a given wallet
Wallet.prototype.getWalletTransactionBySequenceId = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['sequenceId'], [], callback);
    var url = this.url('/tx/sequence/' + params.sequenceId);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// Key chains
// Gets the user key chain for this wallet
// The user key chain is typically the first keychain of the wallet and has the encrypted xpriv stored on BitGo.
// Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
Wallet.prototype.getEncryptedUserKeychain = function (params, callback) {
    return co(function () {
        var self, tryKeyChain;
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, [], [], callback);
            self = this;
            tryKeyChain = co(function (index) {
                var error, params, keychain;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!self.keychains || index >= self.keychains.length) {
                                error = new Error('No encrypted keychains on this wallet.');
                                error.code = 'no_encrypted_keychain_on_wallet';
                                throw error;
                            }
                            params = { xpub: self.keychains[index].xpub };
                            return [4 /*yield*/, self.bitgo.keychains().get(params)];
                        case 1:
                            keychain = _a.sent();
                            // If we find the xprv, then this is probably the user keychain we're looking for
                            keychain.walletSubPath = self.keychains[index].path;
                            if (keychain.encryptedXprv) {
                                return [2 /*return*/, keychain];
                            }
                            return [2 /*return*/, tryKeyChain(index + 1)];
                    }
                });
            });
            return [2 /*return*/, tryKeyChain(0)];
        });
    }).call(this).asCallback(callback);
};
//
// createTransaction
// Create a transaction (unsigned). To sign it, do signTransaction
// Parameters:
//   recipients - object of recipient addresses and the amount to send to each e.g. {address:1500, address2:1500}
//   fee      - the blockchain fee to send (optional)
//   feeRate  - the fee per kb to send (optional)
//   minConfirms - minimum number of confirms to use when gathering unspents
//   forceChangeAtEnd - force change address to be last output (optional)
//   noSplitChange - disable automatic change splitting for purposes of unspent management
//   changeAddress - override the change address (optional)
//   validate - extra verification of change addresses (which are always verified server-side) (defaults to global config)
// Returns:
//   callback(err, { transactionHex: string, unspents: [inputs], fee: satoshis })
Wallet.prototype.createTransaction = function (params, callback) {
    params = _.extend({}, params);
    common.validateParams(params, [], [], callback);
    if ((!_.isNumber(params.fee) && !_.isUndefined(params.fee)) ||
        (!_.isNumber(params.feeRate) && !_.isUndefined(params.feeRate)) ||
        (!_.isNumber(params.minConfirms) && !_.isUndefined(params.minConfirms)) ||
        (!_.isBoolean(params.forceChangeAtEnd) && !_.isUndefined(params.forceChangeAtEnd)) ||
        (!_.isString(params.changeAddress) && !_.isUndefined(params.changeAddress)) ||
        (!_.isBoolean(params.validate) && !_.isUndefined(params.validate)) ||
        (!_.isBoolean(params.instant) && !_.isUndefined(params.instant))) {
        throw new Error('invalid argument');
    }
    if (!_.isObject(params.recipients)) {
        throw new Error('expecting recipients object');
    }
    params.validate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    params.wallet = this;
    return TransactionBuilder.createTransaction(params)
        .nodeify(callback);
};
//
// signTransaction
// Sign a previously created transaction with a keychain
// Parameters:
// transactionHex - serialized form of the transaction in hex
// unspents - array of unspent information, where each unspent is a chainPath
//            and redeemScript with the same index as the inputs in the
//            transactionHex
// keychain - Keychain containing the xprv to sign with.
// signingKey - For legacy safe wallets, the private key string.
// validate - extra verification of signatures (which are always verified server-side) (defaults to global config)
// Returns:
//   callback(err, transaction)
Wallet.prototype.signTransaction = function (params, callback) {
    params = _.extend({}, params);
    common.validateParams(params, ['transactionHex'], [], callback);
    if (!Array.isArray(params.unspents)) {
        throw new Error('expecting the unspents array');
    }
    if ((!_.isObject(params.keychain) || !params.keychain.xprv) && !_.isString(params.signingKey)) {
        // allow passing in a WIF private key for legacy safe wallet support
        var error = new Error('expecting keychain object with xprv or signingKey WIF');
        error.code = 'missing_keychain_or_signingKey';
        throw error;
    }
    params.validate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    params.bitgo = this.bitgo;
    return TransactionBuilder.signTransaction(params)
        .then(function (result) {
        return {
            tx: result.transactionHex
        };
    })
        .nodeify(callback);
};
//
// send
// Send a transaction to the Bitcoin network via BitGo.
// One of the keys is typically signed, and BitGo will sign the other (if approved) and relay it to the P2P network.
// Parameters:
//   tx  - the hex encoded, signed transaction to send
// Returns:
//
Wallet.prototype.sendTransaction = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['tx'], ['message', 'otp'], callback);
    return this.bitgo.post(this.bitgo.url('/tx/send'))
        .send(params)
        .result()
        .then(function (body) {
        if (body.pendingApproval) {
            return _.extend(body, { status: 'pendingApproval' });
        }
        if (body.otp) {
            return _.extend(body, { status: 'otp' });
        }
        return {
            status: 'accepted',
            tx: body.transaction,
            hash: body.transactionHash,
            instant: body.instant,
            instantId: body.instantId
        };
    })
        .nodeify(callback);
};
/**
 * Share the wallet with an existing BitGo user.
 * @param {string} user The recipient's user id, must have a corresponding user record in our database.
 * @param {keychain} keychain The keychain to be shared with the recipient.
 * @param {string} permissions A comma-separated value string that specifies the recipient's permissions if the share is accepted.
 * @param {string} message The message to be used for this share.
 */
Wallet.prototype.createShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['user', 'permissions'], [], callback);
    if (params.keychain && !_.isEmpty(params.keychain)) {
        if (!params.keychain.xpub || !params.keychain.encryptedXprv || !params.keychain.fromPubKey || !params.keychain.toPubKey || !params.keychain.path) {
            throw new Error('requires keychain parameters - xpub, encryptedXprv, fromPubKey, toPubKey, path');
        }
    }
    return this.bitgo.post(this.url('/share'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// createInvite
// invite a non BitGo customer to join a wallet
// Parameters:
//   email - the recipient's email address
//   permissions - the recipient's permissions if the share is accepted
// Returns:
//
Wallet.prototype.createInvite = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['email', 'permissions'], ['message'], callback);
    var options = {
        toEmail: params.email,
        permissions: params.permissions
    };
    if (params.message) {
        options.message = params.message;
    }
    return this.bitgo.post(this.url('/invite'))
        .send(options)
        .result()
        .nodeify(callback);
};
//
// confirmInviteAndShareWallet
// confirm my invite on this wallet to a recipient who has
// subsequently signed up by creating the actual wallet share
// Parameters:
//   walletInviteId - the wallet invite id
//   walletPassphrase - required if the wallet share success is expected
// Returns:
//
Wallet.prototype.confirmInviteAndShareWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletInviteId'], ['walletPassphrase'], callback);
    var self = this;
    return this.bitgo.wallets().listInvites()
        .then(function (invites) {
        var outgoing = invites.outgoing;
        var invite = _.find(outgoing, function (out) {
            return out.id === params.walletInviteId;
        });
        if (!invite) {
            throw new Error('wallet invite not found');
        }
        var options = {
            email: invite.toEmail,
            permissions: invite.permissions,
            message: invite.message,
            walletPassphrase: params.walletPassphrase
        };
        return self.shareWallet(options);
    })
        .then(function () {
        return this.bitgo.put(this.bitgo.url('/walletinvite/' + params.walletInviteId));
    })
        .nodeify(callback);
};
//
// sendCoins
// Send coins to a destination address from this wallet using the user key.
// 1. Gets the user keychain by checking the wallet for a key which has an encrypted xpriv
// 2. Decrypts user key
// 3. Creates the transaction with default fee
// 4. Signs transaction with decrypted user key
// 3. Sends the transaction to BitGo
//
// Parameters:
//   address - the destination address
//   amount - the amount in satoshis to be sent
//   message - optional message to attach to transaction
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   xprv - the private key in string form, if walletPassphrase is not available
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.sendCoins = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], ['message'], callback);
    if (!_.isNumber(params.amount)) {
        throw new Error('invalid argument for amount - number expected');
    }
    params.recipients = {};
    params.recipients[params.address] = params.amount;
    return this.sendMany(params)
        .nodeify(callback);
};
//
// sendMany
// Send coins to multiple destination addresses from this wallet using the user key.
// 1. Gets the user keychain by checking the wallet for a key which has an encrypted xpriv
// 2. Decrypts user key
// 3. Creates the transaction with default fee
// 4. Signs transaction with decrypted user key
// 3. Sends the transaction to BitGo
//
// Parameters:
//   recipients - array of { address: string, amount: number, travelInfo: object } to send to
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   xprv - the private key in string form, if walletPassphrase is not available
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.sendMany = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['message', 'otp'], callback);
    var self = this;
    if (!_.isObject(params.recipients)) {
        throw new Error('expecting recipients object');
    }
    if (params.fee && !_.isNumber(params.fee)) {
        throw new Error('invalid argument for fee - number expected');
    }
    if (params.feeRate && !_.isNumber(params.feeRate)) {
        throw new Error('invalid argument for feeRate - number expected');
    }
    if (params.instant && !_.isBoolean(params.instant)) {
        throw new Error('invalid argument for instant - boolean expected');
    }
    var bitgoFee;
    var travelInfos;
    var finalResult;
    var unspentsUsed;
    var acceptedBuildParams = [
        'numBlocks', 'feeRate', 'minConfirms', 'enforceMinConfirmsForChange',
        'targetWalletUnspents', 'message', 'minValue', 'maxValue',
        'noSplitChange', 'comment'
    ];
    var preservedBuildParams = _.pick(params, acceptedBuildParams);
    // Get the user keychain
    var retPromise = this.createAndSignTransaction(params)
        .then(function (transaction) {
        // Send the transaction
        bitgoFee = transaction.bitgoFee;
        travelInfos = transaction.travelInfos;
        unspentsUsed = transaction.unspents;
        return self.sendTransaction({
            tx: transaction.tx,
            message: params.message,
            sequenceId: params.sequenceId,
            instant: params.instant,
            otp: params.otp,
            // The below params are for logging only, and do not impact the API call
            estimatedSize: transaction.estimatedSize,
            buildParams: preservedBuildParams
        });
    })
        .then(function (result) {
        var tx = bitcoin.Transaction.fromHex(result.tx);
        var inputsSum = _.sumBy(unspentsUsed, 'value');
        var outputsSum = _.sumBy(tx.outs, 'value');
        var feeUsed = inputsSum - outputsSum;
        if (isNaN(feeUsed)) {
            throw new Error('invalid feeUsed');
        }
        result.fee = feeUsed,
            result.feeRate = feeUsed * 1000 / tx.virtualSize();
        result.travelInfos = travelInfos;
        if (bitgoFee) {
            result.bitgoFee = bitgoFee;
        }
        finalResult = result;
        // Handle sending travel infos if they exist, but make sure we never fail here.
        // Error or result (with possible sub-errors) will be provided in travelResult
        if (travelInfos && travelInfos.length) {
            try {
                return self.pollForTransaction({ id: result.hash })
                    .then(function () {
                    return self.bitgo.travelRule().sendMany(result);
                })
                    .then(function (res) {
                    finalResult.travelResult = res;
                })
                    .catch(function (err) {
                    // catch async errors
                    finalResult.travelResult = { error: err.message };
                });
            }
            catch (err) {
                // catch synchronous errors
                finalResult.travelResult = { error: err.message };
            }
        }
    })
        .then(function () {
        return finalResult;
    });
    return Bluebird.resolve(retPromise).nodeify(callback);
};
/**
 * Accelerate a stuck transaction using Child-Pays-For-Parent (CPFP).
 *
 * This should only be used for stuck transactions which have no unconfirmed inputs.
 *
 * @param {Object} params - Input parameters
 * @param {String} params.transactionID - ID of transaction to accelerate
 * @param {Number} params.feeRate - New effective fee rate for stuck transaction (sat per 1000 bytes)
 * @param {Number} params.maxAdditionalUnspents - Maximum additional unspents to use from the wallet to cover any child fees that the parent unspent output cannot cover. Defaults to 100.
 * @param {String} params.walletPassphrase - The passphrase which should be used to decrypt the wallet private key. One of either walletPassphrase or xprv is required.
 * @param {String} params.xprv - The private key for the wallet. One of either walletPassphrase or xprv is required.
 * @param {Function} callback
 * @returns Result of sendTransaction() on the child transaction
 */
Wallet.prototype.accelerateTransaction = function accelerateTransaction(params, callback) {
    var _this = this;
    /**
     * Helper function to estimate a transactions size in virtual bytes.
     * Actual transactions may be slightly fewer virtual bytes, due to
     * the fact that valid ECSDA signatures have a variable length
     * between 8 and 73 virtual bytes.
     *
     * @param inputs.segwit The number of segwit inputs to the transaction
     * @param inputs.P2SH The number of P2SH inputs to the transaction
     * @param inputs.P2PKH The number of P2PKH inputs to the transaction
     */
    var estimateTxVSize = function (inputs) {
        var segwit = inputs.segwit || 0;
        var P2SH = inputs.P2SH || 0;
        var P2PKH = inputs.P2PKH || 0;
        var childFeeInfo = TransactionBuilder.calculateMinerFeeInfo({
            nP2shInputs: P2SH,
            nP2pkhInputs: P2PKH,
            nP2shP2wshInputs: segwit,
            nOutputs: 1,
            feeRate: 1
        });
        return childFeeInfo.size;
    };
    /**
     * Calculate the number of satoshis that should be paid in fees by the child transaction
     *
     * @param inputs Inputs to the child transaction which are passed to estimateTxVSize
     * @param parentFee The number of satoshis the parent tx originally paid in fees
     * @param parentVSize The number of virtual bytes in the parent tx
     * @param feeRate The new fee rate which should be paid by the combined CPFP transaction
     * @returns {number} The number of satoshis the child tx should pay in fees
     */
    var estimateChildFee = function (_a) {
        var inputs = _a.inputs, parentFee = _a.parentFee, parentVSize = _a.parentVSize, feeRate = _a.feeRate;
        // calculate how much more we *should* have paid in parent fees,
        // had the parent been originally sent with the new fee rate
        var additionalParentFee = _.ceil(parentVSize * feeRate / 1000) - parentFee;
        // calculate how much we would pay in fees for the child,
        // if it were only paying for itself at the new fee rate
        var childFee = estimateTxVSize(inputs) * feeRate / 1000;
        return _.ceil(childFee + additionalParentFee);
    };
    /**
     * Helper function to find additional unspents to use to pay the child tx fees.
     * This function is called when the the parent tx output is not sufficient to
     * cover the total fees which should be paid by the child tx.
     *
     * @param inputs Inputs to the child transaction which are passed to estimateTxVSize
     * @param parentOutputValue The value of the output from the parent tx which we are using as an input to the child tx
     * @param parentFee The number of satoshis the parent tx originally paid in fees
     * @param parentVSize The number of virtual bytes in the parent tx
     * @param maxUnspents The maximum number of additional unspents which should be used to cover the remaining child fees
     * @returns An object with the additional unspents to use, the updated number of satoshis which should be paid by
     *          the child tx, and the updated inputs for the child tx.
     */
    var findAdditionalUnspents = function (_a) {
        var inputs = _a.inputs, parentOutputValue = _a.parentOutputValue, parentFee = _a.parentFee, parentVSize = _a.parentVSize, maxUnspents = _a.maxUnspents;
        return co(function coFindAdditionalUnspents() {
            var additionalUnspents, currentChildFeeEstimate, uncoveredChildFee, _loop_1, this_1, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        additionalUnspents = [];
                        currentChildFeeEstimate = estimateChildFee({ inputs: inputs, parentFee: parentFee, parentVSize: parentVSize, feeRate: params.feeRate });
                        uncoveredChildFee = currentChildFeeEstimate - parentOutputValue;
                        _loop_1 = function () {
                            var unspents, additionalUnspentValue;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this_1.unspents({
                                            minConfirms: 1,
                                            target: uncoveredChildFee,
                                            limit: maxUnspents - additionalUnspents.length
                                        })];
                                    case 1:
                                        unspents = _a.sent();
                                        if (unspents.length === 0) {
                                            return [2 /*return*/, "break"];
                                        }
                                        additionalUnspentValue = 0;
                                        // consume all unspents returned by the server, even if we don't need
                                        // all of them to cover the child fee. This is because the server will
                                        // return enough unspent value to ensure that the minimum change amount
                                        // is achieved for the child tx, and we can't leave out those unspents
                                        // or else the minimum change amount constraint could be violated
                                        _.forEach(unspents, function (unspent) {
                                            // update the child tx inputs
                                            var unspentChain = getChain(unspent);
                                            if (unspentChain === unspents_1.Codes.p2shP2wsh.external || unspentChain === unspents_1.Codes.p2shP2wsh.internal) {
                                                inputs.segwit++;
                                            }
                                            else {
                                                inputs.P2SH++;
                                            }
                                            additionalUnspents.push(unspent);
                                            additionalUnspentValue += unspent.value;
                                        });
                                        currentChildFeeEstimate = estimateChildFee({ inputs: inputs, parentFee: parentFee, parentVSize: parentVSize, feeRate: params.feeRate });
                                        uncoveredChildFee = currentChildFeeEstimate - parentOutputValue - additionalUnspentValue;
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _a.label = 1;
                    case 1:
                        if (!(uncoveredChildFee > 0 && additionalUnspents.length < maxUnspents)) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_1()];
                    case 2:
                        state_1 = _a.sent();
                        if (state_1 === "break")
                            return [3 /*break*/, 3];
                        return [3 /*break*/, 1];
                    case 3:
                        if (uncoveredChildFee > 0) {
                            // Unable to find enough unspents to cover the child fee
                            throw new Error("Insufficient confirmed unspents available to cover the child fee");
                        }
                        // found enough unspents
                        return [2 /*return*/, {
                                additional: additionalUnspents,
                                newChildFee: currentChildFeeEstimate,
                                newInputs: inputs
                            }];
                }
            });
        }).call(_this);
    };
    /**
     * Helper function to get a full copy (including witness data) of an arbitrary tx using only the tx id.
     *
     * We have to use an external service for this (currently smartbit.com.au), since
     * the v1 indexer service (based on bitcoinj) does not have segwit support and
     * does not return any segwit related fields in the tx hex.
     *
     * @param parentTxId The ID of the transaction to get the full hex of
     * @returns {Bluebird<any>} The full hex for the specified transaction
     */
    var getParentTxHex = function (_a) {
        var parentTxId = _a.parentTxId;
        return co(function coGetParentTxHex() {
            var smartBitApiUrl, txUrl, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        smartBitApiUrl = common.Environments[this.bitgo.getEnv()].smartBitApiBaseUrl + '/blockchain/tx/';
                        txUrl = smartBitApiUrl + parentTxId + '/hex';
                        return [4 /*yield*/, request.get(txUrl)];
                    case 1:
                        result = _a.sent();
                        if (!_.isBoolean(result.body.success) || !result.body.success) {
                            throw new Error('Did not successfully receive parent tx hex');
                        }
                        return [2 /*return*/, result.body.hex[0].hex];
                }
            });
        }).call(_this);
    };
    /**
     * Helper function to get the chain from an unspent or tx output.
     *
     * @param outputOrUnspent The output or unspent whose chain should be determined
     * @returns {number} The chain for the given output or unspent
     */
    var getChain = function (outputOrUnspent) {
        if (outputOrUnspent.chain !== undefined) {
            return outputOrUnspent.chain;
        }
        if (outputOrUnspent.chainPath !== undefined) {
            return _.toNumber(outputOrUnspent.chainPath.split('/')[1]);
        }
        // no way to tell the chain, let's just blow up now instead
        // of blowing up later when the undefined return value is used.
        // Note: for unspents the field to use is 'address', but for outputs
        // the field to use is 'account'
        throw Error("Could not get chain for output on account " + (outputOrUnspent.account || outputOrUnspent.address));
    };
    /**
     * Helper function to calculate the actual value contribution an output or unspent will
     * contribute to a transaction, were it to be used. Each type of output or unspent
     * will have a different value contribution since each type has a different number
     * of virtual bytes, and thus will cause a different fee to be paid.
     *
     * @param outputOrUnspent Output or unspent whose effective value should be determined
     * @returns {number} The actual number of satoshis that this unspent or output
     *                   would contribute to a transaction, were it to be used.
     */
    var effectiveValue = function (outputOrUnspent) {
        var chain = getChain(outputOrUnspent);
        if (chain === unspents_1.Codes.p2shP2wsh.external || chain === unspents_1.Codes.p2shP2wsh.internal) {
            // VirtualSizes.txP2shP2wshInputSize is in bytes, so we need to convert to kB
            return outputOrUnspent.value - (unspents_1.VirtualSizes.txP2shP2wshInputSize * params.feeRate / 1000);
        }
        // VirtualSizes.txP2shInputSize is in bytes, so we need to convert to kB
        return outputOrUnspent.value - (unspents_1.VirtualSizes.txP2shInputSize * params.feeRate / 1000);
    };
    /**
     * Coroutine which actually implements the accelerateTransaction algorithm
     *
     * Described at a high level, the algorithm is as follows:
     * 1) Find appropriate output from parent transaction to use as child transaction input
     * 2) Find unspent corresponding to parent transaction output. If not found, return to step 1.
     * 3) Determine if parent transaction unspent can cover entire child fee, plus minimum change
     * 4) If yes, go to step 6
     * 5) Otherwise, find additional unspents from the wallet to use to cover the remaining child fee
     * 6) Create and sign the child transaction, using the parent transaction output
     *    (and, if necessary, additional wallet unspents) as inputs
     * 7) Broadcast the new child transaction
     */
    return co(function coAccelerateTransaction() {
        var parentTx, walletOutputs, sortedOutputs, parentUnspentToUse, outputToUse, unspentsResult, parentTxHex, decodedParent, parentVSize, parentRate, isParentOutputSegwit, childInputs, childFee, unspentsToUse, minChangeSize, _a, additional, newChildFee, newInputs, maxFeeRate, childVSize, combinedVSize, combinedFee, combinedFeeRate, changeAmount, changeChain, changeAddress, tx, childFeeRate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, ['transactionID'], [], callback);
                    // validate fee rate
                    if (params.feeRate === undefined) {
                        throw new Error('Missing parameter: feeRate');
                    }
                    if (!_.isFinite(params.feeRate) || params.feeRate <= 0) {
                        throw new Error('Expecting positive finite number for parameter: feeRate');
                    }
                    // validate maxUnspents
                    if (params.maxAdditionalUnspents === undefined) {
                        // by default, use at most 100 additional unspents (not including the unspent output from the parent tx)
                        params.maxAdditionalUnspents = 100;
                    }
                    if (!_.isInteger(params.maxAdditionalUnspents) || params.maxAdditionalUnspents <= 0) {
                        throw Error('Expecting positive integer for parameter: maxAdditionalUnspents');
                    }
                    return [4 /*yield*/, this.getTransaction({ id: params.transactionID })];
                case 1:
                    parentTx = _b.sent();
                    if (parentTx.confirmations > 0) {
                        throw new Error("Transaction " + params.transactionID + " is already confirmed and cannot be accelerated");
                    }
                    walletOutputs = _.filter(parentTx.outputs, function (output) { return output.isMine; });
                    if (walletOutputs.length === 0) {
                        throw new Error("Transaction " + params.transactionID + " contains no outputs to this wallet, and thus cannot be accelerated");
                    }
                    sortedOutputs = _.sortBy(walletOutputs, effectiveValue);
                    _b.label = 2;
                case 2:
                    if (!(sortedOutputs.length > 0 && parentUnspentToUse === undefined)) return [3 /*break*/, 4];
                    outputToUse = sortedOutputs.pop();
                    return [4 /*yield*/, this.unspents({
                            minSize: outputToUse.value,
                            maxSize: outputToUse.value
                        })];
                case 3:
                    unspentsResult = _b.sent();
                    parentUnspentToUse = _.find(unspentsResult, function (unspent) {
                        // make sure unspent belongs to the given txid
                        if (unspent.tx_hash !== params.transactionID) {
                            return false;
                        }
                        // make sure unspent has correct v_out index
                        return unspent.tx_output_n === outputToUse.vout;
                    });
                    return [3 /*break*/, 2];
                case 4:
                    if (parentUnspentToUse === undefined) {
                        throw new Error("Could not find unspent output from parent tx to use as child input");
                    }
                    return [4 /*yield*/, getParentTxHex({ parentTxId: params.transactionID })];
                case 5:
                    parentTxHex = _b.sent();
                    decodedParent = bitcoin.Transaction.fromHex(parentTxHex);
                    parentVSize = decodedParent.virtualSize();
                    // make sure id from decoded tx and given tx id match
                    // this should catch problems emanating from the use of an external service
                    // for getting the complete parent tx hex
                    if (decodedParent.getId() !== params.transactionID) {
                        throw new Error("Decoded transaction id is " + decodedParent.getId() + ", which does not match given txid " + params.transactionID);
                    }
                    parentRate = 1000 * parentTx.fee / parentVSize;
                    if (params.feeRate <= parentRate) {
                        throw new Error("Cannot lower fee rate! (Parent tx fee rate is " + parentRate + " sat/kB, and requested fee rate was " + params.feeRate + " sat/kB)");
                    }
                    isParentOutputSegwit = outputToUse.chain === unspents_1.Codes.p2shP2wsh.external ||
                        outputToUse.chain === unspents_1.Codes.p2shP2wsh.internal;
                    childInputs = {
                        segwit: isParentOutputSegwit ? 1 : 0,
                        P2SH: isParentOutputSegwit ? 0 : 1
                    };
                    childFee = estimateChildFee({
                        inputs: childInputs,
                        parentFee: parentTx.fee,
                        feeRate: params.feeRate,
                        parentVSize: parentVSize
                    });
                    unspentsToUse = [parentUnspentToUse];
                    minChangeSize = this.bitgo.getConstants().minChangeSize || 1e7;
                    if (!(outputToUse.value < childFee + minChangeSize)) return [3 /*break*/, 7];
                    return [4 /*yield*/, findAdditionalUnspents({
                            inputs: childInputs,
                            parentOutputValue: outputToUse.value,
                            parentFee: parentTx.fee,
                            maxUnspents: params.maxAdditionalUnspents,
                            parentVSize: parentVSize
                        })];
                case 6:
                    _a = _b.sent(), additional = _a.additional, newChildFee = _a.newChildFee, newInputs = _a.newInputs;
                    childFee = newChildFee;
                    childInputs = newInputs;
                    unspentsToUse.push.apply(unspentsToUse, additional);
                    _b.label = 7;
                case 7:
                    maxFeeRate = this.bitgo.getConstants().maxFeeRate;
                    childVSize = estimateTxVSize(childInputs);
                    combinedVSize = childVSize + parentVSize;
                    combinedFee = parentTx.fee + childFee;
                    combinedFeeRate = 1000 * combinedFee / combinedVSize;
                    if (combinedFeeRate > maxFeeRate) {
                        throw new Error("Transaction cannot be accelerated. Combined fee rate of " + combinedFeeRate + " sat/kB exceeds maximum fee rate of " + maxFeeRate + " sat/kB");
                    }
                    changeAmount = _.sumBy(unspentsToUse, function (unspent) { return unspent.value; }) - childFee;
                    changeChain = this.getChangeChain({});
                    return [4 /*yield*/, this.createAddress({ chain: changeChain })];
                case 8:
                    changeAddress = _b.sent();
                    return [4 /*yield*/, this.createAndSignTransaction({
                            unspents: unspentsToUse,
                            recipients: [{
                                    address: changeAddress.address,
                                    amount: changeAmount
                                }],
                            fee: childFee,
                            bitgoFee: {
                                amount: 0,
                                address: ''
                            },
                            xprv: params.xprv,
                            walletPassphrase: params.walletPassphrase
                        })];
                case 9:
                    tx = _b.sent();
                    childFeeRate = 1000 * childFee / childVSize;
                    if (childFeeRate > maxFeeRate) {
                        // combined tx is within max fee rate limits, but the child tx is not.
                        // in this case, we need to use the ignoreMaxFeeRate flag to get the child tx to be accepted
                        tx.ignoreMaxFeeRate = true;
                    }
                    return [2 /*return*/, this.sendTransaction(tx)];
            }
        });
    }).call(this).asCallback(callback);
};
//
// createAndSignTransaction
// INTERNAL function to create and sign a transaction
//
// Parameters:
//   recipients - array of { address, amount } to send to
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.createAndSignTransaction = function (params, callback) {
    return co(function () {
        var transaction, fee, feeRate, estimatedSize, bitgoFee, travelInfos, unspents, keychain, e_1, safeUserKey, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, [], [], callback);
                    if (!_.isObject(params.recipients)) {
                        throw new Error('expecting recipients object');
                    }
                    if (params.fee && !_.isNumber(params.fee)) {
                        throw new Error('invalid argument for fee - number expected');
                    }
                    if (params.feeRate && !_.isNumber(params.feeRate)) {
                        throw new Error('invalid argument for feeRate - number expected');
                    }
                    if (params.dynamicFeeConfirmTarget && !_.isNumber(params.dynamicFeeConfirmTarget)) {
                        throw new Error('invalid argument for confirmTarget - number expected');
                    }
                    if (params.instant && !_.isBoolean(params.instant)) {
                        throw new Error('invalid argument for instant - boolean expected');
                    }
                    return [4 /*yield*/, this.createTransaction(params)];
                case 1:
                    transaction = _a.sent();
                    fee = transaction.fee;
                    feeRate = transaction.feeRate;
                    estimatedSize = transaction.estimatedSize;
                    bitgoFee = transaction.bitgoFee;
                    travelInfos = transaction.travelInfos;
                    unspents = transaction.unspents;
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 6]);
                    return [4 /*yield*/, this.getAndPrepareSigningKeychain(params)];
                case 3:
                    keychain = _a.sent();
                    transaction.keychain = keychain;
                    return [3 /*break*/, 6];
                case 4:
                    e_1 = _a.sent();
                    if (e_1.code !== 'no_encrypted_keychain_on_wallet') {
                        throw e_1;
                    }
                    // this might be a safe wallet, so let's retrieve the private key info
                    return [4 /*yield*/, this.refresh({ gpk: true })];
                case 5:
                    // this might be a safe wallet, so let's retrieve the private key info
                    _a.sent();
                    safeUserKey = _.get(this.wallet, 'private.userPrivKey');
                    if (_.isString(safeUserKey) && _.isString(params.walletPassphrase)) {
                        transaction.signingKey = this.bitgo.decrypt({ password: params.walletPassphrase, input: safeUserKey });
                    }
                    else {
                        throw e_1;
                    }
                    return [3 /*break*/, 6];
                case 6:
                    transaction.feeSingleKeyWIF = params.feeSingleKeyWIF;
                    return [4 /*yield*/, this.signTransaction(transaction)];
                case 7:
                    result = _a.sent();
                    return [2 /*return*/, _.extend(result, {
                            fee: fee,
                            feeRate: feeRate,
                            instant: params.instant,
                            bitgoFee: bitgoFee,
                            travelInfos: travelInfos,
                            estimatedSize: estimatedSize,
                            unspents: unspents
                        })];
            }
        });
    }).call(this).asCallback(callback);
};
//
// getAndPrepareSigningKeychain
// INTERNAL function to get the user keychain for signing.
// Caller must provider either a keychain, or walletPassphrase or xprv as a string
// If the caller provides the keychain with xprv, it is simply returned.
// If the caller provides the encrypted xprv (walletPassphrase), then fetch the keychain object and decrypt
// Otherwise if the xprv is provided, fetch the keychain object and augment it with the xprv.
//
// Parameters:
//   keychain - keychain with xprv
//   xprv - the private key in string form
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
// Returns:
//   Keychain object containing xprv, xpub and paths
//
Wallet.prototype.getAndPrepareSigningKeychain = function (params, callback) {
    params = params || {};
    // If keychain with xprv is already provided, use it
    if (_.isObject(params.keychain) && params.keychain.xprv) {
        return Bluebird.resolve(params.keychain);
    }
    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
    if ((params.walletPassphrase && params.xprv) || (!params.walletPassphrase && !params.xprv)) {
        throw new Error('must provide exactly one of xprv or walletPassphrase');
    }
    var self = this;
    // Caller provided a wallet passphrase
    if (params.walletPassphrase) {
        return self.getEncryptedUserKeychain()
            .then(function (keychain) {
            // Decrypt the user key with a passphrase
            try {
                keychain.xprv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedXprv });
            }
            catch (e) {
                throw new Error('Unable to decrypt user keychain');
            }
            return keychain;
        });
    }
    // Caller provided an xprv - validate and construct keychain object
    var xpub;
    try {
        xpub = bitcoin.HDNode.fromBase58(params.xprv).neutered().toBase58();
    }
    catch (e) {
        throw new Error('Unable to parse the xprv');
    }
    if (xpub === params.xprv) {
        throw new Error('xprv provided was not a private key (found xpub instead)');
    }
    var walletXpubs = _.map(self.keychains, 'xpub');
    if (!_.includes(walletXpubs, xpub)) {
        throw new Error('xprv provided was not a keychain on this wallet!');
    }
    // get the keychain object from bitgo to find the path and (potential) wallet structure
    return self.bitgo.keychains().get({ xpub: xpub })
        .then(function (keychain) {
        keychain.xprv = params.xprv;
        return keychain;
    });
};
/**
 * Takes a wallet's unspents and fans them out into a larger number of equally sized unspents
 * @param params
 *  target: set how many unspents you want to have in the end
 *  minConfirms: minimum number of confirms the unspents must have
 *  xprv: private key to sign transaction
 *  walletPassphrase: wallet passphrase to decrypt the wallet's private key
 * @param callback
 * @returns {*}
 */
Wallet.prototype.fanOutUnspents = function (params, callback) {
    var self = this;
    return Bluebird.coroutine(function () {
        var MAX_FANOUT_INPUT_COUNT, MAX_FANOUT_OUTPUT_COUNT, validate, target, minConfirms, splitNumberIntoCloseNaturalNumbers, allUnspents, grossAmount, txParams, newAddressPromises, newAddresses, splitAmounts, error_1, debugParams, baseFee, totalFee, netAmount, remainingSplitAmounts, fanoutTx, e_2, debugParams;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    MAX_FANOUT_INPUT_COUNT = 80;
                    MAX_FANOUT_OUTPUT_COUNT = 300;
                    params = params || {};
                    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
                    validate = params.validate === undefined ? true : params.validate;
                    target = params.target;
                    // the target must be defined, be a number, be at least two, and be a natural number
                    if (!_.isNumber(target) || target < 2 || (target % 1) !== 0) {
                        throw new Error('Target needs to be a positive integer');
                    }
                    if (target > MAX_FANOUT_OUTPUT_COUNT) {
                        throw new Error('Fan out target too high');
                    }
                    minConfirms = params.minConfirms;
                    if (minConfirms === undefined) {
                        minConfirms = 1;
                    }
                    if (!_.isNumber(minConfirms) || minConfirms < 0) {
                        throw new Error('minConfirms needs to be an integer >= 0');
                    }
                    splitNumberIntoCloseNaturalNumbers = function (total, partCount) {
                        var partSize = Math.floor(total / partCount);
                        var remainder = total - partSize * partCount;
                        // initialize placeholder array
                        var almostEqualParts = new Array(partCount);
                        // fill the first remainder parts with the value partSize+1
                        _.fill(almostEqualParts, partSize + 1, 0, remainder);
                        // fill the remaining parts with the value partSize
                        _.fill(almostEqualParts, partSize, remainder);
                        // assert the correctness of the almost equal parts
                        // TODO: add check for the biggest deviation between any two parts and make sure it's <= 1
                        if (_(almostEqualParts).sum() !== total || _(almostEqualParts).size() !== partCount) {
                            throw new Error('part sum or part count mismatch');
                        }
                        return almostEqualParts;
                    };
                    return [4 /*yield*/, self.unspents({ minConfirms: minConfirms })];
                case 1:
                    allUnspents = _a.sent();
                    if (allUnspents.length < 1) {
                        throw new Error('No unspents to branch out');
                    }
                    // this consolidation is essentially just a waste of money
                    if (allUnspents.length >= target) {
                        throw new Error('Fan out target has to be bigger than current number of unspents');
                    }
                    // we have at the very minimum 81 inputs, and 81 outputs. That transaction will be big
                    // in the medium run, this algorithm could be reworked to only work with a subset of the transactions
                    if (allUnspents.length > MAX_FANOUT_INPUT_COUNT) {
                        throw new Error('Too many unspents');
                    }
                    grossAmount = _(allUnspents).map('value').sum();
                    txParams = _.extend({}, params);
                    txParams.unspents = allUnspents;
                    txParams.recipients = {};
                    newAddressPromises = _.range(target)
                        .map(function () { return self.createAddress({ chain: self.getChangeChain(params), validate: validate }); });
                    return [4 /*yield*/, Bluebird.all(newAddressPromises)];
                case 2:
                    newAddresses = _a.sent();
                    splitAmounts = splitNumberIntoCloseNaturalNumbers(grossAmount, target);
                    // map the newly created addresses to the almost components amounts we just calculated
                    txParams.recipients = _.zipObject(_.map(newAddresses, 'address'), splitAmounts);
                    txParams.noSplitChange = true;
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 4:
                    _a.sent();
                    return [3 /*break*/, 6];
                case 5:
                    error_1 = _a.sent();
                    // as expected, the transaction creation did indeed fail due to insufficient fees
                    // the error suggests a fee value which we then use for the transaction
                    // however, let's make sure it wasn't something else
                    if (!error_1.fee && (!error_1.result || !error_1.result.fee)) {
                        debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                        error_1.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                        throw error_1;
                    }
                    baseFee = error_1.fee || error_1.result.fee;
                    totalFee = baseFee;
                    if (error_1.result.bitgoFee && error_1.result.bitgoFee.amount) {
                        totalFee += error_1.result.bitgoFee.amount;
                        txParams.bitgoFee = error_1.result.bitgoFee;
                    }
                    // Need to clear these out since only 1 may be set
                    delete txParams.fee;
                    txParams.originalFeeRate = txParams.feeRate;
                    delete txParams.feeRate;
                    delete txParams.feeTxConfirmTarget;
                    txParams.fee = baseFee;
                    netAmount = error_1.result.available - totalFee;
                    remainingSplitAmounts = splitNumberIntoCloseNaturalNumbers(netAmount, target);
                    // and the distribution again mapped to the new addresses
                    txParams.recipients = _.zipObject(_.map(newAddresses, 'address'), remainingSplitAmounts);
                    return [3 /*break*/, 6];
                case 6:
                    _a.trys.push([6, 8, , 9]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 7:
                    fanoutTx = _a.sent();
                    return [3 /*break*/, 9];
                case 8:
                    e_2 = _a.sent();
                    debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                    e_2.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                    throw e_2;
                case 9: return [2 /*return*/, Bluebird.resolve(fanoutTx).asCallback(callback)];
            }
        });
    })().asCallback(callback);
};
/**
 * Determine whether to fan out or coalesce a wallet's unspents
 * @param params
 * @param callback
 * @returns {Request|Promise.<T>|*}
 */
Wallet.prototype.regroupUnspents = function (params, callback) {
    params = params || {};
    var target = params.target;
    if (!_.isNumber(target) || target < 1 || (target % 1) !== 0) {
        // the target must be defined, be a number, be at least one, and be a natural number
        throw new Error('Target needs to be a positive integer');
    }
    var minConfirms = params.minConfirms;
    if (minConfirms === undefined) {
        minConfirms = 1;
    }
    if ((!_.isNumber(minConfirms) || minConfirms < 0)) {
        throw new Error('minConfirms needs to be an integer equal to or bigger than 0');
    }
    var self = this;
    return self.unspents({ minConfirms: minConfirms })
        .then(function (unspents) {
        if (unspents.length === target) {
            return unspents;
        }
        else if (unspents.length > target) {
            return self.consolidateUnspents(params, callback);
        }
        else if (unspents.length < target) {
            return self.fanOutUnspents(params, callback);
        }
    });
};
/**
 * Consolidate a wallet's unspents into fewer unspents
 * @param params
 *  target: set how many unspents you want to have in the end
 *  maxInputCountPerConsolidation: set how many maximum inputs are to be permitted per consolidation batch
 *  xprv: private key to sign transaction
 *  walletPassphrase: wallet passphrase to decrypt the wallet's private key
 *  maxIterationCount: maximum number of iterations to be performed until function stops
 *  progressCallback: method to be called with object outlining current progress details
 * @param callback
 * @returns {*}
 */
Wallet.prototype.consolidateUnspents = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
    var validate = params.validate === undefined ? true : params.validate;
    var target = params.target;
    if (target === undefined) {
        target = 1;
    }
    else if (!_.isNumber(target) || target < 1 || (target % 1) !== 0) {
        // the target must be defined, be a number, be at least one, and be a natural number
        throw new Error('Target needs to be a positive integer');
    }
    if (params.maxSize && !_.isNumber(params.maxSize)) {
        throw new Error('maxSize should be a number');
    }
    if (params.minSize && !_.isNumber(params.minSize)) {
        throw new Error('minSize should be a number');
    }
    // maximum number of inputs per transaction for consolidation
    var MAX_INPUT_COUNT = 200;
    var maxInputCount = params.maxInputCountPerConsolidation;
    if (maxInputCount === undefined) { // null or unidentified, because equality to zero returns true in if(! clause
        maxInputCount = MAX_INPUT_COUNT;
    }
    if (typeof (maxInputCount) !== 'number' || maxInputCount < 2 || (maxInputCount % 1) !== 0) {
        throw new Error('Maximum consolidation input count needs to be an integer equal to or bigger than 2');
    }
    else if (maxInputCount > MAX_INPUT_COUNT) {
        throw new Error('Maximum consolidation input count cannot be bigger than ' + MAX_INPUT_COUNT);
    }
    var maxIterationCount = params.maxIterationCount || -1;
    if (params.maxIterationCount && (!_.isNumber(maxIterationCount) || maxIterationCount < 1) || (maxIterationCount % 1) !== 0) {
        throw new Error('Maximum iteration count needs to be an integer equal to or bigger than 1');
    }
    var minConfirms = params.minConfirms;
    if (minConfirms === undefined) {
        minConfirms = 1;
    }
    if ((!_.isNumber(minConfirms) || minConfirms < 0)) {
        throw new Error('minConfirms needs to be an integer equal to or bigger than 0');
    }
    var minSize = params.minSize || 0;
    if (params.feeRate) {
        // fee rate is in satoshis per kB, input size in bytes
        var feeBasedMinSize = Math.ceil(unspents_1.VirtualSizes.txP2shInputSize * params.feeRate / 1000);
        if (params.minSize && minSize < feeBasedMinSize) {
            throw new Error('provided minSize too low due to too high fee rate');
        }
        minSize = Math.max(feeBasedMinSize, minSize);
        if (!params.minSize) {
            // fee rate-based min size needs no logging if it was set explicitly
            console.log('Only consolidating unspents larger than ' + minSize + ' satoshis to avoid wasting money on fees. To consolidate smaller unspents, use a lower fee rate.');
        }
    }
    var iterationCount = 0;
    var self = this;
    var consolidationIndex = 0;
    /**
     * Consolidate one batch of up to MAX_INPUT_COUNT unspents.
     * @returns {*}
     */
    var runNextConsolidation = co(function () {
        var consolidationTransactions, isFinalConsolidation, queryParams, allUnspents, allUnspentsCount, targetInputCount, inputCount, currentChunk, changeChain, newAddress, txParams, currentAddress, grossAmount, error_2, debugParams, baseFee, bitgoFee, totalFee, netAmount, sentTx, e_3, debugParams, _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    consolidationTransactions = [];
                    isFinalConsolidation = false;
                    iterationCount++;
                    queryParams = {
                        limit: target + maxInputCount,
                        minConfirms: minConfirms,
                        minSize: minSize
                    };
                    if (params.maxSize) {
                        queryParams.maxSize = params.maxSize;
                    }
                    return [4 /*yield*/, self.unspents(queryParams)];
                case 1:
                    allUnspents = _d.sent();
                    // this consolidation is essentially just a waste of money
                    if (allUnspents.length <= target) {
                        if (iterationCount <= 1) {
                            // this is the first iteration, so the method is incorrect
                            throw new Error('Fewer unspents than consolidation target. Use fanOutUnspents instead.');
                        }
                        else {
                            // it's a later iteration, so the target may have been surpassed (due to confirmations in the background)
                            throw new Error('Done');
                        }
                    }
                    allUnspentsCount = allUnspents.length;
                    targetInputCount = allUnspentsCount - target + 1;
                    targetInputCount = Math.min(targetInputCount, allUnspents.length);
                    inputCount = Math.min(targetInputCount, maxInputCount);
                    // if either the number of inputs left to coalesce equals the number we will coalesce in this iteration
                    // or if the number of iterations matches the maximum permitted number
                    isFinalConsolidation = (inputCount === targetInputCount || iterationCount === maxIterationCount);
                    currentChunk = allUnspents.splice(0, inputCount);
                    changeChain = self.getChangeChain(params);
                    return [4 /*yield*/, self.createAddress({ chain: changeChain, validate: validate })];
                case 2:
                    newAddress = _d.sent();
                    txParams = _.extend({}, params);
                    currentAddress = newAddress;
                    grossAmount = _(currentChunk).map('value').sum();
                    txParams.unspents = currentChunk;
                    txParams.recipients = {};
                    txParams.recipients[newAddress.address] = grossAmount;
                    txParams.noSplitChange = true;
                    if (txParams.unspents.length <= 1) {
                        throw new Error('Done');
                    }
                    _d.label = 3;
                case 3:
                    _d.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 4:
                    _d.sent();
                    return [3 /*break*/, 6];
                case 5:
                    error_2 = _d.sent();
                    // this error should occur due to insufficient funds
                    // however, let's make sure it wasn't something else
                    if (!error_2.fee && (!error_2.result || !error_2.result.fee)) {
                        debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                        error_2.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                        throw error_2;
                    }
                    baseFee = error_2.fee || error_2.result.fee;
                    bitgoFee = 0;
                    totalFee = baseFee;
                    if (error_2.result.bitgoFee && error_2.result.bitgoFee.amount) {
                        bitgoFee = error_2.result.bitgoFee.amount;
                        totalFee += bitgoFee;
                        txParams.bitgoFee = error_2.result.bitgoFee;
                    }
                    netAmount = Math.max(error_2.result.available - totalFee, self.bitgo.getConstants().minOutputSize);
                    // Need to clear these out since only 1 may be set
                    delete txParams.fee;
                    txParams.originalFeeRate = txParams.feeRate;
                    delete txParams.feeRate;
                    delete txParams.feeTxConfirmTarget;
                    // we set the fee explicitly
                    txParams.fee = error_2.result.available - netAmount - bitgoFee;
                    txParams.recipients[newAddress.address] = netAmount;
                    return [3 /*break*/, 6];
                case 6:
                    _d.trys.push([6, 8, , 9]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 7:
                    sentTx = _d.sent();
                    return [3 /*break*/, 9];
                case 8:
                    e_3 = _d.sent();
                    debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                    e_3.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                    throw e_3;
                case 9:
                    consolidationTransactions.push(sentTx);
                    if (_.isFunction(params.progressCallback)) {
                        params.progressCallback({
                            txid: sentTx.hash,
                            destination: currentAddress,
                            amount: grossAmount,
                            fee: sentTx.fee,
                            inputCount: inputCount,
                            index: consolidationIndex
                        });
                    }
                    consolidationIndex++;
                    if (!!isFinalConsolidation) return [3 /*break*/, 12];
                    // this last consolidation has not yet brought the unspents count down to the target unspent count
                    // therefore, we proceed by consolidating yet another batch
                    // before we do that, we wait 1 second so that the newly created unspent will be fetched in the next batch
                    return [4 /*yield*/, Bluebird.delay(1000)];
                case 10:
                    // this last consolidation has not yet brought the unspents count down to the target unspent count
                    // therefore, we proceed by consolidating yet another batch
                    // before we do that, we wait 1 second so that the newly created unspent will be fetched in the next batch
                    _d.sent();
                    _b = (_a = consolidationTransactions.push).apply;
                    _c = [consolidationTransactions];
                    return [4 /*yield*/, runNextConsolidation()];
                case 11:
                    _b.apply(_a, _c.concat([_d.sent()]));
                    _d.label = 12;
                case 12: 
                // this is the final consolidation transaction. We return all the ones we've had so far
                return [2 /*return*/, consolidationTransactions];
            }
        });
    });
    return runNextConsolidation(this, target)
        .catch(function (err) {
        if (err.message === 'Done') {
            return;
        }
        throw err;
    })
        .nodeify(callback);
};
Wallet.prototype.shareWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['email', 'permissions'], ['walletPassphrase', 'message'], callback);
    if (params.reshare !== undefined && !_.isBoolean(params.reshare)) {
        throw new Error('Expected reshare to be a boolean.');
    }
    if (params.skipKeychain !== undefined && !_.isBoolean(params.skipKeychain)) {
        throw new Error('Expected skipKeychain to be a boolean. ');
    }
    var needsKeychain = !params.skipKeychain && params.permissions.indexOf('spend') !== -1;
    if (params.disableEmail !== undefined && !_.isBoolean(params.disableEmail)) {
        throw new Error('Expected disableEmail to be a boolean.');
    }
    var self = this;
    var sharing;
    var sharedKeychain;
    return this.bitgo.getSharingKey({ email: params.email.toLowerCase() })
        .then(function (result) {
        sharing = result;
        if (needsKeychain) {
            return self.getEncryptedUserKeychain({})
                .then(function (keychain) {
                // Decrypt the user key with a passphrase
                if (keychain.encryptedXprv) {
                    if (!params.walletPassphrase) {
                        throw new Error('Missing walletPassphrase argument');
                    }
                    try {
                        keychain.xprv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedXprv });
                    }
                    catch (e) {
                        throw new Error('Unable to decrypt user keychain');
                    }
                    var eckey = bitcoin_1.makeRandomKey();
                    var secret = self.bitgo.getECDHSecret({ eckey: eckey, otherPubKeyHex: sharing.pubkey });
                    var newEncryptedXprv = self.bitgo.encrypt({ password: secret, input: keychain.xprv });
                    sharedKeychain = {
                        xpub: keychain.xpub,
                        encryptedXprv: newEncryptedXprv,
                        fromPubKey: eckey.getPublicKeyBuffer().toString('hex'),
                        toPubKey: sharing.pubkey,
                        path: sharing.path
                    };
                }
            });
        }
    })
        .then(function () {
        var options = {
            user: sharing.userId,
            permissions: params.permissions,
            reshare: params.reshare,
            message: params.message,
            disableEmail: params.disableEmail
        };
        if (sharedKeychain) {
            options.keychain = sharedKeychain;
        }
        else if (params.skipKeychain) {
            options.keychain = {};
        }
        return self.createShare(options);
    })
        .nodeify(callback);
};
Wallet.prototype.removeUser = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['user'], [], callback);
    return this.bitgo.del(this.url('/user/' + params.user))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.getPolicy = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/policy'))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.getPolicyStatus = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/policy/status'))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.setPolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id', 'type'], ['message'], callback);
    if (!_.isObject(params.condition)) {
        throw new Error('missing parameter: conditions object');
    }
    if (!_.isObject(params.action)) {
        throw new Error('missing parameter: action object');
    }
    return this.bitgo.put(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.removePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], ['message'], callback);
    return this.bitgo.del(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.listWebhooks = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/webhooks'))
        .send()
        .result()
        .nodeify(callback);
};
/**
 * Simulate wallet webhook, currently for webhooks of type transaction and pending approval
 * @param params
 * - webhookId (required): id of the webhook to be simulated
 * - txHash (optional but required for transaction webhooks) hash of the simulated transaction
 * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
 * @param callback
 * @returns {*}
 */
Wallet.prototype.simulateWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['webhookId'], ['txHash', 'pendingApprovalId'], callback);
    var hasTxHash = !!params.txHash;
    var hasPendingApprovalId = !!params.pendingApprovalId;
    if ((hasTxHash && hasPendingApprovalId) || (!hasTxHash && !hasPendingApprovalId)) {
        throw new Error('must supply either txHash or pendingApprovalId, but not both');
    }
    // depending on the coin type of the wallet, the txHash has to adhere to its respective format
    // but the server takes care of that
    // only take the txHash and pendingApprovalId properties
    var filteredParams = _.pick(params, ['txHash', 'pendingApprovalId']);
    var webhookId = params.webhookId;
    return this.bitgo.post(this.url('/webhooks/' + webhookId + '/simulate'))
        .send(filteredParams)
        .result()
        .nodeify(callback);
};
Wallet.prototype.addWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.bitgo.post(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.removeWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.bitgo.del(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.estimateFee = function (params, callback) {
    common.validateParams(params, [], [], callback);
    if (params.amount && params.recipients) {
        throw new Error('cannot specify both amount as well as recipients');
    }
    if (params.recipients && !_.isObject(params.recipients)) {
        throw new Error('recipients must be array of { address: abc, amount: 100000 } objects');
    }
    if (params.amount && !_.isNumber(params.amount)) {
        throw new Error('invalid amount argument, expecting number');
    }
    var recipients = params.recipients || [];
    if (params.amount) {
        // only the amount was passed in, so we need to make a false recipient to run createTransaction with
        recipients.push({
            address: common.Environments[this.bitgo.env].signingAddress,
            amount: params.amount
        });
    }
    var transactionParams = _.extend({}, params);
    transactionParams.amount = undefined;
    transactionParams.recipients = recipients;
    return this.createTransaction(transactionParams)
        .then(function (tx) {
        return {
            estimatedSize: tx.estimatedSize,
            fee: tx.fee,
            feeRate: tx.feeRate
        };
    });
};
// Not fully implemented / released on SDK. Testing for now.
Wallet.prototype.updatePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id', 'type'], [], callback);
    return this.bitgo.put(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.deletePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    return this.bitgo.del(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// getBitGoFee
// Get the required on-transaction BitGo fee
//
Wallet.prototype.getBitGoFee = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (!_.isNumber(params.amount)) {
        throw new Error('invalid amount argument');
    }
    if (params.instant && !_.isBoolean(params.instant)) {
        throw new Error('invalid instant argument');
    }
    return this.bitgo.get(this.url('/billing/fee'))
        .query(params)
        .result()
        .nodeify(callback);
};
module.exports = Wallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFSDtHQUNHO0FBQ0gsRUFBRTtBQUNGLGdCQUFnQjtBQUNoQix1Q0FBdUM7QUFDdkMsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFO0FBRUYsNENBQXNEO0FBRXRELElBQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDM0Qsd0NBQTBDO0FBQzFDLCtFQUErRTtBQUMvRSxJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUVyRCxpQ0FBbUM7QUFDbkMsbUNBQXFDO0FBQ3JDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFDOUIsMEJBQTRCO0FBQzVCLHFDQUE4RDtBQUM5RCxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFFdEMsRUFBRTtBQUNGLGNBQWM7QUFDZCxFQUFFO0FBQ0YsSUFBTSxNQUFNLEdBQUcsVUFBUyxLQUFLLEVBQUUsTUFBTTtJQUNuQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUVwQixJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7UUFDbEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQztLQUMzQztBQUNILENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHO0lBQ3hCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUNyQixDQUFDLENBQUM7QUFFRixFQUFFO0FBQ0YsS0FBSztBQUNMLDZCQUE2QjtB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QUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRWhELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQzlELE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztLQUNyRDtJQUNELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzVELE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztLQUNwRDtJQUNELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQzFFLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztLQUMzRDtJQUNELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQy9ELE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztLQUN0RDtJQUNELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ2xFLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztLQUM3RDtJQUNELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxT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UUFBUSxDQUFDLENBQUM7SUFFcEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQzlDLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDWixNQUFNLEVBQUU7U0FDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDO0FBRUYsRUFBRTtBQUNGLGNBQWM7QUFDZCw0Q0FBNEM7QUFDNUMsRUFBRTtBQUNGLE1BQU0sQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDdEQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNoRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0tBQzVDO0lBQ0QsSUFBSSxNQUFNLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDbEQsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0tBQzdDO0lBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQzlDLEtBQUssQ0FBQyxNQUFNLENBQUM7U0FDYixNQUFNLEVBQUU7U0FDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDO0FBRUYsaUJBQVMsTUFBTSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKi9cbi8vXG4vLyBXYWxsZXQgT2JqZWN0XG4vLyBCaXRHbyBhY2Nlc3NvciBmb3IgYSBzcGVjaWZpYyB3YWxsZXRcbi8vXG4vLyBDb3B5cmlnaHQgMjAxNCwgQml0R28sIEluYy4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuXG5pbXBvcnQgeyBDb2RlcywgVmlydHVhbFNpemVzIH0gZnJvbSAnQGJpdGdvL3Vuc3BlbnRzJztcblxuY29uc3QgVHJhbnNhY3Rpb25CdWlsZGVyID0gcmVxdWlyZSgnLi90cmFuc2FjdGlvbkJ1aWxkZXInKTtcbmltcG9ydCAqIGFzIGJpdGNvaW4gZnJvbSAnYml0Z28tdXR4by1saWInO1xuLy8gVE9ETzogc3dpdGNoIHRvIGJpdGNvaW5qcy1saWIgZXZlbnR1YWxseSBvbmNlIHdlIHVwZ3JhZGUgaXQgdG8gdmVyc2lvbiAzLngueFxuY29uc3QgUGVuZGluZ0FwcHJvdmFsID0gcmVxdWlyZSgnLi9wZW5kaW5nYXBwcm92YWwnKTtcblxuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4vY29tbW9uJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaGRQYXRoLCBtYWtlUmFuZG9tS2V5LCBnZXROZXR3b3JrIH0gZnJvbSAnLi9iaXRjb2luJztcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50Jyk7XG5cbi8vXG4vLyBDb25zdHJ1Y3RvclxuLy9cbmNvbnN0IFdhbGxldCA9IGZ1bmN0aW9uKGJpdGdvLCB3YWxsZXQpIHtcbiAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICB0aGlzLndhbGxldCA9IHdhbGxldDtcbiAgdGhpcy5rZXljaGFpbnMgPSBbXTtcblxuICBpZiAod2FsbGV0LnByaXZhdGUpIHtcbiAgICB0aGlzLmtleWNoYWlucyA9IHdhbGxldC5wcml2YXRlLmtleWNoYWlucztcbiAgfVxufTtcblxuV2FsbGV0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0O1xufTtcblxuLy9cbi8vIGlkXG4vLyBHZXQgdGhlIGlkIG9mIHRoaXMgd2FsbGV0LlxuLy9cbldhbGxldC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0LmlkO1xufTtcblxuLy9cbi8vIGxhYmVsXG4vLyBHZXQgdGhlIGxhYmVsIG9mIHRoaXMgd2FsbGV0LlxuLy9cbldhbGxldC5wcm90b3R5cGUubGFiZWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0LmxhYmVsO1xufTtcblxuLy9cbi8vIGJhbGFuY2Vcbi8vIEdldCB0aGUgYmFsYW5jZSBvZiB0aGlzIHdhbGxldC5cbi8vXG5XYWxsZXQucHJvdG90eXBlLmJhbGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0LmJhbGFuY2U7XG59O1xuXG4vL1xuLy8gYmFsYW5jZVxuLy8gR2V0IHRoZSBzcGVuZGFibGUgYmFsYW5jZSBvZiB0aGlzIHdhbGxldC5cbi8vIFRoaXMgaXMgdGhlIHRvdGFsIG9mIGFsbCB1bnNwZW50cyBleGNlcHQgdGhvc2UgdGhhdCBhcmUgdW5jb25maXJtZWQgYW5kIGV4dGVybmFsXG4vL1xuV2FsbGV0LnByb3RvdHlwZS5zcGVuZGFibGVCYWxhbmNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndhbGxldC5zcGVuZGFibGVCYWxhbmNlO1xufTtcblxuLy9cbi8vIGNvbmZpcm1lZEJhbGFuY2Vcbi8vIEdldCB0aGUgY29uZmlybWVkQmFsYW5jZSBvZiB0aGlzIHdhbGxldC5cbi8vXG5XYWxsZXQucHJvdG90eXBlLmNvbmZpcm1lZEJhbGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0LmNvbmZpcm1lZEJhbGFuY2U7XG59O1xuXG4vL1xuLy8gY2FuU2VuZEluc3RhbnRcbi8vIFJldHVybnMgaWYgdGhlIHdhbGxldCBjYW4gc2VuZCBpbnN0YW50IHRyYW5zYWN0aW9uc1xuLy8gVGhpcyBpcyBpbXBhY3RlZCBieSB0aGUgY2hvaWNlIG9mIGJhY2t1cCBrZXkgcHJvdmlkZXJcbi8vXG5XYWxsZXQucHJvdG90eXBlLmNhblNlbmRJbnN0YW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndhbGxldCAmJiB0aGlzLndhbGxldC5jYW5TZW5kSW5zdGFudDtcbn07XG5cbi8vXG4vLyBpbnN0YW50IGJhbGFuY2Vcbi8vIEdldCB0aGUgaW5zdGFudCBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0LlxuLy8gVGhpcyBpcyB0aGUgdG90YWwgb2YgYWxsIHVuc3BlbnRzIHRoYXQgbWF5IGJlIHNwZW50IGluc3RhbnRseS5cbi8vXG5XYWxsZXQucHJvdG90eXBlLmluc3RhbnRCYWxhbmNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW5TZW5kSW5zdGFudCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYW4gaW5zdGFudCB3YWxsZXQnKTtcbiAgfVxuICByZXR1cm4gdGhpcy53YWxsZXQuaW5zdGFudEJhbGFuY2U7XG59O1xuXG4vL1xuLy8gdW5jb25maXJtZWRTZW5kc1xuLy8gR2V0IHRoZSBiYWxhbmNlIG9mIHVuY29uZmlybWVkU2VuZHMgb2YgdGhpcyB3YWxsZXQuXG4vL1xuV2FsbGV0LnByb3RvdHlwZS51bmNvbmZpcm1lZFNlbmRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndhbGxldC51bmNvbmZpcm1lZFNlbmRzO1xufTtcblxuLy9cbi8vIHVuY29uZmlybWVkUmVjZWl2ZXNcbi8vIEdldCB0aGUgYmFsYW5jZSBvZiB1bmNvbmZpcm1lZFJlY2VpdmVzIGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXQuXG4vL1xuV2FsbGV0LnByb3RvdHlwZS51bmNvbmZpcm1lZFJlY2VpdmVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndhbGxldC51bmNvbmZpcm1lZFJlY2VpdmVzO1xufTtcblxuLy9cbi8vIHR5cGVcbi8vIEdldCB0aGUgdHlwZSBvZiB0aGlzIHdhbGxldCwgZS5nLiAnc2FmZWhkJ1xuLy9cbldhbGxldC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53YWxsZXQudHlwZTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24oZXh0cmEpIHtcbiAgZXh0cmEgPSBleHRyYSB8fCAnJztcbiAgcmV0dXJuIHRoaXMuYml0Z28udXJsKCcvd2FsbGV0LycgKyB0aGlzLmlkKCkgKyBleHRyYSk7XG59O1xuXG4vL1xuLy8gcGVuZGluZ0FwcHJvdmFsc1xuLy8gcmV0dXJucyB0aGUgcGVuZGluZyBhcHByb3ZhbHMgbGlzdCBmb3IgdGhpcyB3YWxsZXQgYXMgcGVuZGluZyBhcHByb3ZhbCBvYmplY3RzXG4vL1xuV2FsbGV0LnByb3RvdHlwZS5wZW5kaW5nQXBwcm92YWxzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy53YWxsZXQucGVuZGluZ0FwcHJvdmFscy5tYXAoZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBuZXcgUGVuZGluZ0FwcHJvdmFsKHNlbGYuYml0Z28sIHAsIHNlbGYpO1xuICB9KTtcbn07XG5cbi8vXG4vLyBhcHByb3ZhbHNSZXF1aXJlZFxuLy8gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGFwcHJvdmFscyByZXF1aXJlZCB0byBhcHByb3ZlIHBlbmRpbmcgYXBwcm92YWxzIGludm9sdmluZyB0aGlzIHdhbGxldFxuLy9cbldhbGxldC5wcm90b3R5cGUuYXBwcm92YWxzUmVxdWlyZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0LmFwcHJvdmFsc1JlcXVpcmVkIHx8IDE7XG59O1xuXG4vL1xuLy8gZ2V0XG4vLyBSZWZldGNoZXMgdGhpcyB3YWxsZXQgYW5kIHJldHVybnMgaXRcbi8vXG5XYWxsZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spOiBCbHVlYmlyZDxhbnk+IHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoKSlcbiAgLnJlc3VsdCgpXG4gIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIHNlbGYud2FsbGV0ID0gcmVzO1xuICAgIHJldHVybiBzZWxmO1xuICB9KVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gdXBkYXRlQXBwcm92YWxzUmVxdWlyZWRcbi8vIFVwZGF0ZXMgdGhlIG51bWJlciBvZiBhcHByb3ZhbHMgcmVxdWlyZWQgb24gYSBwZW5kaW5nIGFwcHJvdmFsIGludm9sdmluZyB0aGlzIHdhbGxldC5cbi8vIFRoZSBhcHByb3ZhbHMgcmVxdWlyZWQgaXMgYnkgZGVmYXVsdCAxLCBidXQgdGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHVwZGF0ZSB0aGVcbi8vIG51bWJlciBzdWNoIHRoYXQgMSA8PSBhcHByb3ZhbHNSZXF1aXJlZCA8PSB3YWxsZXRBZG1pbnMubGVuZ3RoIC0gMVxuLy9cbldhbGxldC5wcm90b3R5cGUudXBkYXRlQXBwcm92YWxzUmVxdWlyZWQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKTogQmx1ZWJpcmQ8YW55PiB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG4gIGlmIChwYXJhbXMuYXBwcm92YWxzUmVxdWlyZWQgPT09IHVuZGVmaW5lZCB8fFxuICAhXy5pc0ludGVnZXIocGFyYW1zLmFwcHJvdmFsc1JlcXVpcmVkKSB8fFxuICBwYXJhbXMuYXBwcm92YWxzUmVxdWlyZWQgPCAxXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcHByb3ZhbHNSZXF1aXJlZDogbXVzdCBiZSBhIG5vbnplcm8gcG9zaXRpdmUgbnVtYmVyJyk7XG4gIH1cblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3QgY3VycmVudEFwcHJvdmFsc1JlcXVpcmVkID0gdGhpcy5hcHByb3ZhbHNSZXF1aXJlZCgpO1xuICBpZiAoY3VycmVudEFwcHJvdmFsc1JlcXVpcmVkID09PSBwYXJhbXMuYXBwcm92YWxzUmVxdWlyZWQpIHtcbiAgICAvLyBuby1vcCwganVzdCByZXR1cm4gdGhlIGN1cnJlbnQgd2FsbGV0XG4gICAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxmLndhbGxldDtcbiAgICB9KVxuICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmJpdGdvLnB1dCh0aGlzLnVybCgpKVxuICAuc2VuZChwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvcnJlY3QgY2hhaW4gZm9yIGNoYW5nZSwgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiBzZWd3aXRcbiAqL1xuV2FsbGV0LnByb3RvdHlwZS5nZXRDaGFuZ2VDaGFpbiA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBsZXQgdXNlU2Vnd2l0Q2hhbmdlID0gISF0aGlzLmJpdGdvLmdldENvbnN0YW50cygpLmVuYWJsZVNlZ3dpdDtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5zZWd3aXRDaGFuZ2UpKSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuc2Vnd2l0Q2hhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWd3aXRDaGFuZ2UgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICB9XG5cbiAgICAvLyBpZiBzZWd3aXQgaXMgZGlzYWJsZWQgdGhyb3VnaCB0aGUgY29uc3RhbnRzLCBzZWd3aXQgY2hhbmdlIHNob3VsZCBzdGlsbCBub3QgYmUgY3JlYXRlZFxuICAgIHVzZVNlZ3dpdENoYW5nZSA9IHRoaXMuYml0Z28uZ2V0Q29uc3RhbnRzKCkuZW5hYmxlU2Vnd2l0ICYmIHBhcmFtcy5zZWd3aXRDaGFuZ2U7XG4gIH1cbiAgcmV0dXJuIHVzZVNlZ3dpdENoYW5nZSA/IENvZGVzLmludGVybmFsLnAyc2hQMndzaCA6IENvZGVzLmludGVybmFsLnAyc2g7XG59O1xuXG4vL1xuLy8gY3JlYXRlQWRkcmVzc1xuLy8gQ3JlYXRlcyBhIG5ldyBhZGRyZXNzIGZvciB1c2Ugd2l0aCB0aGlzIHdhbGxldC5cbi8vXG5XYWxsZXQucHJvdG90eXBlLmNyZWF0ZUFkZHJlc3MgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuICBpZiAodGhpcy50eXBlKCkgPT09ICdzYWZlJykge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSB1c2luZyBhIGxlZ2FjeSB3YWxsZXQgdGhhdCBjYW5ub3QgY3JlYXRlIGEgbmV3IGFkZHJlc3MnKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgdG8gY2xpZW50LXNpZGUgYWRkcmVzcyB2YWxpZGF0aW9uIG9uLCBmb3Igc2FmZXR5LiBVc2UgdmFsaWRhdGU9ZmFsc2UgdG8gZGlzYWJsZS5cbiAgY29uc3Qgc2hvdWxkVmFsaWRhdGUgPSBwYXJhbXMudmFsaWRhdGUgIT09IHVuZGVmaW5lZCA/IHBhcmFtcy52YWxpZGF0ZSA6IHRoaXMuYml0Z28uZ2V0VmFsaWRhdGUoKTtcblxuICBjb25zdCBhbGxvd0V4aXN0aW5nID0gcGFyYW1zLmFsbG93RXhpc3Rpbmc7XG4gIGlmICh0eXBlb2YgYWxsb3dFeGlzdGluZyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcGFyYW1zLmFsbG93RXhpc3RpbmcgPSAoYWxsb3dFeGlzdGluZyA9PT0gJ3RydWUnKTtcbiAgfVxuXG4gIGNvbnN0IGlzU2Vnd2l0ID0gdGhpcy5iaXRnby5nZXRDb25zdGFudHMoKS5lbmFibGVTZWd3aXQ7XG4gIGNvbnN0IGRlZmF1bHRDaGFpbiA9IGlzU2Vnd2l0ID8gQ29kZXMuZXh0ZXJuYWwucDJzaFAyd3NoIDogQ29kZXMuZXh0ZXJuYWwucDJzaDtcblxuICBsZXQgY2hhaW4gPSBwYXJhbXMuY2hhaW47XG4gIGlmIChjaGFpbiA9PT0gbnVsbCB8fCBjaGFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2hhaW4gPSBkZWZhdWx0Q2hhaW47XG4gIH1cbiAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL2FkZHJlc3MvJyArIGNoYWluKSlcbiAgLnNlbmQocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLnRoZW4oZnVuY3Rpb24oYWRkcikge1xuICAgIGlmIChzaG91bGRWYWxpZGF0ZSkge1xuICAgICAgc2VsZi52YWxpZGF0ZUFkZHJlc3MoYWRkcik7XG4gICAgfVxuICAgIHJldHVybiBhZGRyO1xuICB9KVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGFkZHJlc3MgbG9jYWxseSB3aXRob3V0IGNhbGxpbmcgc2VydmVyXG4gKiBAcGFyYW0gcGFyYW1zXG4gKlxuICovXG5XYWxsZXQucHJvdG90eXBlLmdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uKHsgc2Vnd2l0LCBwYXRoLCBrZXljaGFpbnMsIHRocmVzaG9sZCB9KSB7XG4gIGNvbnN0IGlzU2Vnd2l0ID0gISFzZWd3aXQ7XG4gIGxldCBzaWduYXR1cmVUaHJlc2hvbGQgPSAyO1xuICBpZiAoXy5pc0ludGVnZXIodGhyZXNob2xkKSkge1xuICAgIHNpZ25hdHVyZVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICBpZiAoc2lnbmF0dXJlVGhyZXNob2xkIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhyZXNob2xkIGhhcyB0byBiZSBwb3NpdGl2ZScpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBhdGhSZWdleCA9IC9eXFwvMT9bMDFdXFwvXFxkKyQvO1xuICBpZiAoIXBhdGgubWF0Y2gocGF0aFJlZ2V4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgcGF0aDogJyArIHBhdGgpO1xuICB9XG5cbiAgbGV0IHJvb3RLZXlzID0gdGhpcy5rZXljaGFpbnM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleWNoYWlucykpIHtcbiAgICByb290S2V5cyA9IGtleWNoYWlucztcbiAgfVxuXG4gIGNvbnN0IG5ldHdvcmsgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLm5ldHdvcms7XG5cbiAgY29uc3QgZGVyaXZlZEtleXMgPSByb290S2V5cy5tYXAoZnVuY3Rpb24oaykge1xuICAgIGNvbnN0IGhkbm9kZSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgoay54cHViKTtcbiAgICBsZXQgZGVyaXZhdGlvblBhdGggPSBrLnBhdGggKyBwYXRoO1xuICAgIGlmIChrLndhbGxldFN1YlBhdGgpIHtcbiAgICAgIC8vIGlmIGEga2V5Y2hhaW4gaGFzIGEgd2FsbGV0IHN1YnBhdGgsIGl0IHNob3VsZCBiZSB1c2VkIGFzIGFuIGluZml4XG4gICAgICBkZXJpdmF0aW9uUGF0aCA9IGsucGF0aCArIGsud2FsbGV0U3ViUGF0aCArIHBhdGg7XG4gICAgfVxuICAgIGlmICghZGVyaXZhdGlvblBhdGguc3RhcnRzV2l0aCgnbScpKSB7XG4gICAgICAvLyBhbGwgZGVyaXZhdGlvbiBwYXRocyBuZWVkIHRvIHN0YXJ0IHdpdGggbSwgYnV0IGsucGF0aCBtYXkgYWxyZWFkeSBjb250YWluIHRoYXRcbiAgICAgIGRlcml2YXRpb25QYXRoID0gYG0vJHtkZXJpdmF0aW9uUGF0aH1gO1xuICAgIH1cbiAgICByZXR1cm4gaGRQYXRoKGhkbm9kZSkuZGVyaXZlS2V5KGRlcml2YXRpb25QYXRoKS5nZXRQdWJsaWNLZXlCdWZmZXIoKTtcbiAgfSk7XG5cbiAgY29uc3QgcGF0aENvbXBvbmVudHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoQ29tcG9uZW50cyA9IF8ubWFwKHBhdGhDb21wb25lbnRzLCAoY29tcG9uZW50KSA9PiB7XG4gICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbXBvbmVudCwgMTApO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHBhdGhEZXRhaWxzID0gXy5maWx0ZXIobm9ybWFsaXplZFBhdGhDb21wb25lbnRzLCBfLmlzSW50ZWdlcik7XG5cbiAgY29uc3QgYWRkcmVzc0RldGFpbHM6IGFueSA9IHtcbiAgICBjaGFpblBhdGg6IHBhdGgsXG4gICAgcGF0aDogcGF0aCxcbiAgICBjaGFpbjogcGF0aERldGFpbHNbMF0sXG4gICAgaW5kZXg6IHBhdGhEZXRhaWxzWzFdLFxuICAgIHdhbGxldDogdGhpcy5pZCgpXG4gIH07XG5cbiAgLy8gcmVkZWVtIHNjcmlwdCBub3JtYWxseSwgd2l0bmVzcyBzY3JpcHQgZm9yIHNlZ3dpdFxuICBjb25zdCBpbnB1dFNjcmlwdCA9IGJpdGNvaW4uc2NyaXB0Lm11bHRpc2lnLm91dHB1dC5lbmNvZGUoc2lnbmF0dXJlVGhyZXNob2xkLCBkZXJpdmVkS2V5cyk7XG4gIGNvbnN0IGlucHV0U2NyaXB0SGFzaCA9IGJpdGNvaW4uY3J5cHRvLmhhc2gxNjAoaW5wdXRTY3JpcHQpO1xuICBsZXQgb3V0cHV0U2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuc2NyaXB0SGFzaC5vdXRwdXQuZW5jb2RlKGlucHV0U2NyaXB0SGFzaCk7XG4gIGFkZHJlc3NEZXRhaWxzLnJlZGVlbVNjcmlwdCA9IGlucHV0U2NyaXB0LnRvU3RyaW5nKCdoZXgnKTtcblxuICBpZiAoaXNTZWd3aXQpIHtcbiAgICBjb25zdCB3aXRuZXNzU2NyaXB0SGFzaCA9IGJpdGNvaW4uY3J5cHRvLnNoYTI1NihpbnB1dFNjcmlwdCk7XG4gICAgY29uc3QgcmVkZWVtU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQud2l0bmVzc1NjcmlwdEhhc2gub3V0cHV0LmVuY29kZSh3aXRuZXNzU2NyaXB0SGFzaCk7XG4gICAgY29uc3QgcmVkZWVtU2NyaXB0SGFzaCA9IGJpdGNvaW4uY3J5cHRvLmhhc2gxNjAocmVkZWVtU2NyaXB0KTtcbiAgICBvdXRwdXRTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5zY3JpcHRIYXNoLm91dHB1dC5lbmNvZGUocmVkZWVtU2NyaXB0SGFzaCk7XG4gICAgYWRkcmVzc0RldGFpbHMud2l0bmVzc1NjcmlwdCA9IGlucHV0U2NyaXB0LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBhZGRyZXNzRGV0YWlscy5yZWRlZW1TY3JpcHQgPSByZWRlZW1TY3JpcHQudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgYWRkcmVzc0RldGFpbHMub3V0cHV0U2NyaXB0ID0gb3V0cHV0U2NyaXB0LnRvU3RyaW5nKCdoZXgnKTtcbiAgYWRkcmVzc0RldGFpbHMuYWRkcmVzcyA9IGJpdGNvaW4uYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KG91dHB1dFNjcmlwdCwgZ2V0TmV0d29yayhuZXR3b3JrKSk7XG5cbiAgcmV0dXJuIGFkZHJlc3NEZXRhaWxzO1xufTtcblxuLy9cbi8vIHZhbGlkYXRlQWRkcmVzc1xuLy8gVmFsaWRhdGVzIGFuIGFkZHJlc3MgYW5kIHBhdGggYnkgY2FsY3VsYXRpbmcgaXQgbG9jYWxseSBmcm9tIHRoZSBrZXljaGFpbiB4cHVic1xuLy9cbldhbGxldC5wcm90b3R5cGUudmFsaWRhdGVBZGRyZXNzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcycsICdwYXRoJ10sIFtdKTtcbiAgY29uc3QgaXNTZWd3aXQgPSAhIXBhcmFtcy53aXRuZXNzU2NyaXB0ICYmIHBhcmFtcy53aXRuZXNzU2NyaXB0Lmxlbmd0aCA+IDA7XG5cbiAgY29uc3QgZ2VuZXJhdGVkQWRkcmVzcyA9IHRoaXMuZ2VuZXJhdGVBZGRyZXNzKHsgcGF0aDogcGFyYW1zLnBhdGgsIHNlZ3dpdDogaXNTZWd3aXQgfSk7XG4gIGlmIChnZW5lcmF0ZWRBZGRyZXNzLmFkZHJlc3MgIT09IHBhcmFtcy5hZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogJyArIHBhcmFtcy5hZGRyZXNzICsgJyB2cy4gJyArIGdlbmVyYXRlZEFkZHJlc3MuYWRkcmVzcyk7XG4gIH1cbn07XG5cbi8vXG4vLyBhZGRyZXNzZXNcbi8vIEdldHMgdGhlIGFkZHJlc3NlcyBvZiBhIEhEIHdhbGxldC5cbi8vIE9wdGlvbnMgaW5jbHVkZTpcbi8vICBsaW1pdDogdGhlIG51bWJlciBvZiBhZGRyZXNzZXMgdG8gZ2V0XG4vL1xuV2FsbGV0LnByb3RvdHlwZS5hZGRyZXNzZXMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgY29uc3QgcXVlcnk6IGFueSA9IHt9O1xuICBpZiAocGFyYW1zLmRldGFpbHMpIHtcbiAgICBxdWVyeS5kZXRhaWxzID0gMTtcbiAgfVxuXG4gIGNvbnN0IGNoYWluID0gcGFyYW1zLmNoYWluO1xuICBpZiAoY2hhaW4gIT09IG51bGwgJiYgY2hhaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoYWluKSkge1xuICAgICAgcXVlcnkuY2hhaW4gPSBfLnVuaXEoXy5maWx0ZXIoY2hhaW4sIF8uaXNJbnRlZ2VyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFpbiAhPT0gMCAmJiBjaGFpbiAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2hhaW4gYXJndW1lbnQsIGV4cGVjdGluZyAwIG9yIDEnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmNoYWluID0gY2hhaW47XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH1cbiAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgfVxuICBpZiAocGFyYW1zLnNraXApIHtcbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5za2lwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNraXAgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICB9XG4gICAgcXVlcnkuc2tpcCA9IHBhcmFtcy5za2lwO1xuICB9XG4gIGlmIChwYXJhbXMuc29ydCkge1xuICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuc29ydCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzb3J0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgfVxuICAgIHF1ZXJ5LnNvcnQgPSBwYXJhbXMuc29ydDtcbiAgfVxuXG4gIGNvbnN0IHVybCA9IHRoaXMudXJsKCcvYWRkcmVzc2VzJyk7XG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh1cmwpXG4gIC5xdWVyeShxdWVyeSlcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuc3RhdHMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG4gIGNvbnN0IGFyZ3M6IHN0cmluZ1tdID0gW107XG4gIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH1cbiAgICBhcmdzLnB1c2goJ2xpbWl0PScgKyBwYXJhbXMubGltaXQpO1xuICB9XG4gIGxldCBxdWVyeSA9ICcnO1xuICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIGFyZ3Muam9pbignJicpO1xuICB9XG5cbiAgY29uc3QgdXJsID0gdGhpcy51cmwoJy9zdGF0cycgKyBxdWVyeSk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHVybClcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgd2FsbGV0IG9iamVjdCBieSBzeW5jaW5nIHdpdGggdGhlIGJhY2stZW5kXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtXYWxsZXR9XG4gKi9cbldhbGxldC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgLy8gd2hlbiBzZXQgdG8gdHJ1ZSwgZ3BrIHJldHVybnMgdGhlIHByaXZhdGUgZGF0YSBvZiBzYWZlIHdhbGxldHNcbiAgICBjb25zdCBxdWVyeSA9IF8uZXh0ZW5kKHt9LCBfLnBpY2socGFyYW1zLCBbJ2dwayddKSk7XG4gICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5iaXRnby5nZXQodGhpcy51cmwoKSkucXVlcnkocXVlcnkpLnJlc3VsdCgpO1xuICAgIHRoaXMud2FsbGV0ID0gcmVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGFkZHJlc3Ncbi8vIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgYWRkcmVzcyBvbiBhIEhEIHdhbGxldC5cbi8vIEluZm9ybWF0aW9uIGluY2x1ZGVzIGluZGV4LCBwYXRoLCByZWRlZW1TY3JpcHQsIHNlbnQsIHJlY2VpdmVkLCB0eENvdW50IGFuZCBiYWxhbmNlXG4vLyBPcHRpb25zIGluY2x1ZGU6XG4vLyAgYWRkcmVzczogdGhlIGFkZHJlc3Mgb24gdGhpcyB3YWxsZXQgdG8gZ2V0XG4vL1xuV2FsbGV0LnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcyddLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHVybCA9IHRoaXMudXJsKCcvYWRkcmVzc2VzLycgKyBwYXJhbXMuYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHVybClcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRnJlZXplIHRoZSB3YWxsZXQgZm9yIGEgZHVyYXRpb24gb2YgY2hvaWNlLCBzdG9wcGluZyBCaXRHbyBmcm9tIHNpZ25pbmcgYW55IHRyYW5zYWN0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgZHVyYXRpb24gdG8gZnJlZXplIHRoZSB3YWxsZXQgZm9yIGluIHNlY29uZHMsIGRlZmF1bHRzIHRvIDM2MDAuXG4gKi9cbldhbGxldC5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGlmIChwYXJhbXMuZHVyYXRpb24pIHtcbiAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmR1cmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGR1cmF0aW9uIC0gc2hvdWxkIGJlIG51bWJlciBvZiBzZWNvbmRzJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL2ZyZWV6ZScpKVxuICAuc2VuZChwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gZGVsZXRlXG4vLyBEZWxldGVzIHRoZSB3YWxsZXRcbi8vXG5XYWxsZXQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy51cmwoKSlcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBsYWJlbHNcbi8vIExpc3QgdGhlIGxhYmVscyBmb3IgdGhlIGFkZHJlc3NlcyBpbiBhIGdpdmVuIHdhbGxldFxuLy9cbldhbGxldC5wcm90b3R5cGUubGFiZWxzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHVybCA9IHRoaXMuYml0Z28udXJsKCcvbGFiZWxzLycgKyB0aGlzLmlkKCkpO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh1cmwpXG4gIC5yZXN1bHQoJ2xhYmVscycpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVuYW1lIGEgd2FsbGV0XG4gKiBAcGFyYW0gcGFyYW1zXG4gKiAgLSBsYWJlbDogdGhlIHdhbGxldCdzIGludGVuZGVkIG5ldyBuYW1lXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHsqfVxuICovXG5XYWxsZXQucHJvdG90eXBlLnNldFdhbGxldE5hbWUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydsYWJlbCddLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHVybCA9IHRoaXMuYml0Z28udXJsKCcvd2FsbGV0LycgKyB0aGlzLmlkKCkpO1xuICByZXR1cm4gdGhpcy5iaXRnby5wdXQodXJsKVxuICAuc2VuZCh7IGxhYmVsOiBwYXJhbXMubGFiZWwgfSlcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBzZXRMYWJlbFxuLy8gU2V0cyBhIGxhYmVsIG9uIHRoZSBwcm92aWRlZCBhZGRyZXNzXG4vL1xuV2FsbGV0LnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnLCAnbGFiZWwnXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuYml0Z28udmVyaWZ5QWRkcmVzcyh7IGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzIH0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJpdGNvaW4gYWRkcmVzczogJyArIHBhcmFtcy5hZGRyZXNzKTtcbiAgfVxuXG4gIGNvbnN0IHVybCA9IHRoaXMuYml0Z28udXJsKCcvbGFiZWxzLycgKyB0aGlzLmlkKCkgKyAnLycgKyBwYXJhbXMuYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28ucHV0KHVybClcbiAgLnNlbmQoeyBsYWJlbDogcGFyYW1zLmxhYmVsIH0pXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gZGVsZXRlTGFiZWxcbi8vIERlbGV0ZXMgdGhlIGxhYmVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgYWRkcmVzc1xuLy9cbldhbGxldC5wcm90b3R5cGUuZGVsZXRlTGFiZWwgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFzZWxmLmJpdGdvLnZlcmlmeUFkZHJlc3MoeyBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyB9KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiaXRjb2luIGFkZHJlc3M6ICcgKyBwYXJhbXMuYWRkcmVzcyk7XG4gIH1cblxuICBjb25zdCB1cmwgPSB0aGlzLmJpdGdvLnVybCgnL2xhYmVscy8nICsgdGhpcy5pZCgpICsgJy8nICsgcGFyYW1zLmFkZHJlc3MpO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmRlbCh1cmwpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gdW5zcGVudHNcbi8vIExpc3QgQUxMIHRoZSB1bnNwZW50cyBmb3IgYSBnaXZlbiB3YWxsZXRcbi8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGEgcGFnZWQgbGlzdCBvZiBhbGwgdW5zcGVudHNcbi8vXG4vLyBQYXJhbWV0ZXJzIGluY2x1ZGU6XG4vLyAgIGxpbWl0OiAgdGhlIG9wdGlvbmFsIGxpbWl0IG9mIHVuc3BlbnRzIHRvIGNvbGxlY3QgaW4gQlRDXG4vLyAgIG1pbkNvbmY6IG9ubHkgaW5jbHVkZSByZXN1bHRzIHdpdGggdGhpcyBudW1iZXIgb2YgY29uZmlybWF0aW9uc1xuLy8gICB0YXJnZXQ6IHRoZSBhbW91bnQgb2YgYnRjIHRvIGZpbmQgdG8gc3BlbmRcbi8vICAgaW5zdGFudDogb25seSBmaW5kIGluc3RhbnQgdHJhbnNhY3Rpb25zIChtdXN0IHNwZWNpZnkgYSB0YXJnZXQpXG4vL1xuV2FsbGV0LnByb3RvdHlwZS51bnNwZW50cyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCBhbGxVbnNwZW50czogYW55W10gPSBbXTtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgY29uc3QgZ2V0VW5zcGVudHNCYXRjaCA9IGZ1bmN0aW9uKHNraXAsIGxpbWl0Pykge1xuXG4gICAgY29uc3QgcXVlcnlPYmplY3QgPSBfLmNsb25lRGVlcChwYXJhbXMpO1xuICAgIGlmIChza2lwID4gMCkge1xuICAgICAgcXVlcnlPYmplY3Quc2tpcCA9IHNraXA7XG4gICAgfVxuICAgIGlmIChsaW1pdCAmJiBsaW1pdCA+IDApIHtcbiAgICAgIHF1ZXJ5T2JqZWN0LmxpbWl0ID0gbGltaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYudW5zcGVudHNQYWdlZChxdWVyeU9iamVjdClcbiAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIC8vIFRoZSBBUEkgaGFzIGl0cyBvd24gbGltaXQgaGFuZGxpbmcuIEZvciBleGFtcGxlLCB0aGUgQVBJIGRvZXMgbm90IHN1cHBvcnQgbGltaXRzIGJpZ2dlciB0aGFuIDUwMC4gSWYgdGhlIGxpbWl0XG4gICAgICAvLyBzcGVjaWZpZWQgaGVyZSBpcyBiaWdnZXIgdGhhbiB0aGF0LCB3ZSB3aWxsIGhhdmUgdG8gZG8gbXVsdGlwbGUgcmVxdWVzdHMgd2l0aCBuZWNlc3NhcnkgbGltaXQgYWRqdXN0bWVudC5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0LnVuc3BlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHVuc3BlbnQgPSByZXN1bHQudW5zcGVudHNbaV07XG4gICAgICAgIGFsbFVuc3BlbnRzLnB1c2godW5zcGVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE91ciBsaW1pdCBhZGp1c3RtZW50IG1ha2VzIHN1cmUgdGhhdCB3ZSBuZXZlciBmZXRjaCBtb3JlIHVuc3BlbnRzIHRoYW4gd2UgbmVlZCwgbWVhbmluZyB0aGF0IGlmIHdlIGhpdCB0aGVcbiAgICAgIC8vIGxpbWl0LCB3ZSBoaXQgaXQgcHJlY2lzZWx5XG4gICAgICBpZiAoYWxsVW5zcGVudHMubGVuZ3RoID49IHBhcmFtcy5saW1pdCkge1xuICAgICAgICByZXR1cm4gYWxsVW5zcGVudHM7IC8vIHdlIGFyZW4ndCBpbnRlcmVzdGVkIGluIGFueSBmdXJ0aGVyIHVuc3BlbnRzXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdGFsVW5zcGVudENvdW50ID0gcmVzdWx0LnRvdGFsO1xuICAgICAgLy8gaWYgbm8gdGFyZ2V0IGlzIHNwZWNpZmllZCBhbmQgdGhlIFNESyBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBoYXMgYmVlbiBhIGxpbWl0LCB3ZSBuZWVkIHRvIGZldGNoIGFub3RoZXIgYmF0Y2hcbiAgICAgIGlmICghcGFyYW1zLnRhcmdldCAmJiB0b3RhbFVuc3BlbnRDb3VudCAmJiB0b3RhbFVuc3BlbnRDb3VudCA+IGFsbFVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZldGNoIHRoZSBuZXh0IGJhdGNoXG4gICAgICAgIC8vIGxldCdzIGp1c3Qgb2Zmc2V0IHRoZSBjdXJyZW50IHNraXAgYnkgdGhlIGNvdW50XG4gICAgICAgIGNvbnN0IG5ld1NraXAgPSBza2lwICsgcmVzdWx0LmNvdW50O1xuICAgICAgICBsZXQgbmV3TGltaXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGxpbWl0ID4gMCkge1xuICAgICAgICAgIC8vIHdlIHNldCB0aGUgbmV3IGxpbWl0IHRvIGJlIHByZWNpc2VseSB0aGUgbnVtYmVyIG9mIG1pc3NpbmcgdW5zcGVudHMgdG8gaGl0IG91ciBvd24gbGltaXRcbiAgICAgICAgICBuZXdMaW1pdCA9IGxpbWl0IC0gYWxsVW5zcGVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRVbnNwZW50c0JhdGNoKG5ld1NraXAsIG5ld0xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbFVuc3BlbnRzO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBnZXRVbnNwZW50c0JhdGNoKDAsIHBhcmFtcy5saW1pdClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBMaXN0IHRoZSB1bnNwZW50cyAocGFnZWQpIGZvciBhIGdpdmVuIHdhbGxldCwgcmV0dXJuaW5nIHRoZSByZXN1bHQgYXMgYW4gb2JqZWN0IG9mIHVuc3BlbnRzLCBjb3VudCwgc2tpcCBhbmQgdG90YWxcbiAqIFRoaXMgbWV0aG9kIG1heSBub3QgcmV0dXJuIGFsbCB0aGUgdW5zcGVudHMgYXMgdGhlIGxpc3QgaXMgcGFnZWQgYnkgdGhlIEFQSVxuICogQHBhcmFtIHBhcmFtc1xuICogQHBhcmFtIHBhcmFtcy5saW1pdCB0aGUgb3B0aW9uYWwgbGltaXQgb2YgdW5zcGVudHMgdG8gY29sbGVjdCBpbiBCVENcbiAqIEBwYXJhbSBwYXJhbXMuc2tpcCBpbmRleCBpbiBsaXN0IG9mIHVuc3BlbnRzIHRvIHN0YXJ0IHBhZ2luZyBmcm9tXG4gKiBAcGFyYW0gcGFyYW1zLm1pbkNvbmZpcm1zIG9ubHkgaW5jbHVkZSByZXN1bHRzIHdpdGggdGhpcyBudW1iZXIgb2YgY29uZmlybWF0aW9uc1xuICogQHBhcmFtIHBhcmFtcy50YXJnZXQgdGhlIGFtb3VudCBvZiBidGMgdG8gZmluZCB0byBzcGVuZFxuICogQHBhcmFtIHBhcmFtcy5pbnN0YW50IG9ubHkgZmluZCBpbnN0YW50IHRyYW5zYWN0aW9ucyAobXVzdCBzcGVjaWZ5IGEgdGFyZ2V0KVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cyBkZXNpcmVkIG51bWJlciBvZiB1bnNwZW50cyB0byBoYXZlIGluIHRoZSB3YWxsZXQgYWZ0ZXIgdGhlIHR4IGdvZXMgdGhyb3VnaCAocmVxdWlyZXMgdGFyZ2V0KVxuICogQHBhcmFtIHBhcmFtcy5taW5TaXplIG1pbmltdW0gdW5zcGVudCBzaXplIGluIHNhdG9zaGlzXG4gKiBAcGFyYW0gcGFyYW1zLnNlZ3dpdCByZXF1ZXN0IHNlZ3dpdCB1bnNwZW50cyAoZGVmYXVsdHMgdG8gdHJ1ZSBpZiB1bmRlZmluZWQpXG4gKiBAcGFyYW0gcGFyYW1zLmFsbG93TGVkZ2VyU2Vnd2l0IGFsbG93IHNlZ3dpdCB1bnNwZW50cyBmb3IgbGVkZ2VyIGRldmljZXMgKGRlZmF1bHRzIHRvIGZhbHNlIGlmIHVuZGVmaW5lZClcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHJldHVybnMgeyp9XG4gKi9cbldhbGxldC5wcm90b3R5cGUudW5zcGVudHNQYWdlZCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmxpbWl0KSAmJiAhXy5pc0ludGVnZXIocGFyYW1zLmxpbWl0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCAtIHNob3VsZCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnNraXApICYmICFfLmlzSW50ZWdlcihwYXJhbXMuc2tpcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2tpcCAtIHNob3VsZCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLm1pbkNvbmZpcm1zKSAmJiAhXy5pc0ludGVnZXIocGFyYW1zLm1pbkNvbmZpcm1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtaW5Db25maXJtcyAtIHNob3VsZCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnRhcmdldCkgJiYgIV8uaXNOdW1iZXIocGFyYW1zLnRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFyZ2V0IC0gc2hvdWxkIGJlIG51bWJlcicpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuaW5zdGFudCkgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5pbnN0YW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0YW50IGZsYWcgLSBzaG91bGQgYmUgYm9vbGVhbicpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuc2Vnd2l0KSAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnNlZ3dpdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2Vnd2l0IGZsYWcgLSBzaG91bGQgYmUgYm9vbGVhbicpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMpICYmICFfLmlzSW50ZWdlcihwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhcmdldFdhbGxldFVuc3BlbnRzIGZsYWcgLSBzaG91bGQgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5taW5TaXplKSAmJiAhXy5pc051bWJlcihwYXJhbXMubWluU2l6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQ6IG1pblNpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuaW5zdGFudCkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLm1pbkNvbmZpcm1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb25seSBvbmUgb2YgaW5zdGFudCBhbmQgbWluQ29uZmlybXMgbWF5IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzKSAmJiBfLmlzVW5kZWZpbmVkKHBhcmFtcy50YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRXYWxsZXRVbnNwZW50cyBjYW4gb25seSBiZSBzcGVjaWZpZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHRhcmdldCcpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuYWxsb3dMZWRnZXJTZWd3aXQpICYmICFfLmlzQm9vbGVhbihwYXJhbXMuYWxsb3dMZWRnZXJTZWd3aXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50OiBhbGxvd0xlZGdlclNlZ3dpdCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICB9XG5cbiAgY29uc3QgcXVlcnlPYmplY3QgPSBfLmNsb25lRGVlcChwYXJhbXMpO1xuXG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMudGFyZ2V0KSkge1xuICAgIC8vIHNraXAgYW5kIGxpbWl0IGFyZSB1bmF2YWlsYWJsZSB3aGVuIGEgdGFyZ2V0IGlzIHNwZWNpZmllZFxuICAgIGRlbGV0ZSBxdWVyeU9iamVjdC5za2lwO1xuICAgIGRlbGV0ZSBxdWVyeU9iamVjdC5saW1pdDtcbiAgfVxuXG4gIHF1ZXJ5T2JqZWN0LnNlZ3dpdCA9IHRydWU7XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuc2Vnd2l0KSkge1xuICAgIHF1ZXJ5T2JqZWN0LnNlZ3dpdCA9IHBhcmFtcy5zZWd3aXQ7XG4gIH1cblxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmFsbG93TGVkZ2VyU2Vnd2l0KSkge1xuICAgIHF1ZXJ5T2JqZWN0LmFsbG93TGVkZ2VyU2Vnd2l0ID0gcGFyYW1zLmFsbG93TGVkZ2VyU2Vnd2l0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvdW5zcGVudHMnKSlcbiAgLnF1ZXJ5KHF1ZXJ5T2JqZWN0KVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIHRyYW5zYWN0aW9uc1xuLy8gTGlzdCB0aGUgdHJhbnNhY3Rpb25zIGZvciBhIGdpdmVuIHdhbGxldFxuLy8gT3B0aW9ucyBpbmNsdWRlOlxuLy8gICAgIFRPRE86ICBBZGQgaXRlcmF0b3JzIGZvciBzdGFydC9jb3VudC9ldGNcbldhbGxldC5wcm90b3R5cGUudHJhbnNhY3Rpb25zID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IGFyZ3M6IHN0cmluZ1tdID0gW107XG4gIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH1cbiAgICBhcmdzLnB1c2goJ2xpbWl0PScgKyBwYXJhbXMubGltaXQpO1xuICB9XG4gIGlmIChwYXJhbXMuc2tpcCkge1xuICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLnNraXApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2tpcCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH1cbiAgICBhcmdzLnB1c2goJ3NraXA9JyArIHBhcmFtcy5za2lwKTtcbiAgfVxuICBpZiAocGFyYW1zLm1pbkhlaWdodCkge1xuICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm1pbkhlaWdodCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtaW5IZWlnaHQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKCdtaW5IZWlnaHQ9JyArIHBhcmFtcy5taW5IZWlnaHQpO1xuICB9XG4gIGlmIChwYXJhbXMubWF4SGVpZ2h0KSB7XG4gICAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMubWF4SGVpZ2h0KSB8fCBwYXJhbXMubWF4SGVpZ2h0IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heEhlaWdodCBhcmd1bWVudCwgZXhwZWN0aW5nIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKCdtYXhIZWlnaHQ9JyArIHBhcmFtcy5tYXhIZWlnaHQpO1xuICB9XG4gIGlmIChwYXJhbXMubWluQ29uZmlybXMpIHtcbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5taW5Db25maXJtcykgfHwgcGFyYW1zLm1pbkNvbmZpcm1zIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1pbkNvbmZpcm1zIGFyZ3VtZW50LCBleHBlY3RpbmcgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cbiAgICBhcmdzLnB1c2goJ21pbkNvbmZpcm1zPScgKyBwYXJhbXMubWluQ29uZmlybXMpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuY29tcGFjdCkpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5jb21wYWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbXBhY3QgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgfVxuICAgIGFyZ3MucHVzaCgnY29tcGFjdD0nICsgcGFyYW1zLmNvbXBhY3QpO1xuICB9XG4gIGxldCBxdWVyeSA9ICcnO1xuICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIGFyZ3Muam9pbignJicpO1xuICB9XG5cbiAgY29uc3QgdXJsID0gdGhpcy51cmwoJy90eCcgKyBxdWVyeSk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHVybClcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyB0cmFuc2FjdGlvblxuLy8gR2V0IGEgdHJhbnNhY3Rpb24gYnkgSUQgZm9yIGEgZ2l2ZW4gd2FsbGV0XG5XYWxsZXQucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCB1cmwgPSB0aGlzLnVybCgnL3R4LycgKyBwYXJhbXMuaWQpO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh1cmwpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gcG9sbEZvclRyYW5zYWN0aW9uXG4vLyBQb2xsIGEgdHJhbnNhY3Rpb24gdW50aWwgc3VjY2Vzc2Z1bCBvciB0aW1lcyBvdXRcbi8vIFBhcmFtZXRlcnM6XG4vLyAgIGlkOiB0aGUgdHhpZFxuLy8gICBkZWxheTogZGVsYXkgYmV0d2VlbiBwb2xscyBpbiBtcyAoZGVmYXVsdDogMTAwMClcbi8vICAgdGltZW91dDogdGltZW91dCBpbiBtcyAoZGVmYXVsdDogMTAwMDApXG5XYWxsZXQucHJvdG90eXBlLnBvbGxGb3JUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSwgY2FsbGJhY2spO1xuICBpZiAocGFyYW1zLmRlbGF5ICYmICFfLmlzTnVtYmVyKHBhcmFtcy5kZWxheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGVsYXkgcGFyYW1ldGVyJyk7XG4gIH1cbiAgaWYgKHBhcmFtcy50aW1lb3V0ICYmICFfLmlzTnVtYmVyKHBhcmFtcy50aW1lb3V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0aW1lb3V0IHBhcmFtZXRlcicpO1xuICB9XG4gIHBhcmFtcy5kZWxheSA9IHBhcmFtcy5kZWxheSB8fCAxMDAwO1xuICBwYXJhbXMudGltZW91dCA9IHBhcmFtcy50aW1lb3V0IHx8IDEwMDAwO1xuXG4gIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoKTtcblxuICBjb25zdCBkb05leHRQb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24ocGFyYW1zKVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIuc3RhdHVzICE9PSA0MDQgfHwgbmV3IERhdGUoKS52YWx1ZU9mKCkgLSBzdGFydC52YWx1ZU9mKCkgPiBwYXJhbXMudGltZW91dCkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gQmx1ZWJpcmQuZGVsYXkocGFyYW1zLmRlbGF5KVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkb05leHRQb2xsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gZG9OZXh0UG9sbCgpO1xufTtcblxuLy9cbi8vIHRyYW5zYWN0aW9uIGJ5IHNlcXVlbmNlIGlkXG4vLyBHZXQgYSB0cmFuc2FjdGlvbiBieSBzZXF1ZW5jZSBpZCBmb3IgYSBnaXZlbiB3YWxsZXRcbldhbGxldC5wcm90b3R5cGUuZ2V0V2FsbGV0VHJhbnNhY3Rpb25CeVNlcXVlbmNlSWQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydzZXF1ZW5jZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgY29uc3QgdXJsID0gdGhpcy51cmwoJy90eC9zZXF1ZW5jZS8nICsgcGFyYW1zLnNlcXVlbmNlSWQpO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh1cmwpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gS2V5IGNoYWluc1xuLy8gR2V0cyB0aGUgdXNlciBrZXkgY2hhaW4gZm9yIHRoaXMgd2FsbGV0XG4vLyBUaGUgdXNlciBrZXkgY2hhaW4gaXMgdHlwaWNhbGx5IHRoZSBmaXJzdCBrZXljaGFpbiBvZiB0aGUgd2FsbGV0IGFuZCBoYXMgdGhlIGVuY3J5cHRlZCB4cHJpdiBzdG9yZWQgb24gQml0R28uXG4vLyBVc2VmdWwgd2hlbiB0cnlpbmcgdG8gZ2V0IHRoZSB1c2Vycycga2V5Y2hhaW4gZnJvbSB0aGUgc2VydmVyIGJlZm9yZSBkZWNyeXB0aW5nIHRvIHNpZ24gYSB0cmFuc2FjdGlvbi5cbldhbGxldC5wcm90b3R5cGUuZ2V0RW5jcnlwdGVkVXNlcktleWNoYWluID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBjb25zdCB0cnlLZXlDaGFpbiA9IGNvKGZ1bmN0aW9uICooaW5kZXgpIHtcbiAgICAgIGlmICghc2VsZi5rZXljaGFpbnMgfHwgaW5kZXggPj0gc2VsZi5rZXljaGFpbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ05vIGVuY3J5cHRlZCBrZXljaGFpbnMgb24gdGhpcyB3YWxsZXQuJyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnbm9fZW5jcnlwdGVkX2tleWNoYWluX29uX3dhbGxldCc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJhbXMgPSB7IHhwdWI6IHNlbGYua2V5Y2hhaW5zW2luZGV4XS54cHViIH07XG5cbiAgICAgIGNvbnN0IGtleWNoYWluID0geWllbGQgc2VsZi5iaXRnby5rZXljaGFpbnMoKS5nZXQocGFyYW1zKTtcbiAgICAgIC8vIElmIHdlIGZpbmQgdGhlIHhwcnYsIHRoZW4gdGhpcyBpcyBwcm9iYWJseSB0aGUgdXNlciBrZXljaGFpbiB3ZSdyZSBsb29raW5nIGZvclxuICAgICAga2V5Y2hhaW4ud2FsbGV0U3ViUGF0aCA9IHNlbGYua2V5Y2hhaW5zW2luZGV4XS5wYXRoO1xuICAgICAgaWYgKGtleWNoYWluLmVuY3J5cHRlZFhwcnYpIHtcbiAgICAgICAgcmV0dXJuIGtleWNoYWluO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyeUtleUNoYWluKGluZGV4ICsgMSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ5S2V5Q2hhaW4oMCk7XG4gIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gY3JlYXRlVHJhbnNhY3Rpb25cbi8vIENyZWF0ZSBhIHRyYW5zYWN0aW9uICh1bnNpZ25lZCkuIFRvIHNpZ24gaXQsIGRvIHNpZ25UcmFuc2FjdGlvblxuLy8gUGFyYW1ldGVyczpcbi8vICAgcmVjaXBpZW50cyAtIG9iamVjdCBvZiByZWNpcGllbnQgYWRkcmVzc2VzIGFuZCB0aGUgYW1vdW50IHRvIHNlbmQgdG8gZWFjaCBlLmcuIHthZGRyZXNzOjE1MDAsIGFkZHJlc3MyOjE1MDB9XG4vLyAgIGZlZSAgICAgIC0gdGhlIGJsb2NrY2hhaW4gZmVlIHRvIHNlbmQgKG9wdGlvbmFsKVxuLy8gICBmZWVSYXRlICAtIHRoZSBmZWUgcGVyIGtiIHRvIHNlbmQgKG9wdGlvbmFsKVxuLy8gICBtaW5Db25maXJtcyAtIG1pbmltdW0gbnVtYmVyIG9mIGNvbmZpcm1zIHRvIHVzZSB3aGVuIGdhdGhlcmluZyB1bnNwZW50c1xuLy8gICBmb3JjZUNoYW5nZUF0RW5kIC0gZm9yY2UgY2hhbmdlIGFkZHJlc3MgdG8gYmUgbGFzdCBvdXRwdXQgKG9wdGlvbmFsKVxuLy8gICBub1NwbGl0Q2hhbmdlIC0gZGlzYWJsZSBhdXRvbWF0aWMgY2hhbmdlIHNwbGl0dGluZyBmb3IgcHVycG9zZXMgb2YgdW5zcGVudCBtYW5hZ2VtZW50XG4vLyAgIGNoYW5nZUFkZHJlc3MgLSBvdmVycmlkZSB0aGUgY2hhbmdlIGFkZHJlc3MgKG9wdGlvbmFsKVxuLy8gICB2YWxpZGF0ZSAtIGV4dHJhIHZlcmlmaWNhdGlvbiBvZiBjaGFuZ2UgYWRkcmVzc2VzICh3aGljaCBhcmUgYWx3YXlzIHZlcmlmaWVkIHNlcnZlci1zaWRlKSAoZGVmYXVsdHMgdG8gZ2xvYmFsIGNvbmZpZylcbi8vIFJldHVybnM6XG4vLyAgIGNhbGxiYWNrKGVyciwgeyB0cmFuc2FjdGlvbkhleDogc3RyaW5nLCB1bnNwZW50czogW2lucHV0c10sIGZlZTogc2F0b3NoaXMgfSlcbldhbGxldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICBpZiAoKCFfLmlzTnVtYmVyKHBhcmFtcy5mZWUpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5mZWUpKSB8fFxuICAoIV8uaXNOdW1iZXIocGFyYW1zLmZlZVJhdGUpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5mZWVSYXRlKSkgfHxcbiAgKCFfLmlzTnVtYmVyKHBhcmFtcy5taW5Db25maXJtcykgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLm1pbkNvbmZpcm1zKSkgfHxcbiAgKCFfLmlzQm9vbGVhbihwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLmZvcmNlQ2hhbmdlQXRFbmQpKSB8fFxuICAoIV8uaXNTdHJpbmcocGFyYW1zLmNoYW5nZUFkZHJlc3MpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5jaGFuZ2VBZGRyZXNzKSkgfHxcbiAgKCFfLmlzQm9vbGVhbihwYXJhbXMudmFsaWRhdGUpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy52YWxpZGF0ZSkpIHx8XG4gICghXy5pc0Jvb2xlYW4ocGFyYW1zLmluc3RhbnQpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5pbnN0YW50KSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICghXy5pc09iamVjdChwYXJhbXMucmVjaXBpZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyByZWNpcGllbnRzIG9iamVjdCcpO1xuICB9XG5cbiAgcGFyYW1zLnZhbGlkYXRlID0gcGFyYW1zLnZhbGlkYXRlICE9PSB1bmRlZmluZWQgPyBwYXJhbXMudmFsaWRhdGUgOiB0aGlzLmJpdGdvLmdldFZhbGlkYXRlKCk7XG4gIHBhcmFtcy53YWxsZXQgPSB0aGlzO1xuXG4gIHJldHVybiBUcmFuc2FjdGlvbkJ1aWxkZXIuY3JlYXRlVHJhbnNhY3Rpb24ocGFyYW1zKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5cbi8vXG4vLyBzaWduVHJhbnNhY3Rpb25cbi8vIFNpZ24gYSBwcmV2aW91c2x5IGNyZWF0ZWQgdHJhbnNhY3Rpb24gd2l0aCBhIGtleWNoYWluXG4vLyBQYXJhbWV0ZXJzOlxuLy8gdHJhbnNhY3Rpb25IZXggLSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHRyYW5zYWN0aW9uIGluIGhleFxuLy8gdW5zcGVudHMgLSBhcnJheSBvZiB1bnNwZW50IGluZm9ybWF0aW9uLCB3aGVyZSBlYWNoIHVuc3BlbnQgaXMgYSBjaGFpblBhdGhcbi8vICAgICAgICAgICAgYW5kIHJlZGVlbVNjcmlwdCB3aXRoIHRoZSBzYW1lIGluZGV4IGFzIHRoZSBpbnB1dHMgaW4gdGhlXG4vLyAgICAgICAgICAgIHRyYW5zYWN0aW9uSGV4XG4vLyBrZXljaGFpbiAtIEtleWNoYWluIGNvbnRhaW5pbmcgdGhlIHhwcnYgdG8gc2lnbiB3aXRoLlxuLy8gc2lnbmluZ0tleSAtIEZvciBsZWdhY3kgc2FmZSB3YWxsZXRzLCB0aGUgcHJpdmF0ZSBrZXkgc3RyaW5nLlxuLy8gdmFsaWRhdGUgLSBleHRyYSB2ZXJpZmljYXRpb24gb2Ygc2lnbmF0dXJlcyAod2hpY2ggYXJlIGFsd2F5cyB2ZXJpZmllZCBzZXJ2ZXItc2lkZSkgKGRlZmF1bHRzIHRvIGdsb2JhbCBjb25maWcpXG4vLyBSZXR1cm5zOlxuLy8gICBjYWxsYmFjayhlcnIsIHRyYW5zYWN0aW9uKVxuV2FsbGV0LnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3RyYW5zYWN0aW9uSGV4J10sIFtdLCBjYWxsYmFjayk7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy51bnNwZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUgdW5zcGVudHMgYXJyYXknKTtcbiAgfVxuXG4gIGlmICgoIV8uaXNPYmplY3QocGFyYW1zLmtleWNoYWluKSB8fCAhcGFyYW1zLmtleWNoYWluLnhwcnYpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5zaWduaW5nS2V5KSkge1xuICAgIC8vIGFsbG93IHBhc3NpbmcgaW4gYSBXSUYgcHJpdmF0ZSBrZXkgZm9yIGxlZ2FjeSBzYWZlIHdhbGxldCBzdXBwb3J0XG4gICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignZXhwZWN0aW5nIGtleWNoYWluIG9iamVjdCB3aXRoIHhwcnYgb3Igc2lnbmluZ0tleSBXSUYnKTtcbiAgICBlcnJvci5jb2RlID0gJ21pc3Npbmdfa2V5Y2hhaW5fb3Jfc2lnbmluZ0tleSc7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBwYXJhbXMudmFsaWRhdGUgPSBwYXJhbXMudmFsaWRhdGUgIT09IHVuZGVmaW5lZCA/IHBhcmFtcy52YWxpZGF0ZSA6IHRoaXMuYml0Z28uZ2V0VmFsaWRhdGUoKTtcbiAgcGFyYW1zLmJpdGdvID0gdGhpcy5iaXRnbztcbiAgcmV0dXJuIFRyYW5zYWN0aW9uQnVpbGRlci5zaWduVHJhbnNhY3Rpb24ocGFyYW1zKVxuICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHg6IHJlc3VsdC50cmFuc2FjdGlvbkhleFxuICAgIH07XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBzZW5kXG4vLyBTZW5kIGEgdHJhbnNhY3Rpb24gdG8gdGhlIEJpdGNvaW4gbmV0d29yayB2aWEgQml0R28uXG4vLyBPbmUgb2YgdGhlIGtleXMgaXMgdHlwaWNhbGx5IHNpZ25lZCwgYW5kIEJpdEdvIHdpbGwgc2lnbiB0aGUgb3RoZXIgKGlmIGFwcHJvdmVkKSBhbmQgcmVsYXkgaXQgdG8gdGhlIFAyUCBuZXR3b3JrLlxuLy8gUGFyYW1ldGVyczpcbi8vICAgdHggIC0gdGhlIGhleCBlbmNvZGVkLCBzaWduZWQgdHJhbnNhY3Rpb24gdG8gc2VuZFxuLy8gUmV0dXJuczpcbi8vXG5XYWxsZXQucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3R4J10sIFsnbWVzc2FnZScsICdvdHAnXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy5iaXRnby51cmwoJy90eC9zZW5kJykpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC50aGVuKGZ1bmN0aW9uKGJvZHkpIHtcbiAgICBpZiAoYm9keS5wZW5kaW5nQXBwcm92YWwpIHtcbiAgICAgIHJldHVybiBfLmV4dGVuZChib2R5LCB7IHN0YXR1czogJ3BlbmRpbmdBcHByb3ZhbCcgfSk7XG4gICAgfVxuXG4gICAgaWYgKGJvZHkub3RwKSB7XG4gICAgICByZXR1cm4gXy5leHRlbmQoYm9keSwgeyBzdGF0dXM6ICdvdHAnIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICdhY2NlcHRlZCcsXG4gICAgICB0eDogYm9keS50cmFuc2FjdGlvbixcbiAgICAgIGhhc2g6IGJvZHkudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgaW5zdGFudDogYm9keS5pbnN0YW50LFxuICAgICAgaW5zdGFudElkOiBib2R5Lmluc3RhbnRJZFxuICAgIH07XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2hhcmUgdGhlIHdhbGxldCB3aXRoIGFuIGV4aXN0aW5nIEJpdEdvIHVzZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlciBUaGUgcmVjaXBpZW50J3MgdXNlciBpZCwgbXVzdCBoYXZlIGEgY29ycmVzcG9uZGluZyB1c2VyIHJlY29yZCBpbiBvdXIgZGF0YWJhc2UuXG4gKiBAcGFyYW0ge2tleWNoYWlufSBrZXljaGFpbiBUaGUga2V5Y2hhaW4gdG8gYmUgc2hhcmVkIHdpdGggdGhlIHJlY2lwaWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwZXJtaXNzaW9ucyBBIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZSBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIHJlY2lwaWVudCdzIHBlcm1pc3Npb25zIGlmIHRoZSBzaGFyZSBpcyBhY2NlcHRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJlIHVzZWQgZm9yIHRoaXMgc2hhcmUuXG4gKi9cbldhbGxldC5wcm90b3R5cGUuY3JlYXRlU2hhcmUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1c2VyJywgJ3Blcm1pc3Npb25zJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgaWYgKHBhcmFtcy5rZXljaGFpbiAmJiAhXy5pc0VtcHR5KHBhcmFtcy5rZXljaGFpbikpIHtcbiAgICBpZiAoIXBhcmFtcy5rZXljaGFpbi54cHViIHx8ICFwYXJhbXMua2V5Y2hhaW4uZW5jcnlwdGVkWHBydiB8fCAhcGFyYW1zLmtleWNoYWluLmZyb21QdWJLZXkgfHwgIXBhcmFtcy5rZXljaGFpbi50b1B1YktleSB8fCAhcGFyYW1zLmtleWNoYWluLnBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMga2V5Y2hhaW4gcGFyYW1ldGVycyAtIHhwdWIsIGVuY3J5cHRlZFhwcnYsIGZyb21QdWJLZXksIHRvUHViS2V5LCBwYXRoJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL3NoYXJlJykpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBjcmVhdGVJbnZpdGVcbi8vIGludml0ZSBhIG5vbiBCaXRHbyBjdXN0b21lciB0byBqb2luIGEgd2FsbGV0XG4vLyBQYXJhbWV0ZXJzOlxuLy8gICBlbWFpbCAtIHRoZSByZWNpcGllbnQncyBlbWFpbCBhZGRyZXNzXG4vLyAgIHBlcm1pc3Npb25zIC0gdGhlIHJlY2lwaWVudCdzIHBlcm1pc3Npb25zIGlmIHRoZSBzaGFyZSBpcyBhY2NlcHRlZFxuLy8gUmV0dXJuczpcbi8vXG5XYWxsZXQucHJvdG90eXBlLmNyZWF0ZUludml0ZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2VtYWlsJywgJ3Blcm1pc3Npb25zJ10sIFsnbWVzc2FnZSddLCBjYWxsYmFjayk7XG5cbiAgY29uc3Qgb3B0aW9uczogYW55ID0ge1xuICAgIHRvRW1haWw6IHBhcmFtcy5lbWFpbCxcbiAgICBwZXJtaXNzaW9uczogcGFyYW1zLnBlcm1pc3Npb25zXG4gIH07XG5cbiAgaWYgKHBhcmFtcy5tZXNzYWdlKSB7XG4gICAgb3B0aW9ucy5tZXNzYWdlID0gcGFyYW1zLm1lc3NhZ2U7XG4gIH1cblxuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvaW52aXRlJykpXG4gIC5zZW5kKG9wdGlvbnMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gY29uZmlybUludml0ZUFuZFNoYXJlV2FsbGV0XG4vLyBjb25maXJtIG15IGludml0ZSBvbiB0aGlzIHdhbGxldCB0byBhIHJlY2lwaWVudCB3aG8gaGFzXG4vLyBzdWJzZXF1ZW50bHkgc2lnbmVkIHVwIGJ5IGNyZWF0aW5nIHRoZSBhY3R1YWwgd2FsbGV0IHNoYXJlXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICB3YWxsZXRJbnZpdGVJZCAtIHRoZSB3YWxsZXQgaW52aXRlIGlkXG4vLyAgIHdhbGxldFBhc3NwaHJhc2UgLSByZXF1aXJlZCBpZiB0aGUgd2FsbGV0IHNoYXJlIHN1Y2Nlc3MgaXMgZXhwZWN0ZWRcbi8vIFJldHVybnM6XG4vL1xuV2FsbGV0LnByb3RvdHlwZS5jb25maXJtSW52aXRlQW5kU2hhcmVXYWxsZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRJbnZpdGVJZCddLCBbJ3dhbGxldFBhc3NwaHJhc2UnXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5iaXRnby53YWxsZXRzKCkubGlzdEludml0ZXMoKVxuICAudGhlbihmdW5jdGlvbihpbnZpdGVzKSB7XG4gICAgY29uc3Qgb3V0Z29pbmcgPSBpbnZpdGVzLm91dGdvaW5nO1xuICAgIGNvbnN0IGludml0ZSA9IF8uZmluZChvdXRnb2luZywgZnVuY3Rpb24ob3V0KSB7XG4gICAgICByZXR1cm4gb3V0LmlkID09PSBwYXJhbXMud2FsbGV0SW52aXRlSWQ7XG4gICAgfSk7XG4gICAgaWYgKCFpbnZpdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0IGludml0ZSBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZW1haWw6IGludml0ZS50b0VtYWlsLFxuICAgICAgcGVybWlzc2lvbnM6IGludml0ZS5wZXJtaXNzaW9ucyxcbiAgICAgIG1lc3NhZ2U6IGludml0ZS5tZXNzYWdlLFxuICAgICAgd2FsbGV0UGFzc3BocmFzZTogcGFyYW1zLndhbGxldFBhc3NwaHJhc2VcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGYuc2hhcmVXYWxsZXQob3B0aW9ucyk7XG4gIH0pXG4gIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJpdGdvLnB1dCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldGludml0ZS8nICsgcGFyYW1zLndhbGxldEludml0ZUlkKSk7XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBzZW5kQ29pbnNcbi8vIFNlbmQgY29pbnMgdG8gYSBkZXN0aW5hdGlvbiBhZGRyZXNzIGZyb20gdGhpcyB3YWxsZXQgdXNpbmcgdGhlIHVzZXIga2V5LlxuLy8gMS4gR2V0cyB0aGUgdXNlciBrZXljaGFpbiBieSBjaGVja2luZyB0aGUgd2FsbGV0IGZvciBhIGtleSB3aGljaCBoYXMgYW4gZW5jcnlwdGVkIHhwcml2XG4vLyAyLiBEZWNyeXB0cyB1c2VyIGtleVxuLy8gMy4gQ3JlYXRlcyB0aGUgdHJhbnNhY3Rpb24gd2l0aCBkZWZhdWx0IGZlZVxuLy8gNC4gU2lnbnMgdHJhbnNhY3Rpb24gd2l0aCBkZWNyeXB0ZWQgdXNlciBrZXlcbi8vIDMuIFNlbmRzIHRoZSB0cmFuc2FjdGlvbiB0byBCaXRHb1xuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAgIGFkZHJlc3MgLSB0aGUgZGVzdGluYXRpb24gYWRkcmVzc1xuLy8gICBhbW91bnQgLSB0aGUgYW1vdW50IGluIHNhdG9zaGlzIHRvIGJlIHNlbnRcbi8vICAgbWVzc2FnZSAtIG9wdGlvbmFsIG1lc3NhZ2UgdG8gYXR0YWNoIHRvIHRyYW5zYWN0aW9uXG4vLyAgIHdhbGxldFBhc3NwaHJhc2UgLSB0aGUgcGFzc3BocmFzZSB0byBiZSB1c2VkIHRvIGRlY3J5cHQgdGhlIHVzZXIga2V5IG9uIHRoaXMgd2FsbGV0XG4vLyAgIHhwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0sIGlmIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuLy8gICAoU2VlIHRyYW5zYWN0aW9uQnVpbGRlci5jcmVhdGVUcmFuc2FjdGlvbiBmb3Igb3RoZXIgcGFzc3Rocm91Z2ggcGFyYW1zKVxuLy8gUmV0dXJuczpcbi8vXG5XYWxsZXQucHJvdG90eXBlLnNlbmRDb2lucyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgWydtZXNzYWdlJ10sIGNhbGxiYWNrKTtcblxuICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFtb3VudCAtIG51bWJlciBleHBlY3RlZCcpO1xuICB9XG5cbiAgcGFyYW1zLnJlY2lwaWVudHMgPSB7fTtcbiAgcGFyYW1zLnJlY2lwaWVudHNbcGFyYW1zLmFkZHJlc3NdID0gcGFyYW1zLmFtb3VudDtcblxuICByZXR1cm4gdGhpcy5zZW5kTWFueShwYXJhbXMpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBzZW5kTWFueVxuLy8gU2VuZCBjb2lucyB0byBtdWx0aXBsZSBkZXN0aW5hdGlvbiBhZGRyZXNzZXMgZnJvbSB0aGlzIHdhbGxldCB1c2luZyB0aGUgdXNlciBrZXkuXG4vLyAxLiBHZXRzIHRoZSB1c2VyIGtleWNoYWluIGJ5IGNoZWNraW5nIHRoZSB3YWxsZXQgZm9yIGEga2V5IHdoaWNoIGhhcyBhbiBlbmNyeXB0ZWQgeHByaXZcbi8vIDIuIERlY3J5cHRzIHVzZXIga2V5XG4vLyAzLiBDcmVhdGVzIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgZmVlXG4vLyA0LiBTaWducyB0cmFuc2FjdGlvbiB3aXRoIGRlY3J5cHRlZCB1c2VyIGtleVxuLy8gMy4gU2VuZHMgdGhlIHRyYW5zYWN0aW9uIHRvIEJpdEdvXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vICAgcmVjaXBpZW50cyAtIGFycmF5IG9mIHsgYWRkcmVzczogc3RyaW5nLCBhbW91bnQ6IG51bWJlciwgdHJhdmVsSW5mbzogb2JqZWN0IH0gdG8gc2VuZCB0b1xuLy8gICB3YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHBhc3NwaHJhc2UgdG8gYmUgdXNlZCB0byBkZWNyeXB0IHRoZSB1c2VyIGtleSBvbiB0aGlzIHdhbGxldFxuLy8gICB4cHJ2IC0gdGhlIHByaXZhdGUga2V5IGluIHN0cmluZyBmb3JtLCBpZiB3YWxsZXRQYXNzcGhyYXNlIGlzIG5vdCBhdmFpbGFibGVcbi8vICAgKFNlZSB0cmFuc2FjdGlvbkJ1aWxkZXIuY3JlYXRlVHJhbnNhY3Rpb24gZm9yIG90aGVyIHBhc3N0aHJvdWdoIHBhcmFtcylcbi8vIFJldHVybnM6XG4vL1xuV2FsbGV0LnByb3RvdHlwZS5zZW5kTWFueSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydtZXNzYWdlJywgJ290cCddLCBjYWxsYmFjayk7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIGlmICghXy5pc09iamVjdChwYXJhbXMucmVjaXBpZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyByZWNpcGllbnRzIG9iamVjdCcpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5mZWUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmZlZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGZlZSAtIG51bWJlciBleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5mZWVSYXRlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5mZWVSYXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgZmVlUmF0ZSAtIG51bWJlciBleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5pbnN0YW50ICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaW5zdGFudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGluc3RhbnQgLSBib29sZWFuIGV4cGVjdGVkJyk7XG4gIH1cblxuICBsZXQgYml0Z29GZWU7XG4gIGxldCB0cmF2ZWxJbmZvcztcbiAgbGV0IGZpbmFsUmVzdWx0O1xuICBsZXQgdW5zcGVudHNVc2VkO1xuXG4gIGNvbnN0IGFjY2VwdGVkQnVpbGRQYXJhbXMgPSBbXG4gICAgJ251bUJsb2NrcycsICdmZWVSYXRlJywgJ21pbkNvbmZpcm1zJywgJ2VuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZScsXG4gICAgJ3RhcmdldFdhbGxldFVuc3BlbnRzJywgJ21lc3NhZ2UnLCAnbWluVmFsdWUnLCAnbWF4VmFsdWUnLFxuICAgICdub1NwbGl0Q2hhbmdlJywgJ2NvbW1lbnQnXG4gIF07XG4gIGNvbnN0IHByZXNlcnZlZEJ1aWxkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgYWNjZXB0ZWRCdWlsZFBhcmFtcyk7XG5cbiAgLy8gR2V0IHRoZSB1c2VyIGtleWNoYWluXG4gIGNvbnN0IHJldFByb21pc2UgPSB0aGlzLmNyZWF0ZUFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXMpXG4gIC50aGVuKGZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICBiaXRnb0ZlZSA9IHRyYW5zYWN0aW9uLmJpdGdvRmVlO1xuICAgIHRyYXZlbEluZm9zID0gdHJhbnNhY3Rpb24udHJhdmVsSW5mb3M7XG4gICAgdW5zcGVudHNVc2VkID0gdHJhbnNhY3Rpb24udW5zcGVudHM7XG4gICAgcmV0dXJuIHNlbGYuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgIHR4OiB0cmFuc2FjdGlvbi50eCxcbiAgICAgIG1lc3NhZ2U6IHBhcmFtcy5tZXNzYWdlLFxuICAgICAgc2VxdWVuY2VJZDogcGFyYW1zLnNlcXVlbmNlSWQsXG4gICAgICBpbnN0YW50OiBwYXJhbXMuaW5zdGFudCxcbiAgICAgIG90cDogcGFyYW1zLm90cCxcbiAgICAgIC8vIFRoZSBiZWxvdyBwYXJhbXMgYXJlIGZvciBsb2dnaW5nIG9ubHksIGFuZCBkbyBub3QgaW1wYWN0IHRoZSBBUEkgY2FsbFxuICAgICAgZXN0aW1hdGVkU2l6ZTogdHJhbnNhY3Rpb24uZXN0aW1hdGVkU2l6ZSxcbiAgICAgIGJ1aWxkUGFyYW1zOiBwcmVzZXJ2ZWRCdWlsZFBhcmFtc1xuICAgIH0pO1xuICB9KVxuICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICBjb25zdCB0eCA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleChyZXN1bHQudHgpO1xuICAgIGNvbnN0IGlucHV0c1N1bSA9IF8uc3VtQnkodW5zcGVudHNVc2VkLCAndmFsdWUnKTtcbiAgICBjb25zdCBvdXRwdXRzU3VtID0gXy5zdW1CeSh0eC5vdXRzLCAndmFsdWUnKTtcbiAgICBjb25zdCBmZWVVc2VkID0gaW5wdXRzU3VtIC0gb3V0cHV0c1N1bTtcbiAgICBpZiAoaXNOYU4oZmVlVXNlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmZWVVc2VkJyk7XG4gICAgfVxuICAgIHJlc3VsdC5mZWUgPSBmZWVVc2VkLFxuICAgIHJlc3VsdC5mZWVSYXRlID0gZmVlVXNlZCAqIDEwMDAgLyB0eC52aXJ0dWFsU2l6ZSgpO1xuICAgIHJlc3VsdC50cmF2ZWxJbmZvcyA9IHRyYXZlbEluZm9zO1xuICAgIGlmIChiaXRnb0ZlZSkge1xuICAgICAgcmVzdWx0LmJpdGdvRmVlID0gYml0Z29GZWU7XG4gICAgfVxuICAgIGZpbmFsUmVzdWx0ID0gcmVzdWx0O1xuXG4gICAgLy8gSGFuZGxlIHNlbmRpbmcgdHJhdmVsIGluZm9zIGlmIHRoZXkgZXhpc3QsIGJ1dCBtYWtlIHN1cmUgd2UgbmV2ZXIgZmFpbCBoZXJlLlxuICAgIC8vIEVycm9yIG9yIHJlc3VsdCAod2l0aCBwb3NzaWJsZSBzdWItZXJyb3JzKSB3aWxsIGJlIHByb3ZpZGVkIGluIHRyYXZlbFJlc3VsdFxuICAgIGlmICh0cmF2ZWxJbmZvcyAmJiB0cmF2ZWxJbmZvcy5sZW5ndGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmLnBvbGxGb3JUcmFuc2FjdGlvbih7IGlkOiByZXN1bHQuaGFzaCB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5iaXRnby50cmF2ZWxSdWxlKCkuc2VuZE1hbnkocmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgZmluYWxSZXN1bHQudHJhdmVsUmVzdWx0ID0gcmVzO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgLy8gY2F0Y2ggYXN5bmMgZXJyb3JzXG4gICAgICAgICAgZmluYWxSZXN1bHQudHJhdmVsUmVzdWx0ID0geyBlcnJvcjogZXJyLm1lc3NhZ2UgfTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gY2F0Y2ggc3luY2hyb25vdXMgZXJyb3JzXG4gICAgICAgIGZpbmFsUmVzdWx0LnRyYXZlbFJlc3VsdCA9IHsgZXJyb3I6IGVyci5tZXNzYWdlIH07XG4gICAgICB9XG4gICAgfVxuICB9KVxuICAudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShyZXRQcm9taXNlKS5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQWNjZWxlcmF0ZSBhIHN0dWNrIHRyYW5zYWN0aW9uIHVzaW5nIENoaWxkLVBheXMtRm9yLVBhcmVudCAoQ1BGUCkuXG4gKlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGZvciBzdHVjayB0cmFuc2FjdGlvbnMgd2hpY2ggaGF2ZSBubyB1bmNvbmZpcm1lZCBpbnB1dHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIElucHV0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudHJhbnNhY3Rpb25JRCAtIElEIG9mIHRyYW5zYWN0aW9uIHRvIGFjY2VsZXJhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIE5ldyBlZmZlY3RpdmUgZmVlIHJhdGUgZm9yIHN0dWNrIHRyYW5zYWN0aW9uIChzYXQgcGVyIDEwMDAgYnl0ZXMpXG4gKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEFkZGl0aW9uYWxVbnNwZW50cyAtIE1heGltdW0gYWRkaXRpb25hbCB1bnNwZW50cyB0byB1c2UgZnJvbSB0aGUgd2FsbGV0IHRvIGNvdmVyIGFueSBjaGlsZCBmZWVzIHRoYXQgdGhlIHBhcmVudCB1bnNwZW50IG91dHB1dCBjYW5ub3QgY292ZXIuIERlZmF1bHRzIHRvIDEwMC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIFRoZSBwYXNzcGhyYXNlIHdoaWNoIHNob3VsZCBiZSB1c2VkIHRvIGRlY3J5cHQgdGhlIHdhbGxldCBwcml2YXRlIGtleS4gT25lIG9mIGVpdGhlciB3YWxsZXRQYXNzcGhyYXNlIG9yIHhwcnYgaXMgcmVxdWlyZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnhwcnYgLSBUaGUgcHJpdmF0ZSBrZXkgZm9yIHRoZSB3YWxsZXQuIE9uZSBvZiBlaXRoZXIgd2FsbGV0UGFzc3BocmFzZSBvciB4cHJ2IGlzIHJlcXVpcmVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIFJlc3VsdCBvZiBzZW5kVHJhbnNhY3Rpb24oKSBvbiB0aGUgY2hpbGQgdHJhbnNhY3Rpb25cbiAqL1xuV2FsbGV0LnByb3RvdHlwZS5hY2NlbGVyYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBhY2NlbGVyYXRlVHJhbnNhY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZXN0aW1hdGUgYSB0cmFuc2FjdGlvbnMgc2l6ZSBpbiB2aXJ0dWFsIGJ5dGVzLlxuICAgKiBBY3R1YWwgdHJhbnNhY3Rpb25zIG1heSBiZSBzbGlnaHRseSBmZXdlciB2aXJ0dWFsIGJ5dGVzLCBkdWUgdG9cbiAgICogdGhlIGZhY3QgdGhhdCB2YWxpZCBFQ1NEQSBzaWduYXR1cmVzIGhhdmUgYSB2YXJpYWJsZSBsZW5ndGhcbiAgICogYmV0d2VlbiA4IGFuZCA3MyB2aXJ0dWFsIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRzLnNlZ3dpdCBUaGUgbnVtYmVyIG9mIHNlZ3dpdCBpbnB1dHMgdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBpbnB1dHMuUDJTSCBUaGUgbnVtYmVyIG9mIFAyU0ggaW5wdXRzIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gaW5wdXRzLlAyUEtIIFRoZSBudW1iZXIgb2YgUDJQS0ggaW5wdXRzIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3QgZXN0aW1hdGVUeFZTaXplID0gKGlucHV0cykgPT4ge1xuICAgIGNvbnN0IHNlZ3dpdCA9IGlucHV0cy5zZWd3aXQgfHwgMDtcbiAgICBjb25zdCBQMlNIID0gaW5wdXRzLlAyU0ggfHwgMDtcbiAgICBjb25zdCBQMlBLSCA9IGlucHV0cy5QMlBLSCB8fCAwO1xuXG4gICAgY29uc3QgY2hpbGRGZWVJbmZvID0gVHJhbnNhY3Rpb25CdWlsZGVyLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyh7XG4gICAgICBuUDJzaElucHV0czogUDJTSCxcbiAgICAgIG5QMnBraElucHV0czogUDJQS0gsXG4gICAgICBuUDJzaFAyd3NoSW5wdXRzOiBzZWd3aXQsXG4gICAgICBuT3V0cHV0czogMSxcbiAgICAgIGZlZVJhdGU6IDFcbiAgICB9KTtcblxuICAgIHJldHVybiBjaGlsZEZlZUluZm8uc2l6ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygc2F0b3NoaXMgdGhhdCBzaG91bGQgYmUgcGFpZCBpbiBmZWVzIGJ5IHRoZSBjaGlsZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRzIElucHV0cyB0byB0aGUgY2hpbGQgdHJhbnNhY3Rpb24gd2hpY2ggYXJlIHBhc3NlZCB0byBlc3RpbWF0ZVR4VlNpemVcbiAgICogQHBhcmFtIHBhcmVudEZlZSBUaGUgbnVtYmVyIG9mIHNhdG9zaGlzIHRoZSBwYXJlbnQgdHggb3JpZ2luYWxseSBwYWlkIGluIGZlZXNcbiAgICogQHBhcmFtIHBhcmVudFZTaXplIFRoZSBudW1iZXIgb2YgdmlydHVhbCBieXRlcyBpbiB0aGUgcGFyZW50IHR4XG4gICAqIEBwYXJhbSBmZWVSYXRlIFRoZSBuZXcgZmVlIHJhdGUgd2hpY2ggc2hvdWxkIGJlIHBhaWQgYnkgdGhlIGNvbWJpbmVkIENQRlAgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBzYXRvc2hpcyB0aGUgY2hpbGQgdHggc2hvdWxkIHBheSBpbiBmZWVzXG4gICAqL1xuICBjb25zdCBlc3RpbWF0ZUNoaWxkRmVlID0gKHsgaW5wdXRzLCBwYXJlbnRGZWUsIHBhcmVudFZTaXplLCBmZWVSYXRlIH0pID0+IHtcbiAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggbW9yZSB3ZSAqc2hvdWxkKiBoYXZlIHBhaWQgaW4gcGFyZW50IGZlZXMsXG4gICAgLy8gaGFkIHRoZSBwYXJlbnQgYmVlbiBvcmlnaW5hbGx5IHNlbnQgd2l0aCB0aGUgbmV3IGZlZSByYXRlXG4gICAgY29uc3QgYWRkaXRpb25hbFBhcmVudEZlZSA9IF8uY2VpbChwYXJlbnRWU2l6ZSAqIGZlZVJhdGUgLyAxMDAwKSAtIHBhcmVudEZlZTtcblxuICAgIC8vIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSB3b3VsZCBwYXkgaW4gZmVlcyBmb3IgdGhlIGNoaWxkLFxuICAgIC8vIGlmIGl0IHdlcmUgb25seSBwYXlpbmcgZm9yIGl0c2VsZiBhdCB0aGUgbmV3IGZlZSByYXRlXG4gICAgY29uc3QgY2hpbGRGZWUgPSBlc3RpbWF0ZVR4VlNpemUoaW5wdXRzKSAqIGZlZVJhdGUgLyAxMDAwO1xuXG4gICAgcmV0dXJuIF8uY2VpbChjaGlsZEZlZSArIGFkZGl0aW9uYWxQYXJlbnRGZWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBhZGRpdGlvbmFsIHVuc3BlbnRzIHRvIHVzZSB0byBwYXkgdGhlIGNoaWxkIHR4IGZlZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIHRoZSBwYXJlbnQgdHggb3V0cHV0IGlzIG5vdCBzdWZmaWNpZW50IHRvXG4gICAqIGNvdmVyIHRoZSB0b3RhbCBmZWVzIHdoaWNoIHNob3VsZCBiZSBwYWlkIGJ5IHRoZSBjaGlsZCB0eC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBJbnB1dHMgdG8gdGhlIGNoaWxkIHRyYW5zYWN0aW9uIHdoaWNoIGFyZSBwYXNzZWQgdG8gZXN0aW1hdGVUeFZTaXplXG4gICAqIEBwYXJhbSBwYXJlbnRPdXRwdXRWYWx1ZSBUaGUgdmFsdWUgb2YgdGhlIG91dHB1dCBmcm9tIHRoZSBwYXJlbnQgdHggd2hpY2ggd2UgYXJlIHVzaW5nIGFzIGFuIGlucHV0IHRvIHRoZSBjaGlsZCB0eFxuICAgKiBAcGFyYW0gcGFyZW50RmVlIFRoZSBudW1iZXIgb2Ygc2F0b3NoaXMgdGhlIHBhcmVudCB0eCBvcmlnaW5hbGx5IHBhaWQgaW4gZmVlc1xuICAgKiBAcGFyYW0gcGFyZW50VlNpemUgVGhlIG51bWJlciBvZiB2aXJ0dWFsIGJ5dGVzIGluIHRoZSBwYXJlbnQgdHhcbiAgICogQHBhcmFtIG1heFVuc3BlbnRzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhZGRpdGlvbmFsIHVuc3BlbnRzIHdoaWNoIHNob3VsZCBiZSB1c2VkIHRvIGNvdmVyIHRoZSByZW1haW5pbmcgY2hpbGQgZmVlc1xuICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgYWRkaXRpb25hbCB1bnNwZW50cyB0byB1c2UsIHRoZSB1cGRhdGVkIG51bWJlciBvZiBzYXRvc2hpcyB3aGljaCBzaG91bGQgYmUgcGFpZCBieVxuICAgKiAgICAgICAgICB0aGUgY2hpbGQgdHgsIGFuZCB0aGUgdXBkYXRlZCBpbnB1dHMgZm9yIHRoZSBjaGlsZCB0eC5cbiAgICovXG4gIGNvbnN0IGZpbmRBZGRpdGlvbmFsVW5zcGVudHMgPSAoeyBpbnB1dHMsIHBhcmVudE91dHB1dFZhbHVlLCBwYXJlbnRGZWUsIHBhcmVudFZTaXplLCBtYXhVbnNwZW50cyB9KSA9PiB7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICpjb0ZpbmRBZGRpdGlvbmFsVW5zcGVudHMoKSB7XG5cbiAgICAgIGNvbnN0IGFkZGl0aW9uYWxVbnNwZW50czogYW55W10gPSBbXTtcblxuICAgICAgLy8gYXNrIHRoZSBzZXJ2ZXIgZm9yIGVub3VnaCB1bnNwZW50cyB0byBjb3ZlciB0aGUgY2hpbGQgZmVlLCBhc3N1bWluZ1xuICAgICAgLy8gdGhhdCBpdCBjYW4gYmUgZG9uZSB3aXRob3V0IGFkZGl0aW9uYWwgdW5zcGVudHMgKHdoaWNoIGlzIG5vdCBwb3NzaWJsZSxcbiAgICAgIC8vIHNpbmNlIGlmIHRoYXQgd2VyZSB0aGUgY2FzZSwgZmluZEFkZGl0aW9uYWxVbnNwZW50cyB3b3VsZCBub3QgaGF2ZSBiZWVuXG4gICAgICAvLyBjYWxsZWQgaW4gdGhlIGZpcnN0IHBsYWNlLiBUaGlzIHdpbGwgYmUgY29ycmVjdGVkIGJlZm9yZSByZXR1cm5pbmcpXG4gICAgICBsZXQgY3VycmVudENoaWxkRmVlRXN0aW1hdGUgPSBlc3RpbWF0ZUNoaWxkRmVlKHsgaW5wdXRzLCBwYXJlbnRGZWUsIHBhcmVudFZTaXplLCBmZWVSYXRlOiBwYXJhbXMuZmVlUmF0ZSB9KTtcbiAgICAgIGxldCB1bmNvdmVyZWRDaGlsZEZlZSA9IGN1cnJlbnRDaGlsZEZlZUVzdGltYXRlIC0gcGFyZW50T3V0cHV0VmFsdWU7XG5cbiAgICAgIHdoaWxlICh1bmNvdmVyZWRDaGlsZEZlZSA+IDAgJiYgYWRkaXRpb25hbFVuc3BlbnRzLmxlbmd0aCA8IG1heFVuc3BlbnRzKSB7XG4gICAgICAgIC8vIHRyeSB0byBnZXQgZW5vdWdoIHVuc3BlbnRzIHRvIGNvdmVyIHRoZSByZXN0IG9mIHRoZSBjaGlsZCBmZWVcbiAgICAgICAgY29uc3QgdW5zcGVudHMgPSB5aWVsZCB0aGlzLnVuc3BlbnRzKHtcbiAgICAgICAgICBtaW5Db25maXJtczogMSxcbiAgICAgICAgICB0YXJnZXQ6IHVuY292ZXJlZENoaWxkRmVlLFxuICAgICAgICAgIGxpbWl0OiBtYXhVbnNwZW50cyAtIGFkZGl0aW9uYWxVbnNwZW50cy5sZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHVuc3BlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIG5vIG1vcmUgdW5zcGVudHMgYXJlIGF2YWlsYWJsZVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFkZGl0aW9uYWxVbnNwZW50VmFsdWUgPSAwO1xuXG4gICAgICAgIC8vIGNvbnN1bWUgYWxsIHVuc3BlbnRzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIsIGV2ZW4gaWYgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAvLyBhbGwgb2YgdGhlbSB0byBjb3ZlciB0aGUgY2hpbGQgZmVlLiBUaGlzIGlzIGJlY2F1c2UgdGhlIHNlcnZlciB3aWxsXG4gICAgICAgIC8vIHJldHVybiBlbm91Z2ggdW5zcGVudCB2YWx1ZSB0byBlbnN1cmUgdGhhdCB0aGUgbWluaW11bSBjaGFuZ2UgYW1vdW50XG4gICAgICAgIC8vIGlzIGFjaGlldmVkIGZvciB0aGUgY2hpbGQgdHgsIGFuZCB3ZSBjYW4ndCBsZWF2ZSBvdXQgdGhvc2UgdW5zcGVudHNcbiAgICAgICAgLy8gb3IgZWxzZSB0aGUgbWluaW11bSBjaGFuZ2UgYW1vdW50IGNvbnN0cmFpbnQgY291bGQgYmUgdmlvbGF0ZWRcbiAgICAgICAgXy5mb3JFYWNoKHVuc3BlbnRzLCAodW5zcGVudCkgPT4ge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgY2hpbGQgdHggaW5wdXRzXG4gICAgICAgICAgY29uc3QgdW5zcGVudENoYWluID0gZ2V0Q2hhaW4odW5zcGVudCk7XG4gICAgICAgICAgaWYgKHVuc3BlbnRDaGFpbiA9PT0gQ29kZXMucDJzaFAyd3NoLmV4dGVybmFsIHx8IHVuc3BlbnRDaGFpbiA9PT0gQ29kZXMucDJzaFAyd3NoLmludGVybmFsKSB7XG4gICAgICAgICAgICBpbnB1dHMuc2Vnd2l0Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0cy5QMlNIKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkaXRpb25hbFVuc3BlbnRzLnB1c2godW5zcGVudCk7XG4gICAgICAgICAgYWRkaXRpb25hbFVuc3BlbnRWYWx1ZSArPSB1bnNwZW50LnZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjdXJyZW50Q2hpbGRGZWVFc3RpbWF0ZSA9IGVzdGltYXRlQ2hpbGRGZWUoeyBpbnB1dHMsIHBhcmVudEZlZSwgcGFyZW50VlNpemUsIGZlZVJhdGU6IHBhcmFtcy5mZWVSYXRlIH0pO1xuICAgICAgICB1bmNvdmVyZWRDaGlsZEZlZSA9IGN1cnJlbnRDaGlsZEZlZUVzdGltYXRlIC0gcGFyZW50T3V0cHV0VmFsdWUgLSBhZGRpdGlvbmFsVW5zcGVudFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5jb3ZlcmVkQ2hpbGRGZWUgPiAwKSB7XG4gICAgICAgIC8vIFVuYWJsZSB0byBmaW5kIGVub3VnaCB1bnNwZW50cyB0byBjb3ZlciB0aGUgY2hpbGQgZmVlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGNvbmZpcm1lZCB1bnNwZW50cyBhdmFpbGFibGUgdG8gY292ZXIgdGhlIGNoaWxkIGZlZWApO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3VuZCBlbm91Z2ggdW5zcGVudHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZGl0aW9uYWw6IGFkZGl0aW9uYWxVbnNwZW50cyxcbiAgICAgICAgbmV3Q2hpbGRGZWU6IGN1cnJlbnRDaGlsZEZlZUVzdGltYXRlLFxuICAgICAgICBuZXdJbnB1dHM6IGlucHV0c1xuICAgICAgfTtcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgZnVsbCBjb3B5IChpbmNsdWRpbmcgd2l0bmVzcyBkYXRhKSBvZiBhbiBhcmJpdHJhcnkgdHggdXNpbmcgb25seSB0aGUgdHggaWQuXG4gICAqXG4gICAqIFdlIGhhdmUgdG8gdXNlIGFuIGV4dGVybmFsIHNlcnZpY2UgZm9yIHRoaXMgKGN1cnJlbnRseSBzbWFydGJpdC5jb20uYXUpLCBzaW5jZVxuICAgKiB0aGUgdjEgaW5kZXhlciBzZXJ2aWNlIChiYXNlZCBvbiBiaXRjb2luaikgZG9lcyBub3QgaGF2ZSBzZWd3aXQgc3VwcG9ydCBhbmRcbiAgICogZG9lcyBub3QgcmV0dXJuIGFueSBzZWd3aXQgcmVsYXRlZCBmaWVsZHMgaW4gdGhlIHR4IGhleC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudFR4SWQgVGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBnZXQgdGhlIGZ1bGwgaGV4IG9mXG4gICAqIEByZXR1cm5zIHtCbHVlYmlyZDxhbnk+fSBUaGUgZnVsbCBoZXggZm9yIHRoZSBzcGVjaWZpZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0IGdldFBhcmVudFR4SGV4ID0gKHsgcGFyZW50VHhJZCB9KSA9PiB7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICpjb0dldFBhcmVudFR4SGV4KCkge1xuICAgICAgY29uc3Qgc21hcnRCaXRBcGlVcmwgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLnNtYXJ0Qml0QXBpQmFzZVVybCArICcvYmxvY2tjaGFpbi90eC8nO1xuICAgICAgY29uc3QgdHhVcmwgPSBzbWFydEJpdEFwaVVybCArIHBhcmVudFR4SWQgKyAnL2hleCc7XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCByZXF1ZXN0LmdldCh0eFVybCk7XG5cbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocmVzdWx0LmJvZHkuc3VjY2VzcykgfHwgIXJlc3VsdC5ib2R5LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IHN1Y2Nlc3NmdWxseSByZWNlaXZlIHBhcmVudCB0eCBoZXgnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdC5ib2R5LmhleFswXS5oZXg7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgY2hhaW4gZnJvbSBhbiB1bnNwZW50IG9yIHR4IG91dHB1dC5cbiAgICpcbiAgICogQHBhcmFtIG91dHB1dE9yVW5zcGVudCBUaGUgb3V0cHV0IG9yIHVuc3BlbnQgd2hvc2UgY2hhaW4gc2hvdWxkIGJlIGRldGVybWluZWRcbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGNoYWluIGZvciB0aGUgZ2l2ZW4gb3V0cHV0IG9yIHVuc3BlbnRcbiAgICovXG4gIGNvbnN0IGdldENoYWluID0gKG91dHB1dE9yVW5zcGVudCkgPT4ge1xuICAgIGlmIChvdXRwdXRPclVuc3BlbnQuY2hhaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG91dHB1dE9yVW5zcGVudC5jaGFpbjtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0T3JVbnNwZW50LmNoYWluUGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gXy50b051bWJlcihvdXRwdXRPclVuc3BlbnQuY2hhaW5QYXRoLnNwbGl0KCcvJylbMV0pO1xuICAgIH1cblxuICAgIC8vIG5vIHdheSB0byB0ZWxsIHRoZSBjaGFpbiwgbGV0J3MganVzdCBibG93IHVwIG5vdyBpbnN0ZWFkXG4gICAgLy8gb2YgYmxvd2luZyB1cCBsYXRlciB3aGVuIHRoZSB1bmRlZmluZWQgcmV0dXJuIHZhbHVlIGlzIHVzZWQuXG4gICAgLy8gTm90ZTogZm9yIHVuc3BlbnRzIHRoZSBmaWVsZCB0byB1c2UgaXMgJ2FkZHJlc3MnLCBidXQgZm9yIG91dHB1dHNcbiAgICAvLyB0aGUgZmllbGQgdG8gdXNlIGlzICdhY2NvdW50J1xuICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgZ2V0IGNoYWluIGZvciBvdXRwdXQgb24gYWNjb3VudCAke291dHB1dE9yVW5zcGVudC5hY2NvdW50IHx8IG91dHB1dE9yVW5zcGVudC5hZGRyZXNzfWApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBhY3R1YWwgdmFsdWUgY29udHJpYnV0aW9uIGFuIG91dHB1dCBvciB1bnNwZW50IHdpbGxcbiAgICogY29udHJpYnV0ZSB0byBhIHRyYW5zYWN0aW9uLCB3ZXJlIGl0IHRvIGJlIHVzZWQuIEVhY2ggdHlwZSBvZiBvdXRwdXQgb3IgdW5zcGVudFxuICAgKiB3aWxsIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgY29udHJpYnV0aW9uIHNpbmNlIGVhY2ggdHlwZSBoYXMgYSBkaWZmZXJlbnQgbnVtYmVyXG4gICAqIG9mIHZpcnR1YWwgYnl0ZXMsIGFuZCB0aHVzIHdpbGwgY2F1c2UgYSBkaWZmZXJlbnQgZmVlIHRvIGJlIHBhaWQuXG4gICAqXG4gICAqIEBwYXJhbSBvdXRwdXRPclVuc3BlbnQgT3V0cHV0IG9yIHVuc3BlbnQgd2hvc2UgZWZmZWN0aXZlIHZhbHVlIHNob3VsZCBiZSBkZXRlcm1pbmVkXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBhY3R1YWwgbnVtYmVyIG9mIHNhdG9zaGlzIHRoYXQgdGhpcyB1bnNwZW50IG9yIG91dHB1dFxuICAgKiAgICAgICAgICAgICAgICAgICB3b3VsZCBjb250cmlidXRlIHRvIGEgdHJhbnNhY3Rpb24sIHdlcmUgaXQgdG8gYmUgdXNlZC5cbiAgICovXG4gIGNvbnN0IGVmZmVjdGl2ZVZhbHVlID0gKG91dHB1dE9yVW5zcGVudCkgPT4ge1xuICAgIGNvbnN0IGNoYWluID0gZ2V0Q2hhaW4ob3V0cHV0T3JVbnNwZW50KTtcbiAgICBpZiAoY2hhaW4gPT09IENvZGVzLnAyc2hQMndzaC5leHRlcm5hbCB8fCBjaGFpbiA9PT0gQ29kZXMucDJzaFAyd3NoLmludGVybmFsKSB7XG4gICAgICAvLyBWaXJ0dWFsU2l6ZXMudHhQMnNoUDJ3c2hJbnB1dFNpemUgaXMgaW4gYnl0ZXMsIHNvIHdlIG5lZWQgdG8gY29udmVydCB0byBrQlxuICAgICAgcmV0dXJuIG91dHB1dE9yVW5zcGVudC52YWx1ZSAtIChWaXJ0dWFsU2l6ZXMudHhQMnNoUDJ3c2hJbnB1dFNpemUgKiBwYXJhbXMuZmVlUmF0ZSAvIDEwMDApO1xuICAgIH1cbiAgICAvLyBWaXJ0dWFsU2l6ZXMudHhQMnNoSW5wdXRTaXplIGlzIGluIGJ5dGVzLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgdG8ga0JcbiAgICByZXR1cm4gb3V0cHV0T3JVbnNwZW50LnZhbHVlIC0gKFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgKiBwYXJhbXMuZmVlUmF0ZSAvIDEwMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb3JvdXRpbmUgd2hpY2ggYWN0dWFsbHkgaW1wbGVtZW50cyB0aGUgYWNjZWxlcmF0ZVRyYW5zYWN0aW9uIGFsZ29yaXRobVxuICAgKlxuICAgKiBEZXNjcmliZWQgYXQgYSBoaWdoIGxldmVsLCB0aGUgYWxnb3JpdGhtIGlzIGFzIGZvbGxvd3M6XG4gICAqIDEpIEZpbmQgYXBwcm9wcmlhdGUgb3V0cHV0IGZyb20gcGFyZW50IHRyYW5zYWN0aW9uIHRvIHVzZSBhcyBjaGlsZCB0cmFuc2FjdGlvbiBpbnB1dFxuICAgKiAyKSBGaW5kIHVuc3BlbnQgY29ycmVzcG9uZGluZyB0byBwYXJlbnQgdHJhbnNhY3Rpb24gb3V0cHV0LiBJZiBub3QgZm91bmQsIHJldHVybiB0byBzdGVwIDEuXG4gICAqIDMpIERldGVybWluZSBpZiBwYXJlbnQgdHJhbnNhY3Rpb24gdW5zcGVudCBjYW4gY292ZXIgZW50aXJlIGNoaWxkIGZlZSwgcGx1cyBtaW5pbXVtIGNoYW5nZVxuICAgKiA0KSBJZiB5ZXMsIGdvIHRvIHN0ZXAgNlxuICAgKiA1KSBPdGhlcndpc2UsIGZpbmQgYWRkaXRpb25hbCB1bnNwZW50cyBmcm9tIHRoZSB3YWxsZXQgdG8gdXNlIHRvIGNvdmVyIHRoZSByZW1haW5pbmcgY2hpbGQgZmVlXG4gICAqIDYpIENyZWF0ZSBhbmQgc2lnbiB0aGUgY2hpbGQgdHJhbnNhY3Rpb24sIHVzaW5nIHRoZSBwYXJlbnQgdHJhbnNhY3Rpb24gb3V0cHV0XG4gICAqICAgIChhbmQsIGlmIG5lY2Vzc2FyeSwgYWRkaXRpb25hbCB3YWxsZXQgdW5zcGVudHMpIGFzIGlucHV0c1xuICAgKiA3KSBCcm9hZGNhc3QgdGhlIG5ldyBjaGlsZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgcmV0dXJuIGNvKGZ1bmN0aW9uICpjb0FjY2VsZXJhdGVUcmFuc2FjdGlvbigpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd0cmFuc2FjdGlvbklEJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICAvLyB2YWxpZGF0ZSBmZWUgcmF0ZVxuICAgIGlmIChwYXJhbXMuZmVlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGFyYW1ldGVyOiBmZWVSYXRlJyk7XG4gICAgfVxuICAgIGlmICghXy5pc0Zpbml0ZShwYXJhbXMuZmVlUmF0ZSkgfHwgcGFyYW1zLmZlZVJhdGUgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgcG9zaXRpdmUgZmluaXRlIG51bWJlciBmb3IgcGFyYW1ldGVyOiBmZWVSYXRlJyk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgbWF4VW5zcGVudHNcbiAgICBpZiAocGFyYW1zLm1heEFkZGl0aW9uYWxVbnNwZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBieSBkZWZhdWx0LCB1c2UgYXQgbW9zdCAxMDAgYWRkaXRpb25hbCB1bnNwZW50cyAobm90IGluY2x1ZGluZyB0aGUgdW5zcGVudCBvdXRwdXQgZnJvbSB0aGUgcGFyZW50IHR4KVxuICAgICAgcGFyYW1zLm1heEFkZGl0aW9uYWxVbnNwZW50cyA9IDEwMDtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5tYXhBZGRpdGlvbmFsVW5zcGVudHMpIHx8IHBhcmFtcy5tYXhBZGRpdGlvbmFsVW5zcGVudHMgPD0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0V4cGVjdGluZyBwb3NpdGl2ZSBpbnRlZ2VyIGZvciBwYXJhbWV0ZXI6IG1heEFkZGl0aW9uYWxVbnNwZW50cycpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFR4ID0geWllbGQgdGhpcy5nZXRUcmFuc2FjdGlvbih7IGlkOiBwYXJhbXMudHJhbnNhY3Rpb25JRCB9KTtcbiAgICBpZiAocGFyZW50VHguY29uZmlybWF0aW9ucyA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHtwYXJhbXMudHJhbnNhY3Rpb25JRH0gaXMgYWxyZWFkeSBjb25maXJtZWQgYW5kIGNhbm5vdCBiZSBhY2NlbGVyYXRlZGApO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgb3V0cHV0cyBmcm9tIHRoZSBwYXJlbnQgdHggd2hpY2ggYXJlIHRvIG91ciB3YWxsZXRcbiAgICBjb25zdCB3YWxsZXRPdXRwdXRzID0gXy5maWx0ZXIocGFyZW50VHgub3V0cHV0cywgKG91dHB1dCkgPT4gb3V0cHV0LmlzTWluZSk7XG5cbiAgICBpZiAod2FsbGV0T3V0cHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHtwYXJhbXMudHJhbnNhY3Rpb25JRH0gY29udGFpbnMgbm8gb3V0cHV0cyB0byB0aGlzIHdhbGxldCwgYW5kIHRodXMgY2Fubm90IGJlIGFjY2VsZXJhdGVkYCk7XG4gICAgfVxuXG4gICAgLy8gdXNlIGFuIG91dHB1dCBmcm9tIHRoZSBwYXJlbnQgd2l0aCBsYXJnZXN0IGVmZmVjdGl2ZSB2YWx1ZSxcbiAgICAvLyBidXQgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBvdXRwdXQgaXMgYWN0dWFsbHkgdW5zcGVudC5cbiAgICAvLyBBbiBvdXRwdXQgY291bGQgYmUgc3BlbnQgYWxyZWFkeSBpZiB0aGUgb3V0cHV0IHdhcyB1c2VkIGluIGFcbiAgICAvLyBjaGlsZCB0eCB3aGljaCBpdHNlbGYgaGFzIGJlY29tZSBzdHVjayBkdWUgdG8gbG93IGZlZXMgYW5kIGlzXG4gICAgLy8gYWxzbyB1bmNvbmZpcm1lZC5cbiAgICBjb25zdCBzb3J0ZWRPdXRwdXRzID0gXy5zb3J0Qnkod2FsbGV0T3V0cHV0cywgZWZmZWN0aXZlVmFsdWUpO1xuICAgIGxldCBwYXJlbnRVbnNwZW50VG9Vc2U7XG4gICAgbGV0IG91dHB1dFRvVXNlO1xuXG4gICAgd2hpbGUgKHNvcnRlZE91dHB1dHMubGVuZ3RoID4gMCAmJiBwYXJlbnRVbnNwZW50VG9Vc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3V0cHV0VG9Vc2UgPSBzb3J0ZWRPdXRwdXRzLnBvcCgpO1xuXG4gICAgICAvLyBmaW5kIHRoZSB1bnNwZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIG91dHB1dFxuICAgICAgLy8gVE9ETzogaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGdldCB0aGlzIHVuc3BlbnQ/XG4gICAgICAvLyBUT0RPOiBUaGUgYmVzdCB3ZSBjYW4gZG8gaGVyZSBpcyBzZXQgbWluU2l6ZSA9IG1heFNpemUgPSBvdXRwdXRUb1VzZS52YWx1ZVxuICAgICAgY29uc3QgdW5zcGVudHNSZXN1bHQgPSB5aWVsZCB0aGlzLnVuc3BlbnRzKHtcbiAgICAgICAgbWluU2l6ZTogb3V0cHV0VG9Vc2UudmFsdWUsXG4gICAgICAgIG1heFNpemU6IG91dHB1dFRvVXNlLnZhbHVlXG4gICAgICB9KTtcblxuICAgICAgcGFyZW50VW5zcGVudFRvVXNlID0gXy5maW5kKHVuc3BlbnRzUmVzdWx0LCAodW5zcGVudCkgPT4ge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdW5zcGVudCBiZWxvbmdzIHRvIHRoZSBnaXZlbiB0eGlkXG4gICAgICAgIGlmICh1bnNwZW50LnR4X2hhc2ggIT09IHBhcmFtcy50cmFuc2FjdGlvbklEKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB1bnNwZW50IGhhcyBjb3JyZWN0IHZfb3V0IGluZGV4XG4gICAgICAgIHJldHVybiB1bnNwZW50LnR4X291dHB1dF9uID09PSBvdXRwdXRUb1VzZS52b3V0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudFVuc3BlbnRUb1VzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHVuc3BlbnQgb3V0cHV0IGZyb20gcGFyZW50IHR4IHRvIHVzZSBhcyBjaGlsZCBpbnB1dGApO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgZnVsbCBoZXggZm9yIHRoZSBwYXJlbnQgdHggYW5kIGRlY29kZSBpdCB0byBnZXQgaXRzIHZzaXplXG4gICAgY29uc3QgcGFyZW50VHhIZXggPSB5aWVsZCBnZXRQYXJlbnRUeEhleCh7IHBhcmVudFR4SWQ6IHBhcmFtcy50cmFuc2FjdGlvbklEIH0pO1xuICAgIGNvbnN0IGRlY29kZWRQYXJlbnQgPSBiaXRjb2luLlRyYW5zYWN0aW9uLmZyb21IZXgocGFyZW50VHhIZXgpO1xuICAgIGNvbnN0IHBhcmVudFZTaXplID0gZGVjb2RlZFBhcmVudC52aXJ0dWFsU2l6ZSgpO1xuXG4gICAgLy8gbWFrZSBzdXJlIGlkIGZyb20gZGVjb2RlZCB0eCBhbmQgZ2l2ZW4gdHggaWQgbWF0Y2hcbiAgICAvLyB0aGlzIHNob3VsZCBjYXRjaCBwcm9ibGVtcyBlbWFuYXRpbmcgZnJvbSB0aGUgdXNlIG9mIGFuIGV4dGVybmFsIHNlcnZpY2VcbiAgICAvLyBmb3IgZ2V0dGluZyB0aGUgY29tcGxldGUgcGFyZW50IHR4IGhleFxuICAgIGlmIChkZWNvZGVkUGFyZW50LmdldElkKCkgIT09IHBhcmFtcy50cmFuc2FjdGlvbklEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERlY29kZWQgdHJhbnNhY3Rpb24gaWQgaXMgJHtkZWNvZGVkUGFyZW50LmdldElkKCl9LCB3aGljaCBkb2VzIG5vdCBtYXRjaCBnaXZlbiB0eGlkICR7cGFyYW1zLnRyYW5zYWN0aW9uSUR9YCk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIG5ldyBmZWUgcmF0ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHBhcmVudCdzIGN1cnJlbnQgZmVlIHJhdGVcbiAgICAvLyB2aXJ0dWFsU2l6ZSBpcyByZXR1cm5lZCBpbiB2Ynl0ZXMsIHNvIHdlIG5lZWQgdG8gY29udmVydCB0byBrdkJcbiAgICBjb25zdCBwYXJlbnRSYXRlID0gMTAwMCAqIHBhcmVudFR4LmZlZSAvIHBhcmVudFZTaXplO1xuICAgIGlmIChwYXJhbXMuZmVlUmF0ZSA8PSBwYXJlbnRSYXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBsb3dlciBmZWUgcmF0ZSEgKFBhcmVudCB0eCBmZWUgcmF0ZSBpcyAke3BhcmVudFJhdGV9IHNhdC9rQiwgYW5kIHJlcXVlc3RlZCBmZWUgcmF0ZSB3YXMgJHtwYXJhbXMuZmVlUmF0ZX0gc2F0L2tCKWApO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBpZiBwYXJlbnQgb3V0cHV0IGNhbiBjb3ZlciBjaGlsZCBmZWVcbiAgICBjb25zdCBpc1BhcmVudE91dHB1dFNlZ3dpdCA9XG4gICAgICBvdXRwdXRUb1VzZS5jaGFpbiA9PT0gQ29kZXMucDJzaFAyd3NoLmV4dGVybmFsIHx8XG4gICAgICBvdXRwdXRUb1VzZS5jaGFpbiA9PT0gQ29kZXMucDJzaFAyd3NoLmludGVybmFsO1xuXG4gICAgbGV0IGNoaWxkSW5wdXRzID0ge1xuICAgICAgc2Vnd2l0OiBpc1BhcmVudE91dHB1dFNlZ3dpdCA/IDEgOiAwLFxuICAgICAgUDJTSDogaXNQYXJlbnRPdXRwdXRTZWd3aXQgPyAwIDogMVxuICAgIH07XG5cbiAgICBsZXQgY2hpbGRGZWUgPSBlc3RpbWF0ZUNoaWxkRmVlKHtcbiAgICAgIGlucHV0czogY2hpbGRJbnB1dHMsXG4gICAgICBwYXJlbnRGZWU6IHBhcmVudFR4LmZlZSxcbiAgICAgIGZlZVJhdGU6IHBhcmFtcy5mZWVSYXRlLFxuICAgICAgcGFyZW50VlNpemVcbiAgICB9KTtcblxuICAgIGNvbnN0IHVuc3BlbnRzVG9Vc2UgPSBbcGFyZW50VW5zcGVudFRvVXNlXTtcblxuICAgIC8vIHRyeSB0byBnZXQgdGhlIG1pbiBjaGFuZ2Ugc2l6ZSBmcm9tIHRoZSBzZXJ2ZXIsIG90aGVyd2lzZSBkZWZhdWx0IHRvIDAuMSBCVENcbiAgICAvLyBUT0RPOiBtaW5DaGFuZ2VTaXplIGlzIG5vdCBjdXJyZW50bHkgYSBjb25zdGFudCBkZWZpbmVkIG9uIHRoZSBjbGllbnQgYW5kIHNob3VsZCBiZSBhZGRlZFxuICAgIGNvbnN0IG1pbkNoYW5nZVNpemUgPSB0aGlzLmJpdGdvLmdldENvbnN0YW50cygpLm1pbkNoYW5nZVNpemUgfHwgMWU3O1xuXG4gICAgaWYgKG91dHB1dFRvVXNlLnZhbHVlIDwgY2hpbGRGZWUgKyBtaW5DaGFuZ2VTaXplKSB7XG4gICAgICAvLyBwYXJlbnQgb3V0cHV0IGNhbm5vdCBjb3ZlciBjaGlsZCBmZWUgcGx1cyB0aGUgbWluaW11bSBjaGFuZ2UsXG4gICAgICAvLyBtdXN0IGZpbmQgYWRkaXRpb25hbCB1bnNwZW50cyB0byBjb3ZlciB0aGUgZGlmZmVyZW5jZVxuICAgICAgY29uc3QgeyBhZGRpdGlvbmFsLCBuZXdDaGlsZEZlZSwgbmV3SW5wdXRzIH0gPSB5aWVsZCBmaW5kQWRkaXRpb25hbFVuc3BlbnRzKHtcbiAgICAgICAgaW5wdXRzOiBjaGlsZElucHV0cyxcbiAgICAgICAgcGFyZW50T3V0cHV0VmFsdWU6IG91dHB1dFRvVXNlLnZhbHVlLFxuICAgICAgICBwYXJlbnRGZWU6IHBhcmVudFR4LmZlZSxcbiAgICAgICAgbWF4VW5zcGVudHM6IHBhcmFtcy5tYXhBZGRpdGlvbmFsVW5zcGVudHMsXG4gICAgICAgIHBhcmVudFZTaXplXG4gICAgICB9KTtcbiAgICAgIGNoaWxkRmVlID0gbmV3Q2hpbGRGZWU7XG4gICAgICBjaGlsZElucHV0cyA9IG5ld0lucHV0cztcbiAgICAgIHVuc3BlbnRzVG9Vc2UucHVzaCguLi4gYWRkaXRpb25hbCk7XG4gICAgfVxuXG4gICAgLy8gc2FuaXR5IGNoZWNrIHRoZSBmZWUgcmF0ZSB3ZSdyZSBwYXlpbmcgZm9yIHRoZSBjb21iaW5lZCB0eFxuICAgIC8vIHRvIG1ha2Ugc3VyZSBpdCdzIHVuZGVyIHRoZSBtYXggZmVlIHJhdGUuIE9ubHkgdGhlIGNoaWxkIHR4XG4gICAgLy8gY2FuIGJyZWFrIHRoaXMgbGltaXQsIGJ1dCB0aGUgY29tYmluZWQgdHggc2hhbGwgbm90XG4gICAgY29uc3QgbWF4RmVlUmF0ZSA9IHRoaXMuYml0Z28uZ2V0Q29uc3RhbnRzKCkubWF4RmVlUmF0ZTtcbiAgICBjb25zdCBjaGlsZFZTaXplID0gZXN0aW1hdGVUeFZTaXplKGNoaWxkSW5wdXRzKTtcbiAgICBjb25zdCBjb21iaW5lZFZTaXplID0gY2hpbGRWU2l6ZSArIHBhcmVudFZTaXplO1xuICAgIGNvbnN0IGNvbWJpbmVkRmVlID0gcGFyZW50VHguZmVlICsgY2hpbGRGZWU7XG4gICAgLy8gY29tYmluZWQgZmVlIHJhdGUgbXVzdCBiZSBpbiBzYXQva0IsIHNvIHdlIG5lZWQgdG8gY29udmVydFxuICAgIGNvbnN0IGNvbWJpbmVkRmVlUmF0ZSA9IDEwMDAgKiBjb21iaW5lZEZlZSAvIGNvbWJpbmVkVlNpemU7XG5cbiAgICBpZiAoY29tYmluZWRGZWVSYXRlID4gbWF4RmVlUmF0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBjYW5ub3QgYmUgYWNjZWxlcmF0ZWQuIENvbWJpbmVkIGZlZSByYXRlIG9mICR7Y29tYmluZWRGZWVSYXRlfSBzYXQva0IgZXhjZWVkcyBtYXhpbXVtIGZlZSByYXRlIG9mICR7bWF4RmVlUmF0ZX0gc2F0L2tCYCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgbmV3IGNoYW5nZSBhZGRyZXNzIGFuZCBkZXRlcm1pbmUgY2hhbmdlIGFtb3VudC5cbiAgICAvLyB0aGUgdHggYnVpbGRlciB3aWxsIHJlamVjdCB0cmFuc2FjdGlvbnMgd2hpY2ggaGF2ZSBubyByZWNpcGllbnRzLFxuICAgIC8vIGFuZCBzdWNoIHplcm8tb3V0cHV0IHRyYW5zYWN0aW9ucyBhcmUgZm9yYmlkZGVuIGJ5IHRoZSBCaXRjb2luIHByb3RvY29sLFxuICAgIC8vIHNvIHdlIG5lZWQgYXQgbGVhc3QgYSBzaW5nbGUgcmVjaXBpZW50IGZvciB0aGUgY2hhbmdlIHdoaWNoIHdvbid0IGJlIHBydW5lZC5cbiAgICBjb25zdCBjaGFuZ2VBbW91bnQgPSBfLnN1bUJ5KHVuc3BlbnRzVG9Vc2UsICh1bnNwZW50KSA9PiB1bnNwZW50LnZhbHVlKSAtIGNoaWxkRmVlO1xuICAgIGNvbnN0IGNoYW5nZUNoYWluID0gdGhpcy5nZXRDaGFuZ2VDaGFpbih7fSk7XG4gICAgY29uc3QgY2hhbmdlQWRkcmVzcyA9IHlpZWxkIHRoaXMuY3JlYXRlQWRkcmVzcyh7IGNoYWluOiBjaGFuZ2VDaGFpbiB9KTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgY2hpbGQgdHggYW5kIGJyb2FkY2FzdFxuICAgIGNvbnN0IHR4ID0geWllbGQgdGhpcy5jcmVhdGVBbmRTaWduVHJhbnNhY3Rpb24oe1xuICAgICAgdW5zcGVudHM6IHVuc3BlbnRzVG9Vc2UsXG4gICAgICByZWNpcGllbnRzOiBbe1xuICAgICAgICBhZGRyZXNzOiBjaGFuZ2VBZGRyZXNzLmFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogY2hhbmdlQW1vdW50XG4gICAgICB9XSxcbiAgICAgIGZlZTogY2hpbGRGZWUsXG4gICAgICBiaXRnb0ZlZToge1xuICAgICAgICBhbW91bnQ6IDAsXG4gICAgICAgIGFkZHJlc3M6ICcnXG4gICAgICB9LFxuICAgICAgeHBydjogcGFyYW1zLnhwcnYsXG4gICAgICB3YWxsZXRQYXNzcGhyYXNlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZVxuICAgIH0pO1xuXG5cbiAgICAvLyBjaGlsZCBmZWUgcmF0ZSBtdXN0IGJlIGluIHNhdC9rQiwgc28gd2UgbmVlZCB0byBjb252ZXJ0XG4gICAgY29uc3QgY2hpbGRGZWVSYXRlID0gMTAwMCAqIGNoaWxkRmVlIC8gY2hpbGRWU2l6ZTtcbiAgICBpZiAoY2hpbGRGZWVSYXRlID4gbWF4RmVlUmF0ZSkge1xuICAgICAgLy8gY29tYmluZWQgdHggaXMgd2l0aGluIG1heCBmZWUgcmF0ZSBsaW1pdHMsIGJ1dCB0aGUgY2hpbGQgdHggaXMgbm90LlxuICAgICAgLy8gaW4gdGhpcyBjYXNlLCB3ZSBuZWVkIHRvIHVzZSB0aGUgaWdub3JlTWF4RmVlUmF0ZSBmbGFnIHRvIGdldCB0aGUgY2hpbGQgdHggdG8gYmUgYWNjZXB0ZWRcbiAgICAgIHR4Lmlnbm9yZU1heEZlZVJhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNlbmRUcmFuc2FjdGlvbih0eCk7XG4gIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uXG4vLyBJTlRFUk5BTCBmdW5jdGlvbiB0byBjcmVhdGUgYW5kIHNpZ24gYSB0cmFuc2FjdGlvblxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAgIHJlY2lwaWVudHMgLSBhcnJheSBvZiB7IGFkZHJlc3MsIGFtb3VudCB9IHRvIHNlbmQgdG9cbi8vICAgd2FsbGV0UGFzc3BocmFzZSAtIHRoZSBwYXNzcGhyYXNlIHRvIGJlIHVzZWQgdG8gZGVjcnlwdCB0aGUgdXNlciBrZXkgb24gdGhpcyB3YWxsZXRcbi8vICAgKFNlZSB0cmFuc2FjdGlvbkJ1aWxkZXIuY3JlYXRlVHJhbnNhY3Rpb24gZm9yIG90aGVyIHBhc3N0aHJvdWdoIHBhcmFtcylcbi8vIFJldHVybnM6XG4vL1xuV2FsbGV0LnByb3RvdHlwZS5jcmVhdGVBbmRTaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMucmVjaXBpZW50cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHJlY2lwaWVudHMgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5mZWUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmZlZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgZmVlIC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5mZWVSYXRlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5mZWVSYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBmZWVSYXRlIC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5keW5hbWljRmVlQ29uZmlybVRhcmdldCAmJiAhXy5pc051bWJlcihwYXJhbXMuZHluYW1pY0ZlZUNvbmZpcm1UYXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGNvbmZpcm1UYXJnZXQgLSBudW1iZXIgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmluc3RhbnQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5pbnN0YW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBpbnN0YW50IC0gYm9vbGVhbiBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0geWllbGQgdGhpcy5jcmVhdGVUcmFuc2FjdGlvbihwYXJhbXMpO1xuICAgIGNvbnN0IGZlZSA9IHRyYW5zYWN0aW9uLmZlZTtcbiAgICBjb25zdCBmZWVSYXRlID0gdHJhbnNhY3Rpb24uZmVlUmF0ZTtcbiAgICBjb25zdCBlc3RpbWF0ZWRTaXplID0gdHJhbnNhY3Rpb24uZXN0aW1hdGVkU2l6ZTtcbiAgICBjb25zdCBiaXRnb0ZlZSA9IHRyYW5zYWN0aW9uLmJpdGdvRmVlO1xuICAgIGNvbnN0IHRyYXZlbEluZm9zID0gdHJhbnNhY3Rpb24udHJhdmVsSW5mb3M7XG4gICAgY29uc3QgdW5zcGVudHMgPSB0cmFuc2FjdGlvbi51bnNwZW50cztcblxuICAgIC8vIFNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleWNoYWluID0geWllbGQgdGhpcy5nZXRBbmRQcmVwYXJlU2lnbmluZ0tleWNoYWluKHBhcmFtcyk7XG4gICAgICB0cmFuc2FjdGlvbi5rZXljaGFpbiA9IGtleWNoYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdub19lbmNyeXB0ZWRfa2V5Y2hhaW5fb25fd2FsbGV0Jykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBtaWdodCBiZSBhIHNhZmUgd2FsbGV0LCBzbyBsZXQncyByZXRyaWV2ZSB0aGUgcHJpdmF0ZSBrZXkgaW5mb1xuICAgICAgeWllbGQgdGhpcy5yZWZyZXNoKHsgZ3BrOiB0cnVlIH0pO1xuICAgICAgY29uc3Qgc2FmZVVzZXJLZXkgPSBfLmdldCh0aGlzLndhbGxldCwgJ3ByaXZhdGUudXNlclByaXZLZXknKTtcbiAgICAgIGlmIChfLmlzU3RyaW5nKHNhZmVVc2VyS2V5KSAmJiBfLmlzU3RyaW5nKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSkge1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduaW5nS2V5ID0gdGhpcy5iaXRnby5kZWNyeXB0KHsgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLCBpbnB1dDogc2FmZVVzZXJLZXkgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYW5zYWN0aW9uLmZlZVNpbmdsZUtleVdJRiA9IHBhcmFtcy5mZWVTaW5nbGVLZXlXSUY7XG4gICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiBfLmV4dGVuZChyZXN1bHQsIHtcbiAgICAgIGZlZSxcbiAgICAgIGZlZVJhdGUsXG4gICAgICBpbnN0YW50OiBwYXJhbXMuaW5zdGFudCxcbiAgICAgIGJpdGdvRmVlLFxuICAgICAgdHJhdmVsSW5mb3MsXG4gICAgICBlc3RpbWF0ZWRTaXplLFxuICAgICAgdW5zcGVudHNcbiAgICB9KTtcbiAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBnZXRBbmRQcmVwYXJlU2lnbmluZ0tleWNoYWluXG4vLyBJTlRFUk5BTCBmdW5jdGlvbiB0byBnZXQgdGhlIHVzZXIga2V5Y2hhaW4gZm9yIHNpZ25pbmcuXG4vLyBDYWxsZXIgbXVzdCBwcm92aWRlciBlaXRoZXIgYSBrZXljaGFpbiwgb3Igd2FsbGV0UGFzc3BocmFzZSBvciB4cHJ2IGFzIGEgc3RyaW5nXG4vLyBJZiB0aGUgY2FsbGVyIHByb3ZpZGVzIHRoZSBrZXljaGFpbiB3aXRoIHhwcnYsIGl0IGlzIHNpbXBseSByZXR1cm5lZC5cbi8vIElmIHRoZSBjYWxsZXIgcHJvdmlkZXMgdGhlIGVuY3J5cHRlZCB4cHJ2ICh3YWxsZXRQYXNzcGhyYXNlKSwgdGhlbiBmZXRjaCB0aGUga2V5Y2hhaW4gb2JqZWN0IGFuZCBkZWNyeXB0XG4vLyBPdGhlcndpc2UgaWYgdGhlIHhwcnYgaXMgcHJvdmlkZWQsIGZldGNoIHRoZSBrZXljaGFpbiBvYmplY3QgYW5kIGF1Z21lbnQgaXQgd2l0aCB0aGUgeHBydi5cbi8vXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICBrZXljaGFpbiAtIGtleWNoYWluIHdpdGggeHBydlxuLy8gICB4cHJ2IC0gdGhlIHByaXZhdGUga2V5IGluIHN0cmluZyBmb3JtXG4vLyAgIHdhbGxldFBhc3NwaHJhc2UgLSB0aGUgcGFzc3BocmFzZSB0byBiZSB1c2VkIHRvIGRlY3J5cHQgdGhlIHVzZXIga2V5IG9uIHRoaXMgd2FsbGV0XG4vLyBSZXR1cm5zOlxuLy8gICBLZXljaGFpbiBvYmplY3QgY29udGFpbmluZyB4cHJ2LCB4cHViIGFuZCBwYXRoc1xuLy9cbldhbGxldC5wcm90b3R5cGUuZ2V0QW5kUHJlcGFyZVNpZ25pbmdLZXljaGFpbiA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIC8vIElmIGtleWNoYWluIHdpdGggeHBydiBpcyBhbHJlYWR5IHByb3ZpZGVkLCB1c2UgaXRcbiAgaWYgKF8uaXNPYmplY3QocGFyYW1zLmtleWNoYWluKSAmJiBwYXJhbXMua2V5Y2hhaW4ueHBydikge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHBhcmFtcy5rZXljaGFpbik7XG4gIH1cblxuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3hwcnYnXSwgY2FsbGJhY2spO1xuXG4gIGlmICgocGFyYW1zLndhbGxldFBhc3NwaHJhc2UgJiYgcGFyYW1zLnhwcnYpIHx8ICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgJiYgIXBhcmFtcy54cHJ2KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGV4YWN0bHkgb25lIG9mIHhwcnYgb3Igd2FsbGV0UGFzc3BocmFzZScpO1xuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgLy8gQ2FsbGVyIHByb3ZpZGVkIGEgd2FsbGV0IHBhc3NwaHJhc2VcbiAgaWYgKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgcmV0dXJuIHNlbGYuZ2V0RW5jcnlwdGVkVXNlcktleWNoYWluKClcbiAgICAudGhlbihmdW5jdGlvbihrZXljaGFpbikge1xuICAgICAgLy8gRGVjcnlwdCB0aGUgdXNlciBrZXkgd2l0aCBhIHBhc3NwaHJhc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGtleWNoYWluLnhwcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoeyBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsIGlucHV0OiBrZXljaGFpbi5lbmNyeXB0ZWRYcHJ2IH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNyeXB0IHVzZXIga2V5Y2hhaW4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXljaGFpbjtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENhbGxlciBwcm92aWRlZCBhbiB4cHJ2IC0gdmFsaWRhdGUgYW5kIGNvbnN0cnVjdCBrZXljaGFpbiBvYmplY3RcbiAgbGV0IHhwdWI7XG4gIHRyeSB7XG4gICAgeHB1YiA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgocGFyYW1zLnhwcnYpLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIHRoZSB4cHJ2Jyk7XG4gIH1cblxuICBpZiAoeHB1YiA9PT0gcGFyYW1zLnhwcnYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3hwcnYgcHJvdmlkZWQgd2FzIG5vdCBhIHByaXZhdGUga2V5IChmb3VuZCB4cHViIGluc3RlYWQpJyk7XG4gIH1cblxuICBjb25zdCB3YWxsZXRYcHVicyA9IF8ubWFwKHNlbGYua2V5Y2hhaW5zLCAneHB1YicpO1xuICBpZiAoIV8uaW5jbHVkZXMod2FsbGV0WHB1YnMsIHhwdWIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd4cHJ2IHByb3ZpZGVkIHdhcyBub3QgYSBrZXljaGFpbiBvbiB0aGlzIHdhbGxldCEnKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUga2V5Y2hhaW4gb2JqZWN0IGZyb20gYml0Z28gdG8gZmluZCB0aGUgcGF0aCBhbmQgKHBvdGVudGlhbCkgd2FsbGV0IHN0cnVjdHVyZVxuICByZXR1cm4gc2VsZi5iaXRnby5rZXljaGFpbnMoKS5nZXQoeyB4cHViOiB4cHViIH0pXG4gIC50aGVuKGZ1bmN0aW9uKGtleWNoYWluKSB7XG4gICAga2V5Y2hhaW4ueHBydiA9IHBhcmFtcy54cHJ2O1xuICAgIHJldHVybiBrZXljaGFpbjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgd2FsbGV0J3MgdW5zcGVudHMgYW5kIGZhbnMgdGhlbSBvdXQgaW50byBhIGxhcmdlciBudW1iZXIgb2YgZXF1YWxseSBzaXplZCB1bnNwZW50c1xuICogQHBhcmFtIHBhcmFtc1xuICogIHRhcmdldDogc2V0IGhvdyBtYW55IHVuc3BlbnRzIHlvdSB3YW50IHRvIGhhdmUgaW4gdGhlIGVuZFxuICogIG1pbkNvbmZpcm1zOiBtaW5pbXVtIG51bWJlciBvZiBjb25maXJtcyB0aGUgdW5zcGVudHMgbXVzdCBoYXZlXG4gKiAgeHBydjogcHJpdmF0ZSBrZXkgdG8gc2lnbiB0cmFuc2FjdGlvblxuICogIHdhbGxldFBhc3NwaHJhc2U6IHdhbGxldCBwYXNzcGhyYXNlIHRvIGRlY3J5cHQgdGhlIHdhbGxldCdzIHByaXZhdGUga2V5XG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHsqfVxuICovXG5XYWxsZXQucHJvdG90eXBlLmZhbk91dFVuc3BlbnRzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgcmV0dXJuIEJsdWViaXJkLmNvcm91dGluZShmdW5jdGlvbiAqKCkge1xuICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGlucHV0cyBmb3IgZmFub3V0IHRyYW5zYWN0aW9uXG4gICAgLy8gKHdoZW4gZmFubmluZyBvdXQsIHdlIHRha2UgYWxsIHRoZSB1bnNwZW50cyBhbmQgbWFrZSBhIGJpZ2dlciBudW1iZXIgb2Ygb3V0cHV0cylcbiAgICBjb25zdCBNQVhfRkFOT1VUX0lOUFVUX0NPVU5UID0gODA7XG4gICAgLy8gbWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgZmFub3V0IHRyYW5zYWN0aW9uXG4gICAgY29uc3QgTUFYX0ZBTk9VVF9PVVRQVVRfQ09VTlQgPSAzMDA7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAneHBydiddLCBjYWxsYmFjayk7XG4gICAgY29uc3QgdmFsaWRhdGUgPSBwYXJhbXMudmFsaWRhdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMudmFsaWRhdGU7XG5cbiAgICBjb25zdCB0YXJnZXQgPSBwYXJhbXMudGFyZ2V0O1xuICAgIC8vIHRoZSB0YXJnZXQgbXVzdCBiZSBkZWZpbmVkLCBiZSBhIG51bWJlciwgYmUgYXQgbGVhc3QgdHdvLCBhbmQgYmUgYSBuYXR1cmFsIG51bWJlclxuICAgIGlmICghXy5pc051bWJlcih0YXJnZXQpIHx8IHRhcmdldCA8IDIgfHwgKHRhcmdldCAlIDEpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBuZWVkcyB0byBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA+IE1BWF9GQU5PVVRfT1VUUFVUX0NPVU5UKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbiBvdXQgdGFyZ2V0IHRvbyBoaWdoJyk7XG4gICAgfVxuXG4gICAgbGV0IG1pbkNvbmZpcm1zID0gcGFyYW1zLm1pbkNvbmZpcm1zO1xuICAgIGlmIChtaW5Db25maXJtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5Db25maXJtcyA9IDE7XG4gICAgfVxuICAgIGlmICghXy5pc051bWJlcihtaW5Db25maXJtcykgfHwgbWluQ29uZmlybXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbkNvbmZpcm1zIG5lZWRzIHRvIGJlIGFuIGludGVnZXIgPj0gMCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgbmF0dXJhbCBudW1iZXIgTiBpbnRvIG4gYWxtb3N0IGVxdWFsbHkgc2l6ZWQgKMKxMSkgbmF0dXJhbCBudW1iZXJzLlxuICAgICAqIEluIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgc2l6ZXMgb2YgdGhlIHBhcnRzLCB3ZSBjYWxjdWxhdGUgZmxvb3IoTi9uKSwgYW5kIHRodXMgaGF2ZSB0aGUgYmFzZSBzaXplIG9mIGFsbCBwYXJ0cy5cbiAgICAgKiBJZiBOICUgbiAhPT0gMCwgdGhpcyBsZWF2ZXMgdXMgd2l0aCBhIHJlbWFpbmRlciByIHdoZXJlIHIgPCBuLiBXZSBkaXN0cmlidXRlIHIgZXF1YWxseSBhbW9uZyB0aGUgbiBwYXJ0cyBieVxuICAgICAqIGFkZGluZyAxIHRvIHRoZSBmaXJzdCByIHBhcnRzLlxuICAgICAqIEBwYXJhbSB0b3RhbFxuICAgICAqIEBwYXJhbSBwYXJ0Q291bnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgY29uc3Qgc3BsaXROdW1iZXJJbnRvQ2xvc2VOYXR1cmFsTnVtYmVycyA9IGZ1bmN0aW9uKHRvdGFsLCBwYXJ0Q291bnQpIHtcbiAgICAgIGNvbnN0IHBhcnRTaXplID0gTWF0aC5mbG9vcih0b3RhbCAvIHBhcnRDb3VudCk7XG4gICAgICBjb25zdCByZW1haW5kZXIgPSB0b3RhbCAtIHBhcnRTaXplICogcGFydENvdW50O1xuICAgICAgLy8gaW5pdGlhbGl6ZSBwbGFjZWhvbGRlciBhcnJheVxuICAgICAgY29uc3QgYWxtb3N0RXF1YWxQYXJ0cyA9IG5ldyBBcnJheShwYXJ0Q291bnQpO1xuICAgICAgLy8gZmlsbCB0aGUgZmlyc3QgcmVtYWluZGVyIHBhcnRzIHdpdGggdGhlIHZhbHVlIHBhcnRTaXplKzFcbiAgICAgIF8uZmlsbChhbG1vc3RFcXVhbFBhcnRzLCBwYXJ0U2l6ZSArIDEsIDAsIHJlbWFpbmRlcik7XG4gICAgICAvLyBmaWxsIHRoZSByZW1haW5pbmcgcGFydHMgd2l0aCB0aGUgdmFsdWUgcGFydFNpemVcbiAgICAgIF8uZmlsbChhbG1vc3RFcXVhbFBhcnRzLCBwYXJ0U2l6ZSwgcmVtYWluZGVyKTtcbiAgICAgIC8vIGFzc2VydCB0aGUgY29ycmVjdG5lc3Mgb2YgdGhlIGFsbW9zdCBlcXVhbCBwYXJ0c1xuICAgICAgLy8gVE9ETzogYWRkIGNoZWNrIGZvciB0aGUgYmlnZ2VzdCBkZXZpYXRpb24gYmV0d2VlbiBhbnkgdHdvIHBhcnRzIGFuZCBtYWtlIHN1cmUgaXQncyA8PSAxXG4gICAgICBpZiAoXyhhbG1vc3RFcXVhbFBhcnRzKS5zdW0oKSAhPT0gdG90YWwgfHwgXyhhbG1vc3RFcXVhbFBhcnRzKS5zaXplKCkgIT09IHBhcnRDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnQgc3VtIG9yIHBhcnQgY291bnQgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbG1vc3RFcXVhbFBhcnRzO1xuICAgIH07XG5cbiAgICAvLyBmaXJzdCwgbGV0J3MgdGFrZSBhbGwgdGhlIHdhbGxldCdzIHVuc3BlbnRzICh3aXRoIG1pbiBjb25maXJtcyBpZiBuZWNlc3NhcnkpXG4gICAgY29uc3QgYWxsVW5zcGVudHMgPSB5aWVsZCBzZWxmLnVuc3BlbnRzKHsgbWluQ29uZmlybXM6IG1pbkNvbmZpcm1zIH0pO1xuICAgIGlmIChhbGxVbnNwZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVuc3BlbnRzIHRvIGJyYW5jaCBvdXQnKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGNvbnNvbGlkYXRpb24gaXMgZXNzZW50aWFsbHkganVzdCBhIHdhc3RlIG9mIG1vbmV5XG4gICAgaWYgKGFsbFVuc3BlbnRzLmxlbmd0aCA+PSB0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFuIG91dCB0YXJnZXQgaGFzIHRvIGJlIGJpZ2dlciB0aGFuIGN1cnJlbnQgbnVtYmVyIG9mIHVuc3BlbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gd2UgaGF2ZSBhdCB0aGUgdmVyeSBtaW5pbXVtIDgxIGlucHV0cywgYW5kIDgxIG91dHB1dHMuIFRoYXQgdHJhbnNhY3Rpb24gd2lsbCBiZSBiaWdcbiAgICAvLyBpbiB0aGUgbWVkaXVtIHJ1biwgdGhpcyBhbGdvcml0aG0gY291bGQgYmUgcmV3b3JrZWQgdG8gb25seSB3b3JrIHdpdGggYSBzdWJzZXQgb2YgdGhlIHRyYW5zYWN0aW9uc1xuICAgIGlmIChhbGxVbnNwZW50cy5sZW5ndGggPiBNQVhfRkFOT1VUX0lOUFVUX0NPVU5UKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHVuc3BlbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBhbGwgdGhlIG1vbmV5IHRoYXQgaXMgY3VycmVudGx5IGluIHRoZSB3YWxsZXRcbiAgICBjb25zdCBncm9zc0Ftb3VudCA9IF8oYWxsVW5zcGVudHMpLm1hcCgndmFsdWUnKS5zdW0oKTtcblxuICAgIC8vIGluIG9yZGVyIHRvIG5vdCBtb2RpZnkgdGhlIHBhcmFtcyBvYmplY3QsIHdlIGNyZWF0ZSBhIGNvcHlcbiAgICBjb25zdCB0eFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICAgIHR4UGFyYW1zLnVuc3BlbnRzID0gYWxsVW5zcGVudHM7XG4gICAgdHhQYXJhbXMucmVjaXBpZW50cyA9IHt9O1xuXG4gICAgLy8gY3JlYXRlIHRhcmdldCBhbW91bnQgb2YgbmV3IGFkZHJlc3NlcyBmb3IgdGhpcyB3YWxsZXRcbiAgICBjb25zdCBuZXdBZGRyZXNzUHJvbWlzZXMgPSBfLnJhbmdlKHRhcmdldClcbiAgICAubWFwKCgpID0+IHNlbGYuY3JlYXRlQWRkcmVzcyh7IGNoYWluOiBzZWxmLmdldENoYW5nZUNoYWluKHBhcmFtcyksIHZhbGlkYXRlOiB2YWxpZGF0ZSB9KSk7XG4gICAgY29uc3QgbmV3QWRkcmVzc2VzID0geWllbGQgQmx1ZWJpcmQuYWxsKG5ld0FkZHJlc3NQcm9taXNlcyk7XG4gICAgLy8gbGV0J3MgZmluZCBhIG5pY2UsIGVxdWFsIGRpc3RyaWJ1dGlvbiBvZiBvdXIgU2F0b3NoaXMgYW1vbmcgdGhlIG5ldyBhZGRyZXNzZXNcbiAgICBjb25zdCBzcGxpdEFtb3VudHMgPSBzcGxpdE51bWJlckludG9DbG9zZU5hdHVyYWxOdW1iZXJzKGdyb3NzQW1vdW50LCB0YXJnZXQpO1xuICAgIC8vIG1hcCB0aGUgbmV3bHkgY3JlYXRlZCBhZGRyZXNzZXMgdG8gdGhlIGFsbW9zdCBjb21wb25lbnRzIGFtb3VudHMgd2UganVzdCBjYWxjdWxhdGVkXG4gICAgdHhQYXJhbXMucmVjaXBpZW50cyA9IF8uemlwT2JqZWN0KF8ubWFwKG5ld0FkZHJlc3NlcywgJ2FkZHJlc3MnKSwgc3BsaXRBbW91bnRzKTtcbiAgICB0eFBhcmFtcy5ub1NwbGl0Q2hhbmdlID0gdHJ1ZTtcbiAgICAvLyBhdHRlbXB0IHRvIGNyZWF0ZSBhIHRyYW5zYWN0aW9uLiBBcyBpdCBpcyBhIHdhbGxldC1zd2VlcGluZyB0cmFuc2FjdGlvbiB3aXRoIG5vIGZlZSwgd2UgZXhwZWN0IGl0IHRvIGZhaWxcbiAgICB0cnkge1xuICAgICAgeWllbGQgc2VsZi5zZW5kTWFueSh0eFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGFzIGV4cGVjdGVkLCB0aGUgdHJhbnNhY3Rpb24gY3JlYXRpb24gZGlkIGluZGVlZCBmYWlsIGR1ZSB0byBpbnN1ZmZpY2llbnQgZmVlc1xuICAgICAgLy8gdGhlIGVycm9yIHN1Z2dlc3RzIGEgZmVlIHZhbHVlIHdoaWNoIHdlIHRoZW4gdXNlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAgIC8vIGhvd2V2ZXIsIGxldCdzIG1ha2Ugc3VyZSBpdCB3YXNuJ3Qgc29tZXRoaW5nIGVsc2VcbiAgICAgIGlmICghZXJyb3IuZmVlICYmICghZXJyb3IucmVzdWx0IHx8ICFlcnJvci5yZXN1bHQuZmVlKSkge1xuICAgICAgICAvLyBpZiB0aGUgZXJyb3IgZG9lcyBub3QgY29udGFpbiBhIGZlZSBwcm9wZXJ0eSwgaXQgaXMgc29tZXRoaW5nIGVsc2UgdGhhdCBoYXMgZ29uZSBhd3J5LCBhbmQgd2UgdGhyb3cgaXRcbiAgICAgICAgY29uc3QgZGVidWdQYXJhbXMgPSBfLm9taXQodHhQYXJhbXMsIFsnd2FsbGV0UGFzc3BocmFzZScsICd4cHJ2J10pO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGBcXG5cXG5UWCBQQVJBTVM6XFxuICR7SlNPTi5zdHJpbmdpZnkoZGVidWdQYXJhbXMsIG51bGwsIDQpfWA7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFzZUZlZSA9IGVycm9yLmZlZSB8fCBlcnJvci5yZXN1bHQuZmVlO1xuICAgICAgbGV0IHRvdGFsRmVlID0gYmFzZUZlZTtcbiAgICAgIGlmIChlcnJvci5yZXN1bHQuYml0Z29GZWUgJiYgZXJyb3IucmVzdWx0LmJpdGdvRmVlLmFtb3VudCkge1xuICAgICAgICB0b3RhbEZlZSArPSBlcnJvci5yZXN1bHQuYml0Z29GZWUuYW1vdW50O1xuICAgICAgICB0eFBhcmFtcy5iaXRnb0ZlZSA9IGVycm9yLnJlc3VsdC5iaXRnb0ZlZTtcbiAgICAgIH1cblxuICAgICAgLy8gTmVlZCB0byBjbGVhciB0aGVzZSBvdXQgc2luY2Ugb25seSAxIG1heSBiZSBzZXRcbiAgICAgIGRlbGV0ZSB0eFBhcmFtcy5mZWU7XG4gICAgICB0eFBhcmFtcy5vcmlnaW5hbEZlZVJhdGUgPSB0eFBhcmFtcy5mZWVSYXRlO1xuICAgICAgZGVsZXRlIHR4UGFyYW1zLmZlZVJhdGU7XG4gICAgICBkZWxldGUgdHhQYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0O1xuICAgICAgdHhQYXJhbXMuZmVlID0gYmFzZUZlZTtcbiAgICAgIC8vIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBlcXVhbCBkaXN0cmlidXRpb24sIHdlIG5lZWQgdG8gc3VidHJhY3QgdGhlIGZlZSBmcm9tIHRoZSBjdW11bGF0aXZlIGZ1bmRzXG4gICAgICAvLyBpbiBjYXNlIHNvbWUgdW5zcGVudHMgZ290IHBydW5lZCwgd2UgbmVlZCB0byB1c2UgZXJyb3IucmVzdWx0LmF2YWlsYWJsZVxuICAgICAgY29uc3QgbmV0QW1vdW50ID0gZXJyb3IucmVzdWx0LmF2YWlsYWJsZSAtIHRvdGFsRmVlOyAvLyBhZnRlciBmZWVzXG4gICAgICAvLyB0aGF0IG1lYW5zIHRoYXQgdGhlIGRpc3RyaWJ1dGlvbiBoYXMgdG8gYmUgcmVjYWxjdWxhdGVkXG4gICAgICBjb25zdCByZW1haW5pbmdTcGxpdEFtb3VudHMgPSBzcGxpdE51bWJlckludG9DbG9zZU5hdHVyYWxOdW1iZXJzKG5ldEFtb3VudCwgdGFyZ2V0KTtcbiAgICAgIC8vIGFuZCB0aGUgZGlzdHJpYnV0aW9uIGFnYWluIG1hcHBlZCB0byB0aGUgbmV3IGFkZHJlc3Nlc1xuICAgICAgdHhQYXJhbXMucmVjaXBpZW50cyA9IF8uemlwT2JqZWN0KF8ubWFwKG5ld0FkZHJlc3NlcywgJ2FkZHJlc3MnKSwgcmVtYWluaW5nU3BsaXRBbW91bnRzKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIHRpbWUsIHRoZSB0cmFuc2FjdGlvbiBjcmVhdGlvbiBzaG91bGQgd29ya1xuICAgIGxldCBmYW5vdXRUeDtcbiAgICB0cnkge1xuICAgICAgZmFub3V0VHggPSB5aWVsZCBzZWxmLnNlbmRNYW55KHR4UGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBkZWJ1Z1BhcmFtcyA9IF8ub21pdCh0eFBhcmFtcywgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3hwcnYnXSk7XG4gICAgICBlLm1lc3NhZ2UgKz0gYFxcblxcblRYIFBBUkFNUzpcXG4gJHtKU09OLnN0cmluZ2lmeShkZWJ1Z1BhcmFtcywgbnVsbCwgNCl9YDtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoZmFub3V0VHgpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9KSgpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0byBmYW4gb3V0IG9yIGNvYWxlc2NlIGEgd2FsbGV0J3MgdW5zcGVudHNcbiAqIEBwYXJhbSBwYXJhbXNcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHJldHVybnMge1JlcXVlc3R8UHJvbWlzZS48VD58Kn1cbiAqL1xuV2FsbGV0LnByb3RvdHlwZS5yZWdyb3VwVW5zcGVudHMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29uc3QgdGFyZ2V0ID0gcGFyYW1zLnRhcmdldDtcbiAgaWYgKCFfLmlzTnVtYmVyKHRhcmdldCkgfHwgdGFyZ2V0IDwgMSB8fCAodGFyZ2V0ICUgMSkgIT09IDApIHtcbiAgICAvLyB0aGUgdGFyZ2V0IG11c3QgYmUgZGVmaW5lZCwgYmUgYSBudW1iZXIsIGJlIGF0IGxlYXN0IG9uZSwgYW5kIGJlIGEgbmF0dXJhbCBudW1iZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBuZWVkcyB0byBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgfVxuXG4gIGxldCBtaW5Db25maXJtcyA9IHBhcmFtcy5taW5Db25maXJtcztcbiAgaWYgKG1pbkNvbmZpcm1zID09PSB1bmRlZmluZWQpIHtcbiAgICBtaW5Db25maXJtcyA9IDE7XG4gIH1cbiAgaWYgKCghXy5pc051bWJlcihtaW5Db25maXJtcykgfHwgbWluQ29uZmlybXMgPCAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluQ29uZmlybXMgbmVlZHMgdG8gYmUgYW4gaW50ZWdlciBlcXVhbCB0byBvciBiaWdnZXIgdGhhbiAwJyk7XG4gIH1cblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHNlbGYudW5zcGVudHMoeyBtaW5Db25maXJtczogbWluQ29uZmlybXMgfSlcbiAgLnRoZW4oZnVuY3Rpb24odW5zcGVudHMpIHtcbiAgICBpZiAodW5zcGVudHMubGVuZ3RoID09PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB1bnNwZW50cztcbiAgICB9IGVsc2UgaWYgKHVuc3BlbnRzLmxlbmd0aCA+IHRhcmdldCkge1xuICAgICAgcmV0dXJuIHNlbGYuY29uc29saWRhdGVVbnNwZW50cyhwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKHVuc3BlbnRzLmxlbmd0aCA8IHRhcmdldCkge1xuICAgICAgcmV0dXJuIHNlbGYuZmFuT3V0VW5zcGVudHMocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ29uc29saWRhdGUgYSB3YWxsZXQncyB1bnNwZW50cyBpbnRvIGZld2VyIHVuc3BlbnRzXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiAgdGFyZ2V0OiBzZXQgaG93IG1hbnkgdW5zcGVudHMgeW91IHdhbnQgdG8gaGF2ZSBpbiB0aGUgZW5kXG4gKiAgbWF4SW5wdXRDb3VudFBlckNvbnNvbGlkYXRpb246IHNldCBob3cgbWFueSBtYXhpbXVtIGlucHV0cyBhcmUgdG8gYmUgcGVybWl0dGVkIHBlciBjb25zb2xpZGF0aW9uIGJhdGNoXG4gKiAgeHBydjogcHJpdmF0ZSBrZXkgdG8gc2lnbiB0cmFuc2FjdGlvblxuICogIHdhbGxldFBhc3NwaHJhc2U6IHdhbGxldCBwYXNzcGhyYXNlIHRvIGRlY3J5cHQgdGhlIHdhbGxldCdzIHByaXZhdGUga2V5XG4gKiAgbWF4SXRlcmF0aW9uQ291bnQ6IG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gYmUgcGVyZm9ybWVkIHVudGlsIGZ1bmN0aW9uIHN0b3BzXG4gKiAgcHJvZ3Jlc3NDYWxsYmFjazogbWV0aG9kIHRvIGJlIGNhbGxlZCB3aXRoIG9iamVjdCBvdXRsaW5pbmcgY3VycmVudCBwcm9ncmVzcyBkZXRhaWxzXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHsqfVxuICovXG5XYWxsZXQucHJvdG90eXBlLmNvbnNvbGlkYXRlVW5zcGVudHMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnd2FsbGV0UGFzc3BocmFzZScsICd4cHJ2J10sIGNhbGxiYWNrKTtcbiAgY29uc3QgdmFsaWRhdGUgPSBwYXJhbXMudmFsaWRhdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMudmFsaWRhdGU7XG5cbiAgbGV0IHRhcmdldCA9IHBhcmFtcy50YXJnZXQ7XG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRhcmdldCA9IDE7XG4gIH0gZWxzZSBpZiAoIV8uaXNOdW1iZXIodGFyZ2V0KSB8fCB0YXJnZXQgPCAxIHx8ICh0YXJnZXQgJSAxKSAhPT0gMCkge1xuICAgIC8vIHRoZSB0YXJnZXQgbXVzdCBiZSBkZWZpbmVkLCBiZSBhIG51bWJlciwgYmUgYXQgbGVhc3Qgb25lLCBhbmQgYmUgYSBuYXR1cmFsIG51bWJlclxuICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IG5lZWRzIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5tYXhTaXplICYmICFfLmlzTnVtYmVyKHBhcmFtcy5tYXhTaXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWF4U2l6ZSBzaG91bGQgYmUgYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmIChwYXJhbXMubWluU2l6ZSAmJiAhXy5pc051bWJlcihwYXJhbXMubWluU2l6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pblNpemUgc2hvdWxkIGJlIGEgbnVtYmVyJyk7XG4gIH1cblxuICAvLyBtYXhpbXVtIG51bWJlciBvZiBpbnB1dHMgcGVyIHRyYW5zYWN0aW9uIGZvciBjb25zb2xpZGF0aW9uXG4gIGNvbnN0IE1BWF9JTlBVVF9DT1VOVCA9IDIwMDtcbiAgbGV0IG1heElucHV0Q291bnQgPSBwYXJhbXMubWF4SW5wdXRDb3VudFBlckNvbnNvbGlkYXRpb247XG4gIGlmIChtYXhJbnB1dENvdW50ID09PSB1bmRlZmluZWQpIHsgLy8gbnVsbCBvciB1bmlkZW50aWZpZWQsIGJlY2F1c2UgZXF1YWxpdHkgdG8gemVybyByZXR1cm5zIHRydWUgaW4gaWYoISBjbGF1c2VcbiAgICBtYXhJbnB1dENvdW50ID0gTUFYX0lOUFVUX0NPVU5UO1xuICB9XG4gIGlmICh0eXBlb2YgKG1heElucHV0Q291bnQpICE9PSAnbnVtYmVyJyB8fCBtYXhJbnB1dENvdW50IDwgMiB8fCAobWF4SW5wdXRDb3VudCAlIDEpICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIGNvbnNvbGlkYXRpb24gaW5wdXQgY291bnQgbmVlZHMgdG8gYmUgYW4gaW50ZWdlciBlcXVhbCB0byBvciBiaWdnZXIgdGhhbiAyJyk7XG4gIH0gZWxzZSBpZiAobWF4SW5wdXRDb3VudCA+IE1BWF9JTlBVVF9DT1VOVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWF4aW11bSBjb25zb2xpZGF0aW9uIGlucHV0IGNvdW50IGNhbm5vdCBiZSBiaWdnZXIgdGhhbiAnICsgTUFYX0lOUFVUX0NPVU5UKTtcbiAgfVxuXG4gIGNvbnN0IG1heEl0ZXJhdGlvbkNvdW50ID0gcGFyYW1zLm1heEl0ZXJhdGlvbkNvdW50IHx8IC0xO1xuICBpZiAocGFyYW1zLm1heEl0ZXJhdGlvbkNvdW50ICYmICghXy5pc051bWJlcihtYXhJdGVyYXRpb25Db3VudCkgfHwgbWF4SXRlcmF0aW9uQ291bnQgPCAxKSB8fCAobWF4SXRlcmF0aW9uQ291bnQgJSAxKSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWF4aW11bSBpdGVyYXRpb24gY291bnQgbmVlZHMgdG8gYmUgYW4gaW50ZWdlciBlcXVhbCB0byBvciBiaWdnZXIgdGhhbiAxJyk7XG4gIH1cblxuICBsZXQgbWluQ29uZmlybXMgPSBwYXJhbXMubWluQ29uZmlybXM7XG4gIGlmIChtaW5Db25maXJtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWluQ29uZmlybXMgPSAxO1xuICB9XG4gIGlmICgoIV8uaXNOdW1iZXIobWluQ29uZmlybXMpIHx8IG1pbkNvbmZpcm1zIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbkNvbmZpcm1zIG5lZWRzIHRvIGJlIGFuIGludGVnZXIgZXF1YWwgdG8gb3IgYmlnZ2VyIHRoYW4gMCcpO1xuICB9XG5cbiAgbGV0IG1pblNpemUgPSBwYXJhbXMubWluU2l6ZSB8fCAwO1xuICBpZiAocGFyYW1zLmZlZVJhdGUpIHtcbiAgICAvLyBmZWUgcmF0ZSBpcyBpbiBzYXRvc2hpcyBwZXIga0IsIGlucHV0IHNpemUgaW4gYnl0ZXNcbiAgICBjb25zdCBmZWVCYXNlZE1pblNpemUgPSBNYXRoLmNlaWwoVmlydHVhbFNpemVzLnR4UDJzaElucHV0U2l6ZSAqIHBhcmFtcy5mZWVSYXRlIC8gMTAwMCk7XG4gICAgaWYgKHBhcmFtcy5taW5TaXplICYmIG1pblNpemUgPCBmZWVCYXNlZE1pblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdmlkZWQgbWluU2l6ZSB0b28gbG93IGR1ZSB0byB0b28gaGlnaCBmZWUgcmF0ZScpO1xuICAgIH1cbiAgICBtaW5TaXplID0gTWF0aC5tYXgoZmVlQmFzZWRNaW5TaXplLCBtaW5TaXplKTtcblxuICAgIGlmICghcGFyYW1zLm1pblNpemUpIHtcbiAgICAgIC8vIGZlZSByYXRlLWJhc2VkIG1pbiBzaXplIG5lZWRzIG5vIGxvZ2dpbmcgaWYgaXQgd2FzIHNldCBleHBsaWNpdGx5XG4gICAgICBjb25zb2xlLmxvZygnT25seSBjb25zb2xpZGF0aW5nIHVuc3BlbnRzIGxhcmdlciB0aGFuICcgKyBtaW5TaXplICsgJyBzYXRvc2hpcyB0byBhdm9pZCB3YXN0aW5nIG1vbmV5IG9uIGZlZXMuIFRvIGNvbnNvbGlkYXRlIHNtYWxsZXIgdW5zcGVudHMsIHVzZSBhIGxvd2VyIGZlZSByYXRlLicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBpdGVyYXRpb25Db3VudCA9IDA7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGxldCBjb25zb2xpZGF0aW9uSW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZSBvbmUgYmF0Y2ggb2YgdXAgdG8gTUFYX0lOUFVUX0NPVU5UIHVuc3BlbnRzLlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGNvbnN0IHJ1bk5leHRDb25zb2xpZGF0aW9uID0gY28oZnVuY3Rpb24gKigpIHtcbiAgICBjb25zdCBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zOiBhbnlbXSA9IFtdO1xuICAgIGxldCBpc0ZpbmFsQ29uc29saWRhdGlvbiA9IGZhbHNlO1xuICAgIGl0ZXJhdGlvbkNvdW50Kys7XG4gICAgLypcbiAgICAgV2UgdGFrZSBhIG1heGltdW0gb2YgdW5zcGVudEJ1bGtTaXplTGltaXQgdW5zcGVudHMgZnJvbSB0aGUgd2FsbGV0LiBXZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIHN3aXBlIHRoZSB3YWxsZXRcbiAgICAgY2xlYW4gb2YgYWxsIGV4Y2Vzc2l2ZSB1bnNwZW50cywgc28gd2UgYWRkIDEgdG8gdGhlIHRhcmdldCB1bnNwZW50IGNvdW50IHRvIG1ha2Ugc3VyZSB3ZSBoYXZlbid0IG1pc3NlZCBhbnl0aGluZy5cbiAgICAgSW4gY2FzZSB0aGVyZSBhcmUgZXZlbiBtb3JlIHVuc3BlbnRzIHRoYW4gdGhhdCwgdG8gbWFrZSB0aGUgY29uc29saWRhdGlvbiBhcyBmYXN0IGFzIHBvc3NpYmxlLCB3ZSBleHBhbmQgb3VyXG4gICAgIHNlbGVjdGlvbiB0byBpbmNsdWRlIGFzIG1hbnkgYXMgdGhlIG1heGltdW0gcGVybWlzc2libGUgbnVtYmVyIG9mIGlucHV0cyBwZXIgY29uc29saWRhdGlvbiBiYXRjaC5cbiAgICAgU2hvdWxkIHRoZSB0YXJnZXQgbnVtYmVyIG9mIHVuc3BlbnRzIGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBpZiBpbnB1dHMgcGVyIGNvbnNvbGlkYXRpb24sXG4gICAgIHdlIHN0aWxsIHdhbnQgdG8gZmV0Y2ggdGhlbSBhbGwgc2ltcGx5IHRvIGJlIGFibGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEgY29uc29saWRhdGlvbiBjYW4gYmUgcGVyZm9ybWVkXG4gICAgIGF0IGFsbCwgd2hpY2ggaXMgZGVwZW5kZW50IG9uIHRoZSBudW1iZXIgb2YgYWxsIHVuc3BlbnRzIGJlaW5nIGhpZ2hlciB0aGFuIHRoZSB0YXJnZXQuXG4gICAgIEluIHRoZSBuZXh0IHZlcnNpb24gb2YgdGhlIHVuc3BlbnRzIHZlcnNpb24gU0RLLCB3ZSB3aWxsIGtub3cgdGhlIHRvdGFsIG51bWJlciBvZiB1bnNwZW50cyB3aXRob3V0IGhhdmluZyB0byBmZXRjaFxuICAgICB0aGVtLCBhbmQgdGhlcmVmb3JlIHdpbGwgYmUgYWJsZSB0byBzaW1wbGlmeSB0aGlzIG1ldGhvZC5cbiAgICAgKi9cblxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zOiBhbnkgPSB7XG4gICAgICBsaW1pdDogdGFyZ2V0ICsgbWF4SW5wdXRDb3VudCxcbiAgICAgIG1pbkNvbmZpcm1zOiBtaW5Db25maXJtcyxcbiAgICAgIG1pblNpemU6IG1pblNpemVcbiAgICB9O1xuICAgIGlmIChwYXJhbXMubWF4U2l6ZSkge1xuICAgICAgcXVlcnlQYXJhbXMubWF4U2l6ZSA9IHBhcmFtcy5tYXhTaXplO1xuICAgIH1cbiAgICBjb25zdCBhbGxVbnNwZW50cyA9IHlpZWxkIHNlbGYudW5zcGVudHMocXVlcnlQYXJhbXMpO1xuICAgIC8vIHRoaXMgY29uc29saWRhdGlvbiBpcyBlc3NlbnRpYWxseSBqdXN0IGEgd2FzdGUgb2YgbW9uZXlcbiAgICBpZiAoYWxsVW5zcGVudHMubGVuZ3RoIDw9IHRhcmdldCkge1xuICAgICAgaWYgKGl0ZXJhdGlvbkNvdW50IDw9IDEpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmlyc3QgaXRlcmF0aW9uLCBzbyB0aGUgbWV0aG9kIGlzIGluY29ycmVjdFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zld2VyIHVuc3BlbnRzIHRoYW4gY29uc29saWRhdGlvbiB0YXJnZXQuIFVzZSBmYW5PdXRVbnNwZW50cyBpbnN0ZWFkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaXQncyBhIGxhdGVyIGl0ZXJhdGlvbiwgc28gdGhlIHRhcmdldCBtYXkgaGF2ZSBiZWVuIHN1cnBhc3NlZCAoZHVlIHRvIGNvbmZpcm1hdGlvbnMgaW4gdGhlIGJhY2tncm91bmQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRG9uZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFsbFVuc3BlbnRzQ291bnQgPSBhbGxVbnNwZW50cy5sZW5ndGg7XG5cbiAgICAvLyBob3cgbWFueSBvZiB0aGUgdW5zcGVudHMgZG8gd2Ugd2FudCB0byBjb25zb2xpZGF0ZT9cbiAgICAvLyB0aGUgKzEgaXMgYmVjYXVzZSB0aGUgY29uc29saWRhdGVkIGJsb2NrIGJlY29tZXMgYSBuZXcgdW5zcGVudCBsYXRlclxuICAgIGxldCB0YXJnZXRJbnB1dENvdW50ID0gYWxsVW5zcGVudHNDb3VudCAtIHRhcmdldCArIDE7XG4gICAgdGFyZ2V0SW5wdXRDb3VudCA9IE1hdGgubWluKHRhcmdldElucHV0Q291bnQsIGFsbFVuc3BlbnRzLmxlbmd0aCk7XG5cbiAgICAvLyBpZiB0aGUgdGFyZ2V0SW5wdXRDb3VudCByZXF1aXJlcyBtb3JlIGlucHV0cyB0aGFuIHdlIGFsbG93IHBlciBiYXRjaCwgd2UgcmVkdWNlIHRoZSBudW1iZXJcbiAgICBjb25zdCBpbnB1dENvdW50ID0gTWF0aC5taW4odGFyZ2V0SW5wdXRDb3VudCwgbWF4SW5wdXRDb3VudCk7XG5cbiAgICAvLyBpZiBlaXRoZXIgdGhlIG51bWJlciBvZiBpbnB1dHMgbGVmdCB0byBjb2FsZXNjZSBlcXVhbHMgdGhlIG51bWJlciB3ZSB3aWxsIGNvYWxlc2NlIGluIHRoaXMgaXRlcmF0aW9uXG4gICAgLy8gb3IgaWYgdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIG1hdGNoZXMgdGhlIG1heGltdW0gcGVybWl0dGVkIG51bWJlclxuICAgIGlzRmluYWxDb25zb2xpZGF0aW9uID0gKGlucHV0Q291bnQgPT09IHRhcmdldElucHV0Q291bnQgfHwgaXRlcmF0aW9uQ291bnQgPT09IG1heEl0ZXJhdGlvbkNvdW50KTtcblxuICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IGFsbFVuc3BlbnRzLnNwbGljZSgwLCBpbnB1dENvdW50KTtcbiAgICBjb25zdCBjaGFuZ2VDaGFpbiA9IHNlbGYuZ2V0Q2hhbmdlQ2hhaW4ocGFyYW1zKTtcbiAgICBjb25zdCBuZXdBZGRyZXNzID0geWllbGQgc2VsZi5jcmVhdGVBZGRyZXNzKHsgY2hhaW46IGNoYW5nZUNoYWluLCB2YWxpZGF0ZTogdmFsaWRhdGUgfSk7XG4gICAgY29uc3QgdHhQYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zKTtcbiAgICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IG5ld0FkZHJlc3M7XG4gICAgLy8gdGhlIHRvdGFsIGFtb3VudCB0aGF0IHdlIGFyZSBjb25zb2xpZGF0aW5nIHdpdGhpbiB0aGlzIGJhdGNoXG4gICAgY29uc3QgZ3Jvc3NBbW91bnQgPSBfKGN1cnJlbnRDaHVuaykubWFwKCd2YWx1ZScpLnN1bSgpOyAvLyBiZWZvcmUgZmVlc1xuXG4gICAgdHhQYXJhbXMudW5zcGVudHMgPSBjdXJyZW50Q2h1bms7XG4gICAgdHhQYXJhbXMucmVjaXBpZW50cyA9IHt9O1xuICAgIHR4UGFyYW1zLnJlY2lwaWVudHNbbmV3QWRkcmVzcy5hZGRyZXNzXSA9IGdyb3NzQW1vdW50O1xuICAgIHR4UGFyYW1zLm5vU3BsaXRDaGFuZ2UgPSB0cnVlO1xuXG4gICAgaWYgKHR4UGFyYW1zLnVuc3BlbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvbmUnKTtcbiAgICB9XG5cbiAgICAvLyBsZXQncyBhdHRlbXB0IHRvIGNyZWF0ZSB0aGlzIHRyYW5zYWN0aW9uLiBXZSBleHBlY3QgaXQgdG8gZmFpbCBiZWNhdXNlIG5vIGZlZSBpcyBzZXQuXG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkIHNlbGYuc2VuZE1hbnkodHhQYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGVycm9yIHNob3VsZCBvY2N1ciBkdWUgdG8gaW5zdWZmaWNpZW50IGZ1bmRzXG4gICAgICAvLyBob3dldmVyLCBsZXQncyBtYWtlIHN1cmUgaXQgd2Fzbid0IHNvbWV0aGluZyBlbHNlXG4gICAgICBpZiAoIWVycm9yLmZlZSAmJiAoIWVycm9yLnJlc3VsdCB8fCAhZXJyb3IucmVzdWx0LmZlZSkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGVycm9yIGRvZXMgbm90IGNvbnRhaW4gYSBmZWUgcHJvcGVydHksIGl0IGlzIHNvbWV0aGluZyBlbHNlIHRoYXQgaGFzIGdvbmUgYXdyeSwgYW5kIHdlIHRocm93IGl0XG4gICAgICAgIGNvbnN0IGRlYnVnUGFyYW1zID0gXy5vbWl0KHR4UGFyYW1zLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAneHBydiddKTtcbiAgICAgICAgZXJyb3IubWVzc2FnZSArPSBgXFxuXFxuVFggUEFSQU1TOlxcbiAke0pTT04uc3RyaW5naWZ5KGRlYnVnUGFyYW1zLCBudWxsLCA0KX1gO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhc2VGZWUgPSBlcnJvci5mZWUgfHwgZXJyb3IucmVzdWx0LmZlZTtcbiAgICAgIGxldCBiaXRnb0ZlZSA9IDA7XG4gICAgICBsZXQgdG90YWxGZWUgPSBiYXNlRmVlO1xuICAgICAgaWYgKGVycm9yLnJlc3VsdC5iaXRnb0ZlZSAmJiBlcnJvci5yZXN1bHQuYml0Z29GZWUuYW1vdW50KSB7XG4gICAgICAgIGJpdGdvRmVlID0gZXJyb3IucmVzdWx0LmJpdGdvRmVlLmFtb3VudDtcbiAgICAgICAgdG90YWxGZWUgKz0gYml0Z29GZWU7XG4gICAgICAgIHR4UGFyYW1zLmJpdGdvRmVlID0gZXJyb3IucmVzdWx0LmJpdGdvRmVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgbmV0IGFtb3VudCBpcyBuZWdhdGl2ZSwgaXQgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggdGhlIG1pbmltdW0gb3V0cHV0IHNpemVcbiAgICAgIGNvbnN0IG5ldEFtb3VudCA9IE1hdGgubWF4KGVycm9yLnJlc3VsdC5hdmFpbGFibGUgLSB0b3RhbEZlZSwgc2VsZi5iaXRnby5nZXRDb25zdGFudHMoKS5taW5PdXRwdXRTaXplKTtcbiAgICAgIC8vIE5lZWQgdG8gY2xlYXIgdGhlc2Ugb3V0IHNpbmNlIG9ubHkgMSBtYXkgYmUgc2V0XG4gICAgICBkZWxldGUgdHhQYXJhbXMuZmVlO1xuICAgICAgdHhQYXJhbXMub3JpZ2luYWxGZWVSYXRlID0gdHhQYXJhbXMuZmVlUmF0ZTtcbiAgICAgIGRlbGV0ZSB0eFBhcmFtcy5mZWVSYXRlO1xuICAgICAgZGVsZXRlIHR4UGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldDtcblxuICAgICAgLy8gd2Ugc2V0IHRoZSBmZWUgZXhwbGljaXRseVxuICAgICAgdHhQYXJhbXMuZmVlID0gZXJyb3IucmVzdWx0LmF2YWlsYWJsZSAtIG5ldEFtb3VudCAtIGJpdGdvRmVlO1xuICAgICAgdHhQYXJhbXMucmVjaXBpZW50c1tuZXdBZGRyZXNzLmFkZHJlc3NdID0gbmV0QW1vdW50O1xuICAgIH1cbiAgICAvLyB0aGlzIHRyYW5zYWN0aW9uLCBvbiB0aGUgb3RoZXIgaGFuZCwgc2hvdWxkIGJlIGNyZWF0ZWQgd2l0aCBubyBpc3N1ZXMsIGJlY2F1c2UgYW4gYXBwcm9wcmlhdGUgZmVlIGlzIHNldFxuICAgIGxldCBzZW50VHg7XG4gICAgdHJ5IHtcbiAgICAgIHNlbnRUeCA9IHlpZWxkIHNlbGYuc2VuZE1hbnkodHhQYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IGRlYnVnUGFyYW1zID0gXy5vbWl0KHR4UGFyYW1zLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAneHBydiddKTtcbiAgICAgIGUubWVzc2FnZSArPSBgXFxuXFxuVFggUEFSQU1TOlxcbiAke0pTT04uc3RyaW5naWZ5KGRlYnVnUGFyYW1zLCBudWxsLCA0KX1gO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5wdXNoKHNlbnRUeCk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihwYXJhbXMucHJvZ3Jlc3NDYWxsYmFjaykpIHtcbiAgICAgIHBhcmFtcy5wcm9ncmVzc0NhbGxiYWNrKHtcbiAgICAgICAgdHhpZDogc2VudFR4Lmhhc2gsXG4gICAgICAgIGRlc3RpbmF0aW9uOiBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBncm9zc0Ftb3VudCxcbiAgICAgICAgZmVlOiBzZW50VHguZmVlLFxuICAgICAgICBpbnB1dENvdW50OiBpbnB1dENvdW50LFxuICAgICAgICBpbmRleDogY29uc29saWRhdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc29saWRhdGlvbkluZGV4Kys7XG4gICAgaWYgKCFpc0ZpbmFsQ29uc29saWRhdGlvbikge1xuICAgICAgLy8gdGhpcyBsYXN0IGNvbnNvbGlkYXRpb24gaGFzIG5vdCB5ZXQgYnJvdWdodCB0aGUgdW5zcGVudHMgY291bnQgZG93biB0byB0aGUgdGFyZ2V0IHVuc3BlbnQgY291bnRcbiAgICAgIC8vIHRoZXJlZm9yZSwgd2UgcHJvY2VlZCBieSBjb25zb2xpZGF0aW5nIHlldCBhbm90aGVyIGJhdGNoXG4gICAgICAvLyBiZWZvcmUgd2UgZG8gdGhhdCwgd2Ugd2FpdCAxIHNlY29uZCBzbyB0aGF0IHRoZSBuZXdseSBjcmVhdGVkIHVuc3BlbnQgd2lsbCBiZSBmZXRjaGVkIGluIHRoZSBuZXh0IGJhdGNoXG4gICAgICB5aWVsZCBCbHVlYmlyZC5kZWxheSgxMDAwKTtcbiAgICAgIGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMucHVzaCguLi55aWVsZCBydW5OZXh0Q29uc29saWRhdGlvbigpKTtcbiAgICB9XG4gICAgLy8gdGhpcyBpcyB0aGUgZmluYWwgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbi4gV2UgcmV0dXJuIGFsbCB0aGUgb25lcyB3ZSd2ZSBoYWQgc28gZmFyXG4gICAgcmV0dXJuIGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnM7XG4gIH0pO1xuXG4gIHJldHVybiBydW5OZXh0Q29uc29saWRhdGlvbih0aGlzLCB0YXJnZXQpXG4gIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UgPT09ICdEb25lJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuc2hhcmVXYWxsZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydlbWFpbCcsICdwZXJtaXNzaW9ucyddLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAnbWVzc2FnZSddLCBjYWxsYmFjayk7XG5cbiAgaWYgKHBhcmFtcy5yZXNoYXJlICE9PSB1bmRlZmluZWQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5yZXNoYXJlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzaGFyZSB0byBiZSBhIGJvb2xlYW4uJyk7XG4gIH1cblxuICBpZiAocGFyYW1zLnNraXBLZXljaGFpbiAhPT0gdW5kZWZpbmVkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuc2tpcEtleWNoYWluKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc2tpcEtleWNoYWluIHRvIGJlIGEgYm9vbGVhbi4gJyk7XG4gIH1cbiAgY29uc3QgbmVlZHNLZXljaGFpbiA9ICFwYXJhbXMuc2tpcEtleWNoYWluICYmIHBhcmFtcy5wZXJtaXNzaW9ucy5pbmRleE9mKCdzcGVuZCcpICE9PSAtMTtcblxuICBpZiAocGFyYW1zLmRpc2FibGVFbWFpbCAhPT0gdW5kZWZpbmVkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZUVtYWlsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZGlzYWJsZUVtYWlsIHRvIGJlIGEgYm9vbGVhbi4nKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBsZXQgc2hhcmluZztcbiAgbGV0IHNoYXJlZEtleWNoYWluO1xuICByZXR1cm4gdGhpcy5iaXRnby5nZXRTaGFyaW5nS2V5KHsgZW1haWw6IHBhcmFtcy5lbWFpbC50b0xvd2VyQ2FzZSgpIH0pXG4gIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHNoYXJpbmcgPSByZXN1bHQ7XG5cbiAgICBpZiAobmVlZHNLZXljaGFpbikge1xuICAgICAgcmV0dXJuIHNlbGYuZ2V0RW5jcnlwdGVkVXNlcktleWNoYWluKHt9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24oa2V5Y2hhaW4pIHtcbiAgICAgICAgLy8gRGVjcnlwdCB0aGUgdXNlciBrZXkgd2l0aCBhIHBhc3NwaHJhc2VcbiAgICAgICAgaWYgKGtleWNoYWluLmVuY3J5cHRlZFhwcnYpIHtcbiAgICAgICAgICBpZiAoIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgd2FsbGV0UGFzc3BocmFzZSBhcmd1bWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5Y2hhaW4ueHBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7IHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSwgaW5wdXQ6IGtleWNoYWluLmVuY3J5cHRlZFhwcnYgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCB1c2VyIGtleWNoYWluJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZWNrZXkgPSBtYWtlUmFuZG9tS2V5KCk7XG4gICAgICAgICAgY29uc3Qgc2VjcmV0ID0gc2VsZi5iaXRnby5nZXRFQ0RIU2VjcmV0KHsgZWNrZXk6IGVja2V5LCBvdGhlclB1YktleUhleDogc2hhcmluZy5wdWJrZXkgfSk7XG4gICAgICAgICAgY29uc3QgbmV3RW5jcnlwdGVkWHBydiA9IHNlbGYuYml0Z28uZW5jcnlwdCh7IHBhc3N3b3JkOiBzZWNyZXQsIGlucHV0OiBrZXljaGFpbi54cHJ2IH0pO1xuXG4gICAgICAgICAgc2hhcmVkS2V5Y2hhaW4gPSB7XG4gICAgICAgICAgICB4cHViOiBrZXljaGFpbi54cHViLFxuICAgICAgICAgICAgZW5jcnlwdGVkWHBydjogbmV3RW5jcnlwdGVkWHBydixcbiAgICAgICAgICAgIGZyb21QdWJLZXk6IGVja2V5LmdldFB1YmxpY0tleUJ1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgIHRvUHViS2V5OiBzaGFyaW5nLnB1YmtleSxcbiAgICAgICAgICAgIHBhdGg6IHNoYXJpbmcucGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcbiAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgaW50ZXJmYWNlIE9wdGlvbnMge1xuICAgICAgdXNlcjogYW55O1xuICAgICAgcGVybWlzc2lvbnM6IHN0cmluZztcbiAgICAgIHJlc2hhcmU6IGJvb2xlYW47XG4gICAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgICBkaXNhYmxlRW1haWw6IGFueTtcbiAgICAgIGtleWNoYWluPzogYW55O1xuICAgICAgc2tpcEtleWNoYWluPzogYm9vbGVhblxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnM6IE9wdGlvbnMgPSB7XG4gICAgICB1c2VyOiBzaGFyaW5nLnVzZXJJZCxcbiAgICAgIHBlcm1pc3Npb25zOiBwYXJhbXMucGVybWlzc2lvbnMsXG4gICAgICByZXNoYXJlOiBwYXJhbXMucmVzaGFyZSxcbiAgICAgIG1lc3NhZ2U6IHBhcmFtcy5tZXNzYWdlLFxuICAgICAgZGlzYWJsZUVtYWlsOiBwYXJhbXMuZGlzYWJsZUVtYWlsXG4gICAgfTtcbiAgICBpZiAoc2hhcmVkS2V5Y2hhaW4pIHtcbiAgICAgIG9wdGlvbnMua2V5Y2hhaW4gPSBzaGFyZWRLZXljaGFpbjtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5za2lwS2V5Y2hhaW4pIHtcbiAgICAgIG9wdGlvbnMua2V5Y2hhaW4gPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5jcmVhdGVTaGFyZShvcHRpb25zKTtcbiAgfSlcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5yZW1vdmVVc2VyID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXNlciddLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLnVybCgnL3VzZXIvJyArIHBhcmFtcy51c2VyKSlcbiAgLnNlbmQoKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRQb2xpY3kgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvcG9saWN5JykpXG4gIC5zZW5kKClcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0UG9saWN5U3RhdHVzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3BvbGljeS9zdGF0dXMnKSlcbiAgLnNlbmQoKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5zZXRQb2xpY3lSdWxlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnLCAndHlwZSddLCBbJ21lc3NhZ2UnXSwgY2FsbGJhY2spO1xuXG4gIGlmICghXy5pc09iamVjdChwYXJhbXMuY29uZGl0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwYXJhbWV0ZXI6IGNvbmRpdGlvbnMgb2JqZWN0Jyk7XG4gIH1cblxuICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmFjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcGFyYW1ldGVyOiBhY3Rpb24gb2JqZWN0Jyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5iaXRnby5wdXQodGhpcy51cmwoJy9wb2xpY3kvcnVsZScpKVxuICAuc2VuZChwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLnJlbW92ZVBvbGljeVJ1bGUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbJ21lc3NhZ2UnXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLnVybCgnL3BvbGljeS9ydWxlJykpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUubGlzdFdlYmhvb2tzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3dlYmhvb2tzJykpXG4gIC5zZW5kKClcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2ltdWxhdGUgd2FsbGV0IHdlYmhvb2ssIGN1cnJlbnRseSBmb3Igd2ViaG9va3Mgb2YgdHlwZSB0cmFuc2FjdGlvbiBhbmQgcGVuZGluZyBhcHByb3ZhbFxuICogQHBhcmFtIHBhcmFtc1xuICogLSB3ZWJob29rSWQgKHJlcXVpcmVkKTogaWQgb2YgdGhlIHdlYmhvb2sgdG8gYmUgc2ltdWxhdGVkXG4gKiAtIHR4SGFzaCAob3B0aW9uYWwgYnV0IHJlcXVpcmVkIGZvciB0cmFuc2FjdGlvbiB3ZWJob29rcykgaGFzaCBvZiB0aGUgc2ltdWxhdGVkIHRyYW5zYWN0aW9uXG4gKiAtIHBlbmRpbmdBcHByb3ZhbElkIChvcHRpb25hbCBidXQgcmVxdWlyZWQgZm9yIHBlbmRpbmcgYXBwcm92YWwgd2ViaG9va3MpIGlkIG9mIHRoZSBzaW11bGF0ZWQgcGVuZGluZyBhcHByb3ZhbFxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuV2FsbGV0LnByb3RvdHlwZS5zaW11bGF0ZVdlYmhvb2sgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3ZWJob29rSWQnXSwgWyd0eEhhc2gnLCAncGVuZGluZ0FwcHJvdmFsSWQnXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IGhhc1R4SGFzaCA9ICEhcGFyYW1zLnR4SGFzaDtcbiAgY29uc3QgaGFzUGVuZGluZ0FwcHJvdmFsSWQgPSAhIXBhcmFtcy5wZW5kaW5nQXBwcm92YWxJZDtcblxuICBpZiAoKGhhc1R4SGFzaCAmJiBoYXNQZW5kaW5nQXBwcm92YWxJZCkgfHwgKCFoYXNUeEhhc2ggJiYgIWhhc1BlbmRpbmdBcHByb3ZhbElkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzdXBwbHkgZWl0aGVyIHR4SGFzaCBvciBwZW5kaW5nQXBwcm92YWxJZCwgYnV0IG5vdCBib3RoJyk7XG4gIH1cblxuICAvLyBkZXBlbmRpbmcgb24gdGhlIGNvaW4gdHlwZSBvZiB0aGUgd2FsbGV0LCB0aGUgdHhIYXNoIGhhcyB0byBhZGhlcmUgdG8gaXRzIHJlc3BlY3RpdmUgZm9ybWF0XG4gIC8vIGJ1dCB0aGUgc2VydmVyIHRha2VzIGNhcmUgb2YgdGhhdFxuXG4gIC8vIG9ubHkgdGFrZSB0aGUgdHhIYXNoIGFuZCBwZW5kaW5nQXBwcm92YWxJZCBwcm9wZXJ0aWVzXG4gIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgWyd0eEhhc2gnLCAncGVuZGluZ0FwcHJvdmFsSWQnXSk7XG5cbiAgY29uc3Qgd2ViaG9va0lkID0gcGFyYW1zLndlYmhvb2tJZDtcbiAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL3dlYmhvb2tzLycgKyB3ZWJob29rSWQgKyAnL3NpbXVsYXRlJykpXG4gIC5zZW5kKGZpbHRlcmVkUGFyYW1zKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5hZGRXZWJob29rID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXJsJywgJ3R5cGUnXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvd2ViaG9va3MnKSlcbiAgLnNlbmQocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5yZW1vdmVXZWJob29rID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXJsJywgJ3R5cGUnXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy51cmwoJy93ZWJob29rcycpKVxuICAuc2VuZChwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmVzdGltYXRlRmVlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICBpZiAocGFyYW1zLmFtb3VudCAmJiBwYXJhbXMucmVjaXBpZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgYm90aCBhbW91bnQgYXMgd2VsbCBhcyByZWNpcGllbnRzJyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5yZWNpcGllbnRzICYmICFfLmlzT2JqZWN0KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVjaXBpZW50cyBtdXN0IGJlIGFycmF5IG9mIHsgYWRkcmVzczogYWJjLCBhbW91bnQ6IDEwMDAwMCB9IG9iamVjdHMnKTtcbiAgfVxuICBpZiAocGFyYW1zLmFtb3VudCAmJiAhXy5pc051bWJlcihwYXJhbXMuYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbW91bnQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgfVxuXG4gIGNvbnN0IHJlY2lwaWVudHMgPSBwYXJhbXMucmVjaXBpZW50cyB8fCBbXTtcblxuICBpZiAocGFyYW1zLmFtb3VudCkge1xuICAgIC8vIG9ubHkgdGhlIGFtb3VudCB3YXMgcGFzc2VkIGluLCBzbyB3ZSBuZWVkIHRvIG1ha2UgYSBmYWxzZSByZWNpcGllbnQgdG8gcnVuIGNyZWF0ZVRyYW5zYWN0aW9uIHdpdGhcbiAgICByZWNpcGllbnRzLnB1c2goe1xuICAgICAgYWRkcmVzczogY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmVudl0uc2lnbmluZ0FkZHJlc3MsIC8vIGFueSBhZGRyZXNzIHdpbGwgZG9cbiAgICAgIGFtb3VudDogcGFyYW1zLmFtb3VudFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgdHJhbnNhY3Rpb25QYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zKTtcbiAgdHJhbnNhY3Rpb25QYXJhbXMuYW1vdW50ID0gdW5kZWZpbmVkO1xuICB0cmFuc2FjdGlvblBhcmFtcy5yZWNpcGllbnRzID0gcmVjaXBpZW50cztcblxuICByZXR1cm4gdGhpcy5jcmVhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvblBhcmFtcylcbiAgLnRoZW4oZnVuY3Rpb24odHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXN0aW1hdGVkU2l6ZTogdHguZXN0aW1hdGVkU2l6ZSxcbiAgICAgIGZlZTogdHguZmVlLFxuICAgICAgZmVlUmF0ZTogdHguZmVlUmF0ZVxuICAgIH07XG4gIH0pO1xufTtcblxuLy8gTm90IGZ1bGx5IGltcGxlbWVudGVkIC8gcmVsZWFzZWQgb24gU0RLLiBUZXN0aW5nIGZvciBub3cuXG5XYWxsZXQucHJvdG90eXBlLnVwZGF0ZVBvbGljeVJ1bGUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCcsICd0eXBlJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28ucHV0KHRoaXMudXJsKCcvcG9saWN5L3J1bGUnKSlcbiAgLnNlbmQocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5kZWxldGVQb2xpY3lSdWxlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy51cmwoJy9wb2xpY3kvcnVsZScpKVxuICAuc2VuZChwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gZ2V0Qml0R29GZWVcbi8vIEdldCB0aGUgcmVxdWlyZWQgb24tdHJhbnNhY3Rpb24gQml0R28gZmVlXG4vL1xuV2FsbGV0LnByb3RvdHlwZS5nZXRCaXRHb0ZlZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcbiAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5hbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFtb3VudCBhcmd1bWVudCcpO1xuICB9XG4gIGlmIChwYXJhbXMuaW5zdGFudCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmluc3RhbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RhbnQgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy9iaWxsaW5nL2ZlZScpKVxuICAucXVlcnkocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuZXhwb3J0ID0gV2FsbGV0O1xuIl19