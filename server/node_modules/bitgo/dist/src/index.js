"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
//
// index.js - Module definition for BitGoJS
//
// Copyright 2019, BitGo, Inc.  All Rights Reserved.
//
var common = require("./common");
__export(require("./bitgo"));
// Expose bitcoin and sjcl
var utxoLib = require("bitgo-utxo-lib");
var bitcoin_1 = require("./bitcoin");
// can't add types for these since they are part of bitgo-utxo-lib's default export
// see https://github.com/Microsoft/TypeScript/issues/14080
utxoLib.hdPath = bitcoin_1.hdPath;
utxoLib.makeRandomKey = bitcoin_1.makeRandomKey;
exports.bitcoin = utxoLib;
exports.sjcl = require('./vendor/sjcl.min.js');
exports.bs58 = require('bs58');
var buffer_1 = require("buffer");
exports.Buffer = buffer_1.Buffer;
var _ = require("lodash");
var errors = require("./errors");
exports.Environments = _.cloneDeep(common.Environments);
exports.Errors = errors;
var coinFactory_1 = require("./v2/coinFactory");
exports.GlobalCoinFactory = coinFactory_1.GlobalCoinFactory;
__export(require("./v2"));
/**
 * Set the network, i.e. either "bitcoin" for production with real bitcoin, or
 * "testnet" for development with testnet bitcoin.
 *
 * @deprecated
 */
function setNetwork(network) {
    common.setNetwork(network);
}
exports.setNetwork = setNetwork;
/**
 * Get the network. Returns either "bitcoin" or "testnet".
 *
 * @deprecated
 */
function getNetwork() {
    return common.getNetwork();
}
exports.getNetwork = getNetwork;
/**
 * @deprecated
 */
function getNetworkObj() {
    return exports.bitcoin.networks[common.getNetwork()];
}
exports.getNetworkObj = getNetworkObj;
setNetwork('testnet');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7R0FFRztBQUNILEVBQUU7QUFDRiwyQ0FBMkM7QUFDM0MsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFO0FBQ0YsaUNBQW1DO0FBRW5DLDZCQUF3QjtBQUV4QiwwQkFBMEI7QUFDMUIsd0NBQTBDO0FBQzFDLHFDQUFrRDtBQUVsRCxtRkFBbUY7QUFDbkYsMkRBQTJEO0FBQzFELE9BQWUsQ0FBQyxNQUFNLEdBQUcsZ0JBQU0sQ0FBQztBQUNoQyxPQUFlLENBQUMsYUFBYSxHQUFHLHVCQUFhLENBQUM7QUFFbEMsUUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ2xCLFFBQUEsSUFBSSxHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQ3ZDLFFBQUEsSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUVwQyxpQ0FBZ0M7QUFBdkIsMEJBQUEsTUFBTSxDQUFBO0FBRWYsMEJBQTRCO0FBQzVCLGlDQUFtQztBQUN0QixRQUFBLFlBQVksR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNoRCxRQUFBLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDN0IsZ0RBQXNFO0FBQTdELDBDQUFBLGlCQUFpQixDQUFBO0FBRzFCLDBCQUFxQjtBQUVyQjs7Ozs7R0FLRztBQUNILFNBQWdCLFVBQVUsQ0FBQyxPQUFPO0lBQ2hDLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUZELGdDQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFVBQVU7SUFDeEIsT0FBTyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDN0IsQ0FBQztBQUZELGdDQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixhQUFhO0lBQzNCLE9BQU8sZUFBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztBQUMvQyxDQUFDO0FBRkQsc0NBRUM7QUFFRCxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG4vL1xuLy8gaW5kZXguanMgLSBNb2R1bGUgZGVmaW5pdGlvbiBmb3IgQml0R29KU1xuLy9cbi8vIENvcHlyaWdodCAyMDE5LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgKiBmcm9tICcuL2JpdGdvJztcblxuLy8gRXhwb3NlIGJpdGNvaW4gYW5kIHNqY2xcbmltcG9ydCAqIGFzIHV0eG9MaWIgZnJvbSAnYml0Z28tdXR4by1saWInO1xuaW1wb3J0IHsgaGRQYXRoLCBtYWtlUmFuZG9tS2V5IH0gZnJvbSAnLi9iaXRjb2luJztcblxuLy8gY2FuJ3QgYWRkIHR5cGVzIGZvciB0aGVzZSBzaW5jZSB0aGV5IGFyZSBwYXJ0IG9mIGJpdGdvLXV0eG8tbGliJ3MgZGVmYXVsdCBleHBvcnRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE0MDgwXG4odXR4b0xpYiBhcyBhbnkpLmhkUGF0aCA9IGhkUGF0aDtcbih1dHhvTGliIGFzIGFueSkubWFrZVJhbmRvbUtleSA9IG1ha2VSYW5kb21LZXk7XG5cbmV4cG9ydCBjb25zdCBiaXRjb2luID0gdXR4b0xpYjtcbmV4cG9ydCBjb25zdCBzamNsID0gcmVxdWlyZSgnLi92ZW5kb3Ivc2pjbC5taW4uanMnKTtcbmV4cG9ydCBjb25zdCBiczU4ID0gcmVxdWlyZSgnYnM1OCcpO1xuXG5leHBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBlcnJvcnMgZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0IGNvbnN0IEVudmlyb25tZW50cyA9IF8uY2xvbmVEZWVwKGNvbW1vbi5FbnZpcm9ubWVudHMpO1xuZXhwb3J0IGNvbnN0IEVycm9ycyA9IGVycm9ycztcbmV4cG9ydCB7IEdsb2JhbENvaW5GYWN0b3J5LCBDb2luQ29uc3RydWN0b3IgfSBmcm9tICcuL3YyL2NvaW5GYWN0b3J5JztcbmV4cG9ydCB7IFYxTmV0d29yaywgVjFSbWdOZXR3b3JrIH0gZnJvbSAnLi92Mi90eXBlcyc7XG5leHBvcnQgeyBFbnZpcm9ubWVudE5hbWUgfSBmcm9tICcuL3YyL2Vudmlyb25tZW50cyc7XG5leHBvcnQgKiBmcm9tICcuL3YyJztcblxuLyoqXG4gKiBTZXQgdGhlIG5ldHdvcmssIGkuZS4gZWl0aGVyIFwiYml0Y29pblwiIGZvciBwcm9kdWN0aW9uIHdpdGggcmVhbCBiaXRjb2luLCBvclxuICogXCJ0ZXN0bmV0XCIgZm9yIGRldmVsb3BtZW50IHdpdGggdGVzdG5ldCBiaXRjb2luLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXROZXR3b3JrKG5ldHdvcmspIHtcbiAgY29tbW9uLnNldE5ldHdvcmsobmV0d29yayk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXR3b3JrLiBSZXR1cm5zIGVpdGhlciBcImJpdGNvaW5cIiBvciBcInRlc3RuZXRcIi5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV0d29yaygpIHtcbiAgcmV0dXJuIGNvbW1vbi5nZXROZXR3b3JrKCk7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ldHdvcmtPYmooKSB7XG4gIHJldHVybiBiaXRjb2luLm5ldHdvcmtzW2NvbW1vbi5nZXROZXR3b3JrKCldO1xufVxuXG5zZXROZXR3b3JrKCd0ZXN0bmV0Jyk7XG4iXX0=