"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var Bluebird = require("bluebird");
var util_1 = require("./internal/util");
var common_1 = require("../common");
var co = Bluebird.coroutine;
var KeyIndices;
(function (KeyIndices) {
    KeyIndices[KeyIndices["USER"] = 0] = "USER";
    KeyIndices[KeyIndices["BACKUP"] = 1] = "BACKUP";
    KeyIndices[KeyIndices["BITGO"] = 2] = "BITGO";
})(KeyIndices = exports.KeyIndices || (exports.KeyIndices = {}));
var Keychains = /** @class */ (function () {
    function Keychains(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a keychain by ID
     * @param params
     * @param params.id
     * @param params.xpub (optional)
     * @param params.ethAddress (optional)
     * @param params.reqId (optional)
     * @param callback
     */
    Keychains.prototype.get = function (params, callback) {
        common_1.validateParams(params, [], ['xpub', 'ethAddress'], callback);
        if (_.isUndefined(params.id)) {
            throw new Error('id must be defined');
        }
        var id = params.id;
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return this.bitgo.get(this.baseCoin.url('/key/' + encodeURIComponent(id)))
            .result()
            .nodeify(callback);
    };
    /**
     * list the users keychains
     * @param params
     * @param params.limit - Max number of results in a single call.
     * @param params.prevId - Continue iterating (provided by nextBatchPrevId in the previous list)
     * @param callback
     * @returns {*}
     */
    Keychains.prototype.list = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var queryObject;
            return __generator(this, function (_a) {
                queryObject = {};
                if (!_.isUndefined(params.limit)) {
                    if (!_.isNumber(params.limit)) {
                        throw new Error('invalid limit argument, expecting number');
                    }
                    queryObject.limit = params.limit;
                }
                if (!_.isUndefined(params.prevId)) {
                    if (!_.isString(params.prevId)) {
                        throw new Error('invalid prevId argument, expecting string');
                    }
                    queryObject.prevId = params.prevId;
                }
                return [2 /*return*/, self.bitgo.get(self.baseCoin.url('/key')).query(queryObject).result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Change the decryption password for all possible keychains associated with a user.
     *
     * This function iterates through all keys associated with the user, decrypts
     * them with the old password and re-encrypts them with the new password.
     *
     * This should be called when a user changes their login password, and are expecting
     * that their wallet passwords are changed to match the new login password.
     *
     * @param params
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @param callback
     * @returns changedKeys Object - e.g.:
     *  {
     *    xpub1: encryptedPrv,
     *    ...
     *  }
     */
    Keychains.prototype.updatePassword = function (params, callback) {
        var self = this;
        return co(function () {
            var changedKeys, prevId, keysLeft, result, _i, _a, key, oldEncryptedPrv, updatedKeychain;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        common_1.validateParams(params, ['oldPassword', 'newPassword'], [], callback);
                        changedKeys = {};
                        keysLeft = true;
                        _b.label = 1;
                    case 1:
                        if (!keysLeft) return [3 /*break*/, 3];
                        return [4 /*yield*/, self.list({ limit: 500, prevId: prevId })];
                    case 2:
                        result = _b.sent();
                        for (_i = 0, _a = result.keys; _i < _a.length; _i++) {
                            key = _a[_i];
                            oldEncryptedPrv = key.encryptedPrv;
                            if (_.isUndefined(oldEncryptedPrv)) {
                                continue;
                            }
                            try {
                                updatedKeychain = self.updateSingleKeychainPassword({
                                    keychain: key,
                                    oldPassword: params.oldPassword,
                                    newPassword: params.newPassword
                                });
                                if (updatedKeychain.encryptedPrv) {
                                    changedKeys[updatedKeychain.pub] = updatedKeychain.encryptedPrv;
                                }
                            }
                            catch (e) {
                                // if the password was incorrect, silence the error, throw otherwise
                                if (!e.message.includes('private key is incorrect')) {
                                    throw e;
                                }
                            }
                        }
                        if (result.nextBatchPrevId) {
                            prevId = result.nextBatchPrevId;
                        }
                        else {
                            keysLeft = false;
                        }
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/, changedKeys];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Update the password used to decrypt a single keychain
     * @param params
     * @param params.keychain - The keychain whose password should be updated
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns {object}
     */
    Keychains.prototype.updateSingleKeychainPassword = function (params) {
        if (params === void 0) { params = {}; }
        if (!_.isString(params.oldPassword)) {
            throw new Error('expected old password to be a string');
        }
        if (!_.isString(params.newPassword)) {
            throw new Error('expected new password to be a string');
        }
        if (!_.isObject(params.keychain) || !_.isString(params.keychain.encryptedPrv)) {
            throw new Error('expected keychain to be an object with an encryptedPrv property');
        }
        var oldEncryptedPrv = params.keychain.encryptedPrv;
        try {
            var decryptedPrv = this.bitgo.decrypt({ input: oldEncryptedPrv, password: params.oldPassword });
            var newEncryptedPrv = this.bitgo.encrypt({ input: decryptedPrv, password: params.newPassword });
            return _.assign({}, params.keychain, { encryptedPrv: newEncryptedPrv });
        }
        catch (e) {
            // catching an error here means that the password was incorrect or, less likely, the input to decrypt is corrupted
            throw new Error('password used to decrypt keychain private key is incorrect');
        }
    };
    /**
     * Create a public/private key pair
     * @param params.seed
     */
    Keychains.prototype.create = function (params) {
        if (params === void 0) { params = {}; }
        return this.baseCoin.generateKeyPair(params.seed);
    };
    /**
     * Add a keychain to BitGo's records
     * @param params
     * @param callback
     */
    Keychains.prototype.add = function (params, callback) {
        if (params === void 0) { params = {}; }
        params = params || {};
        common_1.validateParams(params, [], ['pub', 'encryptedPrv', 'type', 'source', 'originalPasscodeEncryptionCode', 'enterprise', 'derivedFromParentWithSeed'], callback);
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return this.bitgo.post(this.baseCoin.url('/key'))
            .send({
            pub: params.pub,
            encryptedPrv: params.encryptedPrv,
            type: params.type,
            source: params.source,
            provider: params.provider,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            enterprise: params.enterprise,
            derivedFromParentWithSeed: params.derivedFromParentWithSeed,
            disableKRSEmail: params.disableKRSEmail,
            krsSpecific: params.krsSpecific
        })
            .result()
            .nodeify(callback);
    };
    /**
     * Create a BitGo key
     * @param params (empty)
     * @param callback
     */
    Keychains.prototype.createBitGo = function (params, callback) {
        if (params === void 0) { params = {}; }
        params.source = 'bitgo';
        this.baseCoin.preCreateBitGo(params);
        return this.add(params, callback);
    };
    /**
     * Create a backup key
     * @param params
     * @param params.provider (optional)
     * @param callback
     */
    Keychains.prototype.createBackup = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var key, serverResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params.source = 'backup';
                        if (_.isUndefined(params.provider)) {
                            key = self.create();
                            _.extend(params, key);
                        }
                        return [4 /*yield*/, self.add(params, callback)];
                    case 1:
                        serverResponse = _a.sent();
                        return [2 /*return*/, _.extend({}, serverResponse, _.pick(params, ['prv', 'encryptedPrv', 'provider', 'source']))];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Gets keys for signing from a wallet
     * @param params
     * @param callback
     * @returns {Bluebird[]}
     */
    Keychains.prototype.getKeysForSigning = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var wallet, reqId, ids, keychainQueriesBluebirds;
            return __generator(this, function (_a) {
                if (!_.isObject(params.wallet)) {
                    throw new Error('missing required param wallet');
                }
                wallet = params.wallet;
                reqId = params.reqId || new util_1.RequestTracer();
                ids = wallet.baseCoin.keyIdsForSigning();
                keychainQueriesBluebirds = ids.map(function (id) { return self.get({ id: wallet.keyIds()[id], reqId: reqId }); });
                return [2 /*return*/, Bluebird.all(keychainQueriesBluebirds)];
            });
        }).call(this).asCallback(callback);
    };
    return Keychains;
}());
exports.Keychains = Keychains;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL2tleWNoYWlucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDBCQUE0QjtBQUM1QixtQ0FBcUM7QUFNckMsd0NBQWdEO0FBQ2hELG9DQUEyQztBQUUzQyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBNkU5QixJQUFZLFVBSVg7QUFKRCxXQUFZLFVBQVU7SUFDcEIsMkNBQVEsQ0FBQTtJQUNSLCtDQUFVLENBQUE7SUFDViw2Q0FBUyxDQUFBO0FBQ1gsQ0FBQyxFQUpXLFVBQVUsR0FBVixrQkFBVSxLQUFWLGtCQUFVLFFBSXJCO0FBRUQ7SUFLRSxtQkFBWSxLQUFZLEVBQUUsUUFBa0I7UUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsdUJBQUcsR0FBSCxVQUFJLE1BQTBCLEVBQUUsUUFBaUM7UUFDL0QsdUJBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRTdELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsSUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUNyQixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0M7UUFDRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxD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RUFBRSxDQUFDO2dCQUM1QyxHQUFHLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO2dCQUN6Qyx3QkFBd0IsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUN0QyxVQUFBLEVBQUUsSUFBSSxPQUFBLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssT0FBQSxFQUFFLENBQUMsRUFBNUMsQ0FBNEMsQ0FDbkQsQ0FBQztnQkFDRixzQkFBTyxRQUFRLENBQUMsR0FBRyxDQUFDLHdCQUF3QixDQUFDLEVBQUM7O1NBQy9DLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFDSCxnQkFBQztBQUFELENBQUMsQUE5UEQsSUE4UEM7QUE5UFksOEJBQVMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uL2JpdGdvJztcblxuaW1wb3J0IHsgQmFzZUNvaW4sIEtleVBhaXIgfSBmcm9tICcuL2Jhc2VDb2luJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnLi93YWxsZXQnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4vaW50ZXJuYWwvdXRpbCc7XG5pbXBvcnQgeyB2YWxpZGF0ZVBhcmFtcyB9IGZyb20gJy4uL2NvbW1vbic7XG5cbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5leHBvcnQgaW50ZXJmYWNlIEtleWNoYWluIHtcbiAgaWQ6IHN0cmluZztcbiAgcHViOiBzdHJpbmc7XG4gIHBydj86IHN0cmluZztcbiAgcHJvdmlkZXI/OiBzdHJpbmc7XG4gIGVuY3J5cHRlZFBydj86IHN0cmluZztcbiAgZGVyaXZhdGlvblBhdGg/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhbmdlZEtleWNoYWlucyB7XG4gIFtwdWJrZXk6IHN0cmluZ106IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0S2V5Y2hhaW5zUmVzdWx0IHtcbiAga2V5czogS2V5Y2hhaW5bXTtcbiAgbmV4dEJhdGNoUHJldklkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEtleWNoYWluT3B0aW9ucyB7XG4gIGlkOiBzdHJpbmc7XG4gIHhwdWI/OiBzdHJpbmc7XG4gIGV0aEFkZHJlc3M/OiBzdHJpbmc7XG4gIHJlcUlkPzogUmVxdWVzdFRyYWNlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0S2V5Y2hhaW5PcHRpb25zIHtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIHByZXZJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVQYXNzd29yZE9wdGlvbnMge1xuICBvbGRQYXNzd29yZDogc3RyaW5nO1xuICBuZXdQYXNzd29yZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVXBkYXRlU2luZ2xlS2V5Y2hhaW5QYXNzd29yZE9wdGlvbnMge1xuICBrZXljaGFpbj86IEtleWNoYWluO1xuICBvbGRQYXNzd29yZD86IHN0cmluZztcbiAgbmV3UGFzc3dvcmQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBBZGRLZXljaGFpbk9wdGlvbnMge1xuICBwdWI/OiBzdHJpbmc7XG4gIGVuY3J5cHRlZFBydj86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgc291cmNlPzogc3RyaW5nO1xuICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmc7XG4gIGVudGVycHJpc2U/OiBzdHJpbmc7XG4gIGRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQ/OiBhbnk7XG4gIGRpc2FibGVLUlNFbWFpbD86IGJvb2xlYW47XG4gIHByb3ZpZGVyPzogc3RyaW5nO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gIGtyc1NwZWNpZmljPzogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQmFja3VwT3B0aW9ucyB7XG4gIHByb3ZpZGVyPzogc3RyaW5nO1xuICBzb3VyY2U/OiBzdHJpbmc7XG4gIGRpc2FibGVLUlNFbWFpbD86IGJvb2xlYW47XG4gIGtyc1NwZWNpZmljPzogYW55O1xuICB0eXBlPzogc3RyaW5nO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG59XG5cbmludGVyZmFjZSBDcmVhdGVCaXRHb09wdGlvbnMge1xuICBzb3VyY2U/OiAnYml0Z28nO1xuICBlbnRlcnByaXNlPzogc3RyaW5nO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG59XG5cbmludGVyZmFjZSBHZXRLZXlzRm9yU2lnbmluZ09wdGlvbnMge1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gIHdhbGxldD86IFdhbGxldDtcbn1cblxuZXhwb3J0IGVudW0gS2V5SW5kaWNlcyB7XG4gIFVTRVIgPSAwLFxuICBCQUNLVVAgPSAxLFxuICBCSVRHTyA9IDIsXG59XG5cbmV4cG9ydCBjbGFzcyBLZXljaGFpbnMge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBCYXNlQ29pbjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIGJhc2VDb2luOiBCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEga2V5Y2hhaW4gYnkgSURcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmlkXG4gICAqIEBwYXJhbSBwYXJhbXMueHB1YiAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBwYXJhbXMuZXRoQWRkcmVzcyAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBwYXJhbXMucmVxSWQgKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldChwYXJhbXM6IEdldEtleWNoYWluT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8S2V5Y2hhaW4+KTogQmx1ZWJpcmQ8S2V5Y2hhaW4+IHtcbiAgICB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3hwdWInLCAnZXRoQWRkcmVzcyddLCBjYWxsYmFjayk7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkO1xuICAgIGlmIChwYXJhbXMucmVxSWQpIHtcbiAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy9rZXkvJyArIGVuY29kZVVSSUNvbXBvbmVudChpZCkpKVxuICAgICAgICAucmVzdWx0KClcbiAgICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIGxpc3QgdGhlIHVzZXJzIGtleWNoYWluc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMubGltaXQgLSBNYXggbnVtYmVyIG9mIHJlc3VsdHMgaW4gYSBzaW5nbGUgY2FsbC5cbiAgICogQHBhcmFtIHBhcmFtcy5wcmV2SWQgLSBDb250aW51ZSBpdGVyYXRpbmcgKHByb3ZpZGVkIGJ5IG5leHRCYXRjaFByZXZJZCBpbiB0aGUgcHJldmlvdXMgbGlzdClcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgbGlzdChwYXJhbXM6IExpc3RLZXljaGFpbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8TGlzdEtleWNoYWluc1Jlc3VsdD4pOiBCbHVlYmlyZDxMaXN0S2V5Y2hhaW5zUmVzdWx0PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPExpc3RLZXljaGFpbnNSZXN1bHQ+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBxdWVyeU9iamVjdDogYW55ID0ge307XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnlPYmplY3QubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5T2JqZWN0LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLmdldChzZWxmLmJhc2VDb2luLnVybCgnL2tleScpKS5xdWVyeShxdWVyeU9iamVjdCkucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGRlY3J5cHRpb24gcGFzc3dvcmQgZm9yIGFsbCBwb3NzaWJsZSBrZXljaGFpbnMgYXNzb2NpYXRlZCB3aXRoIGEgdXNlci5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpdGVyYXRlcyB0aHJvdWdoIGFsbCBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciwgZGVjcnlwdHNcbiAgICogdGhlbSB3aXRoIHRoZSBvbGQgcGFzc3dvcmQgYW5kIHJlLWVuY3J5cHRzIHRoZW0gd2l0aCB0aGUgbmV3IHBhc3N3b3JkLlxuICAgKlxuICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgd2hlbiBhIHVzZXIgY2hhbmdlcyB0aGVpciBsb2dpbiBwYXNzd29yZCwgYW5kIGFyZSBleHBlY3RpbmdcbiAgICogdGhhdCB0aGVpciB3YWxsZXQgcGFzc3dvcmRzIGFyZSBjaGFuZ2VkIHRvIG1hdGNoIHRoZSBuZXcgbG9naW4gcGFzc3dvcmQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5vbGRQYXNzd29yZCAtIFRoZSBvbGQgcGFzc3dvcmQgdXNlZCBmb3IgZW5jcnlwdGluZyB0aGUga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkIHRvIGJlIHVzZWQgZm9yIGVuY3J5cHRpbmcgdGhlIGtleVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgY2hhbmdlZEtleXMgT2JqZWN0IC0gZS5nLjpcbiAgICogIHtcbiAgICogICAgeHB1YjE6IGVuY3J5cHRlZFBydixcbiAgICogICAgLi4uXG4gICAqICB9XG4gICAqL1xuICB1cGRhdGVQYXNzd29yZChwYXJhbXM6IFVwZGF0ZVBhc3N3b3JkT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Q2hhbmdlZEtleWNoYWlucz4pOiBCbHVlYmlyZDxDaGFuZ2VkS2V5Y2hhaW5zPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPENoYW5nZWRLZXljaGFpbnM+KGZ1bmN0aW9uICooKSB7XG4gICAgICB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnb2xkUGFzc3dvcmQnLCAnbmV3UGFzc3dvcmQnXSwgW10sIGNhbGxiYWNrKTtcbiAgICAgIGNvbnN0IGNoYW5nZWRLZXlzOiBDaGFuZ2VkS2V5Y2hhaW5zID0ge307XG4gICAgICBsZXQgcHJldklkO1xuICAgICAgbGV0IGtleXNMZWZ0ID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChrZXlzTGVmdCkge1xuICAgICAgICBjb25zdCByZXN1bHQ6IExpc3RLZXljaGFpbnNSZXN1bHQgPSB5aWVsZCBzZWxmLmxpc3QoeyBsaW1pdDogNTAwLCBwcmV2SWQgfSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlc3VsdC5rZXlzKSB7XG4gICAgICAgICAgY29uc3Qgb2xkRW5jcnlwdGVkUHJ2ID0ga2V5LmVuY3J5cHRlZFBydjtcbiAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChvbGRFbmNyeXB0ZWRQcnYpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRLZXljaGFpbiA9IHNlbGYudXBkYXRlU2luZ2xlS2V5Y2hhaW5QYXNzd29yZCh7XG4gICAgICAgICAgICAgIGtleWNoYWluOiBrZXksXG4gICAgICAgICAgICAgIG9sZFBhc3N3b3JkOiBwYXJhbXMub2xkUGFzc3dvcmQsXG4gICAgICAgICAgICAgIG5ld1Bhc3N3b3JkOiBwYXJhbXMubmV3UGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZWRLZXljaGFpbi5lbmNyeXB0ZWRQcnYpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZEtleXNbdXBkYXRlZEtleWNoYWluLnB1Yl0gPSB1cGRhdGVkS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXNzd29yZCB3YXMgaW5jb3JyZWN0LCBzaWxlbmNlIHRoZSBlcnJvciwgdGhyb3cgb3RoZXJ3aXNlXG4gICAgICAgICAgICBpZiAoIWUubWVzc2FnZS5pbmNsdWRlcygncHJpdmF0ZSBrZXkgaXMgaW5jb3JyZWN0JykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5uZXh0QmF0Y2hQcmV2SWQpIHtcbiAgICAgICAgICBwcmV2SWQgPSByZXN1bHQubmV4dEJhdGNoUHJldklkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleXNMZWZ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2VkS2V5cztcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcGFzc3dvcmQgdXNlZCB0byBkZWNyeXB0IGEgc2luZ2xlIGtleWNoYWluXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5rZXljaGFpbiAtIFRoZSBrZXljaGFpbiB3aG9zZSBwYXNzd29yZCBzaG91bGQgYmUgdXBkYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zLm9sZFBhc3N3b3JkIC0gVGhlIG9sZCBwYXNzd29yZCB1c2VkIGZvciBlbmNyeXB0aW5nIHRoZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtcy5uZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQgdG8gYmUgdXNlZCBmb3IgZW5jcnlwdGluZyB0aGUga2V5XG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICB1cGRhdGVTaW5nbGVLZXljaGFpblBhc3N3b3JkKHBhcmFtczogVXBkYXRlU2luZ2xlS2V5Y2hhaW5QYXNzd29yZE9wdGlvbnMgPSB7fSk6IEtleWNoYWluIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLm9sZFBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBvbGQgcGFzc3dvcmQgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLm5ld1Bhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBuZXcgcGFzc3dvcmQgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmtleWNoYWluKSB8fCAhXy5pc1N0cmluZyhwYXJhbXMua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBrZXljaGFpbiB0byBiZSBhbiBvYmplY3Qgd2l0aCBhbiBlbmNyeXB0ZWRQcnYgcHJvcGVydHknKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRFbmNyeXB0ZWRQcnYgPSBwYXJhbXMua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogb2xkRW5jcnlwdGVkUHJ2LCBwYXNzd29yZDogcGFyYW1zLm9sZFBhc3N3b3JkIH0pO1xuICAgICAgY29uc3QgbmV3RW5jcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5lbmNyeXB0KHsgaW5wdXQ6IGRlY3J5cHRlZFBydiwgcGFzc3dvcmQ6IHBhcmFtcy5uZXdQYXNzd29yZCB9KTtcbiAgICAgIHJldHVybiBfLmFzc2lnbih7fSwgcGFyYW1zLmtleWNoYWluLCB7IGVuY3J5cHRlZFBydjogbmV3RW5jcnlwdGVkUHJ2IH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGNhdGNoaW5nIGFuIGVycm9yIGhlcmUgbWVhbnMgdGhhdCB0aGUgcGFzc3dvcmQgd2FzIGluY29ycmVjdCBvciwgbGVzcyBsaWtlbHksIHRoZSBpbnB1dCB0byBkZWNyeXB0IGlzIGNvcnJ1cHRlZFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZCB1c2VkIHRvIGRlY3J5cHQga2V5Y2hhaW4gcHJpdmF0ZSBrZXkgaXMgaW5jb3JyZWN0Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHB1YmxpYy9wcml2YXRlIGtleSBwYWlyXG4gICAqIEBwYXJhbSBwYXJhbXMuc2VlZFxuICAgKi9cbiAgY3JlYXRlKHBhcmFtczogeyBzZWVkPzogQnVmZmVyIH0gPSB7fSk6IEtleVBhaXIge1xuICAgIHJldHVybiB0aGlzLmJhc2VDb2luLmdlbmVyYXRlS2V5UGFpcihwYXJhbXMuc2VlZCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEga2V5Y2hhaW4gdG8gQml0R28ncyByZWNvcmRzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBhZGQocGFyYW1zOiBBZGRLZXljaGFpbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8S2V5Y2hhaW4+KTogQmx1ZWJpcmQ8S2V5Y2hhaW4+IHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydwdWInLCAnZW5jcnlwdGVkUHJ2JywgJ3R5cGUnLCAnc291cmNlJywgJ29yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZScsICdlbnRlcnByaXNlJywgJ2Rlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQnXSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5kaXNhYmxlS1JTRW1haWwpKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5kaXNhYmxlS1JTRW1haWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkaXNhYmxlS1JTRW1haWwgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy9rZXknKSlcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgcHViOiBwYXJhbXMucHViLFxuICAgICAgICBlbmNyeXB0ZWRQcnY6IHBhcmFtcy5lbmNyeXB0ZWRQcnYsXG4gICAgICAgIHR5cGU6IHBhcmFtcy50eXBlLFxuICAgICAgICBzb3VyY2U6IHBhcmFtcy5zb3VyY2UsXG4gICAgICAgIHByb3ZpZGVyOiBwYXJhbXMucHJvdmlkZXIsXG4gICAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogcGFyYW1zLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgICAgIGRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQ6IHBhcmFtcy5kZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkLFxuICAgICAgICBkaXNhYmxlS1JTRW1haWw6IHBhcmFtcy5kaXNhYmxlS1JTRW1haWwsXG4gICAgICAgIGtyc1NwZWNpZmljOiBwYXJhbXMua3JzU3BlY2lmaWNcbiAgICAgIH0pXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCaXRHbyBrZXlcbiAgICogQHBhcmFtIHBhcmFtcyAoZW1wdHkpXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgY3JlYXRlQml0R28ocGFyYW1zOiBDcmVhdGVCaXRHb09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8S2V5Y2hhaW4+KTogQmx1ZWJpcmQ8S2V5Y2hhaW4+IHtcbiAgICBwYXJhbXMuc291cmNlID0gJ2JpdGdvJztcblxuICAgIHRoaXMuYmFzZUNvaW4ucHJlQ3JlYXRlQml0R28ocGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcy5hZGQocGFyYW1zLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgYmFja3VwIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMucHJvdmlkZXIgKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNyZWF0ZUJhY2t1cChwYXJhbXM6IENyZWF0ZUJhY2t1cE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8S2V5Y2hhaW4+KTogQmx1ZWJpcmQ8S2V5Y2hhaW4+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288S2V5Y2hhaW4+KGZ1bmN0aW9uICooKSB7XG4gICAgICBwYXJhbXMuc291cmNlID0gJ2JhY2t1cCc7XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcm92aWRlcikpIHtcbiAgICAgICAgLy8gaWYgdGhlIHByb3ZpZGVyIGlzIHVuZGVmaW5lZCwgd2UgZ2VuZXJhdGUgYSBsb2NhbCBrZXkgYW5kIGFkZCB0aGUgc291cmNlIGRldGFpbHNcbiAgICAgICAgY29uc3Qga2V5ID0gc2VsZi5jcmVhdGUoKTtcbiAgICAgICAgXy5leHRlbmQocGFyYW1zLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IHlpZWxkIHNlbGYuYWRkKHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBzZXJ2ZXJSZXNwb25zZSwgXy5waWNrKHBhcmFtcywgWydwcnYnLCAnZW5jcnlwdGVkUHJ2JywgJ3Byb3ZpZGVyJywgJ3NvdXJjZSddKSk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGtleXMgZm9yIHNpZ25pbmcgZnJvbSBhIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Qmx1ZWJpcmRbXX1cbiAgICovXG4gIGdldEtleXNGb3JTaWduaW5nKHBhcmFtczogR2V0S2V5c0ZvclNpZ25pbmdPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEtleWNoYWluW10+KTogQmx1ZWJpcmQ8S2V5Y2hhaW5bXT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxLZXljaGFpbltdPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy53YWxsZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSB3YWxsZXQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGxldCA9IHBhcmFtcy53YWxsZXQ7XG4gICAgICBjb25zdCByZXFJZCA9IHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgICAgY29uc3QgaWRzID0gd2FsbGV0LmJhc2VDb2luLmtleUlkc0ZvclNpZ25pbmcoKTtcbiAgICAgIGNvbnN0IGtleWNoYWluUXVlcmllc0JsdWViaXJkcyA9IGlkcy5tYXAoXG4gICAgICAgIGlkID0+IHNlbGYuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtpZF0sIHJlcUlkIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIEJsdWViaXJkLmFsbChrZXljaGFpblF1ZXJpZXNCbHVlYmlyZHMpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cbn1cblxuIl19