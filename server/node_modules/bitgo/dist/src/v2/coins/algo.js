"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var _ = require("lodash");
var stellar = require("stellar-sdk");
var algosdk_1 = require("algosdk");
var baseCoin_1 = require("../baseCoin");
var keychains_1 = require("../keychains");
var co = Bluebird.coroutine;
var Algo = /** @class */ (function (_super) {
    __extends(Algo, _super);
    function Algo(bitgo) {
        return _super.call(this, bitgo) || this;
    }
    Algo.createInstance = function (bitgo) {
        return new Algo(bitgo);
    };
    Algo.prototype.getChain = function () {
        return 'algo';
    };
    Algo.prototype.getFamily = function () {
        return 'algo';
    };
    Algo.prototype.getFullName = function () {
        return 'Algorand';
    };
    Algo.prototype.getBaseFactor = function () {
        return 1e6;
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Algo.prototype.valuelessTransferAllowed = function () {
        // TODO: this sounds like its true with the staking txes - confirm before launch
        return false;
    };
    /**
     * Algorand supports account consolidations. These are transfers from the receive addresses
     * to the main address.
     */
    Algo.prototype.allowsAccountConsolidations = function () {
        return true;
    };
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    Algo.prototype.generateKeyPair = function (seed) {
        var pair = seed ? algosdk_1.generateAccountFromSeed(seed) : algosdk_1.generateAccount();
        return {
            pub: pair.addr,
            prv: algosdk_1.Seed.encode(pair.sk),
        };
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidPub = function (pub) {
        return algosdk_1.isValidAddress(pub);
    };
    /**
     * Return boolean indicating whether input is valid seed for the coin
     * In Algorand, when the private key is encoded as base32 string only the first 32 bytes are taken,
     * so the encoded value is actually the seed
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidPrv = function (prv) {
        return algosdk_1.isValidSeed(prv);
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidAddress = function (address) {
        return algosdk_1.isValidAddress(address);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    Algo.prototype.signMessage = function (key, message) {
        // key.prv actually holds the encoded seed, but we use the prv name to avoid breaking the keypair schema.
        // See jsdoc comment in isValidPrv
        var seed = key.prv;
        if (!this.isValidPrv(seed)) {
            throw new Error("invalid seed: " + seed);
        }
        if (typeof seed === 'string') {
            try {
                seed = algosdk_1.Seed.decode(seed).seed;
            }
            catch (e) {
                throw new Error("could not decode seed: " + seed);
            }
        }
        var keyPair = algosdk_1.generateAccountFromSeed(seed);
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        return Buffer.from(algosdk_1.NaclWrapper.sign(message, keyPair.sk));
    };
    /**
     * Specifies what key we will need for signing` - Algorand needs the backup, bitgo pubs.
     */
    Algo.prototype.keyIdsForSigning = function () {
        return [keychains_1.KeyIndices.USER, keychains_1.KeyIndices.BACKUP, keychains_1.KeyIndices.BITGO];
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Algo.prototype.explainTransaction = function (params, callback) {
        return co(function () {
            var txHex, tx, type, senderAddress, voteKeyBase64, voteLastBlock, txToHex, decodedTx, txnForDecoding, id, fee, outputAmount, outputs, memo;
            return __generator(this, function (_a) {
                txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                if (!txHex) {
                    throw new Error('missing required param txHex or halfSigned.txHex');
                }
                try {
                    txToHex = Buffer.from(txHex, 'base64');
                    decodedTx = algosdk_1.Encoding.decode(txToHex);
                    txnForDecoding = decodedTx.txn || decodedTx;
                    if (!!txnForDecoding.votekey) {
                        type = txnForDecoding.type;
                        senderAddress = algosdk_1.Address.encode(txnForDecoding.snd);
                        voteKeyBase64 = txnForDecoding.votekey.toString('base64');
                        voteLastBlock = txnForDecoding.votelst;
                    }
                    tx = algosdk_1.Multisig.MultiSigTransaction.from_obj_for_encoding(txnForDecoding);
                }
                catch (ex) {
                    throw new Error('txHex needs to be a valid tx encoded as base64 string');
                }
                id = tx.txID();
                fee = { fee: tx.fee };
                outputAmount = tx.amount || 0;
                outputs = [];
                if (tx.to) {
                    outputs.push({
                        amount: outputAmount,
                        address: algosdk_1.Address.encode(new Uint8Array(tx.to.publicKey)),
                    });
                }
                memo = tx.note;
                return [2 /*return*/, {
                        displayOrder: [
                            'id',
                            'outputAmount',
                            'changeAmount',
                            'outputs',
                            'changeOutputs',
                            'fee',
                            'memo',
                            'type',
                            'senderAddress',
                            'voteKeyBase64',
                            'voteLastBlock',
                        ],
                        id: id,
                        outputs: outputs,
                        outputAmount: outputAmount,
                        changeAmount: 0,
                        fee: fee,
                        changeOutputs: [],
                        memo: memo,
                        type: type,
                        senderAddress: senderAddress,
                        voteKeyBase64: voteKeyBase64,
                        voteLastBlock: voteLastBlock,
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Algo.prototype.isStellarSeed = function (seed) {
        return stellar.StrKey.isValidEd25519SecretSeed(seed);
    };
    Algo.prototype.convertFromStellarSeed = function (seed) {
        // assume this is a trust custodial seed if its a valid ed25519 prv
        if (!this.isStellarSeed(seed)) {
            return null;
        }
        return algosdk_1.Seed.encode(stellar.StrKey.decodeEd25519SecretSeed(seed));
    };
    Algo.prototype.verifySignTransactionParams = function (params) {
        var prv = params.prv;
        var addressVersion = params.txPrebuild.addressVersion;
        var isHalfSigned = false;
        // it's possible this tx was already signed - take the halfSigned
        // txHex if it is
        var txHex = params.txPrebuild.txHex;
        if (params.txPrebuild.halfSigned) {
            isHalfSigned = true;
            txHex = params.txPrebuild.halfSigned.txHex;
        }
        if (_.isUndefined(txHex)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error("txPrebuild must be an object, got type " + typeof txHex);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error("prv must be a string, got type " + typeof prv);
        }
        if (!_.has(params.txPrebuild, 'keys[0]') ||
            !_.has(params.txPrebuild, 'keys[1]') ||
            !_.has(params.txPrebuild, 'keys[2]')) {
            throw new Error('missing public keys parameter to sign transaction');
        }
        if (!_.isNumber(addressVersion)) {
            throw new Error('missing addressVersion parameter to sign transaction');
        }
        // we need to re-encode our public keys using algosdk's format
        var keys = [params.txPrebuild.keys[0], params.txPrebuild.keys[1], params.txPrebuild.keys[2]];
        // re-encode sk from our prv (this acts as a seed out of the keychain)
        var seed = algosdk_1.Seed.decode(prv).seed;
        var pair = algosdk_1.generateAccountFromSeed(seed);
        var sk = pair.sk;
        return { txHex: txHex, addressVersion: addressVersion, keys: keys, sk: sk, isHalfSigned: isHalfSigned };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     */
    Algo.prototype.signTransaction = function (params) {
        var _a = this.verifySignTransactionParams(params), txHex = _a.txHex, addressVersion = _a.addressVersion, keys = _a.keys, sk = _a.sk, isHalfSigned = _a.isHalfSigned;
        var encodedPublicKeys = _.map(keys, function (k) { return algosdk_1.Address.decode(k).publicKey; });
        // decode our unsigned/half-signed tx
        var transaction;
        var txToHex;
        try {
            txToHex = Buffer.from(txHex, 'base64');
            var initialDecodedTx = algosdk_1.Encoding.decode(txToHex);
            // we need to scrub the txn of sigs for half-signed
            var decodedTx = isHalfSigned ? initialDecodedTx.txn : initialDecodedTx;
            transaction = algosdk_1.Multisig.MultiSigTransaction.from_obj_for_encoding(decodedTx);
        }
        catch (e) {
            throw new Error('transaction needs to be a valid tx encoded as base64 string');
        }
        // sign our tx
        var signed = transaction.partialSignTxn({ version: addressVersion, threshold: 2, pks: encodedPublicKeys }, sk);
        // if we have already signed it, we'll have to merge that with our previous tx
        if (isHalfSigned) {
            signed = algosdk_1.mergeMultisigTransactions([Buffer.from(signed), txToHex]);
        }
        var signedBase64 = Buffer.from(signed).toString('base64');
        if (isHalfSigned) {
            return { txHex: signedBase64 };
        }
        else {
            return { halfSigned: { txHex: signedBase64 } };
        }
    };
    Algo.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Algo.prototype.verifyAddress = function (params) {
        return true;
    };
    Algo.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    return Algo;
}(baseCoin_1.BaseCoin));
exports.Algo = Algo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnby5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9hbGdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsbUNBQXFDO0FBQ3JDLDBCQUE0QjtBQUM1QixxQ0FBdUM7QUFDdkMsbUNBV2lCO0FBR2pCLHdDQVNxQjtBQUNyQiwwQ0FBMEM7QUFHMUMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQTREOUI7SUFBMEIsd0JBQVE7SUFDaEMsY0FBWSxLQUFZO2VBQ3RCLGtCQUFNLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFTSxtQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELHVCQUFRLEdBQVI7UUFDRSxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsd0JBQVMsR0FBVDtRQUNFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCwwQkFBVyxHQUFYO1FBQ0UsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztJQUVELDRCQUFhLEdBQWI7UUFDRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7O09BR0c7SUFDSCx1Q0FBd0IsR0FBeEI7UUFDRSxnRkFBZ0Y7UUFDaEYsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsMENBQTJCLEdBQTNCO1FBQ0UsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw4QkFBZSxHQUFmLFVBQWdCLElBQWE7UUFDM0IsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxpQ0FBdUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMseUJBQWUsRUFBRSxDQUFDO1FBQ3RFLE9BQU87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QUFjLENBQUMsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFL0csOEVBQThFO1FBQzlFLElBQUksWUFBWSxFQUFFO1lBQ2hCLE1BQU0sR0FBRyxtQ0FBeUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztTQUNwRTtRQUVELElBQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTVELElBQUksWUFBWSxFQUFFO1lBQ2hCLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLENBQUM7U0FDaEM7YUFBTTtZQUNMLE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEVBQUUsQ0FBQztTQUNoRDtJQUNILENBQUM7SUFFRCwrQkFBZ0IsR0FBaEIsVUFDRSxNQUErQixFQUMvQixRQUEwQztRQUUxQyxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRCw0QkFBYSxHQUFiLFVBQWMsTUFBNEI7UUFDeEMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsZ0NBQWlCLEdBQWpCLFVBQWtCLE1BQWdDLEVBQUUsUUFBZ0M7UUFDbEYsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBQ0gsV0FBQztBQUFELENBQUMsQUF6VUQsQ0FBMEIsbUJBQVEsR0F5VWpDO0FBelVZLG9CQUFJIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgc3RlbGxhciBmcm9tICdzdGVsbGFyLXNkayc7XG5pbXBvcnQge1xuICBOYWNsV3JhcHBlcixcbiAgTXVsdGlzaWcsXG4gIEFkZHJlc3MsXG4gIFNlZWQsXG4gIGdlbmVyYXRlQWNjb3VudEZyb21TZWVkLFxuICBnZW5lcmF0ZUFjY291bnQsXG4gIGlzVmFsaWRBZGRyZXNzLFxuICBpc1ZhbGlkU2VlZCxcbiAgRW5jb2RpbmcsXG4gIG1lcmdlTXVsdGlzaWdUcmFuc2FjdGlvbnMsXG59IGZyb20gJ2FsZ29zZGsnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGFzIEJhc2VUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBLZXlQYWlyLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBLZXlJbmRpY2VzIH0gZnJvbSAnLi4va2V5Y2hhaW5zJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHtcbiAgbWVtbzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xuICBzZW5kZXJBZGRyZXNzPzogc3RyaW5nO1xuICB2b3RlS2V5QmFzZTY0Pzogc3RyaW5nO1xuICB2b3RlTGFzdEJsb2NrPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICB9O1xuICB0eEluZm86IHtcbiAgICBmcm9tOiBzdHJpbmc7XG4gICAgdG86IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZztcbiAgICBmZWU6IG51bWJlcjtcbiAgICBmaXJzdFJvdW5kOiBudW1iZXI7XG4gICAgbGFzdFJvdW5kOiBudW1iZXI7XG4gICAgZ2VuZXNpc0lEOiBzdHJpbmc7XG4gICAgZ2VuZXNpc0hhc2g6IHN0cmluZztcbiAgICBub3RlPzogc3RyaW5nO1xuICB9O1xuICBrZXlzOiBzdHJpbmdbXTtcbiAgYWRkcmVzc1ZlcnNpb246IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkOiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZmllZFRyYW5zYWN0aW9uUGFyYW1ldGVycyB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGFkZHJlc3NWZXJzaW9uOiBudW1iZXI7XG4gIGtleXM6IHN0cmluZ1tdO1xuICBzazogc3RyaW5nO1xuICBpc0hhbGZTaWduZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBBbGdvIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28pIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgQWxnbyhiaXRnbyk7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnYWxnbyc7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2FsZ28nO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0FsZ29yYW5kJztcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKTogYW55IHtcbiAgICByZXR1cm4gMWU2O1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogdGhpcyBzb3VuZHMgbGlrZSBpdHMgdHJ1ZSB3aXRoIHRoZSBzdGFraW5nIHR4ZXMgLSBjb25maXJtIGJlZm9yZSBsYXVuY2hcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQWxnb3JhbmQgc3VwcG9ydHMgYWNjb3VudCBjb25zb2xpZGF0aW9ucy4gVGhlc2UgYXJlIHRyYW5zZmVycyBmcm9tIHRoZSByZWNlaXZlIGFkZHJlc3Nlc1xuICAgKiB0byB0aGUgbWFpbiBhZGRyZXNzLlxuICAgKi9cbiAgYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGVkMjU1MTkga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiwgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IHBhaXIgPSBzZWVkID8gZ2VuZXJhdGVBY2NvdW50RnJvbVNlZWQoc2VlZCkgOiBnZW5lcmF0ZUFjY291bnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBwYWlyLmFkZHIsIC8vIGVuY29kZWQgcHViXG4gICAgICBwcnY6IFNlZWQuZW5jb2RlKHBhaXIuc2spLCAvLyBlbmNvZGVkIHNlZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1ZhbGlkQWRkcmVzcyhwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBzZWVkIGZvciB0aGUgY29pblxuICAgKiBJbiBBbGdvcmFuZCwgd2hlbiB0aGUgcHJpdmF0ZSBrZXkgaXMgZW5jb2RlZCBhcyBiYXNlMzIgc3RyaW5nIG9ubHkgdGhlIGZpcnN0IDMyIGJ5dGVzIGFyZSB0YWtlbixcbiAgICogc28gdGhlIGVuY29kZWQgdmFsdWUgaXMgYWN0dWFsbHkgdGhlIHNlZWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1ZhbGlkU2VlZChwcnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogQnVmZmVyIHtcbiAgICAvLyBrZXkucHJ2IGFjdHVhbGx5IGhvbGRzIHRoZSBlbmNvZGVkIHNlZWQsIGJ1dCB3ZSB1c2UgdGhlIHBydiBuYW1lIHRvIGF2b2lkIGJyZWFraW5nIHRoZSBrZXlwYWlyIHNjaGVtYS5cbiAgICAvLyBTZWUganNkb2MgY29tbWVudCBpbiBpc1ZhbGlkUHJ2XG4gICAgbGV0IHNlZWQgPSBrZXkucHJ2O1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUHJ2KHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VlZDogJHtzZWVkfWApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWVkID0gU2VlZC5kZWNvZGUoc2VlZCkuc2VlZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3QgZGVjb2RlIHNlZWQ6ICR7c2VlZH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2V5UGFpciA9IGdlbmVyYXRlQWNjb3VudEZyb21TZWVkKHNlZWQpO1xuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oTmFjbFdyYXBwZXIuc2lnbihtZXNzYWdlLCBrZXlQYWlyLnNrKSk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHdoYXQga2V5IHdlIHdpbGwgbmVlZCBmb3Igc2lnbmluZ2AgLSBBbGdvcmFuZCBuZWVkcyB0aGUgYmFja3VwLCBiaXRnbyBwdWJzLlxuICAgKi9cbiAga2V5SWRzRm9yU2lnbmluZygpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFtLZXlJbmRpY2VzLlVTRVIsIEtleUluZGljZXMuQkFDS1VQLCBLZXlJbmRpY2VzLkJJVEdPXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+XG4gICk6IEJsdWViaXJkPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgLy8gdGFrZSB0eEhleCBmaXJzdCBhbHdheXMsIGJ1dCBhcyBpdCBtaWdodCBhbHJlYWR5IGJlIHNpZ25lZCwgdGFrZSBoYWxmU2lnbmVkIHNlY29uZFxuICAgICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcblxuICAgICAgaWYgKCF0eEhleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gdHhIZXggb3IgaGFsZlNpZ25lZC50eEhleCcpO1xuICAgICAgfVxuICAgICAgbGV0IHR4LCB0eXBlLCBzZW5kZXJBZGRyZXNzLCB2b3RlS2V5QmFzZTY0LCB2b3RlTGFzdEJsb2NrO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHhUb0hleCA9IEJ1ZmZlci5mcm9tKHR4SGV4LCAnYmFzZTY0Jyk7XG4gICAgICAgIGNvbnN0IGRlY29kZWRUeCA9IEVuY29kaW5nLmRlY29kZSh0eFRvSGV4KTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmUgYSBzaWduZWQgbXNpZyB0eCwgdGhlIHN0cnVjdHVyZSBhY3R1YWxseSBoYXMgdGhlIHsgbXNpZywgdHhuIH0gYXMgdGhlIHJvb3Qgb2JqZWN0XG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgc2lnbmVkLCB0aGUgZGVjb2RlZCB0eCBpcyB0aGUgdHhuIC0gcmVmZXIgdG8gcGFydGlhbFNpZ25UeG4gYW5kIE11bHRpU2lnIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vICAgaW4gYWxnb3NkayBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgICAgICBjb25zdCB0eG5Gb3JEZWNvZGluZyA9IGRlY29kZWRUeC50eG4gfHwgZGVjb2RlZFR4O1xuICAgICAgICBpZiAoISF0eG5Gb3JEZWNvZGluZy52b3Rla2V5KSB7XG4gICAgICAgICAgdHlwZSA9IHR4bkZvckRlY29kaW5nLnR5cGU7XG4gICAgICAgICAgc2VuZGVyQWRkcmVzcyA9IEFkZHJlc3MuZW5jb2RlKHR4bkZvckRlY29kaW5nLnNuZCk7XG4gICAgICAgICAgdm90ZUtleUJhc2U2NCA9IHR4bkZvckRlY29kaW5nLnZvdGVrZXkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgIHZvdGVMYXN0QmxvY2sgPSB0eG5Gb3JEZWNvZGluZy52b3RlbHN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdHggPSBNdWx0aXNpZy5NdWx0aVNpZ1RyYW5zYWN0aW9uLmZyb21fb2JqX2Zvcl9lbmNvZGluZyh0eG5Gb3JEZWNvZGluZyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4SGV4IG5lZWRzIHRvIGJlIGEgdmFsaWQgdHggZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkID0gdHgudHhJRCgpO1xuICAgICAgY29uc3QgZmVlID0geyBmZWU6IHR4LmZlZSB9O1xuXG4gICAgICBjb25zdCBvdXRwdXRBbW91bnQgPSB0eC5hbW91bnQgfHwgMDtcbiAgICAgIGNvbnN0IG91dHB1dHM6IHsgYW1vdW50OiBudW1iZXI7IGFkZHJlc3M6IHN0cmluZyB9W10gPSBbXTtcbiAgICAgIGlmICh0eC50bykge1xuICAgICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICAgIGFtb3VudDogb3V0cHV0QW1vdW50LFxuICAgICAgICAgIGFkZHJlc3M6IEFkZHJlc3MuZW5jb2RlKG5ldyBVaW50OEFycmF5KHR4LnRvLnB1YmxpY0tleSkpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhDVC00ODApOiBhZGQgcmVjaWV2aW5nIGFkZHJlc3MgZGlzcGxheSBoZXJlXG4gICAgICBjb25zdCBtZW1vID0gdHgubm90ZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyOiBbXG4gICAgICAgICAgJ2lkJyxcbiAgICAgICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICAgICAnY2hhbmdlQW1vdW50JyxcbiAgICAgICAgICAnb3V0cHV0cycsXG4gICAgICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgICAgICdmZWUnLFxuICAgICAgICAgICdtZW1vJyxcbiAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgJ3NlbmRlckFkZHJlc3MnLFxuICAgICAgICAgICd2b3RlS2V5QmFzZTY0JyxcbiAgICAgICAgICAndm90ZUxhc3RCbG9jaycsXG4gICAgICAgIF0sXG4gICAgICAgIGlkLFxuICAgICAgICBvdXRwdXRzLFxuICAgICAgICBvdXRwdXRBbW91bnQsXG4gICAgICAgIGNoYW5nZUFtb3VudDogMCxcbiAgICAgICAgZmVlLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgbWVtbyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdm90ZUtleUJhc2U2NCxcbiAgICAgICAgdm90ZUxhc3RCbG9jayxcbiAgICAgIH07XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICBpc1N0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVNlY3JldFNlZWQoc2VlZCk7XG4gIH1cblxuICBjb252ZXJ0RnJvbVN0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgdHJ1c3QgY3VzdG9kaWFsIHNlZWQgaWYgaXRzIGEgdmFsaWQgZWQyNTUxOSBwcnZcbiAgICBpZiAoIXRoaXMuaXNTdGVsbGFyU2VlZChzZWVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBTZWVkLmVuY29kZShzdGVsbGFyLlN0cktleS5kZWNvZGVFZDI1NTE5U2VjcmV0U2VlZChzZWVkKSk7XG4gIH1cblxuICB2ZXJpZnlTaWduVHJhbnNhY3Rpb25QYXJhbXMocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogVmVyaWZpZWRUcmFuc2FjdGlvblBhcmFtZXRlcnMge1xuICAgIGNvbnN0IHBydiA9IHBhcmFtcy5wcnY7XG4gICAgY29uc3QgYWRkcmVzc1ZlcnNpb24gPSBwYXJhbXMudHhQcmVidWlsZC5hZGRyZXNzVmVyc2lvbjtcbiAgICBsZXQgaXNIYWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICAvLyBpdCdzIHBvc3NpYmxlIHRoaXMgdHggd2FzIGFscmVhZHkgc2lnbmVkIC0gdGFrZSB0aGUgaGFsZlNpZ25lZFxuICAgIC8vIHR4SGV4IGlmIGl0IGlzXG4gICAgbGV0IHR4SGV4ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG4gICAgaWYgKHBhcmFtcy50eFByZWJ1aWxkLmhhbGZTaWduZWQpIHtcbiAgICAgIGlzSGFsZlNpZ25lZCA9IHRydWU7XG4gICAgICB0eEhleCA9IHBhcmFtcy50eFByZWJ1aWxkLmhhbGZTaWduZWQudHhIZXg7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4SGV4fWApO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcnYgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgcHJ2fWApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFfLmhhcyhwYXJhbXMudHhQcmVidWlsZCwgJ2tleXNbMF0nKSB8fFxuICAgICAgIV8uaGFzKHBhcmFtcy50eFByZWJ1aWxkLCAna2V5c1sxXScpIHx8XG4gICAgICAhXy5oYXMocGFyYW1zLnR4UHJlYnVpbGQsICdrZXlzWzJdJylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwdWJsaWMga2V5cyBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghXy5pc051bWJlcihhZGRyZXNzVmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhZGRyZXNzVmVyc2lvbiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gcmUtZW5jb2RlIG91ciBwdWJsaWMga2V5cyB1c2luZyBhbGdvc2RrJ3MgZm9ybWF0XG4gICAgY29uc3Qga2V5cyA9IFtwYXJhbXMudHhQcmVidWlsZC5rZXlzWzBdLCBwYXJhbXMudHhQcmVidWlsZC5rZXlzWzFdLCBwYXJhbXMudHhQcmVidWlsZC5rZXlzWzJdXTtcblxuICAgIC8vIHJlLWVuY29kZSBzayBmcm9tIG91ciBwcnYgKHRoaXMgYWN0cyBhcyBhIHNlZWQgb3V0IG9mIHRoZSBrZXljaGFpbilcbiAgICBjb25zdCBzZWVkID0gU2VlZC5kZWNvZGUocHJ2KS5zZWVkO1xuICAgIGNvbnN0IHBhaXIgPSBnZW5lcmF0ZUFjY291bnRGcm9tU2VlZChzZWVkKTtcbiAgICBjb25zdCBzayA9IHBhaXIuc2s7XG5cbiAgICByZXR1cm4geyB0eEhleCwgYWRkcmVzc1ZlcnNpb24sIGtleXMsIHNrLCBpc0hhbGZTaWduZWQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtPYmplY3R9IHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB7U3RyaW5nfSB1c2VyIHBydlxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldC5hZGRyZXNzVmVyc2lvbiB7U3RyaW5nfSB0aGlzIGlzIHRoZSB2ZXJzaW9uIG9mIHRoZSBBbGdvcmFuZCBtdWx0aXNpZyBhZGRyZXNzIGdlbmVyYXRpb24gZm9ybWF0XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogU2lnbmVkVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHsgdHhIZXgsIGFkZHJlc3NWZXJzaW9uLCBrZXlzLCBzaywgaXNIYWxmU2lnbmVkIH0gPSB0aGlzLnZlcmlmeVNpZ25UcmFuc2FjdGlvblBhcmFtcyhwYXJhbXMpO1xuICAgIGNvbnN0IGVuY29kZWRQdWJsaWNLZXlzID0gXy5tYXAoa2V5cywgayA9PiBBZGRyZXNzLmRlY29kZShrKS5wdWJsaWNLZXkpO1xuXG4gICAgLy8gZGVjb2RlIG91ciB1bnNpZ25lZC9oYWxmLXNpZ25lZCB0eFxuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICBsZXQgdHhUb0hleDtcbiAgICB0cnkge1xuICAgICAgdHhUb0hleCA9IEJ1ZmZlci5mcm9tKHR4SGV4LCAnYmFzZTY0Jyk7XG4gICAgICBjb25zdCBpbml0aWFsRGVjb2RlZFR4ID0gRW5jb2RpbmcuZGVjb2RlKHR4VG9IZXgpO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNjcnViIHRoZSB0eG4gb2Ygc2lncyBmb3IgaGFsZi1zaWduZWRcbiAgICAgIGNvbnN0IGRlY29kZWRUeCA9IGlzSGFsZlNpZ25lZCA/IGluaXRpYWxEZWNvZGVkVHgudHhuIDogaW5pdGlhbERlY29kZWRUeDtcblxuICAgICAgdHJhbnNhY3Rpb24gPSBNdWx0aXNpZy5NdWx0aVNpZ1RyYW5zYWN0aW9uLmZyb21fb2JqX2Zvcl9lbmNvZGluZyhkZWNvZGVkVHgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gbmVlZHMgdG8gYmUgYSB2YWxpZCB0eCBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICAvLyBzaWduIG91ciB0eFxuICAgIGxldCBzaWduZWQgPSB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnblR4bih7IHZlcnNpb246IGFkZHJlc3NWZXJzaW9uLCB0aHJlc2hvbGQ6IDIsIHBrczogZW5jb2RlZFB1YmxpY0tleXMgfSwgc2spO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbHJlYWR5IHNpZ25lZCBpdCwgd2UnbGwgaGF2ZSB0byBtZXJnZSB0aGF0IHdpdGggb3VyIHByZXZpb3VzIHR4XG4gICAgaWYgKGlzSGFsZlNpZ25lZCkge1xuICAgICAgc2lnbmVkID0gbWVyZ2VNdWx0aXNpZ1RyYW5zYWN0aW9ucyhbQnVmZmVyLmZyb20oc2lnbmVkKSwgdHhUb0hleF0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25lZEJhc2U2NCA9IEJ1ZmZlci5mcm9tKHNpZ25lZCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXG4gICAgaWYgKGlzSGFsZlNpZ25lZCkge1xuICAgICAgcmV0dXJuIHsgdHhIZXg6IHNpZ25lZEJhc2U2NCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHR4SGV4OiBzaWduZWRCYXNlNjQgfSB9O1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7fSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxib29sZWFuPik6IEJsdWViaXJkPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh0cnVlKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19