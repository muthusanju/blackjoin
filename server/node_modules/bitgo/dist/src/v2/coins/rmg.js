"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bitcoin_1 = require("../../bitcoin");
var errors_1 = require("../../errors");
var abstractUtxoCoin_1 = require("./abstractUtxoCoin");
var _ = require("lodash");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var prova = require('../../prova');
var Rmg = /** @class */ (function (_super) {
    __extends(Rmg, _super);
    function Rmg(bitgo, network) {
        var _this = this;
        // TODO: move to bitgo-utxo-lib (BG-6821)
        prova.networks.rmg.coin = 'rmg';
        _this = _super.call(this, bitgo, network || prova.networks.rmg) || this;
        return _this;
    }
    Rmg.createInstance = function (bitgo) {
        return new Rmg(bitgo);
    };
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Rmg.prototype.getBaseFactor = function () {
        return 1e6;
    };
    Rmg.prototype.getChain = function () {
        return 'rmg';
    };
    Rmg.prototype.getFamily = function () {
        return 'rmg';
    };
    Rmg.prototype.getFullName = function () {
        return 'Royal Mint Gold';
    };
    Rmg.prototype.isValidAddress = function (address) {
        return prova.Address.validateBase58(address, this.network);
    };
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param address The address string on the network
     * @param keychains Keychain objects with xpubs
     * @param chain Derivation chain
     * @param index Derivation index
     */
    Rmg.prototype.verifyAddress = function (params) {
        if (!params.keychains) {
            throw new Error('missing required param keychains');
        }
        if (!this.isValidAddress(params.address)) {
            throw new Error("invalid address: " + params.address);
        }
        var expectedAddress = this.generateAddress({
            keychains: params.keychains,
            threshold: 2,
            chain: params.chain,
            index: params.index,
        });
        if (expectedAddress.address !== params.address) {
            throw new Error("address validation failure: expected " + expectedAddress.address + " but got " + params.address);
        }
        return true;
    };
    /**
     * Generate an address for a wallet based on a set of configurations
     * @param keychains Array of objects with xpubs
     * @param threshold Minimum number of signatures
     * @param chain Derivation chain
     * @param index Derivation index
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript}}}
     */
    Rmg.prototype.generateAddress = function (params) {
        var signatureThreshold = 2;
        if (_.isInteger(params.threshold)) {
            signatureThreshold = params.threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > params.keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        var derivationChain = 0;
        if (_.isNumber(params.chain) && _.isInteger(params.chain) && params.chain > 0) {
            derivationChain = params.chain;
        }
        var derivationIndex = 0;
        if (_.isInteger(params.index) && params.index > 0) {
            derivationIndex = params.index;
        }
        var path = 'm/0/0/' + derivationChain + '/' + derivationIndex;
        // do not modify the original argument
        var keychainCopy = _.cloneDeep(params.keychains);
        var userKey = keychainCopy.shift();
        if (!userKey) {
            throw new Error('invalid required param keychains - missing user key');
        }
        var aspKeyIds = keychainCopy.map(function (key) { return key.aspKeyId; });
        var userKeyNode = prova.HDNode.fromBase58(userKey.pub);
        var derivedUserKey = bitcoin_1.hdPath(userKeyNode).deriveKey(path).getPublicKeyBuffer();
        var provaAddress = new prova.Address(derivedUserKey, aspKeyIds, this.network);
        provaAddress.signatureCount = signatureThreshold;
        var addressDetails = {
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {
                outputScript: provaAddress.toScript().toString('hex')
            },
        };
        try {
            addressDetails.address = provaAddress.toString();
        }
        catch (e) {
            // non-(n-1)/n signature count
            addressDetails.address = null;
        }
        return addressDetails;
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    Rmg.prototype.signTransaction = function (params) {
        var txPrebuild = params.txPrebuild;
        var userPrv = params.prv;
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
            }
            throw new Error('missing txPrebuild parameter');
        }
        var transaction = prova.Transaction.fromHex(txPrebuild.txHex);
        if (transaction.ins.length !== txPrebuild.txInfo.unspents.length) {
            throw new Error('length of unspents array should equal to the number of transaction inputs');
        }
        if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
            if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                throw new Error("prv must be a string, got type " + typeof userPrv);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        var keychain = prova.HDNode.fromBase58(userPrv, this.network);
        var signatureIssues = [];
        var keychainHdPath = bitcoin_1.hdPath(keychain);
        for (var index = 0; index < transaction.ins.length; ++index) {
            var currentUnspent = txPrebuild.txInfo.unspents[index];
            var path = 'm/0/0/' + currentUnspent.chain + '/' + currentUnspent.index;
            var privKey = keychainHdPath.deriveKey(path);
            var currentSignatureIssue = {
                inputIndex: index,
                unspent: currentUnspent,
                path: path
            };
            var unspentAddress = prova.Address.fromBase58(currentUnspent.address);
            var subscript = unspentAddress.toScript();
            var txb = prova.TransactionBuilder.fromTransaction(transaction, this.network);
            try {
                txb.sign(index, privKey, subscript, currentUnspent.value);
            }
            catch (e) {
                currentSignatureIssue.error = e;
                signatureIssues.push(currentSignatureIssue);
                continue;
            }
            transaction = txb.buildIncomplete();
            var isValidSignature = this.verifySignature(transaction, index, currentUnspent.value);
            if (!isValidSignature) {
                currentSignatureIssue.error = new Error('invalid signature');
                signatureIssues.push(currentSignatureIssue);
            }
        }
        if (signatureIssues.length > 0) {
            var failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
            var error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
            error.code = 'input_signature_failure';
            error.signingErrors = signatureIssues;
            throw error;
        }
        return {
            txHex: transaction.toHex()
        };
    };
    /**
     * Verify the signature(s) on a (half-signed) transaction
     * @param transaction provajs-lib tx object
     * @param inputIndex The input whose signature is to be verified
     * @param amount The input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    Rmg.prototype.verifySignature = function (transaction, inputIndex, amount, verificationSettings) {
        if (verificationSettings === void 0) { verificationSettings = {}; }
        if (!(transaction instanceof prova.Transaction)) {
            throw new Error('transaction has to be an instance of prova.Transaction');
        }
        var currentInput = transaction.ins[inputIndex];
        var signatureScript = currentInput.script;
        var decompiledSigScript = prova.script.decompile(signatureScript);
        // the public keys are all the even-indexed entries
        var publicKeys = _.filter(decompiledSigScript, function (item, index) { return index % 2 === 0; });
        // convert the keys to their hex representations
        var publicKeyHexes = _.map(publicKeys, function (k) { return k.toString('hex'); });
        // the signatures are all the odd-indexed ones
        var signatures = _.filter(decompiledSigScript, function (item, index) { return index % 2 === 1; });
        // we map them to each other
        var signaturesByKeys = _.zipObject(publicKeyHexes, signatures);
        var publicKeysToVerify = publicKeyHexes;
        var publicKeyHex = verificationSettings.publicKey;
        if (!_.isUndefined(verificationSettings.signatureIndex)) {
            publicKeysToVerify = [publicKeyHexes[verificationSettings.signatureIndex]];
        }
        var areAllSignaturesValid = true;
        for (var _i = 0, publicKeysToVerify_1 = publicKeysToVerify; _i < publicKeysToVerify_1.length; _i++) {
            var currentPublicKeyHex = publicKeysToVerify_1[_i];
            if (!_.isUndefined(publicKeyHex) && publicKeyHex !== currentPublicKeyHex) {
                areAllSignaturesValid = false;
                continue;
            }
            if (_.isEmpty(currentPublicKeyHex)) {
                areAllSignaturesValid = false;
                continue;
            }
            var isSignatureValid = false;
            var publicKeyBuffer = Buffer.from(currentPublicKeyHex, 'hex');
            var signatureBuffer = signaturesByKeys[currentPublicKeyHex];
            if (Buffer.isBuffer(publicKeyBuffer) && publicKeyBuffer.length > 0 && Buffer.isBuffer(signatureBuffer) && signatureBuffer.length > 0) {
                var publicKey = prova.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
                var signatureHash = transaction.hashForWitnessV0(inputIndex, null, amount, prova.Transaction.SIGHASH_ALL);
                isSignatureValid = publicKey.verify(signatureHash, signatureBuffer);
            }
            if (!_.isUndefined(publicKeyHex) && isSignatureValid) {
                // We were trying to see if any of the signatures was valid for the given public key. Evidently yes.
                return true;
            }
            areAllSignaturesValid = isSignatureValid && areAllSignaturesValid;
        }
        return areAllSignaturesValid;
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Rmg.prototype.explainTransaction = function (params, callback) {
        return co(function () {
            var self, transaction, id, changeAddresses, spendAmount, changeAmount, explanation;
            return __generator(this, function (_a) {
                self = this;
                transaction = prova.Transaction.fromHex(params.txHex);
                id = transaction.getId();
                changeAddresses = [];
                spendAmount = 0;
                changeAmount = 0;
                if (params.txInfo && params.txInfo.changeAddresses) {
                    changeAddresses = params.txInfo.changeAddresses;
                }
                explanation = {
                    displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs'],
                    id: id,
                    outputs: [],
                    changeOutputs: []
                };
                transaction.outs.forEach(function (currentOutput) {
                    var currentAddress = prova.Address.fromScript(currentOutput.script, self.network).toString();
                    var currentAmount = currentOutput.value;
                    if (changeAddresses.indexOf(currentAddress) !== -1) {
                        // this is change
                        changeAmount += currentAmount;
                        explanation.changeOutputs.push({
                            address: currentAddress,
                            amount: currentAmount
                        });
                        return;
                    }
                    spendAmount += currentAmount;
                    explanation.outputs.push({
                        address: currentAddress,
                        amount: currentAmount
                    });
                });
                explanation.outputAmount = spendAmount;
                explanation.changeAmount = changeAmount;
                // add fee info if available
                if (params.feeInfo) {
                    explanation.displayOrder.push('fee');
                    explanation.fee = params.feeInfo;
                }
                return [2 /*return*/, explanation];
            });
        }).call(this).asCallback(callback);
    };
    Rmg.prototype.getAddressInfoFromExplorer = function (address) {
        throw new errors_1.MethodNotImplementedError();
    };
    Rmg.prototype.getUnspentInfoFromExplorer = function (address) {
        throw new errors_1.MethodNotImplementedError();
    };
    return Rmg;
}(abstractUtxoCoin_1.AbstractUtxoCoin));
exports.Rmg = Rmg;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm1nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3JtZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBdUM7QUFFdkMsdUNBQXlEO0FBRXpELHVEQU00QjtBQUU1QiwwQkFBNEI7QUFDNUIsbUNBQXFDO0FBQ3JDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFDOUIsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBRXJDO0lBQXlCLHVCQUFnQjtJQUN2QyxhQUFZLEtBQVksRUFBRSxPQUFRO1FBQWxDLGlCQUlDO1FBSEMseUNBQXlDO1FBQ3pDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDaEMsUUFBQSxrQkFBTSxLQUFLLEVBQUUsT0FBTyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQUM7O0lBQzlDLENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILDJCQUFhLEdBQWI7UUFDRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsdUJBQVMsR0FBVDtRQUNFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELHlCQUFXLEdBQVg7UUFDRSxPQUFPLGlCQUFpQixDQUFDO0lBQzNCLENBQUM7SUFFRCw0QkFBYyxHQUFkLFVBQWUsT0FBZTtRQUM1QixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFD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YTtxQkFDdEIsQ0FBQyxDQUFDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUNILFdBQVcsQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO2dCQUN2QyxXQUFXLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztnQkFFeEMsNEJBQTRCO2dCQUM1QixJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7b0JBQ2xCLFdBQVcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNyQyxXQUFXLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7aUJBQ2xDO2dCQUNELHNCQUFPLFdBQVcsRUFBQzs7U0FDcEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVTLHdDQUEwQixHQUFwQyxVQUFxQyxPQUFlO1FBQ2xELE1BQU0sSUFBSSxrQ0FBeUIsRUFBRSxDQUFDO0lBQ3hDLENBQUM7SUFFUyx3Q0FBMEIsR0FBcEMsVUFBcUMsT0FBZTtRQUNsRCxNQUFNLElBQUksa0NBQXlCLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBQ0gsVUFBQztBQUFELENBQUMsQUFqVkQsQ0FBeUIsbUNBQWdCLEdBaVZ4QztBQWpWWSxrQkFBRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhkUGF0aCB9IGZyb20gJy4uLy4uL2JpdGNvaW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEJhc2VDb2luIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RVdHhvQ29pbiwgQWRkcmVzc0luZm8sXG4gIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24sIFVuc3BlbnRJbmZvLFxuICBHZW5lcmF0ZUFkZHJlc3NPcHRpb25zLCBBZGRyZXNzRGV0YWlscyxcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucywgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG59IGZyb20gJy4vYWJzdHJhY3RVdHhvQ29pbic7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcbmNvbnN0IHByb3ZhID0gcmVxdWlyZSgnLi4vLi4vcHJvdmEnKTtcblxuZXhwb3J0IGNsYXNzIFJtZyBleHRlbmRzIEFic3RyYWN0VXR4b0NvaW4ge1xuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIG5ldHdvcms/KSB7XG4gICAgLy8gVE9ETzogbW92ZSB0byBiaXRnby11dHhvLWxpYiAoQkctNjgyMSlcbiAgICBwcm92YS5uZXR3b3Jrcy5ybWcuY29pbiA9ICdybWcnO1xuICAgIHN1cGVyKGJpdGdvLCBuZXR3b3JrIHx8IHByb3ZhLm5ldHdvcmtzLnJtZyk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgUm1nKGJpdGdvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDFlNjtcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdybWcnO1xuICB9XG5cbiAgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdybWcnO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1JveWFsIE1pbnQgR29sZCc7XG4gIH1cblxuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdmEuQWRkcmVzcy52YWxpZGF0ZUJhc2U1OChhZGRyZXNzLCB0aGlzLm5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSBhbiBhZGRyZXNzIGlzIHZhbGlkIGFuZCB0aHJvdyBhbiBlcnJvciBpZiBpdCdzIG5vdC5cbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3Mgc3RyaW5nIG9uIHRoZSBuZXR3b3JrXG4gICAqIEBwYXJhbSBrZXljaGFpbnMgS2V5Y2hhaW4gb2JqZWN0cyB3aXRoIHhwdWJzXG4gICAqIEBwYXJhbSBjaGFpbiBEZXJpdmF0aW9uIGNoYWluXG4gICAqIEBwYXJhbSBpbmRleCBEZXJpdmF0aW9uIGluZGV4XG4gICAqL1xuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpIHtcbiAgICBpZiAoIXBhcmFtcy5rZXljaGFpbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSBrZXljaGFpbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHtwYXJhbXMuYWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFkZHJlc3M6IGFueSA9IHRoaXMuZ2VuZXJhdGVBZGRyZXNzKHtcbiAgICAgIGtleWNoYWluczogcGFyYW1zLmtleWNoYWlucyxcbiAgICAgIHRocmVzaG9sZDogMixcbiAgICAgIGNoYWluOiBwYXJhbXMuY2hhaW4sXG4gICAgICBpbmRleDogcGFyYW1zLmluZGV4LFxuICAgIH0pO1xuXG4gICAgaWYgKGV4cGVjdGVkQWRkcmVzcy5hZGRyZXNzICE9PSBwYXJhbXMuYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogZXhwZWN0ZWQgJHtleHBlY3RlZEFkZHJlc3MuYWRkcmVzc30gYnV0IGdvdCAke3BhcmFtcy5hZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGFkZHJlc3MgZm9yIGEgd2FsbGV0IGJhc2VkIG9uIGEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zXG4gICAqIEBwYXJhbSBrZXljaGFpbnMgQXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHhwdWJzXG4gICAqIEBwYXJhbSB0aHJlc2hvbGQgTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlc1xuICAgKiBAcGFyYW0gY2hhaW4gRGVyaXZhdGlvbiBjaGFpblxuICAgKiBAcGFyYW0gaW5kZXggRGVyaXZhdGlvbiBpbmRleFxuICAgKiBAcmV0dXJucyB7e2NoYWluOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGNvaW46IG51bWJlciwgY29pblNwZWNpZmljOiB7b3V0cHV0U2NyaXB0fX19XG4gICAqL1xuICBnZW5lcmF0ZUFkZHJlc3MocGFyYW1zOiBHZW5lcmF0ZUFkZHJlc3NPcHRpb25zKTogQWRkcmVzc0RldGFpbHMge1xuICAgIGxldCBzaWduYXR1cmVUaHJlc2hvbGQgPSAyO1xuICAgIGlmIChfLmlzSW50ZWdlcihwYXJhbXMudGhyZXNob2xkKSkge1xuICAgICAgc2lnbmF0dXJlVGhyZXNob2xkID0gcGFyYW1zLnRocmVzaG9sZDtcbiAgICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBoYXMgdG8gYmUgcG9zaXRpdmUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPiBwYXJhbXMua2V5Y2hhaW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBjYW5ub3QgZXhjZWVkIG51bWJlciBvZiBrZXlzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRlcml2YXRpb25DaGFpbiA9IDA7XG4gICAgaWYgKF8uaXNOdW1iZXIocGFyYW1zLmNoYWluKSAmJiBfLmlzSW50ZWdlcihwYXJhbXMuY2hhaW4pICYmIHBhcmFtcy5jaGFpbiA+IDApIHtcbiAgICAgIGRlcml2YXRpb25DaGFpbiA9IHBhcmFtcy5jaGFpbjtcbiAgICB9XG5cbiAgICBsZXQgZGVyaXZhdGlvbkluZGV4ID0gMDtcbiAgICBpZiAoXy5pc0ludGVnZXIocGFyYW1zLmluZGV4KSAmJiBwYXJhbXMuaW5kZXggPiAwKSB7XG4gICAgICBkZXJpdmF0aW9uSW5kZXggPSBwYXJhbXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9ICdtLzAvMC8nICsgZGVyaXZhdGlvbkNoYWluICsgJy8nICsgZGVyaXZhdGlvbkluZGV4O1xuICAgIC8vIGRvIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGFyZ3VtZW50XG4gICAgY29uc3Qga2V5Y2hhaW5Db3B5ID0gXy5jbG9uZURlZXAocGFyYW1zLmtleWNoYWlucyk7XG4gICAgY29uc3QgdXNlcktleSA9IGtleWNoYWluQ29weS5zaGlmdCgpO1xuXG4gICAgaWYgKCF1c2VyS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVxdWlyZWQgcGFyYW0ga2V5Y2hhaW5zIC0gbWlzc2luZyB1c2VyIGtleScpO1xuICAgIH1cbiAgICBjb25zdCBhc3BLZXlJZHMgPSBrZXljaGFpbkNvcHkubWFwKChrZXkpID0+IGtleS5hc3BLZXlJZCk7XG4gICAgY29uc3QgdXNlcktleU5vZGUgPSBwcm92YS5IRE5vZGUuZnJvbUJhc2U1OCh1c2VyS2V5LnB1Yik7XG4gICAgY29uc3QgZGVyaXZlZFVzZXJLZXkgPSBoZFBhdGgodXNlcktleU5vZGUpLmRlcml2ZUtleShwYXRoKS5nZXRQdWJsaWNLZXlCdWZmZXIoKTtcblxuICAgIGNvbnN0IHByb3ZhQWRkcmVzcyA9IG5ldyBwcm92YS5BZGRyZXNzKGRlcml2ZWRVc2VyS2V5LCBhc3BLZXlJZHMsIHRoaXMubmV0d29yayk7XG4gICAgcHJvdmFBZGRyZXNzLnNpZ25hdHVyZUNvdW50ID0gc2lnbmF0dXJlVGhyZXNob2xkO1xuXG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHM6IGFueSA9IHtcbiAgICAgIGNoYWluOiBkZXJpdmF0aW9uQ2hhaW4sXG4gICAgICBpbmRleDogZGVyaXZhdGlvbkluZGV4LFxuICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgY29pblNwZWNpZmljOiB7XG4gICAgICAgIG91dHB1dFNjcmlwdDogcHJvdmFBZGRyZXNzLnRvU2NyaXB0KCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYWRkcmVzc0RldGFpbHMuYWRkcmVzcyA9IHByb3ZhQWRkcmVzcy50b1N0cmluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vbi0obi0xKS9uIHNpZ25hdHVyZSBjb3VudFxuICAgICAgYWRkcmVzc0RldGFpbHMuYWRkcmVzcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZHJlc3NEZXRhaWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHR4UHJlYnVpbGRcbiAgICogLSBwcnZcbiAgICogQHJldHVybnMge3t0eEhleH19XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogeyB0eEhleDogc3RyaW5nIH0ge1xuICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcbiAgICBjb25zdCB1c2VyUHJ2ID0gcGFyYW1zLnBydjtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpIHx8ICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgJiYgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eFByZWJ1aWxkfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgbGV0IHRyYW5zYWN0aW9uID0gcHJvdmEuVHJhbnNhY3Rpb24uZnJvbUhleCh0eFByZWJ1aWxkLnR4SGV4KTtcblxuICAgIGlmICh0cmFuc2FjdGlvbi5pbnMubGVuZ3RoICE9PSB0eFByZWJ1aWxkLnR4SW5mby51bnNwZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHVuc3BlbnRzIGFycmF5IHNob3VsZCBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9uIGlucHV0cycpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHVzZXJQcnYpIHx8ICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodXNlclBydikgJiYgIV8uaXNTdHJpbmcodXNlclBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgdXNlclBydn1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcnYgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXljaGFpbiA9IHByb3ZhLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJQcnYsIHRoaXMubmV0d29yayk7XG5cbiAgICBjb25zdCBzaWduYXR1cmVJc3N1ZXM6IGFueVtdID0gW107XG4gICAgY29uc3Qga2V5Y2hhaW5IZFBhdGggPSBoZFBhdGgoa2V5Y2hhaW4pO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRyYW5zYWN0aW9uLmlucy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVbnNwZW50ID0gdHhQcmVidWlsZC50eEluZm8udW5zcGVudHNbaW5kZXhdO1xuICAgICAgY29uc3QgcGF0aCA9ICdtLzAvMC8nICsgY3VycmVudFVuc3BlbnQuY2hhaW4gKyAnLycgKyBjdXJyZW50VW5zcGVudC5pbmRleDtcbiAgICAgIGNvbnN0IHByaXZLZXkgPSBrZXljaGFpbkhkUGF0aC5kZXJpdmVLZXkocGF0aCk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRTaWduYXR1cmVJc3N1ZTogYW55ID0ge1xuICAgICAgICBpbnB1dEluZGV4OiBpbmRleCxcbiAgICAgICAgdW5zcGVudDogY3VycmVudFVuc3BlbnQsXG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVuc3BlbnRBZGRyZXNzID0gcHJvdmEuQWRkcmVzcy5mcm9tQmFzZTU4KGN1cnJlbnRVbnNwZW50LmFkZHJlc3MpO1xuICAgICAgY29uc3Qgc3Vic2NyaXB0ID0gdW5zcGVudEFkZHJlc3MudG9TY3JpcHQoKTtcbiAgICAgIGNvbnN0IHR4YiA9IHByb3ZhLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHRoaXMubmV0d29yayk7XG4gICAgICB0cnkge1xuICAgICAgICB0eGIuc2lnbihpbmRleCwgcHJpdktleSwgc3Vic2NyaXB0LCBjdXJyZW50VW5zcGVudC52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGN1cnJlbnRTaWduYXR1cmVJc3N1ZS5lcnJvciA9IGU7XG4gICAgICAgIHNpZ25hdHVyZUlzc3Vlcy5wdXNoKGN1cnJlbnRTaWduYXR1cmVJc3N1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2FjdGlvbiA9IHR4Yi5idWlsZEluY29tcGxldGUoKTtcbiAgICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSB0aGlzLnZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgaW5kZXgsIGN1cnJlbnRVbnNwZW50LnZhbHVlKTtcbiAgICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgICBjdXJyZW50U2lnbmF0dXJlSXNzdWUuZXJyb3IgPSBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAgIHNpZ25hdHVyZUlzc3Vlcy5wdXNoKGN1cnJlbnRTaWduYXR1cmVJc3N1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpZ25hdHVyZUlzc3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmYWlsZWRJbmRpY2VzID0gc2lnbmF0dXJlSXNzdWVzLm1hcChjdXJyZW50SXNzdWUgPT4gY3VycmVudElzc3VlLmlucHV0SW5kZXgpO1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNpZ24gaW5wdXRzIGF0IGluZGljZXMgJHtmYWlsZWRJbmRpY2VzLmpvaW4oJywgJyl9YCk7XG4gICAgICBlcnJvci5jb2RlID0gJ2lucHV0X3NpZ25hdHVyZV9mYWlsdXJlJztcbiAgICAgIGVycm9yLnNpZ25pbmdFcnJvcnMgPSBzaWduYXR1cmVJc3N1ZXM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHhIZXg6IHRyYW5zYWN0aW9uLnRvSGV4KClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgc2lnbmF0dXJlKHMpIG9uIGEgKGhhbGYtc2lnbmVkKSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gcHJvdmFqcy1saWIgdHggb2JqZWN0XG4gICAqIEBwYXJhbSBpbnB1dEluZGV4IFRoZSBpbnB1dCB3aG9zZSBzaWduYXR1cmUgaXMgdG8gYmUgdmVyaWZpZWRcbiAgICogQHBhcmFtIGFtb3VudCBUaGUgaW5wdXQgYW1vdW50IG5lZWRzIHRvIGJlIGtub3duIGZvciBzaWduYXR1cmUgdmVyaWZpY2F0aW9uXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5nc1xuICAgKiBAcGFyYW0gdmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5IChvbmx5IGl0ZXJhdGVzIG92ZXIgbm9uLWVtcHR5IHNpZ25hdHVyZXMpXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkgVGhlIGhleCBvZiB0aGUgcHVibGljIGtleSB0byB2ZXJpZnkgKHdpbGwgdmVyaWZ5IGFsbCBzaWduYXR1cmVzKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbjogYW55LCBpbnB1dEluZGV4OiBudW1iZXIsIGFtb3VudD86IG51bWJlciwgdmVyaWZpY2F0aW9uU2V0dGluZ3M6IHsgc2lnbmF0dXJlSW5kZXg/OiBudW1iZXI7IHB1YmxpY0tleT86IHN0cmluZzsgfSA9IHt9KTogYm9vbGVhbiB7XG4gICAgaWYgKCEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBwcm92YS5UcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gaGFzIHRvIGJlIGFuIGluc3RhbmNlIG9mIHByb3ZhLlRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudElucHV0ID0gdHJhbnNhY3Rpb24uaW5zW2lucHV0SW5kZXhdO1xuICAgIGNvbnN0IHNpZ25hdHVyZVNjcmlwdCA9IGN1cnJlbnRJbnB1dC5zY3JpcHQ7XG4gICAgY29uc3QgZGVjb21waWxlZFNpZ1NjcmlwdCA9IHByb3ZhLnNjcmlwdC5kZWNvbXBpbGUoc2lnbmF0dXJlU2NyaXB0KTtcbiAgICAvLyB0aGUgcHVibGljIGtleXMgYXJlIGFsbCB0aGUgZXZlbi1pbmRleGVkIGVudHJpZXNcbiAgICBjb25zdCBwdWJsaWNLZXlzID0gXy5maWx0ZXIoZGVjb21waWxlZFNpZ1NjcmlwdCwgKGl0ZW0sIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICUgMiA9PT0gMCk7XG4gICAgLy8gY29udmVydCB0aGUga2V5cyB0byB0aGVpciBoZXggcmVwcmVzZW50YXRpb25zXG4gICAgY29uc3QgcHVibGljS2V5SGV4ZXMgPSBfLm1hcChwdWJsaWNLZXlzLCBrID0+IChrIGFzIGFueSkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAvLyB0aGUgc2lnbmF0dXJlcyBhcmUgYWxsIHRoZSBvZGQtaW5kZXhlZCBvbmVzXG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IF8uZmlsdGVyKGRlY29tcGlsZWRTaWdTY3JpcHQsIChpdGVtLCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAlIDIgPT09IDEpO1xuICAgIC8vIHdlIG1hcCB0aGVtIHRvIGVhY2ggb3RoZXJcbiAgICBjb25zdCBzaWduYXR1cmVzQnlLZXlzID0gXy56aXBPYmplY3QocHVibGljS2V5SGV4ZXMsIHNpZ25hdHVyZXMpO1xuXG4gICAgbGV0IHB1YmxpY0tleXNUb1ZlcmlmeSA9IHB1YmxpY0tleUhleGVzO1xuICAgIGNvbnN0IHB1YmxpY0tleUhleCA9IHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCkpIHtcbiAgICAgIHB1YmxpY0tleXNUb1ZlcmlmeSA9IFtwdWJsaWNLZXlIZXhlc1t2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleF1dO1xuICAgIH1cblxuICAgIGxldCBhcmVBbGxTaWduYXR1cmVzVmFsaWQgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgY3VycmVudFB1YmxpY0tleUhleCBvZiBwdWJsaWNLZXlzVG9WZXJpZnkpIHtcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHB1YmxpY0tleUhleCkgJiYgcHVibGljS2V5SGV4ICE9PSBjdXJyZW50UHVibGljS2V5SGV4KSB7XG4gICAgICAgIGFyZUFsbFNpZ25hdHVyZXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNFbXB0eShjdXJyZW50UHVibGljS2V5SGV4KSkge1xuICAgICAgICBhcmVBbGxTaWduYXR1cmVzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBpc1NpZ25hdHVyZVZhbGlkID0gZmFsc2U7XG4gICAgICBjb25zdCBwdWJsaWNLZXlCdWZmZXIgPSBCdWZmZXIuZnJvbShjdXJyZW50UHVibGljS2V5SGV4LCAnaGV4Jyk7XG4gICAgICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSBzaWduYXR1cmVzQnlLZXlzW2N1cnJlbnRQdWJsaWNLZXlIZXhdO1xuXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHB1YmxpY0tleUJ1ZmZlcikgJiYgcHVibGljS2V5QnVmZmVyLmxlbmd0aCA+IDAgJiYgQnVmZmVyLmlzQnVmZmVyKHNpZ25hdHVyZUJ1ZmZlcikgJiYgc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gcHJvdmEuRUNQYWlyLmZyb21QdWJsaWNLZXlCdWZmZXIocHVibGljS2V5QnVmZmVyKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlSGFzaCA9IHRyYW5zYWN0aW9uLmhhc2hGb3JXaXRuZXNzVjAoaW5wdXRJbmRleCwgbnVsbCwgYW1vdW50LCBwcm92YS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCk7XG4gICAgICAgIGlzU2lnbmF0dXJlVmFsaWQgPSBwdWJsaWNLZXkudmVyaWZ5KHNpZ25hdHVyZUhhc2gsIHNpZ25hdHVyZUJ1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwdWJsaWNLZXlIZXgpICYmIGlzU2lnbmF0dXJlVmFsaWQpIHtcbiAgICAgICAgLy8gV2Ugd2VyZSB0cnlpbmcgdG8gc2VlIGlmIGFueSBvZiB0aGUgc2lnbmF0dXJlcyB3YXMgdmFsaWQgZm9yIHRoZSBnaXZlbiBwdWJsaWMga2V5LiBFdmlkZW50bHkgeWVzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgYXJlQWxsU2lnbmF0dXJlc1ZhbGlkID0gaXNTaWduYXR1cmVWYWxpZCAmJiBhcmVBbGxTaWduYXR1cmVzVmFsaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZUFsbFNpZ25hdHVyZXNWYWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPik6IEJsdWViaXJkPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBwcm92YS5UcmFuc2FjdGlvbi5mcm9tSGV4KHBhcmFtcy50eEhleCk7XG4gICAgICBjb25zdCBpZCA9IHRyYW5zYWN0aW9uLmdldElkKCk7XG4gICAgICBsZXQgY2hhbmdlQWRkcmVzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgbGV0IHNwZW5kQW1vdW50ID0gMDtcbiAgICAgIGxldCBjaGFuZ2VBbW91bnQgPSAwO1xuICAgICAgaWYgKHBhcmFtcy50eEluZm8gJiYgcGFyYW1zLnR4SW5mby5jaGFuZ2VBZGRyZXNzZXMpIHtcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzID0gcGFyYW1zLnR4SW5mby5jaGFuZ2VBZGRyZXNzZXM7XG4gICAgICB9XG4gICAgICBjb25zdCBleHBsYW5hdGlvbjogYW55ID0ge1xuICAgICAgICBkaXNwbGF5T3JkZXI6IFsnaWQnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnXSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW11cbiAgICAgIH07XG4gICAgICB0cmFuc2FjdGlvbi5vdXRzLmZvckVhY2goZnVuY3Rpb24oY3VycmVudE91dHB1dCkge1xuICAgICAgICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IHByb3ZhLkFkZHJlc3MuZnJvbVNjcmlwdChjdXJyZW50T3V0cHV0LnNjcmlwdCwgc2VsZi5uZXR3b3JrKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBjdXJyZW50QW1vdW50ID0gY3VycmVudE91dHB1dC52YWx1ZTtcblxuICAgICAgICBpZiAoY2hhbmdlQWRkcmVzc2VzLmluZGV4T2YoY3VycmVudEFkZHJlc3MpICE9PSAtMSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgY2hhbmdlXG4gICAgICAgICAgY2hhbmdlQW1vdW50ICs9IGN1cnJlbnRBbW91bnQ7XG4gICAgICAgICAgZXhwbGFuYXRpb24uY2hhbmdlT3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgICAgYW1vdW50OiBjdXJyZW50QW1vdW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3BlbmRBbW91bnQgKz0gY3VycmVudEFtb3VudDtcbiAgICAgICAgZXhwbGFuYXRpb24ub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6IGN1cnJlbnRBbW91bnRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGV4cGxhbmF0aW9uLm91dHB1dEFtb3VudCA9IHNwZW5kQW1vdW50O1xuICAgICAgZXhwbGFuYXRpb24uY2hhbmdlQW1vdW50ID0gY2hhbmdlQW1vdW50O1xuXG4gICAgICAvLyBhZGQgZmVlIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgICBpZiAocGFyYW1zLmZlZUluZm8pIHtcbiAgICAgICAgZXhwbGFuYXRpb24uZGlzcGxheU9yZGVyLnB1c2goJ2ZlZScpO1xuICAgICAgICBleHBsYW5hdGlvbi5mZWUgPSBwYXJhbXMuZmVlSW5mbztcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHBsYW5hdGlvbjtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEFkZHJlc3NJbmZvRnJvbUV4cGxvcmVyKGFkZHJlc3M6IHN0cmluZyk6IEJsdWViaXJkPEFkZHJlc3NJbmZvPiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRVbnNwZW50SW5mb0Zyb21FeHBsb3JlcihhZGRyZXNzOiBzdHJpbmcpOiBCbHVlYmlyZDxVbnNwZW50SW5mb1tdPiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxufVxuIl19