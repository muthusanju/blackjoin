"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var bignumber_js_1 = require("bignumber.js");
var utxoLib = require("bitgo-utxo-lib");
var Bluebird = require("bluebird");
var crypto = require("crypto");
var debugLib = require("debug");
var Keccak = require("keccak");
var _ = require("lodash");
var secp256k1 = require("secp256k1");
var request = require("superagent");
var baseCoin_1 = require("../baseCoin");
var erc20Token_1 = require("./erc20Token");
var wallet_1 = require("../wallet");
var common = require("../../common");
var config = require("../../config");
var util_1 = require("../internal/util");
var errors_1 = require("../../errors");
var co = Bluebird.coroutine;
var debug = debugLib('bitgo:v2:eth');
exports.optionalDeps = {
    get ethAbi() {
        try {
            return require('ethereumjs-abi');
        }
        catch (e) {
            debug('unable to load ethereumjs-abi:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-abi");
        }
    },
    get ethUtil() {
        try {
            return require('ethereumjs-util');
        }
        catch (e) {
            debug('unable to load ethereumjs-util:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-util");
        }
    },
    get EthTx() {
        try {
            return require('ethereumjs-tx');
        }
        catch (e) {
            debug('unable to load ethereumjs-tx:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-tx");
        }
    },
};
var Eth = /** @class */ (function (_super) {
    __extends(Eth, _super);
    function Eth() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Eth.createInstance = function (bitgo) {
        return new Eth(bitgo);
    };
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Eth.prototype.getBaseFactor = function () {
        // 10^18
        return '1000000000000000000';
    };
    Eth.prototype.getChain = function () {
        return 'eth';
    };
    Eth.prototype.getFamily = function () {
        return 'eth';
    };
    Eth.prototype.getFullName = function () {
        return 'Ethereum';
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Eth.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    Eth.prototype.transactionDataAllowed = function () {
        return true;
    };
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    Eth.prototype.isValidAddress = function (address) {
        return exports.optionalDeps.ethUtil.isValidAddress(exports.optionalDeps.ethUtil.addHexPrefix(address));
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Eth.prototype.isValidPub = function (pub) {
        try {
            utxoLib.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    Eth.prototype.getRecoveryGasPrice = function () {
        return new exports.optionalDeps.ethUtil.BN('20000000000');
    };
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    Eth.prototype.getRecoveryGasLimit = function () {
        return new exports.optionalDeps.ethUtil.BN('500000');
    };
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    Eth.prototype.getDefaultExpireTime = function () {
        return Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
    };
    /**
     * Query Etherscan for the balance of an address
     * @param address {String} the ETH address
     * @param callback
     * @returns {BigNumber} address balance
     */
    Eth.prototype.queryAddressBalance = function (address, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                            module: 'account',
                            action: 'balance',
                            address: address,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(result.result, 10)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Query Etherscan for the balance of an address for a token
     * @param tokenContractAddress {String} address where the token smart contract is hosted
     * @param walletContractAddress {String} address of the wallet
     * @param callback
     * @returns {BigNumber} token balaance in base units
     */
    Eth.prototype.queryAddressTokenBalance = function (tokenContractAddress, walletContractAddress, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!exports.optionalDeps.ethUtil.isValidAddress(tokenContractAddress)) {
                            throw new Error('cannot get balance for invalid token address');
                        }
                        if (!exports.optionalDeps.ethUtil.isValidAddress(walletContractAddress)) {
                            throw new Error('cannot get token balance for invalid wallet address');
                        }
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'account',
                                action: 'tokenbalance',
                                contractaddress: tokenContractAddress,
                                address: walletContractAddress,
                                tag: 'latest',
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(result.result, 10)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Get transfer operation for coin
     * @param recipient recipient info
     * @param expireTime expiry time
     * @param contractSequenceId sequence id
     * @returns {Array} operation array
     */
    Eth.prototype.getOperation = function (recipient, expireTime, contractSequenceId) {
        return [
            ['string', 'address', 'uint', 'bytes', 'uint', 'uint'],
            [
                'ETHER',
                new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                recipient.amount,
                new Buffer(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.data) || '', 'hex'),
                expireTime,
                contractSequenceId,
            ],
        ];
    };
    Eth.prototype.getOperationSha3ForExecuteAndConfirm = function (recipients, expireTime, contractSequenceId) {
        var _a;
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        if (!_.isNumber(expireTime)) {
            throw new Error('expireTime must be number of seconds since epoch');
        }
        if (!_.isNumber(contractSequenceId)) {
            throw new Error('contractSequenceId must be number');
        }
        // Check inputs
        recipients.forEach(function (recipient) {
            if (!_.isString(recipient.address) ||
                !exports.optionalDeps.ethUtil.isValidAddress(exports.optionalDeps.ethUtil.addHexPrefix(recipient.address))) {
                throw new Error('Invalid address: ' + recipient.address);
            }
            var amount;
            try {
                amount = new bignumber_js_1.BigNumber(recipient.amount);
            }
            catch (e) {
                throw new Error('Invalid amount for: ' + recipient.address + ' - should be numeric');
            }
            recipient.amount = amount.toFixed(0);
            if (recipient.data && !_.isString(recipient.data)) {
                throw new Error('Data for recipient ' + recipient.address + ' - should be of type hex string');
            }
        });
        var recipient = recipients[0];
        return exports.optionalDeps.ethUtil.bufferToHex((_a = exports.optionalDeps.ethAbi).soliditySHA3.apply(_a, this.getOperation(recipient, expireTime, contractSequenceId)));
    };
    /**
     * Queries the contract (via Etherscan) for the next sequence ID
     * @param address {String} address of the contract
     * @param callback
     * @returns {Number} sequence ID
     */
    Eth.prototype.querySequenceId = function (address, callback) {
        var self = this;
        return co(function () {
            var sequenceIdMethodSignature, sequenceIdArgs, sequenceIdData, result, sequenceIdHex;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sequenceIdMethodSignature = exports.optionalDeps.ethAbi.methodID('getNextSequenceId', []);
                        sequenceIdArgs = exports.optionalDeps.ethAbi.rawEncode([], []);
                        sequenceIdData = Buffer.concat([sequenceIdMethodSignature, sequenceIdArgs]).toString('hex');
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'proxy',
                                action: 'eth_call',
                                to: address,
                                data: sequenceIdData,
                                tag: 'latest',
                            })];
                    case 1:
                        result = _a.sent();
                        sequenceIdHex = result.result;
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(sequenceIdHex.slice(2), 16).toNumber()];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.signingKeyNonce
     * @param params.walletContractAddress
     * @param params.prv
     * @returns {{txHex: *}}
     */
    Eth.prototype.signFinal = function (params) {
        var txPrebuild = params.txPrebuild;
        if (!_.isNumber(params.signingKeyNonce)) {
            throw new Error('must have signingKeyNonce as a parameter, and it must be a number');
        }
        if (_.isUndefined(params.walletContractAddress)) {
            throw new Error('params must include walletContractAddress, but got undefined');
        }
        var signingNode = utxoLib.HDNode.fromBase58(params.prv);
        var signingKey = signingNode.getKey().getPrivateKeyBuffer();
        var txInfo = {
            recipient: txPrebuild.recipients[0],
            expireTime: txPrebuild.halfSigned.expireTime,
            contractSequenceId: txPrebuild.halfSigned.contractSequenceId,
            signature: txPrebuild.halfSigned.signature,
        };
        var sendMethodArgs = this.getSendMethodArgs(txInfo);
        var methodSignature = exports.optionalDeps.ethAbi.methodID('sendMultiSig', _.map(sendMethodArgs, 'type'));
        var encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
        var sendData = Buffer.concat([methodSignature, encodedArgs]);
        var ethTxParams = {
            to: params.walletContractAddress,
            nonce: params.signingKeyNonce,
            value: 0,
            gasPrice: new exports.optionalDeps.ethUtil.BN(txPrebuild.gasPrice),
            gasLimit: new exports.optionalDeps.ethUtil.BN(txPrebuild.gasLimit),
            data: sendData,
            spendAmount: params.recipients[0].amount,
        };
        var ethTx = new exports.optionalDeps.EthTx(ethTxParams);
        ethTx.sign(signingKey);
        return { txHex: ethTx.serialize().toString('hex') };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    Eth.prototype.signTransaction = function (params) {
        var txPrebuild = params.txPrebuild;
        var userPrv = params.prv;
        var EXPIRETIME_DEFAULT = 60 * 60 * 24 * 7; // This signature will be valid for 1 week
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
            }
            throw new Error('missing txPrebuild parameter');
        }
        if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
            if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                throw new Error("prv must be a string, got type " + typeof userPrv);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        params.recipients = txPrebuild.recipients || params.recipients;
        // if no recipients in either params or txPrebuild, then throw an error
        if (!params.recipients || !Array.isArray(params.recipients)) {
            throw new Error('recipients missing or not array');
        }
        // Normally the SDK provides the first signature for an ETH tx, but occasionally it provides the second and final one.
        if (params.isLastSignature) {
            // In this case when we're doing the second (final) signature, the logic is different.
            return this.signFinal(params);
        }
        var secondsSinceEpoch = Math.floor(new Date().getTime() / 1000);
        var expireTime = params.expireTime || secondsSinceEpoch + EXPIRETIME_DEFAULT;
        var sequenceId = txPrebuild.nextContractSequenceId;
        if (_.isUndefined(sequenceId)) {
            throw new Error('transaction prebuild missing required property nextContractSequenceId');
        }
        var operationHash = this.getOperationSha3ForExecuteAndConfirm(params.recipients, expireTime, sequenceId);
        var signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userPrv));
        var txParams = {
            recipients: params.recipients,
            expireTime: expireTime,
            contractSequenceId: sequenceId,
            sequenceId: params.sequenceId,
            operationHash: operationHash,
            signature: signature,
            gasLimit: params.gasLimit,
            gasPrice: params.gasPrice,
            hopTransaction: txPrebuild.hopTransaction,
        };
        return { halfSigned: txParams };
    };
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    Eth.prototype.preCreateBitGo = function (params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!_.isObject(params)) {
            throw new Error("preCreateBitGo must be passed a params object. Got " + params + " (type " + typeof params + ")");
        }
        if (_.isUndefined(params.enterprise) && _.isUndefined(params.newFeeAddress)) {
            throw new Error('expecting enterprise when adding BitGo key. If you want to create a new ETH bitgo key, set the newFeeAddress parameter to true.');
        }
        // Check whether key should be an enterprise key or a BitGo key for a new fee address
        if (!_.isUndefined(params.enterprise) && !_.isUndefined(params.newFeeAddress)) {
            throw new Error("Incompatible arguments - cannot pass both enterprise and newFeeAddress parameter.");
        }
        if (!_.isUndefined(params.enterprise) && !_.isString(params.enterprise)) {
            throw new Error("enterprise should be a string - got " + params.enterprise + " (type " + typeof params.enterprise + ")");
        }
        if (!_.isUndefined(params.newFeeAddress) && !_.isBoolean(params.newFeeAddress)) {
            throw new Error("newFeeAddress should be a boolean - got " + params.newFeeAddress + " (type " + typeof params.newFeeAddress + ")");
        }
    };
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @param callback
     * @returns {*}
     */
    Eth.prototype.getAddressNonce = function (address, callback) {
        var self = this;
        return co(function () {
            var nonce, result, backupKeyTxList, outgoingTxs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nonce = 0;
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'account',
                                action: 'txlist',
                                address: address,
                            })];
                    case 1:
                        result = _a.sent();
                        backupKeyTxList = result.result;
                        if (backupKeyTxList.length > 0) {
                            outgoingTxs = backupKeyTxList.filter(function (tx) { return tx.from === address; });
                            nonce = outgoingTxs.length;
                        }
                        return [2 /*return*/, nonce];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param txInfo
     * @param ethTx
     * @param userKey
     * @param backupKey
     * @param gasPrice
     * @param gasLimit
     * @param callback
     * @returns {{tx: *, userKey: *, backupKey: *, coin: string, amount: string, gasPrice: string, gasLimit: string, recipients: ({address, amount}|{address: ({address, amount}|string), amount: string}|string)[]}}
     */
    Eth.prototype.formatForOfflineVault = function (txInfo, ethTx, userKey, backupKey, gasPrice, gasLimit, callback) {
        var self = this;
        return co(function () {
            var backupHDNode, backupSigningKey, response, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        backupHDNode = utxoLib.HDNode.fromBase58(backupKey);
                        backupSigningKey = backupHDNode.getKey().getPublicKeyBuffer();
                        _a = {
                            tx: ethTx.serialize().toString('hex'),
                            userKey: userKey,
                            backupKey: backupKey,
                            coin: self.getChain(),
                            gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
                            gasLimit: gasLimit,
                            recipients: [txInfo.recipient],
                            walletContractAddress: '0x' + ethTx.to.toString('hex'),
                            amount: txInfo.recipient.amount
                        };
                        return [4 /*yield*/, self.getAddressNonce("0x" + exports.optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex'))];
                    case 1:
                        response = (_a.backupKeyNonce = _b.sent(),
                            _a);
                        _.extend(response, txInfo);
                        response.nextContractSequenceId = response.contractSequenceId;
                        return [2 /*return*/, response];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.krsProvider {String} necessary if backup key is held by KRS
     * @param params.recoveryDestination {String} target address to send recovered funds to
     * @param callback
     */
    Eth.prototype.recover = function (params, callback) {
        var self = this;
        return co(function recover() {
            var isKrsRecovery, isUnsignedSweep, userKey, backupKey, gasPrice, gasLimit, backupKeyAddress, backupSigningKey, backupHDNode, backupPrv, backupHDNode, backupKeyNonce, backupKeyBalance, txAmount, recipients, sequenceId, operationHash, signature, txInfo, sendMethodArgs, methodSignature, encodedArgs, sendData, tx, signedTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isUndefined(params.userKey)) {
                            throw new Error('missing userKey');
                        }
                        if (_.isUndefined(params.backupKey)) {
                            throw new Error('missing backupKey');
                        }
                        if (_.isUndefined(params.walletPassphrase) && !params.userKey.startsWith('xpub')) {
                            throw new Error('missing wallet passphrase');
                        }
                        if (_.isUndefined(params.walletContractAddress) || !self.isValidAddress(params.walletContractAddress)) {
                            throw new Error('invalid walletContractAddress');
                        }
                        if (_.isUndefined(params.recoveryDestination) || !self.isValidAddress(params.recoveryDestination)) {
                            throw new Error('invalid recoveryDestination');
                        }
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                            throw new Error('unknown key recovery service provider');
                        }
                        userKey = params.userKey.replace(/\s/g, '');
                        backupKey = params.backupKey.replace(/\s/g, '');
                        gasPrice = self.getRecoveryGasPrice();
                        gasLimit = self.getRecoveryGasLimit();
                        // Decrypt private keys from KeyCard values if necessary
                        if (!userKey.startsWith('xpub') && !userKey.startsWith('xprv')) {
                            try {
                                userKey = self.bitgo.decrypt({
                                    input: userKey,
                                    password: params.walletPassphrase,
                                });
                            }
                            catch (e) {
                                throw new Error("Error decrypting user keychain: " + e.message);
                            }
                        }
                        if (isKrsRecovery || isUnsignedSweep) {
                            backupHDNode = utxoLib.HDNode.fromBase58(backupKey);
                            backupSigningKey = backupHDNode.getKey().getPublicKeyBuffer();
                            backupKeyAddress = "0x" + exports.optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex');
                        }
                        else {
                            backupPrv = void 0;
                            try {
                                backupPrv = self.bitgo.decrypt({
                                    input: backupKey,
                                    password: params.walletPassphrase,
                                });
                            }
                            catch (e) {
                                throw new Error("Error decrypting backup keychain: " + e.message);
                            }
                            backupHDNode = utxoLib.HDNode.fromBase58(backupPrv);
                            backupSigningKey = backupHDNode.getKey().getPrivateKeyBuffer();
                            backupKeyAddress = "0x" + exports.optionalDeps.ethUtil.privateToAddress(backupSigningKey).toString('hex');
                        }
                        return [4 /*yield*/, self.getAddressNonce(backupKeyAddress)];
                    case 1:
                        backupKeyNonce = _a.sent();
                        return [4 /*yield*/, self.queryAddressBalance(backupKeyAddress)];
                    case 2:
                        backupKeyBalance = _a.sent();
                        if (backupKeyBalance.lt(gasPrice.mul(gasLimit))) {
                            throw new Error("Backup key address " + backupKeyAddress + " has balance " + backupKeyBalance.toString(10) + ". This address must have a balance of at least 0.01 ETH to perform recoveries. Try sending some ETH to this address then retry.");
                        }
                        return [4 /*yield*/, self.queryAddressBalance(params.walletContractAddress)];
                    case 3:
                        txAmount = _a.sent();
                        recipients = [
                            {
                                address: params.recoveryDestination,
                                amount: txAmount.toString(10),
                            },
                        ];
                        return [4 /*yield*/, self.querySequenceId(params.walletContractAddress)];
                    case 4:
                        sequenceId = _a.sent();
                        // Get operation hash and sign it
                        if (!isUnsignedSweep) {
                            operationHash = self.getOperationSha3ForExecuteAndConfirm(recipients, self.getDefaultExpireTime(), sequenceId);
                            signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userKey));
                            try {
                                util_1.Util.ecRecoverEthAddress(operationHash, signature);
                            }
                            catch (e) {
                                throw new Error('Invalid signature');
                            }
                        }
                        txInfo = {
                            recipient: recipients[0],
                            expireTime: self.getDefaultExpireTime(),
                            contractSequenceId: sequenceId,
                            operationHash: operationHash,
                            signature: signature,
                            gasLimit: gasLimit.toString(10),
                        };
                        sendMethodArgs = self.getSendMethodArgs(txInfo);
                        methodSignature = exports.optionalDeps.ethAbi.methodID('sendMultiSig', _.map(sendMethodArgs, 'type'));
                        encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
                        sendData = Buffer.concat([methodSignature, encodedArgs]);
                        tx = new exports.optionalDeps.EthTx({
                            to: params.walletContractAddress,
                            nonce: backupKeyNonce,
                            value: 0,
                            gasPrice: gasPrice,
                            gasLimit: gasLimit,
                            data: sendData,
                            spendAmount: txAmount,
                        });
                        if (isUnsignedSweep) {
                            return [2 /*return*/, self.formatForOfflineVault(txInfo, tx, userKey, backupKey, gasPrice, gasLimit)];
                        }
                        if (!isKrsRecovery) {
                            tx.sign(backupSigningKey);
                        }
                        signedTx = {
                            id: exports.optionalDeps.ethUtil.bufferToHex(tx.hash(true)),
                            tx: tx.serialize().toString('hex'),
                        };
                        if (isKrsRecovery) {
                            signedTx.backupKey = backupKey;
                            signedTx.coin = self.getChain();
                        }
                        return [2 /*return*/, signedTx];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * This builds a half-signed transaction, for which there will be an admin route to co-sign and broadcast. Optionally
     * the user can set params.broadcast = true and the half-signed tx will be sent to BitGo for cosigning and broadcasting
     * @param params
     * @param params.wallet the wallet to recover the token from
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param params.broadcast if true, we will automatically submit the half-signed tx to BitGo for cosigning and broadcasting
     * @param callback
     */
    Eth.prototype.recoverToken = function (params, callback) {
        var self = this;
        return co(function () {
            var coinSpecific, recoveryAmount, sendMethodArgs, methodSignature, encodedArgs, sendData, broadcastParams, recipient, expireTime, _a, nextContractSequenceId, gasPrice, gasLimit, safeSequenceId, operationTypes, operationArgs, operationHash, userPrv, signature, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error("recoverToken must be passed a params object. Got " + params + " (type " + typeof params + ")");
                        }
                        if (_.isUndefined(params.tokenContractAddress) || !_.isString(params.tokenContractAddress)) {
                            throw new Error("tokenContractAddress must be a string, got " + params.tokenContractAddress + " (type " + typeof params.tokenContractAddress + ")");
                        }
                        if (!self.isValidAddress(params.tokenContractAddress)) {
                            throw new Error('tokenContractAddress not a valid address');
                        }
                        if (_.isUndefined(params.wallet) || !(params.wallet instanceof wallet_1.Wallet)) {
                            throw new Error("wallet must be a wallet instance, got " + params.wallet + " (type " + typeof params.wallet + ")");
                        }
                        if (_.isUndefined(params.recipient) || !_.isString(params.recipient)) {
                            throw new Error("recipient must be a string, got " + params.recipient + " (type " + typeof params.recipient + ")");
                        }
                        if (!self.isValidAddress(params.recipient)) {
                            throw new Error('recipient not a valid address');
                        }
                        if (!exports.optionalDeps.ethUtil.bufferToHex || !exports.optionalDeps.ethAbi.soliditySHA3) {
                            throw new Error('ethereum not fully supported in this environment');
                        }
                        coinSpecific = params.wallet.coinSpecific();
                        if (!coinSpecific || !_.isString(coinSpecific.baseAddress)) {
                            throw new Error('missing required coin specific property baseAddress');
                        }
                        return [4 /*yield*/, self.queryAddressTokenBalance(params.tokenContractAddress, coinSpecific.baseAddress)];
                    case 1:
                        recoveryAmount = _b.sent();
                        if (!params.broadcast) return [3 /*break*/, 3];
                        sendMethodArgs = [
                            {
                                name: '_to',
                                type: 'address',
                                value: params.recipient,
                            },
                            {
                                name: '_value',
                                type: 'uint256',
                                value: recoveryAmount.toString(10),
                            },
                        ];
                        methodSignature = exports.optionalDeps.ethAbi.methodID('transfer', _.map(sendMethodArgs, 'type'));
                        encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
                        sendData = Buffer.concat([methodSignature, encodedArgs]);
                        broadcastParams = {
                            address: params.tokenContractAddress,
                            amount: '0',
                            data: sendData.toString('hex'),
                        };
                        if (params.walletPassphrase) {
                            broadcastParams.walletPassphrase = params.walletPassphrase;
                        }
                        else if (params.prv) {
                            broadcastParams.prv = params.prv;
                        }
                        return [4 /*yield*/, params.wallet.send(broadcastParams)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        recipient = {
                            address: params.recipient,
                            amount: recoveryAmount.toString(10),
                        };
                        expireTime = Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
                        return [4 /*yield*/, params.wallet.prebuildTransaction({
                                recipients: [
                                    {
                                        address: params.recipient,
                                        amount: '1',
                                    },
                                ],
                            })];
                    case 4:
                        _a = _b.sent(), nextContractSequenceId = _a.nextContractSequenceId, gasPrice = _a.gasPrice, gasLimit = _a.gasLimit;
                        safeSequenceId = nextContractSequenceId + 1000;
                        operationTypes = ['string', 'address', 'uint', 'address', 'uint', 'uint'];
                        operationArgs = [
                            // "ERC20" has been added here so that ether operation hashes, signatures cannot be re-used for tokenSending
                            'ERC20',
                            new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                            recipient.amount,
                            new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(params.tokenContractAddress), 16),
                            expireTime,
                            safeSequenceId,
                        ];
                        operationHash = exports.optionalDeps.ethUtil.bufferToHex(exports.optionalDeps.ethAbi.soliditySHA3(operationTypes, operationArgs));
                        return [4 /*yield*/, params.wallet.getPrv({
                                prv: params.prv,
                                walletPassphrase: params.walletPassphrase,
                            })];
                    case 5:
                        userPrv = _b.sent();
                        signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userPrv));
                        result = {
                            halfSigned: {
                                recipient: recipient,
                                expireTime: expireTime,
                                contractSequenceId: safeSequenceId,
                                operationHash: operationHash,
                                signature: signature,
                                gasLimit: gasLimit,
                                gasPrice: gasPrice,
                                tokenContractAddress: params.tokenContractAddress,
                                walletId: params.wallet.id(),
                            },
                        };
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Build arguments to call the send method on the wallet contract
     * @param txInfo
     */
    Eth.prototype.getSendMethodArgs = function (txInfo) {
        // Method signature is
        // sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature)
        return [
            {
                name: 'toAddress',
                type: 'address',
                value: txInfo.recipient.address,
            },
            {
                name: 'value',
                type: 'uint',
                value: txInfo.recipient.amount,
            },
            {
                name: 'data',
                type: 'bytes',
                value: exports.optionalDeps.ethUtil.toBuffer(txInfo.recipient.data || ''),
            },
            {
                name: 'expireTime',
                type: 'uint',
                value: txInfo.expireTime,
            },
            {
                name: 'sequenceId',
                type: 'uint',
                value: txInfo.contractSequenceId,
            },
            {
                name: 'signature',
                type: 'bytes',
                value: exports.optionalDeps.ethUtil.toBuffer(txInfo.signature),
            },
        ];
    };
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @param callback
     * @returns {Object} response from Etherscan
     */
    Eth.prototype.recoveryBlockchainExplorerQuery = function (query, callback) {
        var self = this;
        return co(function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, request
                            .get(common.Environments[self.bitgo.getEnv()].etherscanBaseUrl + '/api')
                            .query(query)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) {
                            throw new Error('could not reach Etherscan');
                        }
                        return [2 /*return*/, response.body];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @param callback
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    Eth.prototype.createHopTransactionParams = function (buildParams, callback) {
        var self = this;
        return co(function () {
            var wallet, recipients, walletPassphrase, userKeychain, userPrv, userPrvBuffer, recipientAddress, recipientAmount, feeEstimateParams, feeEstimate, gasLimit, gasPrice, gasPriceMax, paymentId, hopDigest, userReqSig, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        wallet = buildParams.wallet;
                        recipients = buildParams.recipients;
                        walletPassphrase = buildParams.walletPassphrase;
                        return [4 /*yield*/, self.keychains().get({ id: wallet.keyIds()[0] })];
                    case 1:
                        userKeychain = _a.sent();
                        userPrv = wallet.getUserPrv({ keychain: userKeychain, walletPassphrase: walletPassphrase });
                        userPrvBuffer = utxoLib.HDNode.fromBase58(userPrv)
                            .getKey()
                            .getPrivateKeyBuffer();
                        if (!recipients || !Array.isArray(recipients)) {
                            throw new Error('expecting array of recipients');
                        }
                        // Right now we only support 1 recipient
                        if (recipients.length !== 1) {
                            throw new Error('must send to exactly 1 recipient');
                        }
                        recipientAddress = recipients[0].address;
                        recipientAmount = recipients[0].amount;
                        feeEstimateParams = {
                            recipient: recipientAddress,
                            amount: recipientAmount,
                            hop: true,
                        };
                        return [4 /*yield*/, self.feeEstimate(feeEstimateParams)];
                    case 2:
                        feeEstimate = _a.sent();
                        gasLimit = feeEstimate.gasLimitEstimate;
                        gasPrice = Math.round(feeEstimate.feeEstimate / gasLimit);
                        gasPriceMax = gasPrice * 5;
                        paymentId = Math.floor(Math.random() * 10000000000).toString();
                        hopDigest = Eth.getHopDigest([
                            recipientAddress,
                            recipientAmount,
                            gasPriceMax.toString(),
                            gasLimit.toString(),
                            paymentId,
                        ]);
                        userReqSig = exports.optionalDeps.ethUtil.addHexPrefix(secp256k1.sign(hopDigest, userPrvBuffer).signature.toString('hex'));
                        result = {
                            hopParams: {
                                gasPriceMax: gasPriceMax,
                                userReqSig: userReqSig,
                                paymentId: paymentId,
                            },
                            gasLimit: gasLimit,
                        };
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @param callback
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    Eth.prototype.validateHopPrebuild = function (wallet, hopPrebuild, originalParams, callback) {
        var self = this;
        return co(function () {
            var tx, id, signature, serverXpub, serverPubkeyBuffer, signatureBuffer, messageBuffer, isValidSignature, builtHopTx, recipients, originalAmount, originalDestination, hopAmount, hopDestination;
            return __generator(this, function (_a) {
                tx = hopPrebuild.tx, id = hopPrebuild.id, signature = hopPrebuild.signature;
                serverXpub = common.Environments[self.bitgo.getEnv()].hsmXpub;
                serverPubkeyBuffer = utxoLib.HDNode.fromBase58(serverXpub).getPublicKeyBuffer();
                signatureBuffer = Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(signature), 'hex');
                messageBuffer = Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(id), 'hex');
                isValidSignature = secp256k1.verify(messageBuffer, signatureBuffer.slice(1), serverPubkeyBuffer);
                if (!isValidSignature) {
                    throw new Error("Hop txid signature invalid");
                }
                builtHopTx = new exports.optionalDeps.EthTx(tx);
                // If original params are given, we can check them against the transaction prebuild params
                if (!_.isNil(originalParams)) {
                    recipients = originalParams.recipients;
                    originalAmount = new bignumber_js_1.BigNumber(recipients[0].amount);
                    originalDestination = recipients[0].address;
                    hopAmount = new bignumber_js_1.BigNumber(exports.optionalDeps.ethUtil.bufferToHex(builtHopTx.value));
                    hopDestination = exports.optionalDeps.ethUtil.bufferToHex(builtHopTx.to);
                    if (!hopAmount.eq(originalAmount)) {
                        throw new Error("Hop amount: " + hopAmount + " does not equal original amount: " + originalAmount);
                    }
                    if (hopDestination.toLowerCase() !== originalDestination.toLowerCase()) {
                        throw new Error("Hop destination: " + hopDestination + " does not equal original recipient: " + hopDestination);
                    }
                }
                if (!builtHopTx.verifySignature()) {
                    // We dont want to continue at all in this case, at risk of ETH being stuck on the hop address
                    throw new Error("Invalid hop transaction signature, txid: " + id);
                }
                if (exports.optionalDeps.ethUtil.addHexPrefix(builtHopTx.hash().toString('hex')) !== id) {
                    throw new Error("Signed hop txid does not equal actual txid");
                }
                return [2 /*return*/];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    Eth.getHopDigest = function (paramsArr) {
        var hash = new Keccak('keccak256');
        hash.update([Eth.hopTransactionSalt].concat(paramsArr).join('$'));
        return hash.digest();
    };
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     * @param callback
     */
    Eth.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(buildParams.hop) &&
                            buildParams.hop &&
                            !_.isUndefined(buildParams.wallet) &&
                            !_.isUndefined(buildParams.recipients) &&
                            !_.isUndefined(buildParams.walletPassphrase))) return [3 /*break*/, 2];
                        if (this instanceof erc20Token_1.Erc20Token) {
                            throw new Error("Hop transactions are not enabled for ERC-20 tokens, nor are they necessary. Please remove the 'hop' parameter and try again.");
                        }
                        return [4 /*yield*/, self.createHopTransactionParams({
                                wallet: buildParams.wallet,
                                recipients: buildParams.recipients,
                                walletPassphrase: buildParams.walletPassphrase,
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/, {}];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    Eth.prototype.postProcessPrebuild = function (params, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(params.hopTransaction) &&
                            !_.isUndefined(params.wallet) &&
                            !_.isUndefined(params.buildParams))) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.validateHopPrebuild(params.wallet, params.hopTransaction, params.buildParams)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, params];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     * @param callback
     */
    Eth.prototype.presignTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(params.hopTransaction) &&
                            !_.isUndefined(params.wallet) &&
                            !_.isUndefined(params.buildParams))) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.validateHopPrebuild(params.wallet, params.hopTransaction)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, params];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @param callback
     * @returns {Object} The fee info returned from the server
     */
    Eth.prototype.feeEstimate = function (params, callback) {
        var self = this;
        return co(function coFeeEstimate() {
            var query;
            return __generator(this, function (_a) {
                query = {};
                if (params && params.hop) {
                    query.hop = params.hop;
                }
                if (params && params.recipient) {
                    query.recipient = params.recipient;
                }
                if (params && params.data) {
                    query.data = params.data;
                }
                if (params && params.amount) {
                    query.amount = params.amount;
                }
                return [2 /*return*/, self.bitgo
                        .get(self.url('/tx/fee'))
                        .query(query)
                        .result()];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    Eth.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = utxoLib.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    Eth.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Eth.prototype.verifyAddress = function (params) {
        return true;
    };
    Eth.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    Eth.hopTransactionSalt = 'bitgoHopAddressRequestSalt';
    return Eth;
}(baseCoin_1.BaseCoin));
exports.Eth = Eth;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL2V0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDZDQUF5QztBQUN6Qyx3Q0FBMEM7QUFDMUMsbUNBQXFDO0FBQ3JDLCtCQUFpQztBQUNqQyxnQ0FBa0M7QUFDbEMsK0JBQWlDO0FBQ2pDLDBCQUE0QjtBQUM1QixxQ0FBdUM7QUFDdkMsb0NBQXNDO0FBRXRDLHdDQVVxQjtBQUNyQiwyQ0FBMEM7QUFHMUMsb0NBQW1DO0FBQ25DLHFDQUF1QztBQUN2QyxxQ0FBdUM7QUFDdkMseUNBQXdDO0FBQ3hDLHVDQUErRDtBQUUvRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBQzlCLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUUxQixRQUFBLFlBQVksR0FBRztJQUMxQixJQUFJLE1BQU07UUFDUixJQUFJO1lBQ0YsT0FBTyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUNsQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7WUFDeEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNmLE1BQU0sSUFBSSx3Q0FBK0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQzdEO0lBQ0gsQ0FBQztJQUVELElBQUksT0FBTztRQUNULElBQUk7WUFDRixPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ25DO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztZQUN6QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2YsTUFBTSxJQUFJLHdDQUErQixDQUFDLGlCQUFpQixD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QUUsQ0FBQztRQUMvQyxPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUk7WUFDVCxHQUFHLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRTtTQUM1QixDQUFDO0lBQ0osQ0FBQztJQUVELDhCQUFnQixHQUFoQixVQUNFLE1BQStCLEVBQy9CLFFBQTBDO1FBRTFDLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELDJCQUFhLEdBQWIsVUFBYyxNQUE0QjtRQUN4QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCwrQkFBaUIsR0FBakIsVUFBa0IsTUFBZ0MsRUFBRSxRQUFnQztRQUNsRixPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUEzb0NNLHNCQUFrQixHQUFHLDRCQUE0QixDQUFDO0lBNG9DM0QsVUFBQztDQUFBLEFBN29DRCxDQUF5QixtQkFBUSxHQTZvQ2hDO0FBN29DWSxrQkFBRyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyB1dHhvTGliIGZyb20gJ2JpdGdvLXV0eG8tbGliJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuaW1wb3J0ICogYXMgS2VjY2FrIGZyb20gJ2tlY2Nhayc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBzZWNwMjU2azEgZnJvbSAnc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBGZWVFc3RpbWF0ZU9wdGlvbnMsXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIGFzIEJhc2VIYWxmU2lnbmVkVHJhbnNhY3Rpb24sXG59IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEVyYzIwVG9rZW4gfSBmcm9tICcuL2VyYzIwVG9rZW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4uLy4uL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCB7IFV0aWwgfSBmcm9tICcuLi9pbnRlcm5hbC91dGlsJztcbmltcG9ydCB7IEV0aGVyZXVtTGlicmFyeVVuYXZhaWxhYmxlRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYyOmV0aCcpO1xuXG5leHBvcnQgY29uc3Qgb3B0aW9uYWxEZXBzID0ge1xuICBnZXQgZXRoQWJpKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgnZXRoZXJldW1qcy1hYmknKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygndW5hYmxlIHRvIGxvYWQgZXRoZXJldW1qcy1hYmk6Jyk7XG4gICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGBldGhlcmV1bWpzLWFiaWApO1xuICAgIH1cbiAgfSxcblxuICBnZXQgZXRoVXRpbCgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBldGhlcmV1bWpzLXV0aWw6Jyk7XG4gICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGBldGhlcmV1bWpzLXV0aWxgKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0IEV0aFR4KCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgnZXRoZXJldW1qcy10eCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBldGhlcmV1bWpzLXR4OicpO1xuICAgICAgZGVidWcoZS5zdGFjayk7XG4gICAgICB0aHJvdyBuZXcgRXRoZXJldW1MaWJyYXJ5VW5hdmFpbGFibGVFcnJvcihgZXRoZXJldW1qcy10eGApO1xuICAgIH1cbiAgfSxcbn07XG5cbi8qKlxuICogVGhlIGV4dHJhIHBhcmFtZXRlcnMgdG8gc2VuZCB0byBwbGF0Zm9ybSBidWlsZCByb3V0ZSBmb3IgaG9wIHRyYW5zYWN0aW9uc1xuICovXG5pbnRlcmZhY2UgSG9wUGFyYW1zIHtcbiAgaG9wUGFyYW1zOiB7XG4gICAgZ2FzUHJpY2VNYXg6IG51bWJlcjtcbiAgICB1c2VyUmVxU2lnOiBzdHJpbmc7XG4gICAgcGF5bWVudElkOiBzdHJpbmc7XG4gIH07XG4gIGdhc0xpbWl0OiBudW1iZXI7XG59XG5cbi8qKlxuICogVGhlIHByZWJ1aWx0IGhvcCB0cmFuc2FjdGlvbiByZXR1cm5lZCBmcm9tIHRoZSBIU01cbiAqL1xuaW50ZXJmYWNlIEhvcFByZWJ1aWxkIHtcbiAgdHg6IHN0cmluZztcbiAgaWQ6IHN0cmluZztcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZWNpcGllbnQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nO1xuICBkYXRhPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2lnbkZpbmFsT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IHtcbiAgICBnYXNQcmljZTogc3RyaW5nO1xuICAgIGdhc0xpbWl0OiBzdHJpbmc7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gICAgaGFsZlNpZ25lZDoge1xuICAgICAgZXhwaXJlVGltZTogbnVtYmVyO1xuICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXI7XG4gICAgICBzaWduYXR1cmU6IHN0cmluZztcbiAgICB9O1xuICAgIG5leHRDb250cmFjdFNlcXVlbmNlSWQ/OiBudW1iZXI7XG4gICAgaG9wVHJhbnNhY3Rpb24/OiBzdHJpbmc7XG4gIH07XG4gIHNpZ25pbmdLZXlOb25jZTogbnVtYmVyO1xuICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgcHJ2OiBzdHJpbmc7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xufVxuXG5pbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFNpZ25GaW5hbE9wdGlvbnMge1xuICBpc0xhc3RTaWduYXR1cmU/OiBib29sZWFuO1xuICBleHBpcmVUaW1lOiBudW1iZXI7XG4gIHNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgZ2FzTGltaXQ6IG51bWJlcjtcbiAgZ2FzUHJpY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICAgIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgICBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgICBzZXF1ZW5jZUlkOiBudW1iZXI7XG4gICAgdHhIZXg/OiBuZXZlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgU2lnbmVkVHJhbnNhY3Rpb24gPSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gfCBGdWxseVNpZ25lZFRyYW5zYWN0aW9uO1xuXG5pbnRlcmZhY2UgUHJlY3JlYXRlQml0R29PcHRpb25zIHtcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgbmV3RmVlQWRkcmVzcz86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIG5leHRDb250cmFjdFNlcXVlbmNlSWQ/OiBzdHJpbmc7XG4gIGNvbnRyYWN0U2VxdWVuY2VJZD86IHN0cmluZztcbiAgdHg6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBnYXNQcmljZTogbnVtYmVyO1xuICBnYXNMaW1pdDogbnVtYmVyO1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nO1xuICBiYWNrdXBLZXlOb25jZTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVW5mb3JtYXR0ZWRUeEluZm8ge1xuICByZWNpcGllbnQ6IFJlY2lwaWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyT3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHdhbGxldENvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5SW5mbyB7XG4gIGlkOiBzdHJpbmc7XG4gIHR4OiBzdHJpbmc7XG4gIGJhY2t1cEtleT86IHN0cmluZztcbiAgY29pbj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJUb2tlbk9wdGlvbnMge1xuICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IFdhbGxldDtcbiAgcmVjaXBpZW50OiBzdHJpbmc7XG4gIGJyb2FkY2FzdD86IGJvb2xlYW47XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHBydj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEdldFNlbmRNZXRob2RBcmdzT3B0aW9ucyB7XG4gIHJlY2lwaWVudDogUmVjaXBpZW50O1xuICBleHBpcmVUaW1lOiBudW1iZXI7XG4gIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyO1xuICBzaWduYXR1cmU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNlbmRNZXRob2RBcmdzIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIHZhbHVlOiBhbnk7XG59XG5cbmludGVyZmFjZSBIb3BUcmFuc2FjdGlvbkJ1aWxkT3B0aW9ucyB7XG4gIHdhbGxldDogV2FsbGV0O1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQnVpbGRPcHRpb25zIHtcbiAgaG9wPzogYm9vbGVhbjtcbiAgd2FsbGV0PzogV2FsbGV0O1xuICByZWNpcGllbnRzPzogUmVjaXBpZW50W107XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBGZWVFc3RpbWF0ZSB7XG4gIGdhc0xpbWl0RXN0aW1hdGU6IG51bWJlcjtcbiAgZmVlRXN0aW1hdGU6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIGhvcFRyYW5zYWN0aW9uPzogSG9wUHJlYnVpbGQ7XG4gIGJ1aWxkUGFyYW1zOiB7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIH07XG59XG5cbmludGVyZmFjZSBSZWNvdmVyVG9rZW5UcmFuc2FjdGlvbiB7XG4gIGhhbGZTaWduZWQ6IHtcbiAgICByZWNpcGllbnQ6IFJlY2lwaWVudDtcbiAgICBleHBpcmVUaW1lOiBudW1iZXI7XG4gICAgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXI7XG4gICAgb3BlcmF0aW9uSGFzaDogc3RyaW5nO1xuICAgIHNpZ25hdHVyZTogc3RyaW5nO1xuICAgIGdhc0xpbWl0OiBudW1iZXI7XG4gICAgZ2FzUHJpY2U6IG51bWJlcjtcbiAgICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICAgIHdhbGxldElkOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBFdGggZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHN0YXRpYyBob3BUcmFuc2FjdGlvblNhbHQgPSAnYml0Z29Ib3BBZGRyZXNzUmVxdWVzdFNhbHQnO1xuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBFdGgoYml0Z28pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZhY3RvciBiZXR3ZWVuIHRoZSBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEJhc2VGYWN0b3IoKTogc3RyaW5nIHtcbiAgICAvLyAxMF4xOFxuICAgIHJldHVybiAnMTAwMDAwMDAwMDAwMDAwMDAwMCc7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZXRoJztcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZXRoJztcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdFdGhlcmV1bSc7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIGRhdGEgYWxvbmcgd2l0aCB0cmFuc2FjdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIHR4IGRhdGEgKEVUSCksIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdHJhbnNhY3Rpb25EYXRhQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciBhbiBhZGRyZXNzIHN0cmluZyBpcyB2YWxpZCBmb3IgdGhpcyBjb2luXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gb3B0aW9uYWxEZXBzLmV0aFV0aWwuaXNWYWxpZEFkZHJlc3Mob3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KGFkZHJlc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChwdWIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGdhcyBwcmljZSBmcm9tIHBsYXRmb3JtXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9XG4gICAqL1xuICBnZXRSZWNvdmVyeUdhc1ByaWNlKCk6IGFueSB7XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTignMjAwMDAwMDAwMDAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGdhcyBsaW1pdCBmcm9tIHBsYXRmb3JtXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9XG4gICAqL1xuICBnZXRSZWNvdmVyeUdhc0xpbWl0KCk6IGFueSB7XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTignNTAwMDAwJyk7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBleHBpcmUgdGltZSBmb3IgYSBjb250cmFjdCBjYWxsICgxIHdlZWspXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRpbWUgaW4gc2Vjb25kc1xuICAgKi9cbiAgZ2V0RGVmYXVsdEV4cGlyZVRpbWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCAqIDI0ICogNztcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBFdGhlcnNjYW4gZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIEVUSCBhZGRyZXNzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBhZGRyZXNzIGJhbGFuY2VcbiAgICovXG4gIHF1ZXJ5QWRkcmVzc0JhbGFuY2UoYWRkcmVzczogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNlbGYucmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeSh7XG4gICAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgICBhY3Rpb246ICdiYWxhbmNlJyxcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihyZXN1bHQucmVzdWx0LCAxMCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUXVlcnkgRXRoZXJzY2FuIGZvciB0aGUgYmFsYW5jZSBvZiBhbiBhZGRyZXNzIGZvciBhIHRva2VuXG4gICAqIEBwYXJhbSB0b2tlbkNvbnRyYWN0QWRkcmVzcyB7U3RyaW5nfSBhZGRyZXNzIHdoZXJlIHRoZSB0b2tlbiBzbWFydCBjb250cmFjdCBpcyBob3N0ZWRcbiAgICogQHBhcmFtIHdhbGxldENvbnRyYWN0QWRkcmVzcyB7U3RyaW5nfSBhZGRyZXNzIG9mIHRoZSB3YWxsZXRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IHRva2VuIGJhbGFhbmNlIGluIGJhc2UgdW5pdHNcbiAgICovXG4gIHF1ZXJ5QWRkcmVzc1Rva2VuQmFsYW5jZShcbiAgICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIHdhbGxldENvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT5cbiAgKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmICghb3B0aW9uYWxEZXBzLmV0aFV0aWwuaXNWYWxpZEFkZHJlc3ModG9rZW5Db250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBiYWxhbmNlIGZvciBpbnZhbGlkIHRva2VuIGFkZHJlc3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9uYWxEZXBzLmV0aFV0aWwuaXNWYWxpZEFkZHJlc3Mod2FsbGV0Q29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgdG9rZW4gYmFsYW5jZSBmb3IgaW52YWxpZCB3YWxsZXQgYWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzZWxmLnJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkoe1xuICAgICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgICAgYWN0aW9uOiAndG9rZW5iYWxhbmNlJyxcbiAgICAgICAgY29udHJhY3RhZGRyZXNzOiB0b2tlbkNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgYWRkcmVzczogd2FsbGV0Q29udHJhY3RBZGRyZXNzLFxuICAgICAgICB0YWc6ICdsYXRlc3QnLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocmVzdWx0LnJlc3VsdCwgMTApO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2ZlciBvcGVyYXRpb24gZm9yIGNvaW5cbiAgICogQHBhcmFtIHJlY2lwaWVudCByZWNpcGllbnQgaW5mb1xuICAgKiBAcGFyYW0gZXhwaXJlVGltZSBleHBpcnkgdGltZVxuICAgKiBAcGFyYW0gY29udHJhY3RTZXF1ZW5jZUlkIHNlcXVlbmNlIGlkXG4gICAqIEByZXR1cm5zIHtBcnJheX0gb3BlcmF0aW9uIGFycmF5XG4gICAqL1xuICBnZXRPcGVyYXRpb24ocmVjaXBpZW50OiBSZWNpcGllbnQsIGV4cGlyZVRpbWU6IG51bWJlciwgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXIpOiAoc3RyaW5nIHwgQnVmZmVyKVtdW10ge1xuICAgIHJldHVybiBbXG4gICAgICBbJ3N0cmluZycsICdhZGRyZXNzJywgJ3VpbnQnLCAnYnl0ZXMnLCAndWludCcsICd1aW50J10sXG4gICAgICBbXG4gICAgICAgICdFVEhFUicsXG4gICAgICAgIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChyZWNpcGllbnQuYWRkcmVzcyksIDE2KSxcbiAgICAgICAgcmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgbmV3IEJ1ZmZlcihvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChyZWNpcGllbnQuZGF0YSkgfHwgJycsICdoZXgnKSxcbiAgICAgICAgZXhwaXJlVGltZSxcbiAgICAgICAgY29udHJhY3RTZXF1ZW5jZUlkLFxuICAgICAgXSxcbiAgICBdO1xuICB9XG5cbiAgZ2V0T3BlcmF0aW9uU2hhM0ZvckV4ZWN1dGVBbmRDb25maXJtKFxuICAgIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdLFxuICAgIGV4cGlyZVRpbWU6IG51bWJlcixcbiAgICBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlclxuICApOiBzdHJpbmcge1xuICAgIGlmICghcmVjaXBpZW50cyB8fCAhQXJyYXkuaXNBcnJheShyZWNpcGllbnRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgYXJyYXkgb2YgcmVjaXBpZW50cycpO1xuICAgIH1cblxuICAgIC8vIFJpZ2h0IG5vdyB3ZSBvbmx5IHN1cHBvcnQgMSByZWNpcGllbnRcbiAgICBpZiAocmVjaXBpZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzZW5kIHRvIGV4YWN0bHkgMSByZWNpcGllbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIoZXhwaXJlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwaXJlVGltZSBtdXN0IGJlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIGVwb2NoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTnVtYmVyKGNvbnRyYWN0U2VxdWVuY2VJZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29udHJhY3RTZXF1ZW5jZUlkIG11c3QgYmUgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaW5wdXRzXG4gICAgcmVjaXBpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHJlY2lwaWVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAhXy5pc1N0cmluZyhyZWNpcGllbnQuYWRkcmVzcykgfHxcbiAgICAgICAgIW9wdGlvbmFsRGVwcy5ldGhVdGlsLmlzVmFsaWRBZGRyZXNzKG9wdGlvbmFsRGVwcy5ldGhVdGlsLmFkZEhleFByZWZpeChyZWNpcGllbnQuYWRkcmVzcykpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3M6ICcgKyByZWNpcGllbnQuYWRkcmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBhbW91bnQ7XG4gICAgICB0cnkge1xuICAgICAgICBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKHJlY2lwaWVudC5hbW91bnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYW1vdW50IGZvcjogJyArIHJlY2lwaWVudC5hZGRyZXNzICsgJyAtIHNob3VsZCBiZSBudW1lcmljJyk7XG4gICAgICB9XG5cbiAgICAgIHJlY2lwaWVudC5hbW91bnQgPSBhbW91bnQudG9GaXhlZCgwKTtcblxuICAgICAgaWYgKHJlY2lwaWVudC5kYXRhICYmICFfLmlzU3RyaW5nKHJlY2lwaWVudC5kYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZm9yIHJlY2lwaWVudCAnICsgcmVjaXBpZW50LmFkZHJlc3MgKyAnIC0gc2hvdWxkIGJlIG9mIHR5cGUgaGV4IHN0cmluZycpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVjaXBpZW50ID0gcmVjaXBpZW50c1swXTtcbiAgICByZXR1cm4gb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoXG4gICAgICBvcHRpb25hbERlcHMuZXRoQWJpLnNvbGlkaXR5U0hBMyguLi50aGlzLmdldE9wZXJhdGlvbihyZWNpcGllbnQsIGV4cGlyZVRpbWUsIGNvbnRyYWN0U2VxdWVuY2VJZCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyaWVzIHRoZSBjb250cmFjdCAodmlhIEV0aGVyc2NhbikgZm9yIHRoZSBuZXh0IHNlcXVlbmNlIElEXG4gICAqIEBwYXJhbSBhZGRyZXNzIHtTdHJpbmd9IGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBzZXF1ZW5jZSBJRFxuICAgKi9cbiAgcXVlcnlTZXF1ZW5jZUlkKGFkZHJlc3M6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8bnVtYmVyPik6IEJsdWViaXJkPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxudW1iZXI+KGZ1bmN0aW9uKigpIHtcbiAgICAgIC8vIEdldCBzZXF1ZW5jZSBJRCB1c2luZyBjb250cmFjdCBjYWxsXG4gICAgICBjb25zdCBzZXF1ZW5jZUlkTWV0aG9kU2lnbmF0dXJlID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5tZXRob2RJRCgnZ2V0TmV4dFNlcXVlbmNlSWQnLCBbXSk7XG4gICAgICBjb25zdCBzZXF1ZW5jZUlkQXJncyA9IG9wdGlvbmFsRGVwcy5ldGhBYmkucmF3RW5jb2RlKFtdLCBbXSk7XG4gICAgICBjb25zdCBzZXF1ZW5jZUlkRGF0YSA9IEJ1ZmZlci5jb25jYXQoW3NlcXVlbmNlSWRNZXRob2RTaWduYXR1cmUsIHNlcXVlbmNlSWRBcmdzXSkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5yZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHtcbiAgICAgICAgbW9kdWxlOiAncHJveHknLFxuICAgICAgICBhY3Rpb246ICdldGhfY2FsbCcsXG4gICAgICAgIHRvOiBhZGRyZXNzLFxuICAgICAgICBkYXRhOiBzZXF1ZW5jZUlkRGF0YSxcbiAgICAgICAgdGFnOiAnbGF0ZXN0JyxcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2VxdWVuY2VJZEhleCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICByZXR1cm4gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHNlcXVlbmNlSWRIZXguc2xpY2UoMiksIDE2KS50b051bWJlcigpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3Igc2lnblRyYW5zYWN0aW9uIGZvciB0aGUgcmFyZSBjYXNlIHRoYXQgU0RLIGlzIGRvaW5nIHRoZSBzZWNvbmQgc2lnbmF0dXJlXG4gICAqIE5vdGU6IHdlIGFyZSBleHBlY3RpbmcgdGhpcyB0byBiZSBjYWxsZWQgZnJvbSB0aGUgb2ZmbGluZSB2YXVsdFxuICAgKiBAcGFyYW0gcGFyYW1zLnR4UHJlYnVpbGRcbiAgICogQHBhcmFtIHBhcmFtcy5zaWduaW5nS2V5Tm9uY2VcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3NcbiAgICogQHBhcmFtIHBhcmFtcy5wcnZcbiAgICogQHJldHVybnMge3t0eEhleDogKn19XG4gICAqL1xuICBzaWduRmluYWwocGFyYW1zOiBTaWduRmluYWxPcHRpb25zKTogRnVsbHlTaWduZWRUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgdHhQcmVidWlsZCA9IHBhcmFtcy50eFByZWJ1aWxkO1xuXG4gICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5zaWduaW5nS2V5Tm9uY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgaGF2ZSBzaWduaW5nS2V5Tm9uY2UgYXMgYSBwYXJhbWV0ZXIsIGFuZCBpdCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtcyBtdXN0IGluY2x1ZGUgd2FsbGV0Q29udHJhY3RBZGRyZXNzLCBidXQgZ290IHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25pbmdOb2RlID0gdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChwYXJhbXMucHJ2KTtcbiAgICBjb25zdCBzaWduaW5nS2V5ID0gc2lnbmluZ05vZGUuZ2V0S2V5KCkuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuXG4gICAgY29uc3QgdHhJbmZvID0ge1xuICAgICAgcmVjaXBpZW50OiB0eFByZWJ1aWxkLnJlY2lwaWVudHNbMF0sXG4gICAgICBleHBpcmVUaW1lOiB0eFByZWJ1aWxkLmhhbGZTaWduZWQuZXhwaXJlVGltZSxcbiAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogdHhQcmVidWlsZC5oYWxmU2lnbmVkLmNvbnRyYWN0U2VxdWVuY2VJZCxcbiAgICAgIHNpZ25hdHVyZTogdHhQcmVidWlsZC5oYWxmU2lnbmVkLnNpZ25hdHVyZSxcbiAgICB9O1xuXG4gICAgY29uc3Qgc2VuZE1ldGhvZEFyZ3MgPSB0aGlzLmdldFNlbmRNZXRob2RBcmdzKHR4SW5mbyk7XG4gICAgY29uc3QgbWV0aG9kU2lnbmF0dXJlID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5tZXRob2RJRCgnc2VuZE11bHRpU2lnJywgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJykpO1xuICAgIGNvbnN0IGVuY29kZWRBcmdzID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5yYXdFbmNvZGUoXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJyksIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndmFsdWUnKSk7XG4gICAgY29uc3Qgc2VuZERhdGEgPSBCdWZmZXIuY29uY2F0KFttZXRob2RTaWduYXR1cmUsIGVuY29kZWRBcmdzXSk7XG5cbiAgICBjb25zdCBldGhUeFBhcmFtcyA9IHtcbiAgICAgIHRvOiBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzLFxuICAgICAgbm9uY2U6IHBhcmFtcy5zaWduaW5nS2V5Tm9uY2UsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGdhc1ByaWNlOiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4odHhQcmVidWlsZC5nYXNQcmljZSksXG4gICAgICBnYXNMaW1pdDogbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHR4UHJlYnVpbGQuZ2FzTGltaXQpLFxuICAgICAgZGF0YTogc2VuZERhdGEsXG4gICAgICBzcGVuZEFtb3VudDogcGFyYW1zLnJlY2lwaWVudHNbMF0uYW1vdW50LFxuICAgIH07XG5cbiAgICBjb25zdCBldGhUeCA9IG5ldyBvcHRpb25hbERlcHMuRXRoVHgoZXRoVHhQYXJhbXMpO1xuICAgIGV0aFR4LnNpZ24oc2lnbmluZ0tleSk7XG4gICAgcmV0dXJuIHsgdHhIZXg6IGV0aFR4LnNlcmlhbGl6ZSgpLnRvU3RyaW5nKCdoZXgnKSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHR4UHJlYnVpbGRcbiAgICogLSBwcnZcbiAgICogQHJldHVybnMge3t0eEhleH19XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogU2lnbmVkVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcbiAgICBjb25zdCB1c2VyUHJ2ID0gcGFyYW1zLnBydjtcbiAgICBjb25zdCBFWFBJUkVUSU1FX0RFRkFVTFQgPSA2MCAqIDYwICogMjQgKiA3OyAvLyBUaGlzIHNpZ25hdHVyZSB3aWxsIGJlIHZhbGlkIGZvciAxIHdlZWtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpIHx8ICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgJiYgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eFByZWJ1aWxkfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodXNlclBydikgfHwgIV8uaXNTdHJpbmcodXNlclBydikpIHtcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh1c2VyUHJ2KSAmJiAhXy5pc1N0cmluZyh1c2VyUHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiB1c2VyUHJ2fWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIHBhcmFtcy5yZWNpcGllbnRzID0gdHhQcmVidWlsZC5yZWNpcGllbnRzIHx8IHBhcmFtcy5yZWNpcGllbnRzO1xuXG4gICAgLy8gaWYgbm8gcmVjaXBpZW50cyBpbiBlaXRoZXIgcGFyYW1zIG9yIHR4UHJlYnVpbGQsIHRoZW4gdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoIXBhcmFtcy5yZWNpcGllbnRzIHx8ICFBcnJheS5pc0FycmF5KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNpcGllbnRzIG1pc3Npbmcgb3Igbm90IGFycmF5Jyk7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsbHkgdGhlIFNESyBwcm92aWRlcyB0aGUgZmlyc3Qgc2lnbmF0dXJlIGZvciBhbiBFVEggdHgsIGJ1dCBvY2Nhc2lvbmFsbHkgaXQgcHJvdmlkZXMgdGhlIHNlY29uZCBhbmQgZmluYWwgb25lLlxuICAgIGlmIChwYXJhbXMuaXNMYXN0U2lnbmF0dXJlKSB7XG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2hlbiB3ZSdyZSBkb2luZyB0aGUgc2Vjb25kIChmaW5hbCkgc2lnbmF0dXJlLCB0aGUgbG9naWMgaXMgZGlmZmVyZW50LlxuICAgICAgcmV0dXJuIHRoaXMuc2lnbkZpbmFsKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vjb25kc1NpbmNlRXBvY2ggPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgY29uc3QgZXhwaXJlVGltZSA9IHBhcmFtcy5leHBpcmVUaW1lIHx8IHNlY29uZHNTaW5jZUVwb2NoICsgRVhQSVJFVElNRV9ERUZBVUxUO1xuICAgIGNvbnN0IHNlcXVlbmNlSWQgPSB0eFByZWJ1aWxkLm5leHRDb250cmFjdFNlcXVlbmNlSWQ7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChzZXF1ZW5jZUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IG5leHRDb250cmFjdFNlcXVlbmNlSWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcGVyYXRpb25IYXNoID0gdGhpcy5nZXRPcGVyYXRpb25TaGEzRm9yRXhlY3V0ZUFuZENvbmZpcm0ocGFyYW1zLnJlY2lwaWVudHMsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFV0aWwuZXRoU2lnbk1zZ0hhc2gob3BlcmF0aW9uSGFzaCwgVXRpbC54cHJ2VG9FdGhQcml2YXRlS2V5KHVzZXJQcnYpKTtcblxuICAgIGNvbnN0IHR4UGFyYW1zID0ge1xuICAgICAgcmVjaXBpZW50czogcGFyYW1zLnJlY2lwaWVudHMsXG4gICAgICBleHBpcmVUaW1lOiBleHBpcmVUaW1lLFxuICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBzZXF1ZW5jZUlkLFxuICAgICAgc2VxdWVuY2VJZDogcGFyYW1zLnNlcXVlbmNlSWQsXG4gICAgICBvcGVyYXRpb25IYXNoOiBvcGVyYXRpb25IYXNoLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICBnYXNMaW1pdDogcGFyYW1zLmdhc0xpbWl0LFxuICAgICAgZ2FzUHJpY2U6IHBhcmFtcy5nYXNQcmljZSxcbiAgICAgIGhvcFRyYW5zYWN0aW9uOiB0eFByZWJ1aWxkLmhvcFRyYW5zYWN0aW9uLFxuICAgIH07XG4gICAgcmV0dXJuIHsgaGFsZlNpZ25lZDogdHhQYXJhbXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgZWl0aGVyIGVudGVycHJpc2Ugb3IgbmV3RmVlQWRkcmVzcyBpcyBwYXNzZWQsIHRvIGtub3cgd2hldGhlciB0byBjcmVhdGUgbmV3IGtleSBvciB1c2UgZW50ZXJwcmlzZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmVudGVycHJpc2Uge1N0cmluZ30gdGhlIGVudGVycHJpc2UgaWQgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBrZXlcbiAgICogQHBhcmFtIHBhcmFtcy5uZXdGZWVBZGRyZXNzIHtCb29sZWFufSBjcmVhdGUgYSBuZXcgZmVlIGFkZHJlc3MgKGVudGVycHJpc2Ugbm90IG5lZWRlZCBpbiB0aGlzIGNhc2UpXG4gICAqL1xuICBwcmVDcmVhdGVCaXRHbyhwYXJhbXM6IFByZWNyZWF0ZUJpdEdvT3B0aW9ucyk6IHZvaWQge1xuICAgIC8vIFdlIGFsd2F5cyBuZWVkIHBhcmFtcyBvYmplY3QsIHNpbmNlIGVpdGhlciBlbnRlcnByaXNlIG9yIG5ld0ZlZUFkZHJlc3MgaXMgcmVxdWlyZWRcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmVDcmVhdGVCaXRHbyBtdXN0IGJlIHBhc3NlZCBhIHBhcmFtcyBvYmplY3QuIEdvdCAke3BhcmFtc30gKHR5cGUgJHt0eXBlb2YgcGFyYW1zfSlgKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuZW50ZXJwcmlzZSkgJiYgXy5pc1VuZGVmaW5lZChwYXJhbXMubmV3RmVlQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2V4cGVjdGluZyBlbnRlcnByaXNlIHdoZW4gYWRkaW5nIEJpdEdvIGtleS4gSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgbmV3IEVUSCBiaXRnbyBrZXksIHNldCB0aGUgbmV3RmVlQWRkcmVzcyBwYXJhbWV0ZXIgdG8gdHJ1ZS4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHdoZXRoZXIga2V5IHNob3VsZCBiZSBhbiBlbnRlcnByaXNlIGtleSBvciBhIEJpdEdvIGtleSBmb3IgYSBuZXcgZmVlIGFkZHJlc3NcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgYXJndW1lbnRzIC0gY2Fubm90IHBhc3MgYm90aCBlbnRlcnByaXNlIGFuZCBuZXdGZWVBZGRyZXNzIHBhcmFtZXRlci5gKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5lbnRlcnByaXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbnRlcnByaXNlIHNob3VsZCBiZSBhIHN0cmluZyAtIGdvdCAke3BhcmFtcy5lbnRlcnByaXNlfSAodHlwZSAke3R5cGVvZiBwYXJhbXMuZW50ZXJwcmlzZX0pYCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLm5ld0ZlZUFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBuZXdGZWVBZGRyZXNzIHNob3VsZCBiZSBhIGJvb2xlYW4gLSBnb3QgJHtwYXJhbXMubmV3RmVlQWRkcmVzc30gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLm5ld0ZlZUFkZHJlc3N9KWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgcHVibGljIGJsb2NrIGV4cGxvcmVyIHRvIGdldCB0aGUgbmV4dCBFVEggbm9uY2UgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGdpdmVuIEVUSCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldEFkZHJlc3NOb25jZShhZGRyZXNzOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPG51bWJlcj4pOiBCbHVlYmlyZDxudW1iZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288bnVtYmVyPihmdW5jdGlvbiooKSB7XG4gICAgICAvLyBHZXQgbm9uY2UgZm9yIGJhY2t1cCBrZXkgKHNob3VsZCBiZSAwKVxuICAgICAgbGV0IG5vbmNlID0gMDtcblxuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5yZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHtcbiAgICAgICAgbW9kdWxlOiAnYWNjb3VudCcsXG4gICAgICAgIGFjdGlvbjogJ3R4bGlzdCcsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJhY2t1cEtleVR4TGlzdCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICBpZiAoYmFja3VwS2V5VHhMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGxhc3Qgbm9uY2UgdXNlZFxuICAgICAgICBjb25zdCBvdXRnb2luZ1R4cyA9IGJhY2t1cEtleVR4TGlzdC5maWx0ZXIodHggPT4gdHguZnJvbSA9PT0gYWRkcmVzcyk7XG4gICAgICAgIG5vbmNlID0gb3V0Z29pbmdUeHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vbmNlO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcmVjb3ZlcigpXG4gICAqIFRoaXMgdHJhbnNmb3JtcyB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24gaW5mb3JtYXRpb24gaW50byBhIGZvcm1hdCB0aGUgQml0R28gb2ZmbGluZSB2YXVsdCBleHBlY3RzXG4gICAqIEBwYXJhbSB0eEluZm9cbiAgICogQHBhcmFtIGV0aFR4XG4gICAqIEBwYXJhbSB1c2VyS2V5XG4gICAqIEBwYXJhbSBiYWNrdXBLZXlcbiAgICogQHBhcmFtIGdhc1ByaWNlXG4gICAqIEBwYXJhbSBnYXNMaW1pdFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3t0eDogKiwgdXNlcktleTogKiwgYmFja3VwS2V5OiAqLCBjb2luOiBzdHJpbmcsIGFtb3VudDogc3RyaW5nLCBnYXNQcmljZTogc3RyaW5nLCBnYXNMaW1pdDogc3RyaW5nLCByZWNpcGllbnRzOiAoe2FkZHJlc3MsIGFtb3VudH18e2FkZHJlc3M6ICh7YWRkcmVzcywgYW1vdW50fXxzdHJpbmcpLCBhbW91bnQ6IHN0cmluZ318c3RyaW5nKVtdfX1cbiAgICovXG4gIGZvcm1hdEZvck9mZmxpbmVWYXVsdChcbiAgICB0eEluZm86IFVuZm9ybWF0dGVkVHhJbmZvLFxuICAgIGV0aFR4OiBhbnksXG4gICAgdXNlcktleTogc3RyaW5nLFxuICAgIGJhY2t1cEtleTogc3RyaW5nLFxuICAgIGdhc1ByaWNlOiBCdWZmZXIsXG4gICAgZ2FzTGltaXQ6IG51bWJlcixcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxPZmZsaW5lVmF1bHRUeEluZm8+XG4gICk6IEJsdWViaXJkPE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxPZmZsaW5lVmF1bHRUeEluZm8+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IGJhY2t1cEhETm9kZSA9IHV0eG9MaWIuSEROb2RlLmZyb21CYXNlNTgoYmFja3VwS2V5KTtcbiAgICAgIGNvbnN0IGJhY2t1cFNpZ25pbmdLZXkgPSBiYWNrdXBIRE5vZGUuZ2V0S2V5KCkuZ2V0UHVibGljS2V5QnVmZmVyKCk7XG4gICAgICBjb25zdCByZXNwb25zZTogT2ZmbGluZVZhdWx0VHhJbmZvID0ge1xuICAgICAgICB0eDogZXRoVHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB1c2VyS2V5LFxuICAgICAgICBiYWNrdXBLZXksXG4gICAgICAgIGNvaW46IHNlbGYuZ2V0Q2hhaW4oKSxcbiAgICAgICAgZ2FzUHJpY2U6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSW50KGdhc1ByaWNlKS50b0ZpeGVkKCksXG4gICAgICAgIGdhc0xpbWl0LFxuICAgICAgICByZWNpcGllbnRzOiBbdHhJbmZvLnJlY2lwaWVudF0sXG4gICAgICAgIHdhbGxldENvbnRyYWN0QWRkcmVzczogJzB4JyArIGV0aFR4LnRvLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgYW1vdW50OiB0eEluZm8ucmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgYmFja3VwS2V5Tm9uY2U6IHlpZWxkIHNlbGYuZ2V0QWRkcmVzc05vbmNlKFxuICAgICAgICAgIGAweCR7b3B0aW9uYWxEZXBzLmV0aFV0aWwucHVibGljVG9BZGRyZXNzKGJhY2t1cFNpZ25pbmdLZXksIHRydWUpLnRvU3RyaW5nKCdoZXgnKX1gXG4gICAgICAgICksXG4gICAgICB9O1xuICAgICAgXy5leHRlbmQocmVzcG9uc2UsIHR4SW5mbyk7XG4gICAgICByZXNwb25zZS5uZXh0Q29udHJhY3RTZXF1ZW5jZUlkID0gcmVzcG9uc2UuY29udHJhY3RTZXF1ZW5jZUlkO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJLZXkge1N0cmluZ30gW2VuY3J5cHRlZF0geHBydlxuICAgKiBAcGFyYW0gcGFyYW1zLmJhY2t1cEtleSB7U3RyaW5nfSBbZW5jcnlwdGVkXSB4cHJ2IG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2Uge1N0cmluZ30gdXNlZCB0byBkZWNyeXB0IHVzZXJLZXkgYW5kIGJhY2t1cEtleVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyB7U3RyaW5nfSB0aGUgRVRIIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCBjb250cmFjdFxuICAgKiBAcGFyYW0gcGFyYW1zLmtyc1Byb3ZpZGVyIHtTdHJpbmd9IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gICAqIEBwYXJhbSBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiB7U3RyaW5nfSB0YXJnZXQgYWRkcmVzcyB0byBzZW5kIHJlY292ZXJlZCBmdW5kcyB0b1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY292ZXIoXG4gICAgcGFyYW1zOiBSZWNvdmVyT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxSZWNvdmVyeUluZm8gfCBPZmZsaW5lVmF1bHRUeEluZm8+XG4gICk6IEJsdWViaXJkPFJlY292ZXJ5SW5mbyB8IE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxSZWNvdmVyeUluZm8gfCBPZmZsaW5lVmF1bHRUeEluZm8+KGZ1bmN0aW9uKiByZWNvdmVyKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnVzZXJLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5iYWNrdXBLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpIHx8ICFzZWxmLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3YWxsZXRDb250cmFjdEFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pIHx8ICFzZWxmLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnlEZXN0aW5hdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcbiAgICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmIHBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyICYmIF8uaXNVbmRlZmluZWQoY29uZmlnLmtyc1Byb3ZpZGVyc1twYXJhbXMua3JzUHJvdmlkZXJdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHJlY292ZXJ5IHNlcnZpY2UgcHJvdmlkZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW4gdXAgd2hpdGVzcGFjZSBmcm9tIGVudGVyZWQgdmFsdWVzXG4gICAgICBsZXQgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBjb25zdCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICAgIC8vIFNldCBuZXcgZXRoIHR4IGZlZXMgKHVzaW5nIGRlZmF1bHQgY29uZmlnIHZhbHVlcyBmcm9tIHBsYXRmb3JtKVxuICAgICAgY29uc3QgZ2FzUHJpY2UgPSBzZWxmLmdldFJlY292ZXJ5R2FzUHJpY2UoKTtcbiAgICAgIGNvbnN0IGdhc0xpbWl0ID0gc2VsZi5nZXRSZWNvdmVyeUdhc0xpbWl0KCk7XG5cbiAgICAgIC8vIERlY3J5cHQgcHJpdmF0ZSBrZXlzIGZyb20gS2V5Q2FyZCB2YWx1ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoIXVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwcnYnKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVzZXJLZXkgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgdXNlciBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGJhY2t1cEtleUFkZHJlc3M7XG4gICAgICBsZXQgYmFja3VwU2lnbmluZ0tleTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgfHwgaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIGNvbnN0IGJhY2t1cEhETm9kZSA9IHV0eG9MaWIuSEROb2RlLmZyb21CYXNlNTgoYmFja3VwS2V5KTtcbiAgICAgICAgYmFja3VwU2lnbmluZ0tleSA9IGJhY2t1cEhETm9kZS5nZXRLZXkoKS5nZXRQdWJsaWNLZXlCdWZmZXIoKTtcbiAgICAgICAgYmFja3VwS2V5QWRkcmVzcyA9IGAweCR7b3B0aW9uYWxEZXBzLmV0aFV0aWwucHVibGljVG9BZGRyZXNzKGJhY2t1cFNpZ25pbmdLZXksIHRydWUpLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVjcnlwdCBiYWNrdXAgcHJpdmF0ZSBrZXkgYW5kIGdldCBhZGRyZXNzXG4gICAgICAgIGxldCBiYWNrdXBQcnY7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiYWNrdXBQcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IGJhY2t1cEtleSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyBiYWNrdXAga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFja3VwSEROb2RlID0gdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChiYWNrdXBQcnYpO1xuICAgICAgICBiYWNrdXBTaWduaW5nS2V5ID0gYmFja3VwSEROb2RlLmdldEtleSgpLmdldFByaXZhdGVLZXlCdWZmZXIoKTtcbiAgICAgICAgYmFja3VwS2V5QWRkcmVzcyA9IGAweCR7b3B0aW9uYWxEZXBzLmV0aFV0aWwucHJpdmF0ZVRvQWRkcmVzcyhiYWNrdXBTaWduaW5nS2V5KS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFja3VwS2V5Tm9uY2UgPSB5aWVsZCBzZWxmLmdldEFkZHJlc3NOb25jZShiYWNrdXBLZXlBZGRyZXNzKTtcblxuICAgICAgLy8gZ2V0IGJhbGFuY2Ugb2YgYmFja3VwS2V5IHRvIGVuc3VyZSBmdW5kcyBhcmUgYXZhaWxhYmxlIHRvIHBheSBmZWVzXG4gICAgICBjb25zdCBiYWNrdXBLZXlCYWxhbmNlID0geWllbGQgc2VsZi5xdWVyeUFkZHJlc3NCYWxhbmNlKGJhY2t1cEtleUFkZHJlc3MpO1xuXG4gICAgICBpZiAoYmFja3VwS2V5QmFsYW5jZS5sdChnYXNQcmljZS5tdWwoZ2FzTGltaXQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEJhY2t1cCBrZXkgYWRkcmVzcyAke2JhY2t1cEtleUFkZHJlc3N9IGhhcyBiYWxhbmNlICR7YmFja3VwS2V5QmFsYW5jZS50b1N0cmluZyhcbiAgICAgICAgICAgIDEwXG4gICAgICAgICAgKX0uIFRoaXMgYWRkcmVzcyBtdXN0IGhhdmUgYSBiYWxhbmNlIG9mIGF0IGxlYXN0IDAuMDEgRVRIIHRvIHBlcmZvcm0gcmVjb3Zlcmllcy4gVHJ5IHNlbmRpbmcgc29tZSBFVEggdG8gdGhpcyBhZGRyZXNzIHRoZW4gcmV0cnkuYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgYmFsYW5jZSBvZiB3YWxsZXQgYW5kIGRlZHVjdCBmZWVzIHRvIGdldCB0cmFuc2FjdGlvbiBhbW91bnRcbiAgICAgIGNvbnN0IHR4QW1vdW50ID0geWllbGQgc2VsZi5xdWVyeUFkZHJlc3NCYWxhbmNlKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpO1xuXG4gICAgICAvLyBidWlsZCByZWNpcGllbnRzIG9iamVjdFxuICAgICAgY29uc3QgcmVjaXBpZW50cyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICAgIGFtb3VudDogdHhBbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgLy8gR2V0IHNlcXVlbmNlIElEIHVzaW5nIGNvbnRyYWN0IGNhbGxcbiAgICAgIGNvbnN0IHNlcXVlbmNlSWQgPSB5aWVsZCBzZWxmLnF1ZXJ5U2VxdWVuY2VJZChwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKTtcblxuICAgICAgbGV0IG9wZXJhdGlvbkhhc2gsIHNpZ25hdHVyZTtcbiAgICAgIC8vIEdldCBvcGVyYXRpb24gaGFzaCBhbmQgc2lnbiBpdFxuICAgICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgb3BlcmF0aW9uSGFzaCA9IHNlbGYuZ2V0T3BlcmF0aW9uU2hhM0ZvckV4ZWN1dGVBbmRDb25maXJtKHJlY2lwaWVudHMsIHNlbGYuZ2V0RGVmYXVsdEV4cGlyZVRpbWUoKSwgc2VxdWVuY2VJZCk7XG4gICAgICAgIHNpZ25hdHVyZSA9IFV0aWwuZXRoU2lnbk1zZ0hhc2gob3BlcmF0aW9uSGFzaCwgVXRpbC54cHJ2VG9FdGhQcml2YXRlS2V5KHVzZXJLZXkpKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIFV0aWwuZWNSZWNvdmVyRXRoQWRkcmVzcyhvcGVyYXRpb25IYXNoLCBzaWduYXR1cmUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4SW5mbyA9IHtcbiAgICAgICAgcmVjaXBpZW50OiByZWNpcGllbnRzWzBdLFxuICAgICAgICBleHBpcmVUaW1lOiBzZWxmLmdldERlZmF1bHRFeHBpcmVUaW1lKCksXG4gICAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogc2VxdWVuY2VJZCxcbiAgICAgICAgb3BlcmF0aW9uSGFzaDogb3BlcmF0aW9uSGFzaCxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIGdhc0xpbWl0OiBnYXNMaW1pdC50b1N0cmluZygxMCksXG4gICAgICB9O1xuXG4gICAgICAvLyBjYWxjdWxhdGUgc2VuZCBkYXRhXG4gICAgICBjb25zdCBzZW5kTWV0aG9kQXJncyA9IHNlbGYuZ2V0U2VuZE1ldGhvZEFyZ3ModHhJbmZvKTtcbiAgICAgIGNvbnN0IG1ldGhvZFNpZ25hdHVyZSA9IG9wdGlvbmFsRGVwcy5ldGhBYmkubWV0aG9kSUQoJ3NlbmRNdWx0aVNpZycsIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndHlwZScpKTtcbiAgICAgIGNvbnN0IGVuY29kZWRBcmdzID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5yYXdFbmNvZGUoXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJyksIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndmFsdWUnKSk7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IEJ1ZmZlci5jb25jYXQoW21ldGhvZFNpZ25hdHVyZSwgZW5jb2RlZEFyZ3NdKTtcblxuICAgICAgLy8gQnVpbGQgY29udHJhY3QgY2FsbCBhbmQgc2lnbiBpdFxuICAgICAgY29uc3QgdHggPSBuZXcgb3B0aW9uYWxEZXBzLkV0aFR4KHtcbiAgICAgICAgdG86IHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MsXG4gICAgICAgIG5vbmNlOiBiYWNrdXBLZXlOb25jZSxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIGdhc1ByaWNlOiBnYXNQcmljZSxcbiAgICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LFxuICAgICAgICBkYXRhOiBzZW5kRGF0YSxcbiAgICAgICAgc3BlbmRBbW91bnQ6IHR4QW1vdW50LFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KHR4SW5mbywgdHgsIHVzZXJLZXksIGJhY2t1cEtleSwgZ2FzUHJpY2UsIGdhc0xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHR4LnNpZ24oYmFja3VwU2lnbmluZ0tleSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpZ25lZFR4OiBSZWNvdmVyeUluZm8gPSB7XG4gICAgICAgIGlkOiBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleCh0eC5oYXNoKHRydWUpKSxcbiAgICAgICAgdHg6IHR4LnNlcmlhbGl6ZSgpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHNpZ25lZFR4LmJhY2t1cEtleSA9IGJhY2t1cEtleTtcbiAgICAgICAgc2lnbmVkVHguY29pbiA9IHNlbGYuZ2V0Q2hhaW4oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpZ25lZFR4O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY292ZXIgYW4gdW5zdXBwb3J0ZWQgdG9rZW4gZnJvbSBhIEJpdEdvIG11bHRpc2lnIHdhbGxldFxuICAgKiBUaGlzIGJ1aWxkcyBhIGhhbGYtc2lnbmVkIHRyYW5zYWN0aW9uLCBmb3Igd2hpY2ggdGhlcmUgd2lsbCBiZSBhbiBhZG1pbiByb3V0ZSB0byBjby1zaWduIGFuZCBicm9hZGNhc3QuIE9wdGlvbmFsbHlcbiAgICogdGhlIHVzZXIgY2FuIHNldCBwYXJhbXMuYnJvYWRjYXN0ID0gdHJ1ZSBhbmQgdGhlIGhhbGYtc2lnbmVkIHR4IHdpbGwgYmUgc2VudCB0byBCaXRHbyBmb3IgY29zaWduaW5nIGFuZCBicm9hZGNhc3RpbmdcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldCB0aGUgd2FsbGV0IHRvIHJlY292ZXIgdGhlIHRva2VuIGZyb21cbiAgICogQHBhcmFtIHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyB0aGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgdW5zdXBwb3J0ZWQgdG9rZW5cbiAgICogQHBhcmFtIHBhcmFtcy5yZWNpcGllbnQgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MgcmVjb3ZlcmVkIHRva2VucyBzaG91bGQgYmUgc2VudCB0b1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgdGhlIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHRoZSB4cHJ2XG4gICAqIEBwYXJhbSBwYXJhbXMuYnJvYWRjYXN0IGlmIHRydWUsIHdlIHdpbGwgYXV0b21hdGljYWxseSBzdWJtaXQgdGhlIGhhbGYtc2lnbmVkIHR4IHRvIEJpdEdvIGZvciBjb3NpZ25pbmcgYW5kIGJyb2FkY2FzdGluZ1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY292ZXJUb2tlbihcbiAgICBwYXJhbXM6IFJlY292ZXJUb2tlbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UmVjb3ZlclRva2VuVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFJlY292ZXJUb2tlblRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFJlY292ZXJUb2tlblRyYW5zYWN0aW9uPihmdW5jdGlvbiooKSB7XG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlY292ZXJUb2tlbiBtdXN0IGJlIHBhc3NlZCBhIHBhcmFtcyBvYmplY3QuIEdvdCAke3BhcmFtc30gKHR5cGUgJHt0eXBlb2YgcGFyYW1zfSlgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzKSB8fCAhXy5pc1N0cmluZyhwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgdG9rZW5Db250cmFjdEFkZHJlc3MgbXVzdCBiZSBhIHN0cmluZywgZ290ICR7XG4gICAgICAgICAgICBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3NcbiAgICAgICAgICB9ICh0eXBlICR7dHlwZW9mIHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzc30pYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuQ29udHJhY3RBZGRyZXNzIG5vdCBhIHZhbGlkIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldCkgfHwgIShwYXJhbXMud2FsbGV0IGluc3RhbmNlb2YgV2FsbGV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhbGxldCBtdXN0IGJlIGEgd2FsbGV0IGluc3RhbmNlLCBnb3QgJHtwYXJhbXMud2FsbGV0fSAodHlwZSAke3R5cGVvZiBwYXJhbXMud2FsbGV0fSlgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY2lwaWVudCkgfHwgIV8uaXNTdHJpbmcocGFyYW1zLnJlY2lwaWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWNpcGllbnQgbXVzdCBiZSBhIHN0cmluZywgZ290ICR7cGFyYW1zLnJlY2lwaWVudH0gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLnJlY2lwaWVudH0pYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjaXBpZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2lwaWVudCBub3QgYSB2YWxpZCBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXggfHwgIW9wdGlvbmFsRGVwcy5ldGhBYmkuc29saWRpdHlTSEEzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXRoZXJldW0gbm90IGZ1bGx5IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0b2tlbiBiYWxhbmNlIGZyb20gZXh0ZXJuYWwgQVBJXG4gICAgICBjb25zdCBjb2luU3BlY2lmaWMgPSBwYXJhbXMud2FsbGV0LmNvaW5TcGVjaWZpYygpO1xuICAgICAgaWYgKCFjb2luU3BlY2lmaWMgfHwgIV8uaXNTdHJpbmcoY29pblNwZWNpZmljLmJhc2VBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29pbiBzcGVjaWZpYyBwcm9wZXJ0eSBiYXNlQWRkcmVzcycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjb3ZlcnlBbW91bnQgPSB5aWVsZCBzZWxmLnF1ZXJ5QWRkcmVzc1Rva2VuQmFsYW5jZShwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MsIGNvaW5TcGVjaWZpYy5iYXNlQWRkcmVzcyk7XG5cbiAgICAgIGlmIChwYXJhbXMuYnJvYWRjYXN0KSB7XG4gICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNyZWF0ZSBhIG5vcm1hbCBFVEggdHJhbnNhY3Rpb24gdGhhdCBzZW5kcyBhbiBhbW91bnQgb2YgMCBFVEggdG8gdGhlXG4gICAgICAgIC8vIHRva2VuQ29udHJhY3RBZGRyZXNzIGFuZCBlbmNvZGUgdGhlIHVuc3VwcG9ydGVkLXRva2VuLXNlbmQgZGF0YSBpbiB0aGUgZGF0YSBmaWVsZFxuICAgICAgICAvLyAjdHJpY2tzeVxuICAgICAgICBjb25zdCBzZW5kTWV0aG9kQXJncyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnX3RvJyxcbiAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ192YWx1ZScsXG4gICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3ZlcnlBbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG1ldGhvZFNpZ25hdHVyZSA9IG9wdGlvbmFsRGVwcy5ldGhBYmkubWV0aG9kSUQoJ3RyYW5zZmVyJywgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJykpO1xuICAgICAgICBjb25zdCBlbmNvZGVkQXJncyA9IG9wdGlvbmFsRGVwcy5ldGhBYmkucmF3RW5jb2RlKFxuICAgICAgICAgIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndHlwZScpLFxuICAgICAgICAgIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndmFsdWUnKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBzZW5kRGF0YSA9IEJ1ZmZlci5jb25jYXQoW21ldGhvZFNpZ25hdHVyZSwgZW5jb2RlZEFyZ3NdKTtcblxuICAgICAgICBjb25zdCBicm9hZGNhc3RQYXJhbXM6IGFueSA9IHtcbiAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiAnMCcsXG4gICAgICAgICAgZGF0YTogc2VuZERhdGEudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgICAgIGJyb2FkY2FzdFBhcmFtcy53YWxsZXRQYXNzcGhyYXNlID0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnBydikge1xuICAgICAgICAgIGJyb2FkY2FzdFBhcmFtcy5wcnYgPSBwYXJhbXMucHJ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHlpZWxkIHBhcmFtcy53YWxsZXQuc2VuZChicm9hZGNhc3RQYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWNpcGllbnQgPSB7XG4gICAgICAgIGFkZHJlc3M6IHBhcmFtcy5yZWNpcGllbnQsXG4gICAgICAgIGFtb3VudDogcmVjb3ZlcnlBbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgfTtcblxuICAgICAgLy8gVGhpcyBzaWduYXR1cmUgd2lsbCBiZSB2YWxpZCBmb3Igb25lIHdlZWtcbiAgICAgIGNvbnN0IGV4cGlyZVRpbWUgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyA2MCAqIDYwICogMjQgKiA3O1xuXG4gICAgICAvLyBHZXQgc2VxdWVuY2UgSUQuIFdlIGRvIHRoaXMgYnkgYnVpbGRpbmcgYSAnZmFrZScgZXRoIHRyYW5zYWN0aW9uLCBzbyB0aGUgcGxhdGZvcm0gd2lsbCBpbmNyZW1lbnQgYW5kIHJldHVybiB1cyB0aGUgbmV3IHNlcXVlbmNlIGlkXG4gICAgICAvLyBUaGlzIF9kb2VzXyByZXF1aXJlIHRoZSB1c2VyIHRvIGhhdmUgYSBub24temVybyB3YWxsZXQgYmFsYW5jZVxuICAgICAgY29uc3QgeyBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkLCBnYXNQcmljZSwgZ2FzTGltaXQgfSA9IHlpZWxkIHBhcmFtcy53YWxsZXQucHJlYnVpbGRUcmFuc2FjdGlvbih7XG4gICAgICAgIHJlY2lwaWVudHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgICAgICAgYW1vdW50OiAnMScsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGVzZSByZWNvdmVyaWVzIG5lZWQgdG8gYmUgcHJvY2Vzc2VkIGJ5IHN1cHBvcnQsIGJ1dCBpZiB0aGUgY3VzdG9tZXIgc2VuZHMgYW55IHRyYW5zYWN0aW9ucyBiZWZvcmUgcmVjb3ZlcnkgaXNcbiAgICAgIC8vIGNvbXBsZXRlIHRoZSBzZXF1ZW5jZSBJRCB3aWxsIGJlIGludmFsaWQuIGFydGlmaWNpYWxseSBpbmZsYXRlIHRoZSBzZXF1ZW5jZSBJRCB0byBhbGxvdyBtb3JlIHRpbWUgZm9yIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IHNhZmVTZXF1ZW5jZUlkID0gbmV4dENvbnRyYWN0U2VxdWVuY2VJZCArIDEwMDA7XG5cbiAgICAgIC8vIEJ1aWxkIHNlbmREYXRhIGZvciBldGhlcmV1bSB0eFxuICAgICAgY29uc3Qgb3BlcmF0aW9uVHlwZXMgPSBbJ3N0cmluZycsICdhZGRyZXNzJywgJ3VpbnQnLCAnYWRkcmVzcycsICd1aW50JywgJ3VpbnQnXTtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbkFyZ3MgPSBbXG4gICAgICAgIC8vIFwiRVJDMjBcIiBoYXMgYmVlbiBhZGRlZCBoZXJlIHNvIHRoYXQgZXRoZXIgb3BlcmF0aW9uIGhhc2hlcywgc2lnbmF0dXJlcyBjYW5ub3QgYmUgcmUtdXNlZCBmb3IgdG9rZW5TZW5kaW5nXG4gICAgICAgICdFUkMyMCcsXG4gICAgICAgIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChyZWNpcGllbnQuYWRkcmVzcyksIDE2KSxcbiAgICAgICAgcmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyksIDE2KSxcbiAgICAgICAgZXhwaXJlVGltZSxcbiAgICAgICAgc2FmZVNlcXVlbmNlSWQsXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBvcGVyYXRpb25IYXNoID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoXG4gICAgICAgIG9wdGlvbmFsRGVwcy5ldGhBYmkuc29saWRpdHlTSEEzKG9wZXJhdGlvblR5cGVzLCBvcGVyYXRpb25BcmdzKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdXNlclBydiA9IHlpZWxkIHBhcmFtcy53YWxsZXQuZ2V0UHJ2KHtcbiAgICAgICAgcHJ2OiBwYXJhbXMucHJ2LFxuICAgICAgICB3YWxsZXRQYXNzcGhyYXNlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBVdGlsLmV0aFNpZ25Nc2dIYXNoKG9wZXJhdGlvbkhhc2gsIFV0aWwueHBydlRvRXRoUHJpdmF0ZUtleSh1c2VyUHJ2KSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogUmVjb3ZlclRva2VuVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgICAgICByZWNpcGllbnQ6IHJlY2lwaWVudCxcbiAgICAgICAgICBleHBpcmVUaW1lOiBleHBpcmVUaW1lLFxuICAgICAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogc2FmZVNlcXVlbmNlSWQsXG4gICAgICAgICAgb3BlcmF0aW9uSGFzaDogb3BlcmF0aW9uSGFzaCxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgICBnYXNMaW1pdDogZ2FzTGltaXQsXG4gICAgICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlLFxuICAgICAgICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgd2FsbGV0SWQ6IHBhcmFtcy53YWxsZXQuaWQoKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYXJndW1lbnRzIHRvIGNhbGwgdGhlIHNlbmQgbWV0aG9kIG9uIHRoZSB3YWxsZXQgY29udHJhY3RcbiAgICogQHBhcmFtIHR4SW5mb1xuICAgKi9cbiAgZ2V0U2VuZE1ldGhvZEFyZ3ModHhJbmZvOiBHZXRTZW5kTWV0aG9kQXJnc09wdGlvbnMpOiBTZW5kTWV0aG9kQXJnc1tdIHtcbiAgICAvLyBNZXRob2Qgc2lnbmF0dXJlIGlzXG4gICAgLy8gc2VuZE11bHRpU2lnKGFkZHJlc3MgdG9BZGRyZXNzLCB1aW50IHZhbHVlLCBieXRlcyBkYXRhLCB1aW50IGV4cGlyZVRpbWUsIHVpbnQgc2VxdWVuY2VJZCwgYnl0ZXMgc2lnbmF0dXJlKVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b0FkZHJlc3MnLFxuICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgIHZhbHVlOiB0eEluZm8ucmVjaXBpZW50LmFkZHJlc3MsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgICB0eXBlOiAndWludCcsXG4gICAgICAgIHZhbHVlOiB0eEluZm8ucmVjaXBpZW50LmFtb3VudCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgdmFsdWU6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLnRvQnVmZmVyKHR4SW5mby5yZWNpcGllbnQuZGF0YSB8fCAnJyksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnZXhwaXJlVGltZScsXG4gICAgICAgIHR5cGU6ICd1aW50JyxcbiAgICAgICAgdmFsdWU6IHR4SW5mby5leHBpcmVUaW1lLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3NlcXVlbmNlSWQnLFxuICAgICAgICB0eXBlOiAndWludCcsXG4gICAgICAgIHZhbHVlOiB0eEluZm8uY29udHJhY3RTZXF1ZW5jZUlkLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3NpZ25hdHVyZScsXG4gICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgIHZhbHVlOiBvcHRpb25hbERlcHMuZXRoVXRpbC50b0J1ZmZlcih0eEluZm8uc2lnbmF0dXJlKSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcXVlcnkgdG8gRXRoZXJzY2FuIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gICAqIEBwYXJhbSBxdWVyeSB7T2JqZWN0fSBrZXktdmFsdWUgcGFpcnMgb2YgcGFyYW1ldGVycyB0byBhcHBlbmQgYWZ0ZXIgL2FwaVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gcmVzcG9uc2UgZnJvbSBFdGhlcnNjYW5cbiAgICovXG4gIHJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkocXVlcnk6IGFueSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RcbiAgICAgICAgLmdldChjb21tb24uRW52aXJvbm1lbnRzW3NlbGYuYml0Z28uZ2V0RW52KCldLmV0aGVyc2NhbkJhc2VVcmwgKyAnL2FwaScpXG4gICAgICAgIC5xdWVyeShxdWVyeSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhY2ggRXRoZXJzY2FuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBleHRyYSBwYXJhbWV0ZXJzIG5lZWRlZCB0byBidWlsZCBhIGhvcCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMgVGhlIG9yaWdpbmFsIGJ1aWxkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIGV4dHJhIHBhcmFtZXRlcnMgb2JqZWN0IHRvIG1lcmdlIHdpdGggdGhlIG9yaWdpbmFsIGJ1aWxkIHBhcmFtZXRlcnMgb2JqZWN0IGFuZCBzZW5kIHRvIHRoZSBwbGF0Zm9ybVxuICAgKi9cbiAgY3JlYXRlSG9wVHJhbnNhY3Rpb25QYXJhbXMoXG4gICAgYnVpbGRQYXJhbXM6IEhvcFRyYW5zYWN0aW9uQnVpbGRPcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEhvcFBhcmFtcz5cbiAgKTogQmx1ZWJpcmQ8SG9wUGFyYW1zPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEhvcFBhcmFtcz4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3Qgd2FsbGV0ID0gYnVpbGRQYXJhbXMud2FsbGV0O1xuICAgICAgY29uc3QgcmVjaXBpZW50cyA9IGJ1aWxkUGFyYW1zLnJlY2lwaWVudHM7XG4gICAgICBjb25zdCB3YWxsZXRQYXNzcGhyYXNlID0gYnVpbGRQYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcblxuICAgICAgY29uc3QgdXNlcktleWNoYWluID0geWllbGQgc2VsZi5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpWzBdIH0pO1xuICAgICAgY29uc3QgdXNlclBydiA9IHdhbGxldC5nZXRVc2VyUHJ2KHsga2V5Y2hhaW46IHVzZXJLZXljaGFpbiwgd2FsbGV0UGFzc3BocmFzZSB9KTtcbiAgICAgIGNvbnN0IHVzZXJQcnZCdWZmZXIgPSB1dHhvTGliLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJQcnYpXG4gICAgICAgIC5nZXRLZXkoKVxuICAgICAgICAuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuICAgICAgaWYgKCFyZWNpcGllbnRzIHx8ICFBcnJheS5pc0FycmF5KHJlY2lwaWVudHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGFycmF5IG9mIHJlY2lwaWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmlnaHQgbm93IHdlIG9ubHkgc3VwcG9ydCAxIHJlY2lwaWVudFxuICAgICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzZW5kIHRvIGV4YWN0bHkgMSByZWNpcGllbnQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlY2lwaWVudEFkZHJlc3MgPSByZWNpcGllbnRzWzBdLmFkZHJlc3M7XG4gICAgICBjb25zdCByZWNpcGllbnRBbW91bnQgPSByZWNpcGllbnRzWzBdLmFtb3VudDtcbiAgICAgIGNvbnN0IGZlZUVzdGltYXRlUGFyYW1zID0ge1xuICAgICAgICByZWNpcGllbnQ6IHJlY2lwaWVudEFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogcmVjaXBpZW50QW1vdW50LFxuICAgICAgICBob3A6IHRydWUsXG4gICAgICB9O1xuICAgICAgY29uc3QgZmVlRXN0aW1hdGU6IEZlZUVzdGltYXRlID0geWllbGQgc2VsZi5mZWVFc3RpbWF0ZShmZWVFc3RpbWF0ZVBhcmFtcyk7XG5cbiAgICAgIGNvbnN0IGdhc0xpbWl0ID0gZmVlRXN0aW1hdGUuZ2FzTGltaXRFc3RpbWF0ZTtcbiAgICAgIGNvbnN0IGdhc1ByaWNlID0gTWF0aC5yb3VuZChmZWVFc3RpbWF0ZS5mZWVFc3RpbWF0ZSAvIGdhc0xpbWl0KTtcbiAgICAgIGNvbnN0IGdhc1ByaWNlTWF4ID0gZ2FzUHJpY2UgKiA1O1xuICAgICAgLy8gUGF5bWVudCBpZCBhIHJhbmRvbSBudW1iZXIgc28gaXRzIGRpZmZlcmVudCBmb3IgZXZlcnkgdHhcbiAgICAgIGNvbnN0IHBheW1lbnRJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgaG9wRGlnZXN0OiBCdWZmZXIgPSBFdGguZ2V0SG9wRGlnZXN0KFtcbiAgICAgICAgcmVjaXBpZW50QWRkcmVzcyxcbiAgICAgICAgcmVjaXBpZW50QW1vdW50LFxuICAgICAgICBnYXNQcmljZU1heC50b1N0cmluZygpLFxuICAgICAgICBnYXNMaW1pdC50b1N0cmluZygpLFxuICAgICAgICBwYXltZW50SWQsXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgdXNlclJlcVNpZyA9IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmFkZEhleFByZWZpeChcbiAgICAgICAgc2VjcDI1NmsxLnNpZ24oaG9wRGlnZXN0LCB1c2VyUHJ2QnVmZmVyKS5zaWduYXR1cmUudG9TdHJpbmcoJ2hleCcpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHQ6IEhvcFBhcmFtcyA9IHtcbiAgICAgICAgaG9wUGFyYW1zOiB7XG4gICAgICAgICAgZ2FzUHJpY2VNYXgsXG4gICAgICAgICAgdXNlclJlcVNpZyxcbiAgICAgICAgICBwYXltZW50SWQsXG4gICAgICAgIH0sXG4gICAgICAgIGdhc0xpbWl0LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgaG9wIHByZWJ1aWxkIGZyb20gdGhlIEhTTSBpcyB2YWxpZCBhbmQgY29ycmVjdFxuICAgKiBAcGFyYW0gd2FsbGV0IFRoZSB3YWxsZXQgdGhhdCB0aGUgcHJlYnVpbGQgaXMgZm9yXG4gICAqIEBwYXJhbSBob3BQcmVidWlsZCBUaGUgcHJlYnVpbGQgdG8gdmFsaWRhdGVcbiAgICogQHBhcmFtIG9yaWdpbmFsUGFyYW1zIFRoZSBvcmlnaW5hbCBwYXJhbWV0ZXJzIHBhc3NlZCB0byBwcmVidWlsZFRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgVGhlIHByZWJ1aWxkIGlzIGludmFsaWRcbiAgICovXG4gIHZhbGlkYXRlSG9wUHJlYnVpbGQoXG4gICAgd2FsbGV0OiBXYWxsZXQsXG4gICAgaG9wUHJlYnVpbGQ6IEhvcFByZWJ1aWxkLFxuICAgIG9yaWdpbmFsUGFyYW1zPzogeyByZWNpcGllbnRzOiBSZWNpcGllbnRbXSB9LFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHZvaWQ+XG4gICk6IEJsdWViaXJkPHZvaWQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288dm9pZD4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgeyB0eCwgaWQsIHNpZ25hdHVyZSB9ID0gaG9wUHJlYnVpbGQ7XG5cbiAgICAgIC8vIGZpcnN0LCB2YWxpZGF0ZSB0aGUgSFNNIHNpZ25hdHVyZVxuICAgICAgY29uc3Qgc2VydmVyWHB1YiA9IGNvbW1vbi5FbnZpcm9ubWVudHNbc2VsZi5iaXRnby5nZXRFbnYoKV0uaHNtWHB1YjtcbiAgICAgIGNvbnN0IHNlcnZlclB1YmtleUJ1ZmZlcjogQnVmZmVyID0gdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChzZXJ2ZXJYcHViKS5nZXRQdWJsaWNLZXlCdWZmZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlcjogQnVmZmVyID0gQnVmZmVyLmZyb20ob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoc2lnbmF0dXJlKSwgJ2hleCcpO1xuICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlcjogQnVmZmVyID0gQnVmZmVyLmZyb20ob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoaWQpLCAnaGV4Jyk7XG5cbiAgICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmU6IGJvb2xlYW4gPSBzZWNwMjU2azEudmVyaWZ5KG1lc3NhZ2VCdWZmZXIsIHNpZ25hdHVyZUJ1ZmZlci5zbGljZSgxKSwgc2VydmVyUHVia2V5QnVmZmVyKTtcbiAgICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvcCB0eGlkIHNpZ25hdHVyZSBpbnZhbGlkYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1aWx0SG9wVHggPSBuZXcgb3B0aW9uYWxEZXBzLkV0aFR4KHR4KTtcbiAgICAgIC8vIElmIG9yaWdpbmFsIHBhcmFtcyBhcmUgZ2l2ZW4sIHdlIGNhbiBjaGVjayB0aGVtIGFnYWluc3QgdGhlIHRyYW5zYWN0aW9uIHByZWJ1aWxkIHBhcmFtc1xuICAgICAgaWYgKCFfLmlzTmlsKG9yaWdpbmFsUGFyYW1zKSkge1xuICAgICAgICBjb25zdCB7IHJlY2lwaWVudHMgfSA9IG9yaWdpbmFsUGFyYW1zO1xuXG4gICAgICAgIC8vIFRoZW4gdmFsaWRhdGUgdGhhdCB0aGUgdHggcGFyYW1zIGFjdHVhbGx5IGVxdWFsIHRoZSByZXF1ZXN0ZWQgcGFyYW1zXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnRzWzBdLmFtb3VudCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGVzdGluYXRpb246IHN0cmluZyA9IHJlY2lwaWVudHNbMF0uYWRkcmVzcztcblxuICAgICAgICBjb25zdCBob3BBbW91bnQgPSBuZXcgQmlnTnVtYmVyKG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSGV4KGJ1aWx0SG9wVHgudmFsdWUpKTtcbiAgICAgICAgY29uc3QgaG9wRGVzdGluYXRpb246IHN0cmluZyA9IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSGV4KGJ1aWx0SG9wVHgudG8pO1xuICAgICAgICBpZiAoIWhvcEFtb3VudC5lcShvcmlnaW5hbEFtb3VudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvcCBhbW91bnQ6ICR7aG9wQW1vdW50fSBkb2VzIG5vdCBlcXVhbCBvcmlnaW5hbCBhbW91bnQ6ICR7b3JpZ2luYWxBbW91bnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvcERlc3RpbmF0aW9uLnRvTG93ZXJDYXNlKCkgIT09IG9yaWdpbmFsRGVzdGluYXRpb24udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSG9wIGRlc3RpbmF0aW9uOiAke2hvcERlc3RpbmF0aW9ufSBkb2VzIG5vdCBlcXVhbCBvcmlnaW5hbCByZWNpcGllbnQ6ICR7aG9wRGVzdGluYXRpb259YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFidWlsdEhvcFR4LnZlcmlmeVNpZ25hdHVyZSgpKSB7XG4gICAgICAgIC8vIFdlIGRvbnQgd2FudCB0byBjb250aW51ZSBhdCBhbGwgaW4gdGhpcyBjYXNlLCBhdCByaXNrIG9mIEVUSCBiZWluZyBzdHVjayBvbiB0aGUgaG9wIGFkZHJlc3NcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhvcCB0cmFuc2FjdGlvbiBzaWduYXR1cmUsIHR4aWQ6ICR7aWR9YCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KGJ1aWx0SG9wVHguaGFzaCgpLnRvU3RyaW5nKCdoZXgnKSkgIT09IGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnbmVkIGhvcCB0eGlkIGRvZXMgbm90IGVxdWFsIGFjdHVhbCB0eGlkYCk7XG4gICAgICB9XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaG9wIGRpZ2VzdCBmb3IgdGhlIHVzZXIgdG8gc2lnbi4gVGhpcyBpcyB2YWxpZGF0ZWQgaW4gdGhlIEhTTSB0byBwcm92ZSB0aGF0IHRoZSB1c2VyIHJlcXVlc3RlZCB0aGlzIHR4XG4gICAqIEBwYXJhbSBwYXJhbXNBcnIgVGhlIHBhcmFtZXRlcnMgdG8gaGFzaCB0b2dldGhlciBmb3IgdGhlIGRpZ2VzdFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0SG9wRGlnZXN0KHBhcmFtc0Fycjogc3RyaW5nW10pOiBCdWZmZXIge1xuICAgIGNvbnN0IGhhc2ggPSBuZXcgS2VjY2FrKCdrZWNjYWsyNTYnKTtcbiAgICBoYXNoLnVwZGF0ZShbRXRoLmhvcFRyYW5zYWN0aW9uU2FsdCwgLi4ucGFyYW1zQXJyXS5qb2luKCckJykpO1xuICAgIHJldHVybiBoYXNoLmRpZ2VzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSBwcmVidWlsZCBiZWZvcmUgc2VuZGluZyBpdCB0byB0aGUgc2VydmVyLiBBZGQgdGhpbmdzIGxpa2UgaG9wIHRyYW5zYWN0aW9uIHBhcmFtc1xuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMgVGhlIHdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgZm9yIHRoaXMgcHJlYnVpbGRcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zLmhvcCBUcnVlIGlmIHRoaXMgc2hvdWxkIHByZWJ1aWxkIGEgaG9wIHR4LCBlbHNlIGZhbHNlXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy5yZWNpcGllbnRzIFRoZSByZWNpcGllbnRzIGFycmF5IG9mIHRoaXMgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zLndhbGxldCBUaGUgd2FsbGV0IHNlbmRpbmcgdGhpcyB0eFxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMud2FsbGV0UGFzc3BocmFzZSB0aGUgcGFzc3BocmFzZSBmb3IgdGhpcyB3YWxsZXRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRFeHRyYVByZWJ1aWxkUGFyYW1zKGJ1aWxkUGFyYW1zOiBCdWlsZE9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJ1aWxkT3B0aW9ucz4pOiBCbHVlYmlyZDxCdWlsZE9wdGlvbnM+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288QnVpbGRPcHRpb25zPihmdW5jdGlvbiooKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKGJ1aWxkUGFyYW1zLmhvcCkgJiZcbiAgICAgICAgYnVpbGRQYXJhbXMuaG9wICYmXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKGJ1aWxkUGFyYW1zLndhbGxldCkgJiZcbiAgICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMucmVjaXBpZW50cykgJiZcbiAgICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMud2FsbGV0UGFzc3BocmFzZSlcbiAgICAgICkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEVyYzIwVG9rZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSG9wIHRyYW5zYWN0aW9ucyBhcmUgbm90IGVuYWJsZWQgZm9yIEVSQy0yMCB0b2tlbnMsIG5vciBhcmUgdGhleSBuZWNlc3NhcnkuIFBsZWFzZSByZW1vdmUgdGhlICdob3AnIHBhcmFtZXRlciBhbmQgdHJ5IGFnYWluLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5aWVsZCBzZWxmLmNyZWF0ZUhvcFRyYW5zYWN0aW9uUGFyYW1zKHtcbiAgICAgICAgICB3YWxsZXQ6IGJ1aWxkUGFyYW1zLndhbGxldCxcbiAgICAgICAgICByZWNpcGllbnRzOiBidWlsZFBhcmFtcy5yZWNpcGllbnRzLFxuICAgICAgICAgIHdhbGxldFBhc3NwaHJhc2U6IGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSBwcmVidWlsZCBhZnRlciByZWNlaXZpbmcgaXQgZnJvbSB0aGUgc2VydmVyLiBBZGQgdGhpbmdzIGxpa2UgbmxvY2t0aW1lXG4gICAqL1xuICBwb3N0UHJvY2Vzc1ByZWJ1aWxkKFxuICAgIHBhcmFtczogVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvblByZWJ1aWxkPlxuICApOiBCbHVlYmlyZDxUcmFuc2FjdGlvblByZWJ1aWxkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFRyYW5zYWN0aW9uUHJlYnVpbGQ+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIV8uaXNVbmRlZmluZWQocGFyYW1zLmhvcFRyYW5zYWN0aW9uKSAmJlxuICAgICAgICAhXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0KSAmJlxuICAgICAgICAhXy5pc1VuZGVmaW5lZChwYXJhbXMuYnVpbGRQYXJhbXMpXG4gICAgICApIHtcbiAgICAgICAgeWllbGQgc2VsZi52YWxpZGF0ZUhvcFByZWJ1aWxkKHBhcmFtcy53YWxsZXQsIHBhcmFtcy5ob3BUcmFuc2FjdGlvbiwgcGFyYW1zLmJ1aWxkUGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ29pbi1zcGVjaWZpYyB0aGluZ3MgZG9uZSBiZWZvcmUgc2lnbmluZyBhIHRyYW5zYWN0aW9uLCBpLmUuIHZlcmlmaWNhdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHJlc2lnblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvblByZWJ1aWxkPlxuICApOiBCbHVlYmlyZDxUcmFuc2FjdGlvblByZWJ1aWxkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFRyYW5zYWN0aW9uUHJlYnVpbGQ+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIV8uaXNVbmRlZmluZWQocGFyYW1zLmhvcFRyYW5zYWN0aW9uKSAmJlxuICAgICAgICAhXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0KSAmJlxuICAgICAgICAhXy5pc1VuZGVmaW5lZChwYXJhbXMuYnVpbGRQYXJhbXMpXG4gICAgICApIHtcbiAgICAgICAgeWllbGQgc2VsZi52YWxpZGF0ZUhvcFByZWJ1aWxkKHBhcmFtcy53YWxsZXQsIHBhcmFtcy5ob3BUcmFuc2FjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGZlZSBlc3RpbWF0ZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1zIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuaG9wXSBUcnVlIGlmIHdlIHNob3VsZCBlc3RpbWF0ZSBmZWUgZm9yIGEgaG9wIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnJlY2lwaWVudF0gVGhlIHJlY2lwaWVudCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gZXN0aW1hdGUgYSBzZW5kIHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmRhdGFdIFRoZSBFVEggdHggZGF0YSB0byBlc3RpbWF0ZSBhIHNlbmQgZm9yXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZmVlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICBmZWVFc3RpbWF0ZShwYXJhbXM6IEZlZUVzdGltYXRlT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8RmVlRXN0aW1hdGU+KTogQmx1ZWJpcmQ8RmVlRXN0aW1hdGU+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288RmVlRXN0aW1hdGU+KGZ1bmN0aW9uKiBjb0ZlZUVzdGltYXRlKCkge1xuICAgICAgY29uc3QgcXVlcnk6IEZlZUVzdGltYXRlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuaG9wKSB7XG4gICAgICAgIHF1ZXJ5LmhvcCA9IHBhcmFtcy5ob3A7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5yZWNpcGllbnQpIHtcbiAgICAgICAgcXVlcnkucmVjaXBpZW50ID0gcGFyYW1zLnJlY2lwaWVudDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmRhdGEpIHtcbiAgICAgICAgcXVlcnkuZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuYW1vdW50KSB7XG4gICAgICAgIHF1ZXJ5LmFtb3VudCA9IHBhcmFtcy5hbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvXG4gICAgICAgIC5nZXQoc2VsZi51cmwoJy90eC9mZWUnKSlcbiAgICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgc2VjcDI1NmsxIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ6IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTZcbiAgICAgIC8vIGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmUgcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlXG4gICAgICAvLyBtYXhpbXVtIGVudHJvcHkgYW5kIGdpdmVzIHVzIG1heGltdW0gc2VjdXJpdHkgYWdhaW5zdCBjcmFja2luZy5cbiAgICAgIHNlZWQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gdXR4b0xpYi5IRE5vZGUuZnJvbVNlZWRCdWZmZXIoc2VlZCk7XG4gICAgY29uc3QgeHB1YiA9IGV4dGVuZGVkS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiB4cHViLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBwYXJzZVRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UGFyc2VkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe30pLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Ym9vbGVhbj4pOiBCbHVlYmlyZDxib29sZWFuPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUodHJ1ZSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cbn1cbiJdfQ==