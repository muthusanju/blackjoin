"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var crypto = require("crypto");
var co = Bluebird.coroutine;
var bitgoAccountLib = require("@bitgo/account-lib");
var bitgo_utxo_lib_1 = require("bitgo-utxo-lib");
var request = require("superagent");
var common = require("../../common");
var baseCoin_1 = require("../baseCoin");
exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = 1e6;
var NodeTypes;
(function (NodeTypes) {
    NodeTypes[NodeTypes["Full"] = 0] = "Full";
    NodeTypes[NodeTypes["Solidity"] = 1] = "Solidity";
})(NodeTypes = exports.NodeTypes || (exports.NodeTypes = {}));
var Trx = /** @class */ (function (_super) {
    __extends(Trx, _super);
    function Trx(bitgo, staticsCoin) {
        var _this = _super.call(this, bitgo) || this;
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        _this._staticsCoin = staticsCoin;
        return _this;
    }
    Trx.prototype.getChain = function () {
        return this._staticsCoin.name;
    };
    Trx.prototype.getFamily = function () {
        return this._staticsCoin.family;
    };
    Trx.prototype.getFullName = function () {
        return this._staticsCoin.fullName;
    };
    Trx.prototype.getBaseFactor = function () {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    };
    Trx.createInstance = function (bitgo, staticsCoin) {
        return new Trx(bitgo, staticsCoin);
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Trx.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    Trx.prototype.isValidAddress = function (address) {
        if (!address) {
            return false;
        }
        return this.isValidHexAddress(address) || bitgoAccountLib.Trx.Utils.isBase58Address(address);
    };
    /**
     * Checks if this is a valid hex address
     * @param address hex address
     */
    Trx.prototype.isValidHexAddress = function (address) {
        return address.length === 42 && /^(0x)?([0-9a-f]{2})+$/i.test(address);
    };
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    Trx.prototype.generateKeyPair = function (seed) {
        // TODO: move this and address creation logic to account-lib
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256 bit chain code, both of which must be
            // random. 512 bits is therefore the maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var hd = bitgo_utxo_lib_1.HDNode.fromSeedBuffer(seed);
        return {
            pub: hd.neutered().toBase58(),
            prv: hd.toBase58(),
        };
    };
    Trx.prototype.isValidXpub = function (xpub) {
        try {
            return bitgo_utxo_lib_1.HDNode.fromBase58(xpub).isNeutered();
        }
        catch (e) {
            return false;
        }
    };
    Trx.prototype.isValidPub = function (pub) {
        if (this.isValidXpub(pub)) {
            // xpubs can be converted into regular pubs, so technically it is a valid pub
            return true;
        }
        return new RegExp('^04[a-zA-Z0-9]{128}$').test(pub);
    };
    Trx.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Trx.prototype.verifyAddress = function (params) {
        return true;
    };
    Trx.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    Trx.prototype.signTransaction = function (params) {
        var coinName = this.getChain();
        var txBuilder = new bitgoAccountLib.TransactionBuilder({ coinName: coinName });
        txBuilder.from(params.txPrebuild.txHex);
        var key = params.prv;
        if (this.isValidXprv(params.prv)) {
            key = bitgo_utxo_lib_1.HDNode.fromBase58(params.prv)
                .getKey()
                .getPrivateKeyBuffer();
        }
        txBuilder.sign({ key: key });
        var transaction = txBuilder.build();
        var response = {
            txHex: JSON.stringify(transaction.toJson()),
        };
        if (transaction.toJson().signature.length >= 2) {
            return response;
        }
        // Half signed transaction
        return {
            halfSigned: response,
        };
    };
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    Trx.prototype.isValidXprv = function (prv) {
        try {
            bitgo_utxo_lib_1.HDNode.fromBase58(prv);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Convert a message to string in hexadecimal format.
     *
     * @param message {Buffer|String} message to sign
     * @return the message as a hexadecimal string
     */
    Trx.prototype.toHexString = function (message) {
        if (typeof message === 'string') {
            return Buffer.from(message).toString('hex');
        }
        else if (Buffer.isBuffer(message)) {
            return message.toString('hex');
        }
        else {
            throw new Error('Invalid messaged passed to signMessage');
        }
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    Trx.prototype.signMessage = function (key, message) {
        var toSign = this.toHexString(message);
        var prv = key.prv;
        if (this.isValidXprv(prv)) {
            prv = bitgo_utxo_lib_1.HDNode.fromBase58(prv)
                .getKey()
                .getPrivateKeyBuffer();
        }
        var sig = bitgoAccountLib.Trx.Utils.signString(toSign, prv, true);
        // remove the preceding 0x
        sig = sig.replace(/^0x/, '');
        return Buffer.from(sig, 'hex');
    };
    /**
     * Converts an xpub to a compressed pub
     * @param xpub
     */
    Trx.prototype.xpubToCompressedPub = function (xpub) {
        if (!this.isValidXpub(xpub)) {
            throw new Error('invalid xpub');
        }
        var hdNode = bitgo_utxo_lib_1.HDNode.fromBase58(xpub, bitgo_utxo_lib_1.networks.bitcoin);
        return hdNode.keyPair.__Q.getEncoded(false).toString('hex');
    };
    Trx.prototype.compressedPubToHexAddress = function (pub) {
        var byteArrayAddr = bitgoAccountLib.Trx.Utils.getByteArrayFromHexAddress(pub);
        var rawAddress = bitgoAccountLib.Trx.Utils.getRawAddressFromPubKey(byteArrayAddr);
        return bitgoAccountLib.Trx.Utils.getHexAddressFromByteArray(rawAddress);
    };
    Trx.prototype.xprvToCompressedPrv = function (xprv) {
        if (!this.isValidXprv(xprv)) {
            throw new Error('invalid xprv');
        }
        var hdNode = bitgo_utxo_lib_1.HDNode.fromBase58(xprv, bitgo_utxo_lib_1.networks.bitcoin);
        return hdNode.keyPair.d.toBuffer(32).toString('hex');
    };
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @param callback
     * @returns {Object} response from Trongrid
     */
    Trx.prototype.recoveryPost = function (query, callback) {
        var self = this;
        return co(function () {
            var nodeUri, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nodeUri = '';
                        switch (query.node) {
                            case NodeTypes.Full:
                                nodeUri = common.Environments[self.bitgo.getEnv()].tronNodes.full;
                                break;
                            case NodeTypes.Solidity:
                                nodeUri = common.Environments[self.bitgo.getEnv()].tronNodes.solidity;
                                break;
                            default:
                                throw new Error('node type not found');
                        }
                        return [4 /*yield*/, request
                                .post(nodeUri + query.path)
                                .type('json')
                                .send(query.jsonObj)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) {
                            throw new Error('could not reach Tron node');
                        }
                        // unfortunately, it doesn't look like most TRON nodes return valid json as body
                        return [2 /*return*/, JSON.parse(response.text)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Query our explorer for the balance of an address
     * @param address {String} the address encoded in hex
     * @param callback
     * @returns {BigNumber} address balance
     */
    Trx.prototype.getAccountFromNode = function (address, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryPost({
                            path: '/walletsolidity/getaccount',
                            jsonObj: { address: address },
                            node: NodeTypes.Solidity,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     * @param callback
     */
    Trx.prototype.getBuildTransaction = function (toAddr, fromAddr, amount, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryPost({
                            path: '/wallet/createtransaction',
                            jsonObj: {
                                to_address: toAddr,
                                owner_address: fromAddr,
                                amount: amount,
                            },
                            node: NodeTypes.Full,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Throws an error if any keys in the ownerKeys collection don't match the keys array we pass
     * @param ownerKeys
     * @param keysToFind
     */
    Trx.prototype.checkPermissions = function (ownerKeys, keys) {
        keys = keys.map(function (k) { return k.toUpperCase(); });
        ownerKeys.map(function (key) {
            var hexKey = key.address.toUpperCase();
            if (!keys.includes(hexKey)) {
                throw new Error("pub address " + hexKey + " not found in account");
            }
            if (key.weight !== 1) {
                throw new Error('owner permission is invalid for this structure');
            }
        });
    };
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     * @param callback
     */
    Trx.prototype.recover = function (params, callback) {
        var self = this;
        return co(function () {
            var isKrsRecovery, isUnsignedSweep, keys, bitgoHexAddr, recoveryAddressHex, account, recoveryAmount, userXPub, userXPrv, backupXPub, recoveryAmountMinusFees, buildTx, keyHexAddresses, txBuilder, userPrv, backupXPrv, backupPrv;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        keys = _a.sent();
                        bitgoHexAddr = self.compressedPubToHexAddress(self.xpubToCompressedPub(params.bitgoKey));
                        recoveryAddressHex = bitgoAccountLib.Trx.Utils.getHexAddressFromBase58Address(params.recoveryDestination);
                        return [4 /*yield*/, self.getAccountFromNode(bitgoHexAddr)];
                    case 2:
                        account = _a.sent();
                        recoveryAmount = account.balance;
                        userXPub = keys[0].neutered().toBase58();
                        userXPrv = keys[0].toBase58();
                        backupXPub = keys[1].neutered().toBase58();
                        // construct the tx -
                        // there's an assumption here being made about fees: for a wallet that hasn't been used in awhile, the implication is
                        // it has maximum bandwidth. thus, a recovery should cost the minimum amount (1e6 sun or 1 Tron)
                        if (exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE > recoveryAmount) {
                            throw new Error('Amount of funds to recover wouldnt be able to fund a send');
                        }
                        recoveryAmountMinusFees = recoveryAmount - exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE;
                        return [4 /*yield*/, self.getBuildTransaction(recoveryAddressHex, bitgoHexAddr, recoveryAmountMinusFees)];
                    case 3:
                        buildTx = _a.sent();
                        keyHexAddresses = [
                            self.compressedPubToHexAddress(self.xpubToCompressedPub(userXPub)),
                            self.compressedPubToHexAddress(self.xpubToCompressedPub(backupXPub)),
                            bitgoHexAddr,
                        ];
                        // run checks to ensure this is a valid tx - permissions match our signer keys
                        self.checkPermissions(account.owner_permission.keys, keyHexAddresses);
                        self.checkPermissions(account.active_permission[0].keys, keyHexAddresses);
                        txBuilder = new bitgoAccountLib.TransactionBuilder({ coinName: this.getChain() });
                        txBuilder.from(buildTx);
                        // this tx should be enough to drop into a node
                        if (isUnsignedSweep) {
                            return [2 /*return*/, {
                                    tx: txBuilder.build().toJson(),
                                    recoveryAmount: recoveryAmountMinusFees,
                                }];
                        }
                        userPrv = self.xprvToCompressedPrv(userXPrv);
                        txBuilder.sign({ key: userPrv });
                        // krs recoveries don't get signed
                        if (!isKrsRecovery) {
                            backupXPrv = keys[1].toBase58();
                            backupPrv = self.xprvToCompressedPrv(backupXPrv);
                            txBuilder.sign({ key: backupPrv });
                        }
                        return [2 /*return*/, {
                                tx: txBuilder.build().toJson(),
                                recoveryAmount: recoveryAmountMinusFees,
                            }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Explain a Tron transaction from txHex
     * @param params
     * @param callback
     */
    Trx.prototype.explainTransaction = function (params, callback) {
        return co(function () {
            var txHex, coinName, txBuilder, tx, outputs, displayOrder, explanationResult;
            return __generator(this, function (_a) {
                txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                if (!txHex || !params.feeInfo) {
                    throw new Error('missing explain tx parameters');
                }
                coinName = this.getChain();
                txBuilder = new bitgoAccountLib.TransactionBuilder({ coinName: coinName });
                txBuilder.from(txHex);
                tx = txBuilder.build();
                outputs = [
                    {
                        amount: tx.destinations[0].value.toString(),
                        address: tx.destinations[0].address,
                    },
                ];
                displayOrder = [
                    'id',
                    'outputAmount',
                    'changeAmount',
                    'outputs',
                    'changeOutputs',
                    'fee',
                    'timestamp',
                    'expiration',
                ];
                explanationResult = {
                    displayOrder: displayOrder,
                    id: tx.id,
                    outputs: outputs,
                    outputAmount: outputs[0].amount,
                    changeOutputs: [],
                    changeAmount: '0',
                    fee: params.feeInfo,
                    timestamp: tx.validFrom,
                    expiration: tx.validTo,
                };
                return [2 /*return*/, explanationResult];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return Trx;
}(baseCoin_1.BaseCoin));
exports.Trx = Trx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3RyeC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILG1DQUFxQztBQUNyQywrQkFBaUM7QUFFakMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUM5QixvREFBc0Q7QUFDdEQsaURBQWtEO0FBQ2xELG9DQUFzQztBQUN0QyxxQ0FBdUM7QUFFdkMsd0NBYXFCO0FBS1IsUUFBQSxpQ0FBaUMsR0FBRyxHQUFHLENBQUM7QUE4Q3JELElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNuQix5Q0FBSSxDQUFBO0lBQ0osaURBQVEsQ0FBQTtBQUNWLENBQUMsRUFIVyxTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQUdwQjtBQWNEO0lBQXlCLHVCQUFRO0lBRy9CLGFBQVksS0FBWSxFQUFFLFdBQXVDO1FBQWpFLFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBT2I7UUFMQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELEtBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDOztJQUNsQyxDQUFDO0lBRUQsc0JBQVEsR0FBUjtRQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELHVCQUFTLEdBQVQ7UUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFFRCx5QkFBVyxHQUFYO1FBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBRUQsMkJBQWEsR0FBYjtRQUNFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFB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ICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgQ29pbkZhbWlseSwgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5pbXBvcnQgKiBhcyBiaXRnb0FjY291bnRMaWIgZnJvbSAnQGJpdGdvL2FjY291bnQtbGliJztcbmltcG9ydCB7IEhETm9kZSwgbmV0d29ya3MgfSBmcm9tICdiaXRnby11dHhvLWxpYic7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4uLy4uL2NvbW1vbic7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkZlZSxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgUmVjaXBpZW50LFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgTUlOSU1VTV9UUk9OX01TSUdfVFJBTlNBQ1RJT05fRkVFID0gMWU2O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyb25TaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR4SW5mbyB7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICBmcm9tOiBzdHJpbmc7XG4gIHR4aWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBleHRlbmRzIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBleHBpcmF0aW9uOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIHR4SW5mbzogVHhJbmZvO1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7IC8vIHR4SGV4IGlzIHBvb3JseSBuYW1lZCBoZXJlOyBpdCBpcyBqdXN0IGEgd3JhcHBlZCBKU09OIG9iamVjdFxuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7IC8vIHR4SGV4IGlzIHBvb3JseSBuYW1lZCBoZXJlOyBpdCBpcyBqdXN0IGEgd3JhcHBlZCBKU09OIG9iamVjdFxuICB9O1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMge1xuICB1c2VyS2V5OiBzdHJpbmc7IC8vIEJveCBBXG4gIGJhY2t1cEtleTogc3RyaW5nOyAvLyBCb3ggQlxuICBiaXRnb0tleTogc3RyaW5nOyAvLyBCb3ggQyAtIHRoaXMgaXMgYml0Z28ncyB4cHViIGFuZCB3aWxsIGJlIHVzZWQgdG8gZGVyaXZlIHRoZWlyIHJvb3QgYWRkcmVzc1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7IC8vIGJhc2U1OCBhZGRyZXNzXG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5VHJhbnNhY3Rpb24ge1xuICB0eDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcmVjb3ZlcnlBbW91bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gTm9kZVR5cGVzIHtcbiAgRnVsbCxcbiAgU29saWRpdHksXG59XG5cbi8qKlxuICogVGhpcyBzdHJ1Y3R1cmUgaXMgbm90IGEgY29tcGxldGUgbW9kZWwgb2YgdGhlIEFjY291bnRSZXNwb25zZSBmcm9tIGEgbm9kZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50UmVzcG9uc2Uge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGJhbGFuY2U6IG51bWJlcjtcbiAgb3duZXJfcGVybWlzc2lvbjoge1xuICAgIGtleXM6IFtiaXRnb0FjY291bnRMaWIuVHJ4LkludGVyZmFjZS5QZXJtaXNzaW9uS2V5XTtcbiAgfTtcbiAgYWN0aXZlX3Blcm1pc3Npb246IFt7IGtleXM6IFtiaXRnb0FjY291bnRMaWIuVHJ4LkludGVyZmFjZS5QZXJtaXNzaW9uS2V5XSB9XTtcbn1cblxuZXhwb3J0IGNsYXNzIFRyeCBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcblxuICAgIGlmICghc3RhdGljc0NvaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc3RhdGljc0NvaW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0aWNzQ29pbiA9IHN0YXRpY3NDb2luO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLm5hbWU7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mdWxsTmFtZTtcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGF0aWNzQ29pbi5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28sIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFRyeChiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaXMgYSB2YWxpZCBiYXNlNTggb3IgaGV4IGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkSGV4QWRkcmVzcyhhZGRyZXNzKSB8fCBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmlzQmFzZTU4QWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpcyBhIHZhbGlkIGhleCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzIGhleCBhZGRyZXNzXG4gICAqL1xuICBpc1ZhbGlkSGV4QWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gYWRkcmVzcy5sZW5ndGggPT09IDQyICYmIC9eKDB4KT8oWzAtOWEtZl17Mn0pKyQvaS50ZXN0KGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGVkMjU1MTkga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiwgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIC8vIFRPRE86IG1vdmUgdGhpcyBhbmQgYWRkcmVzcyBjcmVhdGlvbiBsb2dpYyB0byBhY2NvdW50LWxpYlxuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTYgYml0IGNoYWluIGNvZGUsIGJvdGggb2Ygd2hpY2ggbXVzdCBiZVxuICAgICAgLy8gcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlIG1heGltdW0gZW50cm9weSBhbmQgZ2l2ZXMgdXMgbWF4aW11bSBzZWN1cml0eSBhZ2FpbnN0IGNyYWNraW5nLlxuICAgICAgc2VlZCA9IGNyeXB0by5yYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgaGQgPSBIRE5vZGUuZnJvbVNlZWRCdWZmZXIoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogaGQubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgcHJ2OiBoZC50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBpc1ZhbGlkWHB1Yih4cHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEhETm9kZS5mcm9tQmFzZTU4KHhwdWIpLmlzTmV1dGVyZWQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzVmFsaWRYcHViKHB1YikpIHtcbiAgICAgIC8vIHhwdWJzIGNhbiBiZSBjb252ZXJ0ZWQgaW50byByZWd1bGFyIHB1YnMsIHNvIHRlY2huaWNhbGx5IGl0IGlzIGEgdmFsaWQgcHViXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14wNFthLXpBLVowLTldezEyOH0kJykudGVzdChwdWIpO1xuICB9XG5cbiAgcGFyc2VUcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFBhcnNlZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHRydWUpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogVHJvblNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBTaWduZWRUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgY29pbk5hbWUgPSB0aGlzLmdldENoYWluKCk7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gbmV3IGJpdGdvQWNjb3VudExpYi5UcmFuc2FjdGlvbkJ1aWxkZXIoeyBjb2luTmFtZSB9KTtcbiAgICB0eEJ1aWxkZXIuZnJvbShwYXJhbXMudHhQcmVidWlsZC50eEhleCk7XG5cbiAgICBsZXQga2V5ID0gcGFyYW1zLnBydjtcbiAgICBpZiAodGhpcy5pc1ZhbGlkWHBydihwYXJhbXMucHJ2KSkge1xuICAgICAga2V5ID0gSEROb2RlLmZyb21CYXNlNTgocGFyYW1zLnBydilcbiAgICAgICAgLmdldEtleSgpXG4gICAgICAgIC5nZXRQcml2YXRlS2V5QnVmZmVyKCk7XG4gICAgfVxuXG4gICAgdHhCdWlsZGVyLnNpZ24oeyBrZXkgfSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgIHR4SGV4OiBKU09OLnN0cmluZ2lmeSh0cmFuc2FjdGlvbi50b0pzb24oKSksXG4gICAgfTtcbiAgICBpZiAodHJhbnNhY3Rpb24udG9Kc29uKCkuc2lnbmF0dXJlLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8vIEhhbGYgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbGZTaWduZWQ6IHJlc3BvbnNlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHNlZWQgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgLSB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICovXG4gIGlzVmFsaWRYcHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIEhETm9kZS5mcm9tQmFzZTU4KHBydik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBtZXNzYWdlIHRvIHN0cmluZyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIHtCdWZmZXJ8U3RyaW5nfSBtZXNzYWdlIHRvIHNpZ25cbiAgICogQHJldHVybiB0aGUgbWVzc2FnZSBhcyBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgKi9cbiAgdG9IZXhTdHJpbmcobWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZS50b1N0cmluZygnaGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlZCBwYXNzZWQgdG8gc2lnbk1lc3NhZ2UnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBCdWZmZXIge1xuICAgIGNvbnN0IHRvU2lnbiA9IHRoaXMudG9IZXhTdHJpbmcobWVzc2FnZSk7XG5cbiAgICBsZXQgcHJ2ID0ga2V5LnBydjtcbiAgICBpZiAodGhpcy5pc1ZhbGlkWHBydihwcnYpKSB7XG4gICAgICBwcnYgPSBIRE5vZGUuZnJvbUJhc2U1OChwcnYpXG4gICAgICAgIC5nZXRLZXkoKVxuICAgICAgICAuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuICAgIH1cblxuICAgIGxldCBzaWcgPSBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLnNpZ25TdHJpbmcodG9TaWduLCBwcnYsIHRydWUpO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBwcmVjZWRpbmcgMHhcbiAgICBzaWcgPSBzaWcucmVwbGFjZSgvXjB4LywgJycpO1xuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNpZywgJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIHhwdWIgdG8gYSBjb21wcmVzc2VkIHB1YlxuICAgKiBAcGFyYW0geHB1YlxuICAgKi9cbiAgeHB1YlRvQ29tcHJlc3NlZFB1Yih4cHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkWHB1Yih4cHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHhwdWInKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZE5vZGUgPSBIRE5vZGUuZnJvbUJhc2U1OCh4cHViLCBuZXR3b3Jrcy5iaXRjb2luKTtcbiAgICByZXR1cm4gaGROb2RlLmtleVBhaXIuX19RLmdldEVuY29kZWQoZmFsc2UpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIGNvbXByZXNzZWRQdWJUb0hleEFkZHJlc3MocHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJ5dGVBcnJheUFkZHIgPSBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKHB1Yik7XG4gICAgY29uc3QgcmF3QWRkcmVzcyA9IGJpdGdvQWNjb3VudExpYi5UcnguVXRpbHMuZ2V0UmF3QWRkcmVzc0Zyb21QdWJLZXkoYnl0ZUFycmF5QWRkcik7XG4gICAgcmV0dXJuIGJpdGdvQWNjb3VudExpYi5UcnguVXRpbHMuZ2V0SGV4QWRkcmVzc0Zyb21CeXRlQXJyYXkocmF3QWRkcmVzcyk7XG4gIH1cblxuICB4cHJ2VG9Db21wcmVzc2VkUHJ2KHhwcnY6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRYcHJ2KHhwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgeHBydicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhkTm9kZSA9IEhETm9kZS5mcm9tQmFzZTU4KHhwcnYsIG5ldHdvcmtzLmJpdGNvaW4pO1xuICAgIHJldHVybiBoZE5vZGUua2V5UGFpci5kLnRvQnVmZmVyKDMyKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHF1ZXJ5IHRvIFRyb25ncmlkIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gICAqIEBwYXJhbSBxdWVyeSB7T2JqZWN0fSBrZXktdmFsdWUgcGFpcnMgb2YgcGFyYW1ldGVycyB0byBhcHBlbmQgYWZ0ZXIgL2FwaVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gcmVzcG9uc2UgZnJvbSBUcm9uZ3JpZFxuICAgKi9cbiAgcHJpdmF0ZSByZWNvdmVyeVBvc3QoXG4gICAgcXVlcnk6IHsgcGF0aDogc3RyaW5nOyBqc29uT2JqOiBhbnk7IG5vZGU6IE5vZGVUeXBlcyB9LFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT5cbiAgKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGxldCBub2RlVXJpID0gJyc7XG4gICAgICBzd2l0Y2ggKHF1ZXJ5Lm5vZGUpIHtcbiAgICAgICAgY2FzZSBOb2RlVHlwZXMuRnVsbDpcbiAgICAgICAgICBub2RlVXJpID0gY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmJpdGdvLmdldEVudigpXS50cm9uTm9kZXMuZnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb2RlVHlwZXMuU29saWRpdHk6XG4gICAgICAgICAgbm9kZVVyaSA9IGNvbW1vbi5FbnZpcm9ubWVudHNbc2VsZi5iaXRnby5nZXRFbnYoKV0udHJvbk5vZGVzLnNvbGlkaXR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9kZSB0eXBlIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RcbiAgICAgICAgLnBvc3Qobm9kZVVyaSArIHF1ZXJ5LnBhdGgpXG4gICAgICAgIC50eXBlKCdqc29uJylcbiAgICAgICAgLnNlbmQocXVlcnkuanNvbk9iaik7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhY2ggVHJvbiBub2RlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVuZm9ydHVuYXRlbHksIGl0IGRvZXNuJ3QgbG9vayBsaWtlIG1vc3QgVFJPTiBub2RlcyByZXR1cm4gdmFsaWQganNvbiBhcyBib2R5XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS50ZXh0KTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBvdXIgZXhwbG9yZXIgZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIGFkZHJlc3MgZW5jb2RlZCBpbiBoZXhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IGFkZHJlc3MgYmFsYW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRBY2NvdW50RnJvbU5vZGUoYWRkcmVzczogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxBY2NvdW50UmVzcG9uc2U+KTogQmx1ZWJpcmQ8QWNjb3VudFJlc3BvbnNlPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEFjY291bnRSZXNwb25zZT4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5yZWNvdmVyeVBvc3Qoe1xuICAgICAgICBwYXRoOiAnL3dhbGxldHNvbGlkaXR5L2dldGFjY291bnQnLFxuICAgICAgICBqc29uT2JqOiB7IGFkZHJlc3MgfSxcbiAgICAgICAgbm9kZTogTm9kZVR5cGVzLlNvbGlkaXR5LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBvdXIgYnVpbGQgdHJhbnNhY3Rpb24gZnJvbSBhIG5vZGUuXG4gICAqIEBwYXJhbSB0b0FkZHIgaGV4LWVuY29kZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gZnJvbUFkZHIgaGV4LWVuY29kZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRCdWlsZFRyYW5zYWN0aW9uKFxuICAgIHRvQWRkcjogc3RyaW5nLFxuICAgIGZyb21BZGRyOiBzdHJpbmcsXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Yml0Z29BY2NvdW50TGliLlRyeC5JbnRlcmZhY2UuVHJhbnNhY3Rpb25SZWNlaXB0PlxuICApOiBCbHVlYmlyZDxiaXRnb0FjY291bnRMaWIuVHJ4LkludGVyZmFjZS5UcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288Yml0Z29BY2NvdW50TGliLlRyeC5JbnRlcmZhY2UuVHJhbnNhY3Rpb25SZWNlaXB0PihmdW5jdGlvbiooKSB7XG4gICAgICAvLyBvdXIgYWRkcmVzc2VzIHNob3VsZCBiZSBiYXNlNTgsIHdlJ2xsIGhhdmUgdG8gZW5jb2RlIHRvIGhleFxuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5yZWNvdmVyeVBvc3Qoe1xuICAgICAgICBwYXRoOiAnL3dhbGxldC9jcmVhdGV0cmFuc2FjdGlvbicsXG4gICAgICAgIGpzb25PYmo6IHtcbiAgICAgICAgICB0b19hZGRyZXNzOiB0b0FkZHIsXG4gICAgICAgICAgb3duZXJfYWRkcmVzczogZnJvbUFkZHIsXG4gICAgICAgICAgYW1vdW50LFxuICAgICAgICB9LFxuICAgICAgICBub2RlOiBOb2RlVHlwZXMuRnVsbCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IGtleXMgaW4gdGhlIG93bmVyS2V5cyBjb2xsZWN0aW9uIGRvbid0IG1hdGNoIHRoZSBrZXlzIGFycmF5IHdlIHBhc3NcbiAgICogQHBhcmFtIG93bmVyS2V5c1xuICAgKiBAcGFyYW0ga2V5c1RvRmluZFxuICAgKi9cbiAgY2hlY2tQZXJtaXNzaW9ucyhvd25lcktleXM6IHsgYWRkcmVzczogc3RyaW5nOyB3ZWlnaHQ6IG51bWJlciB9W10sIGtleXM6IHN0cmluZ1tdKSB7XG4gICAga2V5cyA9IGtleXMubWFwKGsgPT4gay50b1VwcGVyQ2FzZSgpKTtcblxuICAgIG93bmVyS2V5cy5tYXAoa2V5ID0+IHtcbiAgICAgIGNvbnN0IGhleEtleSA9IGtleS5hZGRyZXNzLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoIWtleXMuaW5jbHVkZXMoaGV4S2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHB1YiBhZGRyZXNzICR7aGV4S2V5fSBub3QgZm91bmQgaW4gYWNjb3VudGApO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5LndlaWdodCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ293bmVyIHBlcm1pc3Npb24gaXMgaW52YWxpZCBmb3IgdGhpcyBzdHJ1Y3R1cmUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvLlxuICAgKiBXZSBuZWVkIHRvIGRvIHRocmVlIHF1ZXJpZXMgZHVyaW5nIHRoaXM6XG4gICAqIDEpIE5vZGUgcXVlcnkgLSBob3cgbXVjaCBtb25leSBpcyBpbiB0aGUgYWNjb3VudFxuICAgKiAyKSBCdWlsZCB0cmFuc2FjdGlvbiAtIGJ1aWxkIG91ciB0cmFuc2FjdGlvbiBmb3IgdGhlIGFtb3VudFxuICAgKiAzKSBTZW5kIHNpZ25lZCBidWlsZCAtIHNlbmQgb3VyIHNpZ25lZCBidWlsZCB0byBhIHB1YmxpYyBub2RlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxSZWNvdmVyeVRyYW5zYWN0aW9uPik6IEJsdWViaXJkPFJlY292ZXJ5VHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UmVjb3ZlcnlUcmFuc2FjdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG5cbiAgICAgIC8vIGdldCBvdXIgdXNlciwgYmFja3VwIGtleXNcbiAgICAgIGNvbnN0IGtleXMgPSB5aWVsZCBzZWxmLmluaXRpYXRlUmVjb3ZlcnkocGFyYW1zKTtcblxuICAgICAgLy8gd2UgbmVlZCB0byBkZWNvZGUgb3VyIGJpdGdvS2V5IHRvIGEgYmFzZTU4IGFkZHJlc3NcbiAgICAgIGNvbnN0IGJpdGdvSGV4QWRkciA9IHNlbGYuY29tcHJlc3NlZFB1YlRvSGV4QWRkcmVzcyhzZWxmLnhwdWJUb0NvbXByZXNzZWRQdWIocGFyYW1zLmJpdGdvS2V5KSk7XG4gICAgICBjb25zdCByZWNvdmVyeUFkZHJlc3NIZXggPSBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmdldEhleEFkZHJlc3NGcm9tQmFzZTU4QWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbik7XG5cbiAgICAgIC8vIGNhbGwgdGhlIG5vZGUgdG8gZ2V0IG91ciBhY2NvdW50IGJhbGFuY2VcbiAgICAgIGNvbnN0IGFjY291bnQgPSB5aWVsZCBzZWxmLmdldEFjY291bnRGcm9tTm9kZShiaXRnb0hleEFkZHIpO1xuICAgICAgY29uc3QgcmVjb3ZlcnlBbW91bnQgPSBhY2NvdW50LmJhbGFuY2U7XG5cbiAgICAgIGNvbnN0IHVzZXJYUHViID0ga2V5c1swXS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG4gICAgICBjb25zdCB1c2VyWFBydiA9IGtleXNbMF0udG9CYXNlNTgoKTtcbiAgICAgIGNvbnN0IGJhY2t1cFhQdWIgPSBrZXlzWzFdLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcblxuICAgICAgLy8gY29uc3RydWN0IHRoZSB0eCAtXG4gICAgICAvLyB0aGVyZSdzIGFuIGFzc3VtcHRpb24gaGVyZSBiZWluZyBtYWRlIGFib3V0IGZlZXM6IGZvciBhIHdhbGxldCB0aGF0IGhhc24ndCBiZWVuIHVzZWQgaW4gYXdoaWxlLCB0aGUgaW1wbGljYXRpb24gaXNcbiAgICAgIC8vIGl0IGhhcyBtYXhpbXVtIGJhbmR3aWR0aC4gdGh1cywgYSByZWNvdmVyeSBzaG91bGQgY29zdCB0aGUgbWluaW11bSBhbW91bnQgKDFlNiBzdW4gb3IgMSBUcm9uKVxuICAgICAgaWYgKE1JTklNVU1fVFJPTl9NU0lHX1RSQU5TQUNUSU9OX0ZFRSA+IHJlY292ZXJ5QW1vdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW1vdW50IG9mIGZ1bmRzIHRvIHJlY292ZXIgd291bGRudCBiZSBhYmxlIHRvIGZ1bmQgYSBzZW5kJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWNvdmVyeUFtb3VudE1pbnVzRmVlcyA9IHJlY292ZXJ5QW1vdW50IC0gTUlOSU1VTV9UUk9OX01TSUdfVFJBTlNBQ1RJT05fRkVFO1xuICAgICAgY29uc3QgYnVpbGRUeCA9IHlpZWxkIHNlbGYuZ2V0QnVpbGRUcmFuc2FjdGlvbihyZWNvdmVyeUFkZHJlc3NIZXgsIGJpdGdvSGV4QWRkciwgcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMpO1xuXG4gICAgICBjb25zdCBrZXlIZXhBZGRyZXNzZXMgPSBbXG4gICAgICAgIHNlbGYuY29tcHJlc3NlZFB1YlRvSGV4QWRkcmVzcyhzZWxmLnhwdWJUb0NvbXByZXNzZWRQdWIodXNlclhQdWIpKSxcbiAgICAgICAgc2VsZi5jb21wcmVzc2VkUHViVG9IZXhBZGRyZXNzKHNlbGYueHB1YlRvQ29tcHJlc3NlZFB1YihiYWNrdXBYUHViKSksXG4gICAgICAgIGJpdGdvSGV4QWRkcixcbiAgICAgIF07XG5cbiAgICAgIC8vIHJ1biBjaGVja3MgdG8gZW5zdXJlIHRoaXMgaXMgYSB2YWxpZCB0eCAtIHBlcm1pc3Npb25zIG1hdGNoIG91ciBzaWduZXIga2V5c1xuICAgICAgc2VsZi5jaGVja1Blcm1pc3Npb25zKGFjY291bnQub3duZXJfcGVybWlzc2lvbi5rZXlzLCBrZXlIZXhBZGRyZXNzZXMpO1xuICAgICAgc2VsZi5jaGVja1Blcm1pc3Npb25zKGFjY291bnQuYWN0aXZlX3Blcm1pc3Npb25bMF0ua2V5cywga2V5SGV4QWRkcmVzc2VzKTtcblxuICAgICAgLy8gY29uc3RydWN0IG91ciB0eFxuICAgICAgY29uc3QgdHhCdWlsZGVyID0gbmV3IGJpdGdvQWNjb3VudExpYi5UcmFuc2FjdGlvbkJ1aWxkZXIoeyBjb2luTmFtZTogdGhpcy5nZXRDaGFpbigpIH0pO1xuICAgICAgdHhCdWlsZGVyLmZyb20oYnVpbGRUeCk7XG5cbiAgICAgIC8vIHRoaXMgdHggc2hvdWxkIGJlIGVub3VnaCB0byBkcm9wIGludG8gYSBub2RlXG4gICAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHg6IHR4QnVpbGRlci5idWlsZCgpLnRvSnNvbigpLFxuICAgICAgICAgIHJlY292ZXJ5QW1vdW50OiByZWNvdmVyeUFtb3VudE1pbnVzRmVlcyxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlclBydiA9IHNlbGYueHBydlRvQ29tcHJlc3NlZFBydih1c2VyWFBydik7XG5cbiAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiB1c2VyUHJ2IH0pO1xuXG4gICAgICAvLyBrcnMgcmVjb3ZlcmllcyBkb24ndCBnZXQgc2lnbmVkXG4gICAgICBpZiAoIWlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgY29uc3QgYmFja3VwWFBydiA9IGtleXNbMV0udG9CYXNlNTgoKTtcbiAgICAgICAgY29uc3QgYmFja3VwUHJ2ID0gc2VsZi54cHJ2VG9Db21wcmVzc2VkUHJ2KGJhY2t1cFhQcnYpO1xuXG4gICAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBiYWNrdXBQcnYgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4OiB0eEJ1aWxkZXIuYnVpbGQoKS50b0pzb24oKSxcbiAgICAgICAgcmVjb3ZlcnlBbW91bnQ6IHJlY292ZXJ5QW1vdW50TWludXNGZWVzLFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgVHJvbiB0cmFuc2FjdGlvbiBmcm9tIHR4SGV4XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyb25UcmFuc2FjdGlvbkV4cGxhbmF0aW9uPlxuICApOiBCbHVlYmlyZDxUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIHJldHVybiBjbzxUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICAgIGlmICghdHhIZXggfHwgIXBhcmFtcy5mZWVJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvaW5OYW1lID0gdGhpcy5nZXRDaGFpbigpO1xuICAgICAgY29uc3QgdHhCdWlsZGVyID0gbmV3IGJpdGdvQWNjb3VudExpYi5UcmFuc2FjdGlvbkJ1aWxkZXIoeyBjb2luTmFtZSB9KTtcbiAgICAgIHR4QnVpbGRlci5mcm9tKHR4SGV4KTtcbiAgICAgIGNvbnN0IHR4ID0gdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICBjb25zdCBvdXRwdXRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgYW1vdW50OiB0eC5kZXN0aW5hdGlvbnNbMF0udmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICBhZGRyZXNzOiB0eC5kZXN0aW5hdGlvbnNbMF0uYWRkcmVzcywgLy8gU2hvdWxkIHR1cm4gaXQgaW50byBhIHJlYWRhYmxlIGZvcm1hdCwgYWthIGJhc2U1OFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICAgJ2NoYW5nZUFtb3VudCcsXG4gICAgICAgICdvdXRwdXRzJyxcbiAgICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgICAnZmVlJyxcbiAgICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAgICdleHBpcmF0aW9uJyxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV4cGxhbmF0aW9uUmVzdWx0OiBUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHguaWQsXG4gICAgICAgIG91dHB1dHMsXG4gICAgICAgIG91dHB1dEFtb3VudDogb3V0cHV0c1swXS5hbW91bnQsXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLCAvLyBhY2NvdW50IGJhc2VkIGRvZXMgbm90IHVzZSBjaGFuZ2Ugb3V0cHV0c1xuICAgICAgICBjaGFuZ2VBbW91bnQ6ICcwJywgLy8gYWNjb3VudCBiYXNlIGRvZXMgbm90IG1ha2UgY2hhbmdlXG4gICAgICAgIGZlZTogcGFyYW1zLmZlZUluZm8sXG4gICAgICAgIHRpbWVzdGFtcDogdHgudmFsaWRGcm9tLFxuICAgICAgICBleHBpcmF0aW9uOiB0eC52YWxpZFRvLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGV4cGxhbmF0aW9uUmVzdWx0O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=