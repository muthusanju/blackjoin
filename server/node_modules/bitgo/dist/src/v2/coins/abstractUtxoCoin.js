"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bitcoin = require("bitgo-utxo-lib");
var bitcoinMessage = require("bitcoinjs-message");
var Bluebird = require("bluebird");
var crypto = require("crypto");
var request = require("superagent");
var _ = require("lodash");
var debugLib = require("debug");
var unspents_1 = require("@bitgo/unspents");
var codes_1 = require("@bitgo/unspents/dist/codes");
var bitcoin_1 = require("../../bitcoin");
var baseCoin_1 = require("../baseCoin");
var keychains_1 = require("../keychains");
var config = require("../../config");
var recovery_1 = require("../recovery");
var errors = require("../../errors");
var debug = debugLib('bitgo:v2:utxo');
var co = Bluebird.coroutine;
var AbstractUtxoCoin = /** @class */ (function (_super) {
    __extends(AbstractUtxoCoin, _super);
    function AbstractUtxoCoin(bitgo, network) {
        var _this = _super.call(this, bitgo) || this;
        if (!_.isObject(network)) {
            throw new Error('network must be an object');
        }
        _this._network = network;
        return _this;
    }
    Object.defineProperty(AbstractUtxoCoin.prototype, "network", {
        get: function () {
            return this._network;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractUtxoCoin, "validAddressTypes", {
        get: function () {
            var validAddressTypes = [];
            // best way I could find to loop over enum values
            // https://github.com/Microsoft/TypeScript/issues/17198#issuecomment-423836658
            // this is a typescript rough corner for sure
            var unspentTypeKeys = Object.keys(codes_1.UnspentType);
            var unspentTypes = unspentTypeKeys
                .map(function (k) { return codes_1.UnspentType[k]; })
                .map(function (v) { return v; });
            for (var _i = 0, unspentTypes_1 = unspentTypes; _i < unspentTypes_1.length; _i++) {
                var addressType = unspentTypes_1[_i];
                try {
                    unspents_1.Codes.forType(addressType);
                    validAddressTypes.push(addressType);
                }
                catch (e) {
                    // Do nothing. Codes.forType will throw if the address type has no chain codes, meaning it is invalid on the
                    // BitGo platform and should not be added to the validAddressTypes array.
                }
            }
            return validAddressTypes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    AbstractUtxoCoin.prototype.getBaseFactor = function () {
        return 1e8;
    };
    /**
     * Get an instance of the library which can be used to perform low-level operations for this coin
     */
    AbstractUtxoCoin.prototype.getCoinLibrary = function () {
        return bitcoin;
    };
    /**
     * Helper to get the version number for an address
     */
    AbstractUtxoCoin.prototype.getAddressVersion = function (address) {
        // try decoding as base58 first
        try {
            var version = this.getCoinLibrary().address.fromBase58Check(address).version;
            return version;
        }
        catch (e) {
            // if that fails, and we aren't supporting p2wsh, then we are done and did not find a version
            if (!this.supportsP2wsh()) {
                return;
            }
        }
        // otherwise, try decoding as bech32
        try {
            var _a = this.getCoinLibrary().address.fromBech32(address), version = _a.version, prefix = _a.prefix;
            if (_.isString(this.network.bech32) && prefix === this.network.bech32) {
                return version;
            }
        }
        catch (e) {
            // ignore errors, just fall through and return undefined
        }
    };
    /**
     * Helper to get the bech32 prefix for an address
     */
    AbstractUtxoCoin.prototype.getAddressPrefix = function (address) {
        // otherwise, try decoding as bech32
        try {
            var prefix = this.getCoinLibrary().address.fromBech32(address).prefix;
            return prefix;
        }
        catch (e) {
            // ignore errors, just fall through and return undefined
        }
    };
    /**
     * Check if an address is valid
     * @param address
     * @param forceAltScriptSupport
     */
    AbstractUtxoCoin.prototype.isValidAddress = function (address, forceAltScriptSupport) {
        if (forceAltScriptSupport === void 0) { forceAltScriptSupport = false; }
        var validVersions = [
            this.network.pubKeyHash,
            this.network.scriptHash,
        ];
        if (this.altScriptHash && (forceAltScriptSupport || this.supportAltScriptDestination)) {
            validVersions.push(this.altScriptHash);
        }
        var addressVersion = this.getAddressVersion(address);
        // the address version needs to be among the valid ones
        var addressVersionValid = _.isNumber(addressVersion) && validVersions.includes(addressVersion);
        var addressPrefix = this.getAddressPrefix(address);
        if (!this.supportsP2wsh() || _.isUndefined(addressPrefix)) {
            return addressVersionValid;
        }
        // address has a potential bech32 prefix, validate that
        return _.isString(this.network.bech32) && this.network.bech32 === addressPrefix;
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    AbstractUtxoCoin.prototype.isValidPub = function (pub) {
        try {
            bitcoin.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Get the latest block height
     * @param reqId
     * @param callback
     */
    AbstractUtxoCoin.prototype.getLatestBlockHeight = function (reqId, callback) {
        var self = this;
        return co(function () {
            var chainhead;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (reqId) {
                            this.bitgo._reqId = reqId;
                        }
                        return [4 /*yield*/, self.bitgo.get(self.url('/public/block/latest')).result()];
                    case 1:
                        chainhead = _a.sent();
                        return [2 /*return*/, chainhead.height];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Run custom coin logic after a transaction prebuild has been received from BitGo
     * @param prebuild
     * @param callback
     */
    AbstractUtxoCoin.prototype.postProcessPrebuild = function (prebuild, callback) {
        var self = this;
        return co(function () {
            var transaction, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (_.isUndefined(prebuild.txHex)) {
                            throw new Error('missing required txPrebuild property txHex');
                        }
                        transaction = bitcoin.Transaction.fromHex(prebuild.txHex, self.network);
                        if (!_.isUndefined(prebuild.blockHeight)) return [3 /*break*/, 2];
                        _a = prebuild;
                        return [4 /*yield*/, self.getLatestBlockHeight()];
                    case 1:
                        _a.blockHeight = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // Lock transaction to the next block to discourage fee sniping
                        // See: https://github.com/bitcoin/bitcoin/blob/fb0ac482eee761ec17ed2c11df11e054347a026d/src/wallet/wallet.cpp#L2133
                        transaction.locktime = prebuild.blockHeight;
                        return [2 /*return*/, _.extend({}, prebuild, { txHex: transaction.toHex() })];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Find outputs that are within expected outputs but not within actual outputs, including duplicates
     * @param expectedOutputs
     * @param actualOutputs
     * @returns {Array}
     */
    AbstractUtxoCoin.findMissingOutputs = function (expectedOutputs, actualOutputs) {
        var keyFunc = function (_a) {
            var address = _a.address, amount = _a.amount;
            return address + ":" + Number(amount);
        };
        var groupedOutputs = _.groupBy(expectedOutputs, keyFunc);
        actualOutputs.forEach(function (output) {
            var group = groupedOutputs[keyFunc(output)];
            if (group) {
                group.pop();
            }
        });
        return _.flatten(_.values(groupedOutputs));
    };
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    AbstractUtxoCoin.inferAddressType = function (addressDetails) {
        if (_.isObject(addressDetails.coinSpecific)) {
            if (_.isString(addressDetails.coinSpecific.redeemScript) && _.isString(addressDetails.coinSpecific.witnessScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh');
            }
            else if (_.isString(addressDetails.coinSpecific.redeemScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2sh');
            }
            else if (_.isString(addressDetails.coinSpecific.witnessScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2wsh');
            }
        }
        return null;
    };
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param params
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.parseTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txParams, txPrebuild, wallet, _a, verification, reqId, disableNetworking, keychains, keychainArray, keySignatures, explanation, allOutputs, expectedOutputs, missingOutputs, allOutputDetails, changeOutputs, implicitOutputs, explicitOutputs, explicitExternalOutputs, explicitExternalSpendAmount, implicitExternalOutputs, implicitExternalSpendAmount, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txParams = params.txParams, txPrebuild = params.txPrebuild, wallet = params.wallet, _a = params.verification, verification = _a === void 0 ? {} : _a, reqId = params.reqId;
                        if (!_.isUndefined(verification.disableNetworking) && !_.isBoolean(verification.disableNetworking)) {
                            throw new Error('verification.disableNetworking must be a boolean');
                        }
                        disableNetworking = verification.disableNetworking;
                        keychains = verification.keychains;
                        if (!(!keychains && disableNetworking)) return [3 /*break*/, 1];
                        throw new Error('cannot fetch keychains without networking');
                    case 1:
                        if (!!keychains) return [3 /*break*/, 3];
                        return [4 /*yield*/, Bluebird.props({
                                user: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.USER], reqId: reqId }),
                                backup: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BACKUP], reqId: reqId }),
                                bitgo: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BITGO], reqId: reqId }),
                            })];
                    case 2:
                        keychains = _b.sent();
                        _b.label = 3;
                    case 3:
                        if (!keychains) {
                            throw new Error('keychains are required, but could not be fetched');
                        }
                        keychainArray = [keychains.user, keychains.backup, keychains.bitgo];
                        keySignatures = _.get(wallet, '_wallet.keySignatures');
                        if (_.isUndefined(txPrebuild.txHex)) {
                            throw new Error('missing required txPrebuild property txHex');
                        }
                        return [4 /*yield*/, self.explainTransaction({
                                txHex: txPrebuild.txHex,
                                txInfo: txPrebuild.txInfo,
                            })];
                    case 4:
                        explanation = _b.sent();
                        allOutputs = explanation.outputs.concat(explanation.changeOutputs);
                        expectedOutputs = _.get(txParams, 'recipients', []);
                        missingOutputs = AbstractUtxoCoin.findMissingOutputs(expectedOutputs, allOutputs);
                        return [4 /*yield*/, Bluebird.map(allOutputs, co(function (currentOutput) {
                                var currentAddress, addressDetailsPrebuild, addressDetailsVerification, addressDetails, addressType, e_1, walletAddressNotFound, unexpectedAddress;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            currentAddress = currentOutput.address;
                                            addressDetailsPrebuild = _.get(txPrebuild, "txInfo.walletAddressDetails." + currentAddress, {});
                                            addressDetailsVerification = _.get(verification, "addresses." + currentAddress, {});
                                            debug('Parsing address details for %s', currentAddress);
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 4, , 5]);
                                            addressDetails = _.extend({}, addressDetailsPrebuild, addressDetailsVerification);
                                            debug('Locally available address %s details: %O', currentAddress, addressDetails);
                                            if (!(_.isEmpty(addressDetails) && !disableNetworking)) return [3 /*break*/, 3];
                                            return [4 /*yield*/, wallet.getAddress({ address: currentAddress, reqId: reqId })];
                                        case 2:
                                            addressDetails = _a.sent();
                                            debug('Downloaded address %s details: %O', currentAddress, addressDetails);
                                            _a.label = 3;
                                        case 3:
                                            addressType = AbstractUtxoCoin.inferAddressType(addressDetails);
                                            self.verifyAddress(_.extend({ addressType: addressType }, addressDetails, {
                                                keychains: keychainArray,
                                                address: currentAddress,
                                            }));
                                            debug('Address %s verification passed', currentAddress);
                                            // verify address succeeded without throwing, so the address was
                                            // correctly rederived from the wallet keychains, making it not external
                                            return [2 /*return*/, _.extend({}, currentOutput, addressDetails, { external: false })];
                                        case 4:
                                            e_1 = _a.sent();
                                            // verify address threw an exception
                                            debug('Address %s verification threw an error:', currentAddress, e_1);
                                            walletAddressNotFound = e_1.message.includes('wallet address not found');
                                            unexpectedAddress = (e_1 instanceof errors.UnexpectedAddressError);
                                            if (walletAddressNotFound || unexpectedAddress) {
                                                if (unexpectedAddress && !walletAddressNotFound) {
                                                    /**
                                                     * this could be a migrated SafeHD BCH wallet, and the transaction we are currently
                                                     * parsing is trying to spend change back to the v1 wallet base address.
                                                     * It does this since we don't allow new address creation for these wallets,
                                                     * and instead return the base address from the v1 wallet when a new address is requested.
                                                     * If this new address is requested for the purposes of spending change back to the wallet,
                                                     * the change will go to the v1 wallet base address. This address *is* on the wallet,
                                                     * but it will still cause an error to be thrown by verifyAddress, since the derivation path
                                                     * used for this address is non-standard. (I have seen these addresses derived using paths m/0/0 and m/101,
                                                     * whereas the v2 addresses are derived using path  m/0/0/${chain}/${index}).
                                                     *
                                                     * This means we need to check for this case explicitly in this catch block, and classify
                                                     * these types of outputs as internal instead of external. Failing to do so would cause the
                                                     * transaction's implicit external outputs (ie, outputs which go to addresses not specified in
                                                     * the recipients array) to add up to more than the 150 basis point limit which we enforce on
                                                     * pay-as-you-go outputs (which should be the only implicit external outputs on our transactions).
                                                     *
                                                     * The 150 basis point limit for implicit external sends is enforced in verifyTransaction,
                                                     * which calls this function to get information on the total external/internal spend amounts
                                                     * for a transaction. The idea here is to protect from the transaction being maliciously modified
                                                     * to add more implicit external spends (eg, to an attacker-controlled wallet).
                                                     *
                                                     * See verifyTransaction for more information on how transaction prebuilds are verified before signing.
                                                     */
                                                    if (_.isString(wallet.migratedFrom()) && wallet.migratedFrom() === currentAddress) {
                                                        debug('found address %s which was migrated from v1 wallet, address is not external', currentAddress);
                                                        return [2 /*return*/, _.extend({}, currentOutput, { external: false })];
                                                    }
                                                    debug('Address %s was found on wallet but could not be reconstructed', currentAddress);
                                                }
                                                // the address was found, but not on the wallet, which simply means it's external
                                                debug('Address %s presumed external', currentAddress);
                                                return [2 /*return*/, _.extend({}, currentOutput, { external: true })];
                                            }
                                            else if (e_1 instanceof errors.InvalidAddressDerivationPropertyError && currentAddress === txParams.changeAddress) {
                                                // expect to see this error when passing in a custom changeAddress with no chain or index
                                                return [2 /*return*/, _.extend({}, currentOutput, { external: false })];
                                            }
                                            debug('Address %s verification failed', currentAddress);
                                            /**
                                             * It might be a completely invalid address or a bad validation attempt or something else completely, in
                                             * which case we do not proceed and rather rethrow the error, which is safer than assuming that the address
                                             * validation failed simply because it's external to the wallet.
                                             */
                                            throw e_1;
                                        case 5: return [2 /*return*/];
                                    }
                                });
                            }).bind(this))];
                    case 5:
                        allOutputDetails = _b.sent();
                        changeOutputs = _.filter(allOutputDetails, { external: false });
                        implicitOutputs = AbstractUtxoCoin.findMissingOutputs(allOutputDetails, expectedOutputs);
                        explicitOutputs = AbstractUtxoCoin.findMissingOutputs(allOutputDetails, implicitOutputs);
                        explicitExternalOutputs = _.filter(explicitOutputs, { external: true });
                        explicitExternalSpendAmount = _.sumBy(explicitExternalOutputs, 'amount');
                        implicitExternalOutputs = _.filter(implicitOutputs, { external: true });
                        implicitExternalSpendAmount = _.sumBy(implicitExternalOutputs, 'amount');
                        result = {
                            keychains: keychains,
                            keySignatures: keySignatures,
                            outputs: allOutputDetails,
                            missingOutputs: missingOutputs,
                            explicitExternalOutputs: explicitExternalOutputs,
                            implicitExternalOutputs: implicitExternalOutputs,
                            changeOutputs: changeOutputs,
                            explicitExternalSpendAmount: explicitExternalSpendAmount,
                            implicitExternalSpendAmount: implicitExternalSpendAmount,
                        };
                        return [2 /*return*/, result];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.txPrebuild.txHex prebuilt transaction's txHex form
     * @param params.wallet Wallet object to obtain keys to verify against
     * @param params.verification Object specifying some verification parameters
     * @param params.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param params.verification.keychains Pass keychains manually rather than fetching them by id
     * @param params.verification.addresses Address details to pass in for out-of-band verification
     * @param callback
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.verifyTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txParams, txPrebuild, wallet, _a, verification, reqId, disableNetworking, parsedTransaction, keychains, keySignatures, userPub, userKey, userPrv, encryptedPrv, errorMessage, userPrivateKey, backupPubSignature, bitgoPubSignature, signingAddress, isValidBackupSignature, isValidBitgoSignature, missingOutputs, intendedExternalSpend, payAsYouGoLimit, nonChangeAmount, allOutputs, transaction, transactionCache, inputs, inputAmount, outputAmount, fee;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txParams = params.txParams, txPrebuild = params.txPrebuild, wallet = params.wallet, _a = params.verification, verification = _a === void 0 ? {} : _a, reqId = params.reqId;
                        disableNetworking = !!verification.disableNetworking;
                        return [4 /*yield*/, self.parseTransaction({ txParams: txParams, txPrebuild: txPrebuild, wallet: wallet, verification: verification, reqId: reqId })];
                    case 1:
                        parsedTransaction = _b.sent();
                        keychains = parsedTransaction.keychains;
                        keySignatures = parsedTransaction.keySignatures;
                        if (!_.isEmpty(keySignatures)) {
                            userPub = keychains.user.pub;
                            userKey = bitcoin.HDNode.fromBase58(userPub);
                            userPrv = keychains.user.prv;
                            if (_.isEmpty(userPrv)) {
                                encryptedPrv = keychains.user.encryptedPrv;
                                if (!_.isEmpty(encryptedPrv)) {
                                    // if the decryption fails, it will throw an error
                                    userPrv = self.bitgo.decrypt({
                                        input: encryptedPrv,
                                        password: txParams.walletPassphrase,
                                    });
                                }
                            }
                            if (_.isEmpty(userPrv)) {
                                errorMessage = 'user private key unavailable for verification';
                                if (disableNetworking) {
                                    console.log(errorMessage);
                                }
                                else {
                                    throw new Error(errorMessage);
                                }
                            }
                            else {
                                userPrivateKey = bitcoin.HDNode.fromBase58(userPrv);
                                if (userPrivateKey.toBase58() === userPrivateKey.neutered().toBase58()) {
                                    throw new Error('user private key is only public');
                                }
                                if (userPrivateKey.neutered().toBase58() !== userPub) {
                                    throw new Error('user private key does not match public key');
                                }
                            }
                            backupPubSignature = keySignatures.backupPub;
                            bitgoPubSignature = keySignatures.bitgoPub;
                            signingAddress = userKey.keyPair.getAddress();
                            isValidBackupSignature = bitcoinMessage.verify(keychains.backup.pub, signingAddress, Buffer.from(backupPubSignature, 'hex'));
                            isValidBitgoSignature = bitcoinMessage.verify(keychains.bitgo.pub, signingAddress, Buffer.from(bitgoPubSignature, 'hex'));
                            if (!isValidBackupSignature || !isValidBitgoSignature) {
                                throw new Error('secondary public key signatures invalid');
                            }
                        }
                        else if (!disableNetworking) {
                            // these keys were obtained online and their signatures were not verified
                            // this could be dangerous
                            console.log('unsigned keys obtained online are being used for address verification');
                        }
                        missingOutputs = parsedTransaction.missingOutputs;
                        if (missingOutputs.length !== 0) {
                            // there are some outputs in the recipients list that have not made it into the actual transaction
                            throw new Error('expected outputs missing in transaction prebuild');
                        }
                        intendedExternalSpend = parsedTransaction.explicitExternalSpendAmount;
                        payAsYouGoLimit = intendedExternalSpend * 0.015;
                        nonChangeAmount = parsedTransaction.implicitExternalSpendAmount;
                        // the additional external outputs can only be BitGo's pay-as-you-go fee, but we cannot verify the wallet address
                        if (nonChangeAmount > payAsYouGoLimit) {
                            // there are some addresses that are outside the scope of intended recipients that are not change addresses
                            throw new Error('prebuild attempts to spend to unintended external recipients');
                        }
                        allOutputs = parsedTransaction.outputs;
                        transaction = bitcoin.Transaction.fromHex(txPrebuild.txHex, self.network);
                        transactionCache = {};
                        return [4 /*yield*/, Bluebird.map(transaction.ins, co(function (currentInput) {
                                var transactionId, txHex, localTx, currentOutput, address, _a, _b, transactionDetails;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            transactionId = Buffer.from(currentInput.hash).reverse().toString('hex');
                                            txHex = _.get(txPrebuild, "txInfo.txHexes." + transactionId);
                                            if (!txHex) return [3 /*break*/, 1];
                                            localTx = bitcoin.Transaction.fromHex(txHex, self.network);
                                            if (localTx.getId() !== transactionId) {
                                                throw new Error('input transaction hex does not match id');
                                            }
                                            currentOutput = localTx.outs[currentInput.index];
                                            address = bitcoin.address.fromOutputScript(currentOutput.script, self.network);
                                            return [2 /*return*/, {
                                                    address: address,
                                                    value: currentOutput.value,
                                                }];
                                        case 1:
                                            if (!!transactionCache[transactionId]) return [3 /*break*/, 3];
                                            if (disableNetworking) {
                                                throw new Error('attempting to retrieve transaction details externally with networking disabled');
                                            }
                                            if (reqId) {
                                                self.bitgo.setRequestTracer(reqId);
                                            }
                                            _a = transactionCache;
                                            _b = transactionId;
                                            return [4 /*yield*/, self.bitgo.get(self.url("/public/tx/" + transactionId)).result()];
                                        case 2:
                                            _a[_b] = _c.sent();
                                            _c.label = 3;
                                        case 3:
                                            transactionDetails = transactionCache[transactionId];
                                            return [2 /*return*/, transactionDetails.outputs[currentInput.index]];
                                    }
                                });
                            }).bind(this))];
                    case 2:
                        inputs = _b.sent();
                        inputAmount = _.sumBy(inputs, 'value');
                        outputAmount = _.sumBy(allOutputs, 'amount');
                        fee = inputAmount - outputAmount;
                        if (fee < 0) {
                            throw new Error("attempting to spend " + outputAmount + " satoshis, which exceeds the input amount (" + inputAmount + " satoshis) by " + -fee);
                        }
                        return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param params.address The address string on the network
     * @param params.addressType
     * @param params.keychains Keychain objects with xpubs
     * @param params.coinSpecific Coin-specific details for the address such as a witness script
     * @param params.chain Derivation chain
     * @param params.index Derivation index
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressDerivationPropertyError}
     * @throws {UnexpectedAddressError}
     */
    AbstractUtxoCoin.prototype.verifyAddress = function (params) {
        var address = params.address, addressType = params.addressType, keychains = params.keychains, coinSpecific = params.coinSpecific, chain = params.chain, index = params.index;
        if (!this.isValidAddress(address)) {
            throw new errors.InvalidAddressError("invalid address: " + address);
        }
        if ((_.isUndefined(chain) && _.isUndefined(index)) || (!(_.isFinite(chain) && _.isFinite(index)))) {
            throw new errors.InvalidAddressDerivationPropertyError("address validation failure: invalid chain (" + chain + ") or index (" + index + ")");
        }
        if (!_.isObject(coinSpecific)) {
            throw new errors.InvalidAddressVerificationObjectPropertyError('address validation failure: coinSpecific field must be an object');
        }
        if (!keychains) {
            throw new Error('missing required param keychains');
        }
        var expectedAddress = this.generateAddress({
            addressType: addressType,
            keychains: keychains,
            threshold: 2,
            chain: chain,
            index: index,
        });
        if (expectedAddress.address !== address) {
            throw new errors.UnexpectedAddressError("address validation failure: expected " + expectedAddress.address + " but got " + address);
        }
        return true;
    };
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsBlockTarget = function () {
        return true;
    };
    /**
     * Indicates whether a coin supports wrapped segwit outputs
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsP2shP2wsh = function () {
        return false;
    };
    /**
     * Indicates whether a coin supports native segwit outputs
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsP2wsh = function () {
        return false;
    };
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param params.addressType {string}   Deprecated
     * @param params.keychains   {[object]} Array of objects with xpubs
     * @param params.threshold   {number}   Minimum number of signatures
     * @param params.chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param params.index       {number}   Derivation index
     * @param params.segwit      {boolean}  Deprecated
     * @param params.bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    AbstractUtxoCoin.prototype.generateAddress = function (params) {
        var keychains = params.keychains, threshold = params.threshold, chain = params.chain, index = params.index, _a = params.segwit, segwit = _a === void 0 ? false : _a, _b = params.bech32, bech32 = _b === void 0 ? false : _b;
        var derivationChain = 0;
        if (_.isNumber(chain) && _.isInteger(chain) && chain > 0) {
            derivationChain = chain;
        }
        function convertFlagsToAddressType() {
            if (_.isBoolean(segwit) && segwit) {
                return unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh');
            }
            else if (_.isBoolean(bech32) && bech32) {
                return unspents_1.Codes.UnspentTypeTcomb('p2wsh');
            }
            else {
                return unspents_1.Codes.UnspentTypeTcomb('p2sh');
            }
        }
        var addressType = params.addressType || convertFlagsToAddressType();
        switch (addressType) {
            case unspents_1.Codes.UnspentTypeTcomb('p2sh'):
                if (!unspents_1.Codes.isP2sh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh'):
                if (!this.supportsP2shP2wsh()) {
                    throw new errors.P2shP2wshUnsupportedError();
                }
                if (!unspents_1.Codes.isP2shP2wsh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2wsh'):
                if (!this.supportsP2wsh()) {
                    throw new errors.P2wshUnsupportedError();
                }
                if (!unspents_1.Codes.isP2wsh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            default:
                throw new errors.UnsupportedAddressTypeError();
        }
        var signatureThreshold = 2;
        if (_.isInteger(threshold)) {
            signatureThreshold = threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        var derivationIndex = 0;
        if (_.isInteger(index) && index > 0) {
            derivationIndex = index;
        }
        var path = 'm/0/0/' + derivationChain + '/' + derivationIndex;
        var hdNodes = keychains.map(function (_a) {
            var pub = _a.pub;
            return bitcoin.HDNode.fromBase58(pub);
        });
        var derivedKeys = hdNodes.map(function (hdNode) { return bitcoin_1.hdPath(hdNode).deriveKey(path).getPublicKeyBuffer(); });
        var _c = this.createMultiSigAddress(addressType, signatureThreshold, derivedKeys), outputScript = _c.outputScript, redeemScript = _c.redeemScript, witnessScript = _c.witnessScript, address = _c.address;
        return {
            address: address,
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {
                outputScript: outputScript.toString('hex'),
                redeemScript: redeemScript && redeemScript.toString('hex'),
                witnessScript: witnessScript && witnessScript.toString('hex'),
            },
            addressType: addressType,
        };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params.txPrebuild transaction prebuild from bitgo server
     * @param params.prv private key to be used for signing
     * @param params.isLastSignature True if `TransactionBuilder.build()` should be called and not `TransactionBuilder.buildIncomplete()`
     * @returns {{txHex}}
     */
    AbstractUtxoCoin.prototype.signTransaction = function (params) {
        var _this = this;
        var txPrebuild = params.txPrebuild;
        var userPrv = params.prv;
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
            }
            throw new Error('missing txPrebuild parameter');
        }
        var transaction = bitcoin.Transaction.fromHex(txPrebuild.txHex, this.network);
        if (transaction.ins.length !== txPrebuild.txInfo.unspents.length) {
            throw new Error('length of unspents array should equal to the number of transaction inputs');
        }
        var isLastSignature = false;
        if (_.isBoolean(params.isLastSignature)) {
            // if build is called instead of buildIncomplete, no signature placeholders are left in the sig script
            isLastSignature = params.isLastSignature;
        }
        if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
            if (!_.isUndefined(userPrv)) {
                throw new Error("prv must be a string, got type " + typeof userPrv);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        var keychain = bitcoin.HDNode.fromBase58(userPrv);
        var keychainHdPath = bitcoin_1.hdPath(keychain);
        var txb = bitcoin.TransactionBuilder.fromTransaction(transaction, this.network);
        this.prepareTransactionBuilder(txb);
        var getSignatureContext = function (txPrebuild, index) {
            var currentUnspent = txPrebuild.txInfo.unspents[index];
            return {
                inputIndex: index,
                unspent: currentUnspent,
                path: 'm/0/0/' + currentUnspent.chain + '/' + currentUnspent.index,
                isP2wsh: !currentUnspent.redeemScript,
                isBitGoTaintedUnspent: _this.isBitGoTaintedUnspent(currentUnspent),
                error: undefined,
            };
        };
        var signatureIssues = [];
        // Sign inputs
        for (var index = 0; index < transaction.ins.length; ++index) {
            debug('Signing input %d of %d', index + 1, transaction.ins.length);
            var signatureContext = getSignatureContext(txPrebuild, index);
            if (signatureContext.isBitGoTaintedUnspent) {
                debug('Skipping input %d of %d (unspent from replay protection address which is platform signed only)', index + 1, transaction.ins.length);
                continue;
            }
            var privKey = keychainHdPath.deriveKey(signatureContext.path);
            privKey.network = this.network;
            debug('Input details: %O', signatureContext);
            var sigHashType = this.defaultSigHashType;
            try {
                if (signatureContext.isP2wsh) {
                    debug('Signing p2wsh input');
                    var witnessScript = Buffer.from(signatureContext.unspent.witnessScript, 'hex');
                    var witnessScriptHash = bitcoin.crypto.sha256(witnessScript);
                    var prevOutScript = bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
                    txb.sign(index, privKey, prevOutScript, sigHashType, signatureContext.unspent.value, witnessScript);
                }
                else {
                    var subscript = new Buffer(signatureContext.unspent.redeemScript, 'hex');
                    var isP2shP2wsh = !!signatureContext.unspent.witnessScript;
                    if (isP2shP2wsh) {
                        debug('Signing p2shP2wsh input');
                        var witnessScript = Buffer.from(signatureContext.unspent.witnessScript, 'hex');
                        txb.sign(index, privKey, subscript, sigHashType, signatureContext.unspent.value, witnessScript);
                    }
                    else {
                        debug('Signing p2sh input');
                        txb.sign(index, privKey, subscript, sigHashType, signatureContext.unspent.value);
                    }
                }
            }
            catch (e) {
                debug('Failed to sign input:', e);
                signatureContext.error = e;
                signatureIssues.push(signatureContext);
                continue;
            }
            debug('Successfully signed input %d of %d', index + 1, transaction.ins.length);
        }
        if (isLastSignature) {
            transaction = txb.build();
        }
        else {
            transaction = txb.buildIncomplete();
        }
        // Verify input signatures
        for (var index = 0; index < transaction.ins.length; ++index) {
            debug('Verifying input signature %d of %d', index + 1, transaction.ins.length);
            var signatureContext = getSignatureContext(txPrebuild, index);
            if (signatureContext.isBitGoTaintedUnspent) {
                debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', index + 1, transaction.ins.length);
                continue;
            }
            if (signatureContext.isP2wsh) {
                transaction.setInputScript(index, Buffer.alloc(0));
            }
            var isValidSignature = this.verifySignature(transaction, index, signatureContext.unspent.value);
            if (!isValidSignature) {
                debug('Invalid signature');
                signatureContext.error = new Error('invalid signature');
                signatureIssues.push(signatureContext);
            }
        }
        if (signatureIssues.length > 0) {
            var failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
            var error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
            error.code = 'input_signature_failure';
            error.signingErrors = signatureIssues;
            throw error;
        }
        return {
            txHex: transaction.toBuffer().toString('hex'),
        };
    };
    /**
     * Always false for coins other than BCH and TBCH.
     * @param unspent
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.isBitGoTaintedUnspent = function (unspent) {
        return false;
    };
    /**
     * Modify the transaction builder to comply with the specific coin's requirements such as version and branch id
     * @param txBuilder
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.prepareTransactionBuilder = function (txBuilder) {
        return txBuilder;
    };
    Object.defineProperty(AbstractUtxoCoin.prototype, "defaultSigHashType", {
        /**
         * Get the default sighash type to be used when signing transactions
         * @returns {number}
         */
        get: function () {
            return bitcoin.Transaction.SIGHASH_ALL;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Parse a transaction's signature script to obtain public keys, signatures, the sig script, and other properties
     * @param transaction
     * @param inputIndex
     * @returns { isSegwitInput: boolean, inputClassification: string, signatures: [Buffer], publicKeys: [Buffer], pubScript: Buffer }
     */
    AbstractUtxoCoin.prototype.parseSignatureScript = function (transaction, inputIndex) {
        var currentInput = transaction.ins[inputIndex];
        var isSegwitInput = currentInput.witness.length > 0;
        var isNativeSegwitInput = currentInput.script.length === 0;
        var decompiledSigScript, inputClassification;
        if (isSegwitInput) {
            // The decompiledSigScript is the script containing the signatures, public keys, and the script that was committed
            // to (pubScript). If this is a segwit input the decompiledSigScript is in the witness, regardless of whether it
            // is native or not. The inputClassification is determined based on whether or not the input is native to give an
            // accurate classification. Note that p2shP2wsh inputs will be classified as p2sh and not p2wsh.
            decompiledSigScript = currentInput.witness;
            if (isNativeSegwitInput) {
                inputClassification = bitcoin.script.classifyWitness(bitcoin.script.compile(decompiledSigScript), true);
            }
            else {
                inputClassification = bitcoin.script.classifyInput(currentInput.script, true);
            }
        }
        else {
            inputClassification = bitcoin.script.classifyInput(currentInput.script, true);
            decompiledSigScript = bitcoin.script.decompile(currentInput.script);
        }
        if (inputClassification === bitcoin.script.types.P2PKH) {
            var signature = decompiledSigScript[0], publicKey = decompiledSigScript[1];
            var publicKeys = [publicKey];
            var signatures = [signature];
            var pubScript = bitcoin.script.pubKeyHash.output.encode(bitcoin.crypto.hash160(publicKey));
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification, signatures: signatures, publicKeys: publicKeys, pubScript: pubScript };
        }
        else if (inputClassification === bitcoin.script.types.P2SH
            || inputClassification === bitcoin.script.types.P2WSH) {
            // Note the assumption here that if we have a p2sh or p2wsh input it will be multisig (appropriate because the
            // BitGo platform only supports multisig within these types of inputs). Signatures are all but the last entry in
            // the decompiledSigScript. The redeemScript/witnessScript (depending on which type of input this is) is the last
            // entry in the decompiledSigScript (denoted here as the pubScript). The public keys are the second through
            // antepenultimate entries in the decompiledPubScript. See below for a visual representation of the typical 2-of-3
            // multisig setup:
            //
            // decompiledSigScript = 0 <sig1> <sig2> <pubScript>
            // decompiledPubScript = 2 <pub1> <pub2> <pub3> 3 OP_CHECKMULTISIG
            var signatures = decompiledSigScript.slice(0, -1);
            var pubScript = _.last(decompiledSigScript);
            var decompiledPubScript = bitcoin.script.decompile(pubScript);
            var publicKeys = decompiledPubScript.slice(1, -2);
            // Op codes 81 through 96 represent numbers 1 through 16 (see https://en.bitcoin.it/wiki/Script#Opcodes), which is
            // why we subtract by 80 to get the number of signatures (n) and the number of public keys (m) in an n-of-m setup.
            var len = decompiledPubScript.length;
            var nSignatures = decompiledPubScript[0] - 80;
            var nPubKeys = decompiledPubScript[len - 2] - 80;
            // Due to a bug in the implementation of multisignature in the bitcoin protocol, a 0 is added to the signature
            // script, so we add 1 when asserting the number of signatures matches the number of signatures expected by the
            // pub script. Also, note that we consider a signature script with the the same number of signatures as public
            // keys (+1 as noted above) valid because we use placeholder signatures when parsing a half-signed signature
            // script.
            if (signatures.length !== nSignatures + 1 && signatures.length !== nPubKeys + 1) {
                throw new Error("expected " + nSignatures + " or " + nPubKeys + " signatures, got " + (signatures.length - 1));
            }
            if (publicKeys.length !== nPubKeys) {
                throw new Error("expected " + nPubKeys + " public keys, got " + publicKeys.length);
            }
            var lastOpCode = decompiledPubScript[len - 1];
            if (lastOpCode !== bitcoin.opcodes.OP_CHECKMULTISIG) {
                throw new Error("expected opcode #" + bitcoin.opcodes.OP_CHECKMULTISIG + ", got opcode #" + lastOpCode);
            }
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification, signatures: signatures, publicKeys: publicKeys, pubScript: pubScript };
        }
        else {
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification };
        }
    };
    /**
     * Calculate the hash to verify the signature against
     * @param transaction Transaction object
     * @param inputIndex
     * @param pubScript
     * @param amount The previous output's amount
     * @param hashType
     * @param isSegwitInput
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.calculateSignatureHash = function (transaction, inputIndex, pubScript, amount, hashType, isSegwitInput) {
        if (isSegwitInput) {
            return transaction.hashForWitnessV0(inputIndex, pubScript, amount, hashType);
        }
        else {
            return transaction.hashForSignature(inputIndex, pubScript, hashType);
        }
    };
    /**
     * Verify the signature on a (half-signed) transaction
     * @param transaction bitcoinjs-lib tx object
     * @param inputIndex The input whererfore to check the signature
     * @param amount For segwit and BCH, the input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.verifySignature = function (transaction, inputIndex, amount, verificationSettings) {
        if (verificationSettings === void 0) { verificationSettings = {}; }
        var _a = this.parseSignatureScript(transaction, inputIndex), signatures = _a.signatures, publicKeys = _a.publicKeys, isSegwitInput = _a.isSegwitInput, inputClassification = _a.inputClassification, pubScript = _a.pubScript;
        if (![bitcoin.script.types.P2WSH, bitcoin.script.types.P2SH, bitcoin.script.types.P2PKH].includes(inputClassification)) {
            return false;
        }
        if (!publicKeys || publicKeys.length === 0) {
            return false;
        }
        if (isSegwitInput && !amount) {
            return false;
        }
        // get the first non-empty signature and verify it against all public keys
        var nonEmptySignatures = _.filter(signatures, function (s) { return !_.isEmpty(s); });
        /*
        We either want to verify all signature/pubkey combinations, or do an explicit combination
    
        If a signature index is specified, only that signature is checked. It's verified against all public keys.
        If a single public key is found to be valid, the function returns true.
    
        If a public key is specified, we iterate over all signatures. If a single one matches the public key, the function
        returns true.
    
        If neither is specified, all signatures are checked against all public keys. Each signature must have its own distinct
        public key that it matches for the function to return true.
         */
        var signaturesToCheck = nonEmptySignatures;
        if (!_.isUndefined(verificationSettings.signatureIndex)) {
            signaturesToCheck = [nonEmptySignatures[verificationSettings.signatureIndex]];
        }
        var publicKeyHex = verificationSettings.publicKey;
        var matchedPublicKeyIndices = {};
        var areAllSignaturesValid = true;
        // go over all signatures
        for (var _i = 0, signaturesToCheck_1 = signaturesToCheck; _i < signaturesToCheck_1.length; _i++) {
            var signatureBuffer = signaturesToCheck_1[_i];
            var isSignatureValid = false;
            var hasSignatureBuffer = Buffer.isBuffer(signatureBuffer) && signatureBuffer.length > 0;
            if (hasSignatureBuffer && Buffer.isBuffer(pubScript) && pubScript.length > 0) {
                // slice the last byte from the signature hash input because it's the hash type
                var signature = bitcoin.ECSignature.fromDER(signatureBuffer.slice(0, -1));
                var hashType = _.last(signatureBuffer);
                if (!hashType) {
                    // missing hashType byte - signature cannot be validated
                    return false;
                }
                var signatureHash = this.calculateSignatureHash(transaction, inputIndex, pubScript, amount, hashType, isSegwitInput);
                for (var publicKeyIndex = 0; publicKeyIndex < publicKeys.length; publicKeyIndex++) {
                    var publicKeyBuffer = publicKeys[publicKeyIndex];
                    if (!_.isUndefined(publicKeyHex) && publicKeyBuffer.toString('hex') !== publicKeyHex) {
                        // we are only looking to verify one specific public key's signature (publicKeyHex)
                        // this particular public key is not the one whose signature we're trying to verify
                        continue;
                    }
                    if (matchedPublicKeyIndices[publicKeyIndex]) {
                        continue;
                    }
                    var publicKey = bitcoin.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
                    if (publicKey.verify(signatureHash, signature)) {
                        isSignatureValid = true;
                        matchedPublicKeyIndices[publicKeyIndex] = true;
                        break;
                    }
                }
            }
            if (!_.isUndefined(publicKeyHex) && isSignatureValid) {
                // We were trying to see if any of the signatures was valid for the given public key. Evidently yes.
                return true;
            }
            if (!isSignatureValid && _.isUndefined(publicKeyHex)) {
                return false;
            }
            areAllSignaturesValid = isSignatureValid && areAllSignaturesValid;
        }
        return areAllSignaturesValid;
    };
    /**
     * Decompose a raw transaction into useful information, such as the total amounts,
     * change amounts, and transaction outputs.
     * @param params
     * @param callback
     */
    AbstractUtxoCoin.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txHex, transaction, id, changeAddresses, spendAmount, changeAmount, txInfo, explanation, unspentValues, inputSignatures;
            return __generator(this, function (_a) {
                txHex = _.get(params, 'txHex');
                if (!txHex || !_.isString(txHex) || !txHex.match(/^([a-f0-9]{2})+$/i)) {
                    throw new Error('invalid transaction hex, must be a valid hex string');
                }
                try {
                    transaction = bitcoin.Transaction.fromHex(txHex, self.network);
                }
                catch (e) {
                    throw new Error('failed to parse transaction hex');
                }
                id = transaction.getId();
                changeAddresses = [];
                spendAmount = 0;
                changeAmount = 0;
                txInfo = _.get(params, 'txInfo');
                if (txInfo && txInfo.changeAddresses) {
                    changeAddresses = txInfo.changeAddresses;
                }
                explanation = {
                    displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs'],
                    id: id,
                    outputs: [],
                    changeOutputs: [],
                };
                transaction.outs.forEach(function (currentOutput) {
                    var currentAddress = self.getCoinLibrary().address.fromOutputScript(currentOutput.script, self.network);
                    var currentAmount = currentOutput.value;
                    if (changeAddresses.indexOf(currentAddress) !== -1) {
                        // this is change
                        changeAmount += currentAmount;
                        explanation.changeOutputs.push({
                            address: currentAddress,
                            amount: currentAmount,
                        });
                        return;
                    }
                    spendAmount += currentAmount;
                    explanation.outputs.push({
                        address: currentAddress,
                        amount: currentAmount,
                    });
                });
                explanation.outputAmount = spendAmount;
                explanation.changeAmount = changeAmount;
                // add fee info if available
                if (params.feeInfo) {
                    explanation.displayOrder.push('fee');
                    explanation.fee = params.feeInfo;
                }
                if (_.isInteger(transaction.locktime) && transaction.locktime > 0) {
                    explanation.locktime = transaction.locktime;
                    explanation.displayOrder.push('locktime');
                }
                unspentValues = {};
                inputSignatures = transaction.ins.map(function (input, idx) {
                    var hasSigScript = !_.isEmpty(input.script);
                    var hasWitnessScript = !_.isEmpty(input.witness);
                    if (!hasSigScript && !hasWitnessScript) {
                        // no sig script or witness data for this input
                        debug('no signature script or witness script data for input %s', idx);
                        return 0;
                    }
                    var parsedSigScript;
                    try {
                        parsedSigScript = self.parseSignatureScript(transaction, idx);
                    }
                    catch (e) {
                        return false;
                    }
                    if (hasWitnessScript) {
                        if (!txInfo || !txInfo.unspents) {
                            // segwit txs require input values, cannot validate signatures
                            debug('unable to retrieve input amounts from unspents - cannot validate segwit input signatures');
                            return 0;
                        }
                        // lazily populate unspent values
                        if (_.isEmpty(unspentValues)) {
                            txInfo.unspents.forEach(function (unspent) {
                                unspentValues[unspent.id] = unspent.value;
                            });
                        }
                    }
                    var nonEmptySignatures = parsedSigScript.signatures.filter(function (sig) { return !_.isEmpty(sig); });
                    var validSignatures = nonEmptySignatures.map(function (sig, sigIndex) {
                        if (_.isEmpty(sig)) {
                            return false;
                        }
                        var parentTxId = Buffer.from(input.hash).reverse().toString('hex');
                        var inputId = parentTxId + ":" + input.index;
                        var amount = unspentValues[inputId];
                        try {
                            return self.verifySignature(transaction, idx, amount, { signatureIndex: sigIndex });
                        }
                        catch (e) {
                            return false;
                        }
                    });
                    return validSignatures.reduce(function (validCount, isValid) { return isValid ? validCount + 1 : validCount; }, 0);
                });
                explanation.inputSignatures = inputSignatures;
                explanation.signatures = _.max(inputSignatures);
                return [2 /*return*/, explanation];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Create a multisig address of a given type from a list of keychains and a signing threshold
     * @param addressType
     * @param signatureThreshold
     * @param keys
     */
    AbstractUtxoCoin.prototype.createMultiSigAddress = function (addressType, signatureThreshold, keys) {
        function createWitnessProgram(inputScript) {
            var witnessScriptHash = bitcoin.crypto.sha256(inputScript);
            return bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
        }
        var multiSigScript = bitcoin.script.multisig.output.encode(signatureThreshold, keys);
        var outputScript, redeemScript, witnessScript;
        switch (addressType) {
            case unspents_1.Codes.UnspentTypeTcomb('p2sh'):
                var multisigScriptHash = bitcoin.crypto.hash160(multiSigScript);
                outputScript = bitcoin.script.scriptHash.output.encode(multisigScriptHash);
                redeemScript = multiSigScript;
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh'):
                var witnessProgram = createWitnessProgram(multiSigScript);
                var witnessProgramHash = bitcoin.crypto.hash160(witnessProgram);
                outputScript = bitcoin.script.scriptHash.output.encode(witnessProgramHash);
                redeemScript = witnessProgram;
                witnessScript = multiSigScript;
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2wsh'):
                outputScript = createWitnessProgram(multiSigScript);
                witnessScript = multiSigScript;
                break;
            default:
                throw new Error("unexpected addressType " + addressType);
        }
        return {
            outputScript: outputScript,
            redeemScript: redeemScript,
            witnessScript: witnessScript,
            address: bitcoin.address.fromOutputScript(outputScript, this.network),
        };
    };
    /**
     * @param scriptHashScript
     * @deprecated
     */
    // TODO(BG-11638): remove in next SDK major version release
    AbstractUtxoCoin.prototype.calculateRecoveryAddress = function (scriptHashScript) {
        return this.getCoinLibrary().address.fromOutputScript(scriptHashScript, this.network);
    };
    /**
     * Get a static fee rate which is used in recovery situations
     * @deprecated
     */
    AbstractUtxoCoin.prototype.getRecoveryFeePerBytes = function () {
        return Bluebird.resolve(100);
    };
    /**
     * Get a url which can be used for determining recovery fee rates
     */
    AbstractUtxoCoin.prototype.getRecoveryFeeRecommendationApiBaseUrl = function () {
        return Bluebird.reject(new Error('AbtractUtxoCoin method not implemented'));
    };
    /**
     * Get the current market price from a third party to be used for recovery
     */
    AbstractUtxoCoin.prototype.getRecoveryMarketPrice = function () {
        var self = this;
        return co(function getRecoveryMarketPrice() {
            var bitcoinAverageUrl, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bitcoinAverageUrl = config.bitcoinAverageBaseUrl + self.getFamily().toUpperCase() + 'USD';
                        return [4 /*yield*/, request.get(bitcoinAverageUrl).retry(2).result()];
                    case 1:
                        response = _a.sent();
                        if (response === null || typeof response.last !== 'number') {
                            throw new Error('unable to reach BitcoinAverage for price data');
                        }
                        return [2 /*return*/, response.last];
                }
            });
        }).call(this);
    };
    /**
     * Helper function for recover()
     * This transforms the txInfo from recover into the format that offline-signing-tool expects
     * @param txInfo
     * @param txHex
     * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
     */
    AbstractUtxoCoin.prototype.formatForOfflineVault = function (txInfo, txHex) {
        var response = {
            txHex: txHex,
            txInfo: {
                unspents: txInfo.inputs,
            },
            feeInfo: {},
            coin: this.getChain(),
        };
        _.map(response.txInfo.unspents, function (unspent) {
            var pathArray = unspent.chainPath.split('/');
            // Note this code works because we assume our chainPath is m/0/0/chain/index - this will be incorrect for custom derivation schemes
            unspent.index = pathArray[4];
            unspent.chain = pathArray[3];
        });
        return response;
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] xprv, or xpub
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * - scan: the amount of consecutive addresses without unspents to scan through before stopping
     * - ignoreAddressTypes: (optional) array of AddressTypes to ignore, these are strings defined in Codes.UnspentTypeTcomb
     *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
     * @param callback
     */
    AbstractUtxoCoin.prototype.recover = function (params, callback) {
        var self = this;
        return co(function recover() {
            // ============================HELPER FUNCTIONS============================
            function deriveKeys(keyArray, index) {
                return keyArray.map(function (k) { return k.derive(index); });
            }
            function queryBlockchainUnspentsPath(keyArray, basePath, addressesById) {
                return co(function () {
                    var MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS, numSequentialAddressesWithoutTxs, gatherUnspents, walletUnspents;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS = params.scan || 20;
                                numSequentialAddressesWithoutTxs = 0;
                                gatherUnspents = co(function coGatherUnspents(addrIndex) {
                                    var derivedKeys, chain, keys, address, addrInfo, addressUnspents;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                derivedKeys = deriveKeys(keyArray, addrIndex);
                                                chain = Number(basePath.split('/').pop());
                                                keys = derivedKeys.map(function (k) { return k.getPublicKeyBuffer(); });
                                                address = self.createMultiSigAddress(unspents_1.Codes.typeForCode(chain), 2, keys);
                                                return [4 /*yield*/, self.getAddressInfoFromExplorer(address.address)];
                                            case 1:
                                                addrInfo = _a.sent();
                                                if (!(addrInfo.txCount === 0)) return [3 /*break*/, 2];
                                                numSequentialAddressesWithoutTxs++;
                                                return [3 /*break*/, 4];
                                            case 2:
                                                numSequentialAddressesWithoutTxs = 0;
                                                if (!(addrInfo.totalBalance > 0)) return [3 /*break*/, 4];
                                                // This address has a balance.
                                                address.chainPath = basePath + '/' + addrIndex;
                                                address.userKey = derivedKeys[0];
                                                address.backupKey = derivedKeys[1];
                                                addressesById[address.address] = address;
                                                return [4 /*yield*/, self.getUnspentInfoFromExplorer(address.address)];
                                            case 3:
                                                addressUnspents = _a.sent();
                                                addressUnspents.forEach(function addAddressToUnspent(unspent) {
                                                    unspent.address = address.address;
                                                    walletUnspents.push(unspent);
                                                });
                                                _a.label = 4;
                                            case 4:
                                                if (numSequentialAddressesWithoutTxs >= MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS) {
                                                    // stop searching for addresses with unspents in them, we've found 5 in a row with none
                                                    // we are done
                                                    return [2 /*return*/];
                                                }
                                                return [2 /*return*/, gatherUnspents(addrIndex + 1)];
                                        }
                                    });
                                });
                                walletUnspents = [];
                                // This will populate walletAddresses
                                return [4 /*yield*/, gatherUnspents(0)];
                            case 1:
                                // This will populate walletAddresses
                                _a.sent();
                                if (walletUnspents.length === 0) {
                                    // Couldn't find any addresses with funds
                                    return [2 /*return*/, []];
                                }
                                return [2 /*return*/, walletUnspents];
                        }
                    });
                }).call(this);
            }
            var isKrsRecovery, isUnsignedSweep, krsProvider, keys, baseKeyPath, queries, addressesById, queryResponses, unspents, totalInputAmount, transactionBuilder, txInfo, feePerByte, outputSize, approximateSize, approximateFee, recoveryAmount, krsFee, err_1, krsFeeAddress, txHex, signedTx, _a, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        // ============================LOGIC============================
                        if (_.isUndefined(params.userKey)) {
                            throw new Error('missing userKey');
                        }
                        if (_.isUndefined(params.backupKey)) {
                            throw new Error('missing backupKey');
                        }
                        if (_.isUndefined(params.recoveryDestination) || !self.isValidAddress(params.recoveryDestination)) {
                            throw new Error('invalid recoveryDestination');
                        }
                        if (!_.isUndefined(params.scan) && (!_.isInteger(params.scan) || params.scan < 0)) {
                            throw new Error('scan must be a positive integer');
                        }
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        krsProvider = config.krsProviders[params.krsProvider];
                        if (isKrsRecovery && _.isUndefined(krsProvider)) {
                            throw new Error('unknown key recovery service provider');
                        }
                        if (isKrsRecovery && !(krsProvider.supportedCoins.includes(self.getFamily()))) {
                            throw new Error('specified key recovery service does not support recoveries for this coin');
                        }
                        return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        keys = _b.sent();
                        baseKeyPath = deriveKeys(deriveKeys(keys, 0), 0);
                        queries = [];
                        addressesById = {};
                        _.forEach(Object.keys(unspents_1.Codes.UnspentTypeTcomb.meta.map), function (addressType) {
                            // If we aren't ignoring the address type, we derive the public key and construct the query for the external and
                            // internal indices
                            if (!_.includes(params.ignoreAddressTypes, addressType)) {
                                if (addressType === unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh') && !self.supportsP2shP2wsh()) {
                                    // P2shP2wsh is not supported. Skip.
                                    return;
                                }
                                if (addressType === unspents_1.Codes.UnspentTypeTcomb('p2wsh') && !self.supportsP2wsh()) {
                                    // P2wsh is not supported. Skip.
                                    return;
                                }
                                var codes = void 0;
                                try {
                                    codes = unspents_1.Codes.forType(unspents_1.Codes.UnspentTypeTcomb(addressType));
                                }
                                catch (e) {
                                    // The unspent type is not supported by bitgo so attempting to get its chain codes throws. Catch that error
                                    // and continue.
                                    return;
                                }
                                var externalChainCode = codes.external;
                                var internalChainCode = codes.internal;
                                var externalKey = deriveKeys(baseKeyPath, externalChainCode);
                                var internalKey = deriveKeys(baseKeyPath, internalChainCode);
                                queries.push(queryBlockchainUnspentsPath(externalKey, '/0/0/' + externalChainCode, addressesById));
                                queries.push(queryBlockchainUnspentsPath(internalKey, '/0/0/' + internalChainCode, addressesById));
                            }
                        });
                        return [4 /*yield*/, Promise.all(queries)];
                    case 2:
                        queryResponses = _b.sent();
                        unspents = _.flatten(queryResponses);
                        totalInputAmount = _.sumBy(unspents, 'amount');
                        if (totalInputAmount <= 0) {
                            throw new Error('No input to recover - aborting!');
                        }
                        transactionBuilder = new bitcoin.TransactionBuilder(self.network);
                        self.prepareTransactionBuilder(transactionBuilder);
                        txInfo = {};
                        return [4 /*yield*/, self.getRecoveryFeePerBytes()];
                    case 3:
                        feePerByte = _b.sent();
                        outputSize = (isKrsRecovery ? 2 : 1) * unspents_1.VirtualSizes.txP2wshOutputSize;
                        approximateSize = unspents_1.VirtualSizes.txSegOverheadVSize + outputSize + (unspents_1.VirtualSizes.txP2shInputSize * unspents.length);
                        approximateFee = approximateSize * feePerByte;
                        // Construct a transaction
                        txInfo.inputs = unspents.map(function addInputForUnspent(unspent) {
                            var address = addressesById[unspent.address];
                            transactionBuilder.addInput(unspent.txid, unspent.n, 0xffffffff, address.outputScript);
                            return {
                                chainPath: address.chainPath,
                                redeemScript: address.redeemScript && address.redeemScript.toString('hex'),
                                witnessScript: address.witnessScript && address.witnessScript.toString('hex'),
                                value: unspent.amount,
                            };
                        });
                        recoveryAmount = totalInputAmount - approximateFee;
                        if (!isKrsRecovery) return [3 /*break*/, 7];
                        _b.label = 4;
                    case 4:
                        _b.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, self.calculateFeeAmount({ provider: params.krsProvider, amount: recoveryAmount })];
                    case 5:
                        krsFee = _b.sent();
                        recoveryAmount -= krsFee;
                        return [3 /*break*/, 7];
                    case 6:
                        err_1 = _b.sent();
                        // Don't let this error block the recovery - 
                        console.dir(err_1);
                        return [3 /*break*/, 7];
                    case 7:
                        if (recoveryAmount < 0) {
                            throw new Error('this wallet\'s balance is too low to pay the fees specified by the KRS provider');
                        }
                        transactionBuilder.addOutput(params.recoveryDestination, recoveryAmount);
                        if (isKrsRecovery && krsFee > 0) {
                            krsFeeAddress = krsProvider.feeAddresses[self.getChain()];
                            if (!krsFeeAddress) {
                                throw new Error('this KRS provider has not configured their fee structure yet - recovery cannot be completed');
                            }
                            transactionBuilder.addOutput(krsFeeAddress, krsFee);
                        }
                        if (!isUnsignedSweep) return [3 /*break*/, 8];
                        txHex = transactionBuilder.buildIncomplete().toBuffer().toString('hex');
                        return [2 /*return*/, self.formatForOfflineVault(txInfo, txHex)];
                    case 8:
                        signedTx = self.signRecoveryTransaction(transactionBuilder, unspents, addressesById, !isKrsRecovery);
                        txInfo.transactionHex = signedTx.build().toBuffer().toString('hex');
                        _b.label = 9;
                    case 9:
                        _b.trys.push([9, 11, , 12]);
                        _a = txInfo;
                        return [4 /*yield*/, self.verifyRecoveryTransaction(txInfo)];
                    case 10:
                        _a.tx = _b.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        e_2 = _b.sent();
                        if (!(e_2 instanceof errors.MethodNotImplementedError)) {
                            // some coins don't have a reliable third party verification endpoint, so we continue without verification for those coins
                            throw new Error('could not verify recovery transaction');
                        }
                        return [3 /*break*/, 12];
                    case 12:
                        if (isKrsRecovery) {
                            txInfo.coin = self.getChain();
                            txInfo.backupKey = params.backupKey;
                            txInfo.recoveryAmount = recoveryAmount;
                        }
                        return [2 /*return*/, txInfo];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Apply signatures to a funds recovery transaction using user + backup key
     * @param txb {Object} a transaction builder object (with inputs and outputs)
     * @param unspents {Array} the unspents to use in the transaction
     * @param addresses {Array} the address and redeem script info for the unspents
     * @param cosign {Boolean} whether to cosign this transaction with the user's backup key (false if KRS recovery)
     * @returns the transaction builder originally passed in as the first argument
     */
    AbstractUtxoCoin.prototype.signRecoveryTransaction = function (txb, unspents, addresses, cosign) {
        var _this = this;
        var signatureIssues = [];
        unspents.forEach(function (unspent, i) {
            var address = addresses[unspent.address];
            var backupPrivateKey = address.backupKey.keyPair;
            var userPrivateKey = address.userKey.keyPair;
            // force-override networks
            backupPrivateKey.network = _this.network;
            userPrivateKey.network = _this.network;
            var currentSignatureIssue = {
                inputIndex: i,
                unspent: unspent,
                error: null,
            };
            if (cosign) {
                try {
                    txb.sign(i, backupPrivateKey, address.redeemScript, _this.defaultSigHashType, unspent.amount, address.witnessScript);
                }
                catch (e) {
                    currentSignatureIssue.error = e;
                    signatureIssues.push(currentSignatureIssue);
                }
            }
            try {
                txb.sign(i, userPrivateKey, address.redeemScript, _this.defaultSigHashType, unspent.amount, address.witnessScript);
            }
            catch (e) {
                currentSignatureIssue.error = e;
                signatureIssues.push(currentSignatureIssue);
            }
        });
        if (signatureIssues.length > 0) {
            var failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
            var error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
            error.code = 'input_signature_failure';
            error.signingErrors = signatureIssues;
            throw error;
        }
        return txb;
    };
    /**
     * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
     * @param params
     * @param params.provider {String} the KRS provider that holds the backup key
     * @param params.amount {Number} amount (in base units) to be recovered
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.calculateFeeAmount = function (params, callback) {
        var self = this;
        return co(function calculateFeeAmount() {
            var krsProvider, feeAmountUsd, currentPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        krsProvider = config.krsProviders[params.provider];
                        if (krsProvider === undefined) {
                            throw new Error("no fee structure specified for provider " + params.provider);
                        }
                        if (!(krsProvider.feeType === 'flatUsd')) return [3 /*break*/, 2];
                        feeAmountUsd = krsProvider.feeAmount;
                        return [4 /*yield*/, self.getRecoveryMarketPrice()];
                    case 1:
                        currentPrice = _a.sent();
                        return [2 /*return*/, Math.round(feeAmountUsd / currentPrice * self.getBaseFactor())];
                    case 2: 
                    // we can add more fee structures here as needed for different providers, such as percentage of recovery amount
                    throw new Error('Fee structure not implemented');
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Recover BTC that was sent to the wrong chain
     * @param params
     * @param params.txid The txid of the faulty transaction
     * @param params.recoveryAddress address to send recovered funds to
     * @param params.wallet the wallet that received the funds
     * @param params.recoveryCoin the coin type of the wallet that received the funds
     * @param params.signed return a half-signed transaction (default=true)
     * @param params.walletPassphrase the wallet passphrase
     * @param params.xprv the unencrypted xprv (used instead of wallet passphrase)
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.recoverFromWrongChain = function (params, callback) {
        var self = this;
        return co(function recoverFromWrongChain() {
            var txid, recoveryAddress, wallet, walletPassphrase, xprv, recoveryCoin, signed, sourceCoinFamily, recoveryCoinFamily, supportedRecoveryCoins, recoveryTool;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txid = params.txid, recoveryAddress = params.recoveryAddress, wallet = params.wallet, walletPassphrase = params.walletPassphrase, xprv = params.xprv;
                        recoveryCoin = params.coin || params.recoveryCoin;
                        if (!recoveryCoin) {
                            throw new Error('missing required object recoveryCoin');
                        }
                        signed = params.signed !== false;
                        sourceCoinFamily = self.getFamily();
                        recoveryCoinFamily = recoveryCoin.getFamily();
                        supportedRecoveryCoins = config.supportedCrossChainRecoveries[sourceCoinFamily];
                        if (_.isUndefined(supportedRecoveryCoins) || !supportedRecoveryCoins.includes(recoveryCoinFamily)) {
                            throw new Error("Recovery of " + sourceCoinFamily + " balances from " + recoveryCoinFamily + " wallets is not supported.");
                        }
                        recoveryTool = new recovery_1.CrossChainRecoveryTool({
                            bitgo: self.bitgo,
                            sourceCoin: self,
                            recoveryCoin: recoveryCoin,
                            logging: false,
                        });
                        return [4 /*yield*/, recoveryTool.buildTransaction({
                                wallet: wallet,
                                faultyTxId: txid,
                                recoveryAddress: recoveryAddress,
                            })];
                    case 1:
                        _a.sent();
                        if (!signed) return [3 /*break*/, 3];
                        return [4 /*yield*/, recoveryTool.signTransaction({ passphrase: walletPassphrase, prv: xprv })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, recoveryTool.export()];
                    case 3: return [4 /*yield*/, recoveryTool.buildUnsigned()];
                    case 4: return [2 /*return*/, _a.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    AbstractUtxoCoin.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = bitcoin.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    AbstractUtxoCoin.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    AbstractUtxoCoin.prototype.preCreateBitGo = function (params) { };
    AbstractUtxoCoin.prototype.presignTransaction = function (params, callback) {
        return Bluebird.resolve(params).asCallback(callback);
    };
    AbstractUtxoCoin.prototype.supplementGenerateWallet = function (walletParams, keychains) {
        return Bluebird.resolve(walletParams);
    };
    AbstractUtxoCoin.prototype.transactionDataAllowed = function () {
        return false;
    };
    AbstractUtxoCoin.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    AbstractUtxoCoin.prototype.verifyRecoveryTransaction = function (txInfo) {
        return Bluebird.reject(new errors.MethodNotImplementedError());
    };
    AbstractUtxoCoin.prototype.signMessage = function (key, message) {
        var privateKey = bitcoin.HDNode.fromBase58(key.prv).getKey();
        var privateKeyBuffer = privateKey.d.toBuffer(32);
        var isCompressed = privateKey.compressed;
        var prefix = bitcoin.networks.bitcoin.messagePrefix;
        return bitcoinMessage.sign(message, privateKeyBuffer, isCompressed, prefix);
    };
    return AbstractUtxoCoin;
}(baseCoin_1.BaseCoin));
exports.AbstractUtxoCoin = AbstractUtxoCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3RVdHhvQ29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9hYnN0cmFjdFV0eG9Db2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHdDQUEwQztBQUMxQyxrREFBb0Q7QUFDcEQsbUNBQXFDO0FBQ3JDLCtCQUFpQztBQUNqQyxvQ0FBc0M7QUFDdEMsMEJBQTRCO0FBQzVCLGdDQUFrQztBQUNsQyw0Q0FBc0Q7QUFDdEQsb0RBQXlEO0FBRXpELHlDQUF1QztBQUV2Qyx3Q0FTcUI7QUFDckIsMENBQW9EO0FBRXBELHFDQUF1QztBQUN2Qyx3Q0FBcUQ7QUFDckQscUNBQXVDO0FBSXZDLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUN4QyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBMkw5QjtJQUErQyxvQ0FBUTtJQUtyRCwwQkFBc0IsS0FBWSxFQUFFLE9BQW9CO1FBQXhELFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBS2I7UUFKQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUM7UUFDRCxLQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQzs7SUFDMUIsQ0FBQztJQUVELHNCQUFJLHFDQUFPO2FBQVg7WUFDRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBVyxxQ0FBaUI7YUFBNUI7WUFDRSxJQUFNLGlCQUFpQixHQUFrQixFQUFFLENBQUM7WUFDNUMsaURBQWlEO1lBQ2pELDhFQUE4RTtZQUM5RSw2Q0FBNkM7WUFDN0MsSUFBTSxlQUFlLEdBQWEsTUFBTSxDQUFDLElBQUksQ0FBQyxtQkFB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QztRQUNuRCxJQUFNLFlBQVksR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDO1FBQzNDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztRQUN0RCxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBQ0gsdUJBQUM7QUFBRCxDQUFDLEFBeHZERCxDQUErQyxtQkFBUSxHQXd2RHREO0FBeHZEcUIsNENBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYml0Y29pbiBmcm9tICdiaXRnby11dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBiaXRjb2luTWVzc2FnZSBmcm9tICdiaXRjb2luanMtbWVzc2FnZSc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBkZWJ1Z0xpYiBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBDb2RlcywgVmlydHVhbFNpemVzIH0gZnJvbSAnQGJpdGdvL3Vuc3BlbnRzJztcbmltcG9ydCB7IFVuc3BlbnRUeXBlIH0gZnJvbSAnQGJpdGdvL3Vuc3BlbnRzL2Rpc3QvY29kZXMnO1xuXG5pbXBvcnQgeyBoZFBhdGggfSBmcm9tICcuLi8uLi9iaXRjb2luJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sIEFkZHJlc3NDb2luU3BlY2lmaWMsXG4gIEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLCBLZXljaGFpbnNUcmlwbGV0LFxuICBQcmVjcmVhdGVCaXRHb09wdGlvbnMsIFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsIFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zIGFzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5UmVjb3ZlcnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25QYXJhbXMgYXMgQmFzZVRyYW5zYWN0aW9uUGFyYW1zLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLCBWZXJpZmljYXRpb25PcHRpb25zLCBUcmFuc2FjdGlvblJlY2lwaWVudCxcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgS2V5Y2hhaW4sIEtleUluZGljZXMgfSBmcm9tICcuLi9rZXljaGFpbnMnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gJy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBDcm9zc0NoYWluUmVjb3ZlcnlUb29sIH0gZnJvbSAnLi4vcmVjb3ZlcnknO1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vaW50ZXJuYWwvdXRpbCc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2Mjp1dHhvJyk7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlBZGRyZXNzT3B0aW9ucyBleHRlbmRzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyB7XG4gIGNoYWluOiBudW1iZXI7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0IHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBhbW91bnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgZXh0ZXJuYWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uRmVlIHtcbiAgZmVlOiBudW1iZXI7XG4gIGZlZVJhdGU/OiBudW1iZXI7XG4gIHNpemU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBkaXNwbGF5T3JkZXI6IHN0cmluZ1tdO1xuICBpZDogc3RyaW5nO1xuICBvdXRwdXRzOiBPdXRwdXRbXSxcbiAgY2hhbmdlT3V0cHV0czogT3V0cHV0W10sXG4gIG91dHB1dEFtb3VudDogc3RyaW5nO1xuICBjaGFuZ2VBbW91bnQ6IG51bWJlcjtcbiAgZmVlOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbnNwZW50IHtcbiAgaWQ6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvPzogeyBjaGFuZ2VBZGRyZXNzZXM6IHN0cmluZ1tdLCB1bnNwZW50czogVW5zcGVudFtdIH07XG4gIGZlZUluZm8/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXR4b05ldHdvcmsge1xuICBwdWJLZXlIYXNoOiBudW1iZXI7XG4gIHNjcmlwdEhhc2g6IG51bWJlcjtcbiAgYWx0U2NyaXB0SGFzaD86IG51bWJlcjtcbiAgYmVjaDMyOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkU2lnbmF0dXJlU2NyaXB0IHtcbiAgaXNTZWd3aXRJbnB1dDogYm9vbGVhbjtcbiAgaW5wdXRDbGFzc2lmaWNhdGlvbjogc3RyaW5nO1xuICBzaWduYXR1cmVzPzogQnVmZmVyW107XG4gIHB1YmxpY0tleXM/OiBCdWZmZXJbXTtcbiAgcHViU2NyaXB0PzogQnVmZmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SW5mbz86IGFueTtcbiAgYmxvY2tIZWlnaHQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QYXJhbXMgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QYXJhbXMge1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBjaGFuZ2VBZGRyZXNzPzogc3RyaW5nO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXM7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHdhbGxldDogV2FsbGV0O1xuICB2ZXJpZmljYXRpb24/OiBWZXJpZmljYXRpb25PcHRpb25zO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkVHJhbnNhY3Rpb24ge1xuICBrZXljaGFpbnM6IHtcbiAgICB1c2VyPzogS2V5Y2hhaW4sXG4gICAgYmFja3VwPzogS2V5Y2hhaW4sXG4gICAgYml0Z28/OiBLZXljaGFpbixcbiAgfTtcbiAga2V5U2lnbmF0dXJlczogYW55W107XG4gIG91dHB1dHM6IE91dHB1dFtdO1xuICBtaXNzaW5nT3V0cHV0czogT3V0cHV0W107XG4gIGV4cGxpY2l0RXh0ZXJuYWxPdXRwdXRzOiBPdXRwdXRbXTtcbiAgaW1wbGljaXRFeHRlcm5hbE91dHB1dHM6IE91dHB1dFtdO1xuICBjaGFuZ2VPdXRwdXRzOiBPdXRwdXRbXTtcbiAgZXhwbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50OiBudW1iZXI7XG4gIGltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlQWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzVHlwZT86IHN0cmluZztcbiAga2V5Y2hhaW5zOiB7XG4gICAgcHViOiBzdHJpbmc7XG4gICAgYXNwS2V5SWQ/OiBzdHJpbmc7XG4gIH1bXTtcbiAgdGhyZXNob2xkOiBudW1iZXI7XG4gIGNoYWluPzogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xuICBzZWd3aXQ/OiBib29sZWFuO1xuICBiZWNoMzI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NEZXRhaWxzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBjaGFpbjogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xuICBjb2luOiBzdHJpbmc7XG4gIGNvaW5TcGVjaWZpYzogQWRkcmVzc0NvaW5TcGVjaWZpYztcbiAgYWRkcmVzc1R5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICAgIHR4SW5mbzoge1xuICAgICAgdW5zcGVudHM6IHtcbiAgICAgICAgY2hhaW4/OiBudW1iZXI7XG4gICAgICAgIGluZGV4PzogbnVtYmVyO1xuICAgICAgICB2YWx1ZT86IG51bWJlcjtcbiAgICAgICAgYWRkcmVzcz86IHN0cmluZztcbiAgICAgICAgcmVkZWVtU2NyaXB0Pzogc3RyaW5nO1xuICAgICAgICB3aXRuZXNzU2NyaXB0Pzogc3RyaW5nO1xuICAgICAgfVtdO1xuICAgIH1cbiAgfTtcbiAgcHJ2OiBzdHJpbmc7XG4gIGlzTGFzdFNpZ25hdHVyZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTXVsdGlTaWdBZGRyZXNzIHtcbiAgb3V0cHV0U2NyaXB0OiBCdWZmZXI7XG4gIHJlZGVlbVNjcmlwdDogQnVmZmVyO1xuICB3aXRuZXNzU2NyaXB0OiBCdWZmZXI7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPZmZsaW5lVmF1bHRUeEluZm8ge1xuICBpbnB1dHM6IHtcbiAgICBjaGFpblBhdGg6IHN0cmluZztcbiAgfVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJGcm9tV3JvbmdDaGFpbk9wdGlvbnMge1xuICB0eGlkOiBzdHJpbmc7XG4gIHJlY292ZXJ5QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICB4cHJ2OiBzdHJpbmc7XG4gIGNvaW4/OiBBYnN0cmFjdFV0eG9Db2luO1xuICByZWNvdmVyeUNvaW4/OiBBYnN0cmFjdFV0eG9Db2luO1xuICBzaWduZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHRlZE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIHR4SW5mbzoge1xuICAgIHVuc3BlbnRzOiB7XG4gICAgICBjaGFpblBhdGg6IHN0cmluZztcbiAgICAgIGluZGV4Pzogc3RyaW5nO1xuICAgICAgY2hhaW4/OiBzdHJpbmc7XG4gICAgfVtdO1xuICB9O1xuICB0eEhleDogc3RyaW5nO1xuICBmZWVJbmZvOiB7fTtcbiAgY29pbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NJbmZvIHtcbiAgdHhDb3VudDogbnVtYmVyO1xuICB0b3RhbEJhbGFuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbnNwZW50SW5mbyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyUGFyYW1zIHtcbiAgc2Nhbj86IG51bWJlcjtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBrcnNQcm92aWRlcjogc3RyaW5nO1xuICBpZ25vcmVBZGRyZXNzVHlwZXM6IHN0cmluZ1tdO1xuICBiaXRnb0tleTogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RVdHhvQ29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIGFsdFNjcmlwdEhhc2g/OiBudW1iZXI7XG4gIHB1YmxpYyBzdXBwb3J0QWx0U2NyaXB0RGVzdGluYXRpb24/OiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IF9uZXR3b3JrOiBVdHhvTmV0d29yaztcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBuZXR3b3JrOiBVdHhvTmV0d29yaykge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICBpZiAoIV8uaXNPYmplY3QobmV0d29yaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbmV0d29yayBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICB0aGlzLl9uZXR3b3JrID0gbmV0d29yaztcbiAgfVxuXG4gIGdldCBuZXR3b3JrKCkge1xuICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICB9XG5cbiAgc3RhdGljIGdldCB2YWxpZEFkZHJlc3NUeXBlcygpOiBVbnNwZW50VHlwZVtdIHtcbiAgICBjb25zdCB2YWxpZEFkZHJlc3NUeXBlczogVW5zcGVudFR5cGVbXSA9IFtdO1xuICAgIC8vIGJlc3Qgd2F5IEkgY291bGQgZmluZCB0byBsb29wIG92ZXIgZW51bSB2YWx1ZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MTk4I2lzc3VlY29tbWVudC00MjM4MzY2NThcbiAgICAvLyB0aGlzIGlzIGEgdHlwZXNjcmlwdCByb3VnaCBjb3JuZXIgZm9yIHN1cmVcbiAgICBjb25zdCB1bnNwZW50VHlwZUtleXM6IHN0cmluZ1tdID0gT2JqZWN0LmtleXMoVW5zcGVudFR5cGUpO1xuICAgIGNvbnN0IHVuc3BlbnRUeXBlczogVW5zcGVudFR5cGVbXSA9IHVuc3BlbnRUeXBlS2V5c1xuICAgICAgLm1hcChrID0+IFVuc3BlbnRUeXBlW2sgYXMgYW55XSlcbiAgICAgIC5tYXAodiA9PiB2IGFzIFVuc3BlbnRUeXBlKTtcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3NUeXBlIG9mIHVuc3BlbnRUeXBlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgQ29kZXMuZm9yVHlwZShhZGRyZXNzVHlwZSk7XG4gICAgICAgIHZhbGlkQWRkcmVzc1R5cGVzLnB1c2goYWRkcmVzc1R5cGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLiBDb2Rlcy5mb3JUeXBlIHdpbGwgdGhyb3cgaWYgdGhlIGFkZHJlc3MgdHlwZSBoYXMgbm8gY2hhaW4gY29kZXMsIG1lYW5pbmcgaXQgaXMgaW52YWxpZCBvbiB0aGVcbiAgICAgICAgLy8gQml0R28gcGxhdGZvcm0gYW5kIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gdGhlIHZhbGlkQWRkcmVzc1R5cGVzIGFycmF5LlxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRBZGRyZXNzVHlwZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmFjdG9yIGJldHdlZW4gdGhlIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gMWU4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiB0aGUgbGlicmFyeSB3aGljaCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGxvdy1sZXZlbCBvcGVyYXRpb25zIGZvciB0aGlzIGNvaW5cbiAgICovXG4gIGdldENvaW5MaWJyYXJ5KCkge1xuICAgIHJldHVybiBiaXRjb2luO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBnZXQgdGhlIHZlcnNpb24gbnVtYmVyIGZvciBhbiBhZGRyZXNzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QWRkcmVzc1ZlcnNpb24oYWRkcmVzczogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICAvLyB0cnkgZGVjb2RpbmcgYXMgYmFzZTU4IGZpcnN0XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gdGhpcy5nZXRDb2luTGlicmFyeSgpLmFkZHJlc3MuZnJvbUJhc2U1OENoZWNrKGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgdGhhdCBmYWlscywgYW5kIHdlIGFyZW4ndCBzdXBwb3J0aW5nIHAyd3NoLCB0aGVuIHdlIGFyZSBkb25lIGFuZCBkaWQgbm90IGZpbmQgYSB2ZXJzaW9uXG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNQMndzaCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIHRyeSBkZWNvZGluZyBhcyBiZWNoMzJcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2ZXJzaW9uLCBwcmVmaXggfSA9IHRoaXMuZ2V0Q29pbkxpYnJhcnkoKS5hZGRyZXNzLmZyb21CZWNoMzIoYWRkcmVzcyk7XG4gICAgICBpZiAoXy5pc1N0cmluZyh0aGlzLm5ldHdvcmsuYmVjaDMyKSAmJiBwcmVmaXggPT09IHRoaXMubmV0d29yay5iZWNoMzIpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWdub3JlIGVycm9ycywganVzdCBmYWxsIHRocm91Z2ggYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGdldCB0aGUgYmVjaDMyIHByZWZpeCBmb3IgYW4gYWRkcmVzc1xuICAgKi9cbiAgcHJvdGVjdGVkIGdldEFkZHJlc3NQcmVmaXgoYWRkcmVzczogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBvdGhlcndpc2UsIHRyeSBkZWNvZGluZyBhcyBiZWNoMzJcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHRoaXMuZ2V0Q29pbkxpYnJhcnkoKS5hZGRyZXNzLmZyb21CZWNoMzIoYWRkcmVzcyk7XG4gICAgICByZXR1cm4gcHJlZml4O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlnbm9yZSBlcnJvcnMsIGp1c3QgZmFsbCB0aHJvdWdoIGFuZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGFkZHJlc3MgaXMgdmFsaWRcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICogQHBhcmFtIGZvcmNlQWx0U2NyaXB0U3VwcG9ydFxuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBmb3JjZUFsdFNjcmlwdFN1cHBvcnQgPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHZhbGlkVmVyc2lvbnMgPSBbXG4gICAgICB0aGlzLm5ldHdvcmsucHViS2V5SGFzaCxcbiAgICAgIHRoaXMubmV0d29yay5zY3JpcHRIYXNoLFxuICAgIF07XG4gICAgaWYgKHRoaXMuYWx0U2NyaXB0SGFzaCAmJiAoZm9yY2VBbHRTY3JpcHRTdXBwb3J0IHx8IHRoaXMuc3VwcG9ydEFsdFNjcmlwdERlc3RpbmF0aW9uKSkge1xuICAgICAgdmFsaWRWZXJzaW9ucy5wdXNoKHRoaXMuYWx0U2NyaXB0SGFzaCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc1ZlcnNpb24gPSB0aGlzLmdldEFkZHJlc3NWZXJzaW9uKGFkZHJlc3MpO1xuXG4gICAgLy8gdGhlIGFkZHJlc3MgdmVyc2lvbiBuZWVkcyB0byBiZSBhbW9uZyB0aGUgdmFsaWQgb25lc1xuICAgIGNvbnN0IGFkZHJlc3NWZXJzaW9uVmFsaWQgPSBfLmlzTnVtYmVyKGFkZHJlc3NWZXJzaW9uKSAmJiB2YWxpZFZlcnNpb25zLmluY2x1ZGVzKGFkZHJlc3NWZXJzaW9uKTtcbiAgICBjb25zdCBhZGRyZXNzUHJlZml4ID0gdGhpcy5nZXRBZGRyZXNzUHJlZml4KGFkZHJlc3MpO1xuXG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzUDJ3c2goKSB8fCBfLmlzVW5kZWZpbmVkKGFkZHJlc3NQcmVmaXgpKSB7XG4gICAgICByZXR1cm4gYWRkcmVzc1ZlcnNpb25WYWxpZDtcbiAgICB9XG5cbiAgICAvLyBhZGRyZXNzIGhhcyBhIHBvdGVudGlhbCBiZWNoMzIgcHJlZml4LCB2YWxpZGF0ZSB0aGF0XG4gICAgcmV0dXJuIF8uaXNTdHJpbmcodGhpcy5uZXR3b3JrLmJlY2gzMikgJiYgdGhpcy5uZXR3b3JrLmJlY2gzMiA9PT0gYWRkcmVzc1ByZWZpeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChwdWIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhdGVzdCBibG9jayBoZWlnaHRcbiAgICogQHBhcmFtIHJlcUlkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0TGF0ZXN0QmxvY2tIZWlnaHQocmVxSWQ/OiBSZXF1ZXN0VHJhY2VyLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxudW1iZXI+KTogQmx1ZWJpcmQ8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPG51bWJlcj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmIChyZXFJZCkge1xuICAgICAgICB0aGlzLmJpdGdvLl9yZXFJZCA9IHJlcUlkO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhaW5oZWFkID0geWllbGQgc2VsZi5iaXRnby5nZXQoc2VsZi51cmwoJy9wdWJsaWMvYmxvY2svbGF0ZXN0JykpLnJlc3VsdCgpO1xuICAgICAgcmV0dXJuIGNoYWluaGVhZC5oZWlnaHQ7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gY3VzdG9tIGNvaW4gbG9naWMgYWZ0ZXIgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBoYXMgYmVlbiByZWNlaXZlZCBmcm9tIEJpdEdvXG4gICAqIEBwYXJhbSBwcmVidWlsZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHBvc3RQcm9jZXNzUHJlYnVpbGQocHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uUHJlYnVpbGQ+KTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25QcmVidWlsZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvblByZWJ1aWxkPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocHJlYnVpbGQudHhIZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eFByZWJ1aWxkIHByb3BlcnR5IHR4SGV4Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleChwcmVidWlsZC50eEhleCwgc2VsZi5uZXR3b3JrKTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHByZWJ1aWxkLmJsb2NrSGVpZ2h0KSkge1xuICAgICAgICBwcmVidWlsZC5ibG9ja0hlaWdodCA9ICh5aWVsZCBzZWxmLmdldExhdGVzdEJsb2NrSGVpZ2h0KCkpIGFzIG51bWJlcjtcbiAgICAgIH1cbiAgICAgIC8vIExvY2sgdHJhbnNhY3Rpb24gdG8gdGhlIG5leHQgYmxvY2sgdG8gZGlzY291cmFnZSBmZWUgc25pcGluZ1xuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2Jsb2IvZmIwYWM0ODJlZWU3NjFlYzE3ZWQyYzExZGYxMWUwNTQzNDdhMDI2ZC9zcmMvd2FsbGV0L3dhbGxldC5jcHAjTDIxMzNcbiAgICAgIHRyYW5zYWN0aW9uLmxvY2t0aW1lID0gcHJlYnVpbGQuYmxvY2tIZWlnaHQ7XG4gICAgICByZXR1cm4gXy5leHRlbmQoe30sIHByZWJ1aWxkLCB7IHR4SGV4OiB0cmFuc2FjdGlvbi50b0hleCgpIH0pO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBvdXRwdXRzIHRoYXQgYXJlIHdpdGhpbiBleHBlY3RlZCBvdXRwdXRzIGJ1dCBub3Qgd2l0aGluIGFjdHVhbCBvdXRwdXRzLCBpbmNsdWRpbmcgZHVwbGljYXRlc1xuICAgKiBAcGFyYW0gZXhwZWN0ZWRPdXRwdXRzXG4gICAqIEBwYXJhbSBhY3R1YWxPdXRwdXRzXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgZmluZE1pc3NpbmdPdXRwdXRzKGV4cGVjdGVkT3V0cHV0czogT3V0cHV0W10sIGFjdHVhbE91dHB1dHM6IE91dHB1dFtdKTogT3V0cHV0W10ge1xuICAgIGNvbnN0IGtleUZ1bmMgPSAoeyBhZGRyZXNzLCBhbW91bnQgfTogT3V0cHV0KTogc3RyaW5nID0+IGAke2FkZHJlc3N9OiR7TnVtYmVyKGFtb3VudCl9YDtcbiAgICBjb25zdCBncm91cGVkT3V0cHV0cyA9IF8uZ3JvdXBCeShleHBlY3RlZE91dHB1dHMsIGtleUZ1bmMpO1xuXG4gICAgYWN0dWFsT3V0cHV0cy5mb3JFYWNoKChvdXRwdXQpID0+IHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBlZE91dHB1dHNba2V5RnVuYyhvdXRwdXQpXTtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBncm91cC5wb3AoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBfLmZsYXR0ZW4oXy52YWx1ZXMoZ3JvdXBlZE91dHB1dHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgYW4gYWRkcmVzcycgdHlwZSBiYXNlZCBvbiBpdHMgd2l0bmVzcyBhbmQgcmVkZWVtIHNjcmlwdCBwcmVzZW5jZVxuICAgKiBAcGFyYW0gYWRkcmVzc0RldGFpbHNcbiAgICovXG4gIHN0YXRpYyBpbmZlckFkZHJlc3NUeXBlKGFkZHJlc3NEZXRhaWxzOiB7IGNvaW5TcGVjaWZpYzogQWRkcmVzc0NvaW5TcGVjaWZpYyB9KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKF8uaXNPYmplY3QoYWRkcmVzc0RldGFpbHMuY29pblNwZWNpZmljKSkge1xuICAgICAgaWYgKF8uaXNTdHJpbmcoYWRkcmVzc0RldGFpbHMuY29pblNwZWNpZmljLnJlZGVlbVNjcmlwdCkgJiYgXy5pc1N0cmluZyhhZGRyZXNzRGV0YWlscy5jb2luU3BlY2lmaWMud2l0bmVzc1NjcmlwdCkpIHtcbiAgICAgICAgcmV0dXJuIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2hQMndzaCcpO1xuICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGFkZHJlc3NEZXRhaWxzLmNvaW5TcGVjaWZpYy5yZWRlZW1TY3JpcHQpKSB7XG4gICAgICAgIHJldHVybiBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoJyk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYWRkcmVzc0RldGFpbHMuY29pblNwZWNpZmljLndpdG5lc3NTY3JpcHQpKSB7XG4gICAgICAgIHJldHVybiBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMndzaCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGFuZCBmaWxsIHRyYW5zYWN0aW9uIGRldGFpbHMgc3VjaCBhcyBpbnRlcm5hbC9jaGFuZ2Ugc3BlbmQsIGV4dGVybmFsIHNwZW5kIChleHBsaWNpdCB2cy4gaW1wbGljaXQpLCBldGMuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxQYXJzZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgIHR4UHJlYnVpbGQsXG4gICAgICAgIHdhbGxldCxcbiAgICAgICAgdmVyaWZpY2F0aW9uID0ge30sXG4gICAgICAgIHJlcUlkLFxuICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZykgJiYgIV8uaXNCb29sZWFuKHZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmcgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gdmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nO1xuXG4gICAgICAvLyBvYnRhaW4gdGhlIGtleWNoYWlucyBhbmQga2V5IHNpZ25hdHVyZXNcbiAgICAgIGxldCBrZXljaGFpbnM6IHtcbiAgICAgICAgdXNlcj86IEtleWNoYWluLFxuICAgICAgICBiYWNrdXA/OiBLZXljaGFpbixcbiAgICAgICAgYml0Z28/OiBLZXljaGFpbixcbiAgICAgIH0gfCB1bmRlZmluZWQgPSB2ZXJpZmljYXRpb24ua2V5Y2hhaW5zO1xuICAgICAgaWYgKCFrZXljaGFpbnMgJiYgZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmV0Y2gga2V5Y2hhaW5zIHdpdGhvdXQgbmV0d29ya2luZycpO1xuICAgICAgfSBlbHNlIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICAgIGtleWNoYWlucyA9IHlpZWxkIEJsdWViaXJkLnByb3BzKHtcbiAgICAgICAgICB1c2VyOiBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5VU0VSXSwgcmVxSWQgfSksXG4gICAgICAgICAgYmFja3VwOiBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5CQUNLVVBdLCByZXFJZCB9KSxcbiAgICAgICAgICBiaXRnbzogc2VsZi5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuQklUR09dLCByZXFJZCB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW5zIGFyZSByZXF1aXJlZCwgYnV0IGNvdWxkIG5vdCBiZSBmZXRjaGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleWNoYWluQXJyYXkgPSBba2V5Y2hhaW5zLnVzZXIsIGtleWNoYWlucy5iYWNrdXAsIGtleWNoYWlucy5iaXRnb107XG5cbiAgICAgIGNvbnN0IGtleVNpZ25hdHVyZXMgPSBfLmdldCh3YWxsZXQsICdfd2FsbGV0LmtleVNpZ25hdHVyZXMnKTtcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZC50eEhleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4UHJlYnVpbGQgcHJvcGVydHkgdHhIZXgnKTtcbiAgICAgIH1cbiAgICAgIC8vIG9idGFpbiBhbGwgb3V0cHV0c1xuICAgICAgY29uc3QgZXhwbGFuYXRpb246IFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gPSB5aWVsZCBzZWxmLmV4cGxhaW5UcmFuc2FjdGlvbih7XG4gICAgICAgIHR4SGV4OiB0eFByZWJ1aWxkLnR4SGV4LFxuICAgICAgICB0eEluZm86IHR4UHJlYnVpbGQudHhJbmZvLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFsbE91dHB1dHMgPSBbLi4uZXhwbGFuYXRpb24ub3V0cHV0cywgLi4uZXhwbGFuYXRpb24uY2hhbmdlT3V0cHV0c107XG5cbiAgICAgIC8vIHZlcmlmeSB0aGF0IGVhY2ggcmVjaXBpZW50IGZyb20gdHhQYXJhbXMgaGFzIHRoZWlyIG93biBvdXRwdXRcbiAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0cyA9IF8uZ2V0KHR4UGFyYW1zLCAncmVjaXBpZW50cycsIFtdIGFzIFRyYW5zYWN0aW9uUmVjaXBpZW50W10pO1xuICAgICAgY29uc3QgbWlzc2luZ091dHB1dHMgPSBBYnN0cmFjdFV0eG9Db2luLmZpbmRNaXNzaW5nT3V0cHV0cyhleHBlY3RlZE91dHB1dHMsIGFsbE91dHB1dHMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIExvb3AgdGhyb3VnaCBhbGwgdGhlIG91dHB1dHMgYW5kIGNsYXNzaWZ5IGVhY2ggb2YgdGhlbSBhcyBlaXRoZXIgaW50ZXJuYWwgc3BlbmRzXG4gICAgICAgKiBvciBleHRlcm5hbCBzcGVuZHMgYnkgc2V0dGluZyB0aGUgXCJleHRlcm5hbFwiIHByb3BlcnR5IHRvIHRydWUgb3IgZmFsc2Ugb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGFsbE91dHB1dERldGFpbHM6IE91dHB1dFtdID0geWllbGQgQmx1ZWJpcmQubWFwKGFsbE91dHB1dHMsIGNvKGZ1bmN0aW9uICooY3VycmVudE91dHB1dCkge1xuICAgICAgICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IGN1cnJlbnRPdXRwdXQuYWRkcmVzcztcblxuICAgICAgICAvLyBhdHRlbXB0IHRvIGdyYWIgdGhlIGFkZHJlc3MgZGV0YWlscyBmcm9tIGVpdGhlciB0aGUgcHJlYnVpbHQgdHgsIG9yIHRoZSB2ZXJpZmljYXRpb24gcGFyYW1zLlxuICAgICAgICAvLyBJZiBib3RoIG9mIHRoZXNlIGFyZSBlbXB0eSwgdGhlbiB3ZSB3aWxsIHRyeSB0byBnZXQgdGhlIGFkZHJlc3MgZGV0YWlscyBmcm9tIGJpdGdvIGluc3RlYWRcbiAgICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHNQcmVidWlsZCA9IF8uZ2V0KHR4UHJlYnVpbGQsIGB0eEluZm8ud2FsbGV0QWRkcmVzc0RldGFpbHMuJHtjdXJyZW50QWRkcmVzc31gLCB7fSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uID0gXy5nZXQodmVyaWZpY2F0aW9uLCBgYWRkcmVzc2VzLiR7Y3VycmVudEFkZHJlc3N9YCwge30pO1xuICAgICAgICBkZWJ1ZygnUGFyc2luZyBhZGRyZXNzIGRldGFpbHMgZm9yICVzJywgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBvbmx5IHdheSB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBhZGRyZXNzIGlzIGtub3duIG9uIHRoZSB3YWxsZXQgaXMgdG8gaW5pdGlhdGUgYSBuZXR3b3JrIHJlcXVlc3QgYW5kXG4gICAgICAgICAgICogZmV0Y2ggaXQuIFNob3VsZCB0aGUgcmVxdWVzdCBmYWlsIGFuZCByZXR1cm4gYSA0MDQsIGl0IHdpbGwgdGhyb3cgYW5kIHRoZXJlZm9yZSBoYXMgdG8gYmUgY2F1Z2h0LiBGb3IgdGhhdFxuICAgICAgICAgICAqIHJlYXNvbiwgYWRkcmVzcyB3YWxsZXQgb3duZXJzaGlwIGRldGVjdGlvbiBpcyB3cmFwcGVkIGluIGEgdHJ5L2NhdGNoLiBBZGRpdGlvbmFsbHksIG9uY2UgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgKiBkZXRhaWxzIGFyZSBmZXRjaGVkIG9uIHRoZSB3YWxsZXQsIGEgbG9jYWwgYWRkcmVzcyB2YWxpZGF0aW9uIGlzIHJ1biwgd2hvc2UgZXJyb3JzIGhvd2V2ZXIgYXJlIGdlbmVyYXRlZFxuICAgICAgICAgICAqIGNsaWVudC1zaWRlIGFuZCBjYW4gdGhlcmVmb3JlIGJlIGFuYWx5emVkIHdpdGggbW9yZSBncmFudWxhcml0eSBhbmQgdHlwZSBjaGVja2luZy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsZXQgYWRkcmVzc0RldGFpbHMgPSBfLmV4dGVuZCh7fSwgYWRkcmVzc0RldGFpbHNQcmVidWlsZCwgYWRkcmVzc0RldGFpbHNWZXJpZmljYXRpb24pO1xuICAgICAgICAgIGRlYnVnKCdMb2NhbGx5IGF2YWlsYWJsZSBhZGRyZXNzICVzIGRldGFpbHM6ICVPJywgY3VycmVudEFkZHJlc3MsIGFkZHJlc3NEZXRhaWxzKTtcbiAgICAgICAgICBpZiAoXy5pc0VtcHR5KGFkZHJlc3NEZXRhaWxzKSAmJiAhZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgICAgIGFkZHJlc3NEZXRhaWxzID0geWllbGQgd2FsbGV0LmdldEFkZHJlc3MoeyBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcywgcmVxSWQgfSk7XG4gICAgICAgICAgICBkZWJ1ZygnRG93bmxvYWRlZCBhZGRyZXNzICVzIGRldGFpbHM6ICVPJywgY3VycmVudEFkZHJlc3MsIGFkZHJlc3NEZXRhaWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIGFkZHJlc3MgaXMgb24gdGhlIHdhbGxldC4gdmVyaWZ5QWRkcmVzcyB0aHJvd3MgaWZcbiAgICAgICAgICAvLyBpdCBmYWlscyB0byBjb3JyZWN0bHkgcmVkZXJpdmUgdGhlIGFkZHJlc3MsIG1lYW5pbmcgaXQncyBleHRlcm5hbFxuICAgICAgICAgIGNvbnN0IGFkZHJlc3NUeXBlID0gQWJzdHJhY3RVdHhvQ29pbi5pbmZlckFkZHJlc3NUeXBlKGFkZHJlc3NEZXRhaWxzKTtcbiAgICAgICAgICBzZWxmLnZlcmlmeUFkZHJlc3MoXy5leHRlbmQoeyBhZGRyZXNzVHlwZSB9LCBhZGRyZXNzRGV0YWlscywge1xuICAgICAgICAgICAga2V5Y2hhaW5zOiBrZXljaGFpbkFycmF5LFxuICAgICAgICAgICAgYWRkcmVzczogY3VycmVudEFkZHJlc3MsXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGRlYnVnKCdBZGRyZXNzICVzIHZlcmlmaWNhdGlvbiBwYXNzZWQnLCBjdXJyZW50QWRkcmVzcyk7XG5cbiAgICAgICAgICAvLyB2ZXJpZnkgYWRkcmVzcyBzdWNjZWVkZWQgd2l0aG91dCB0aHJvd2luZywgc28gdGhlIGFkZHJlc3Mgd2FzXG4gICAgICAgICAgLy8gY29ycmVjdGx5IHJlZGVyaXZlZCBmcm9tIHRoZSB3YWxsZXQga2V5Y2hhaW5zLCBtYWtpbmcgaXQgbm90IGV4dGVybmFsXG4gICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCBhZGRyZXNzRGV0YWlscywgeyBleHRlcm5hbDogZmFsc2UgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB2ZXJpZnkgYWRkcmVzcyB0aHJldyBhbiBleGNlcHRpb25cbiAgICAgICAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmljYXRpb24gdGhyZXcgYW4gZXJyb3I6JywgY3VycmVudEFkZHJlc3MsIGUpO1xuICAgICAgICAgIC8vIFRvZG86IG5hbWUgc2VydmVyLXNpZGUgZXJyb3JzIHRvIGF2b2lkIG1lc3NhZ2UtYmFzZWQgY2hlY2tpbmcgW0JHLTUxMjRdXG4gICAgICAgICAgY29uc3Qgd2FsbGV0QWRkcmVzc05vdEZvdW5kID0gZS5tZXNzYWdlLmluY2x1ZGVzKCd3YWxsZXQgYWRkcmVzcyBub3QgZm91bmQnKTtcbiAgICAgICAgICBjb25zdCB1bmV4cGVjdGVkQWRkcmVzcyA9IChlIGluc3RhbmNlb2YgZXJyb3JzLlVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IpO1xuICAgICAgICAgIGlmICh3YWxsZXRBZGRyZXNzTm90Rm91bmQgfHwgdW5leHBlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmICh1bmV4cGVjdGVkQWRkcmVzcyAmJiAhd2FsbGV0QWRkcmVzc05vdEZvdW5kKSB7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiB0aGlzIGNvdWxkIGJlIGEgbWlncmF0ZWQgU2FmZUhEIEJDSCB3YWxsZXQsIGFuZCB0aGUgdHJhbnNhY3Rpb24gd2UgYXJlIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgKiBwYXJzaW5nIGlzIHRyeWluZyB0byBzcGVuZCBjaGFuZ2UgYmFjayB0byB0aGUgdjEgd2FsbGV0IGJhc2UgYWRkcmVzcy5cbiAgICAgICAgICAgICAgICogSXQgZG9lcyB0aGlzIHNpbmNlIHdlIGRvbid0IGFsbG93IG5ldyBhZGRyZXNzIGNyZWF0aW9uIGZvciB0aGVzZSB3YWxsZXRzLFxuICAgICAgICAgICAgICAgKiBhbmQgaW5zdGVhZCByZXR1cm4gdGhlIGJhc2UgYWRkcmVzcyBmcm9tIHRoZSB2MSB3YWxsZXQgd2hlbiBhIG5ldyBhZGRyZXNzIGlzIHJlcXVlc3RlZC5cbiAgICAgICAgICAgICAgICogSWYgdGhpcyBuZXcgYWRkcmVzcyBpcyByZXF1ZXN0ZWQgZm9yIHRoZSBwdXJwb3NlcyBvZiBzcGVuZGluZyBjaGFuZ2UgYmFjayB0byB0aGUgd2FsbGV0LFxuICAgICAgICAgICAgICAgKiB0aGUgY2hhbmdlIHdpbGwgZ28gdG8gdGhlIHYxIHdhbGxldCBiYXNlIGFkZHJlc3MuIFRoaXMgYWRkcmVzcyAqaXMqIG9uIHRoZSB3YWxsZXQsXG4gICAgICAgICAgICAgICAqIGJ1dCBpdCB3aWxsIHN0aWxsIGNhdXNlIGFuIGVycm9yIHRvIGJlIHRocm93biBieSB2ZXJpZnlBZGRyZXNzLCBzaW5jZSB0aGUgZGVyaXZhdGlvbiBwYXRoXG4gICAgICAgICAgICAgICAqIHVzZWQgZm9yIHRoaXMgYWRkcmVzcyBpcyBub24tc3RhbmRhcmQuIChJIGhhdmUgc2VlbiB0aGVzZSBhZGRyZXNzZXMgZGVyaXZlZCB1c2luZyBwYXRocyBtLzAvMCBhbmQgbS8xMDEsXG4gICAgICAgICAgICAgICAqIHdoZXJlYXMgdGhlIHYyIGFkZHJlc3NlcyBhcmUgZGVyaXZlZCB1c2luZyBwYXRoICBtLzAvMC8ke2NoYWlufS8ke2luZGV4fSkuXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIFRoaXMgbWVhbnMgd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBjYXNlIGV4cGxpY2l0bHkgaW4gdGhpcyBjYXRjaCBibG9jaywgYW5kIGNsYXNzaWZ5XG4gICAgICAgICAgICAgICAqIHRoZXNlIHR5cGVzIG9mIG91dHB1dHMgYXMgaW50ZXJuYWwgaW5zdGVhZCBvZiBleHRlcm5hbC4gRmFpbGluZyB0byBkbyBzbyB3b3VsZCBjYXVzZSB0aGVcbiAgICAgICAgICAgICAgICogdHJhbnNhY3Rpb24ncyBpbXBsaWNpdCBleHRlcm5hbCBvdXRwdXRzIChpZSwgb3V0cHV0cyB3aGljaCBnbyB0byBhZGRyZXNzZXMgbm90IHNwZWNpZmllZCBpblxuICAgICAgICAgICAgICAgKiB0aGUgcmVjaXBpZW50cyBhcnJheSkgdG8gYWRkIHVwIHRvIG1vcmUgdGhhbiB0aGUgMTUwIGJhc2lzIHBvaW50IGxpbWl0IHdoaWNoIHdlIGVuZm9yY2Ugb25cbiAgICAgICAgICAgICAgICogcGF5LWFzLXlvdS1nbyBvdXRwdXRzICh3aGljaCBzaG91bGQgYmUgdGhlIG9ubHkgaW1wbGljaXQgZXh0ZXJuYWwgb3V0cHV0cyBvbiBvdXIgdHJhbnNhY3Rpb25zKS5cbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogVGhlIDE1MCBiYXNpcyBwb2ludCBsaW1pdCBmb3IgaW1wbGljaXQgZXh0ZXJuYWwgc2VuZHMgaXMgZW5mb3JjZWQgaW4gdmVyaWZ5VHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAqIHdoaWNoIGNhbGxzIHRoaXMgZnVuY3Rpb24gdG8gZ2V0IGluZm9ybWF0aW9uIG9uIHRoZSB0b3RhbCBleHRlcm5hbC9pbnRlcm5hbCBzcGVuZCBhbW91bnRzXG4gICAgICAgICAgICAgICAqIGZvciBhIHRyYW5zYWN0aW9uLiBUaGUgaWRlYSBoZXJlIGlzIHRvIHByb3RlY3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYmVpbmcgbWFsaWNpb3VzbHkgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICogdG8gYWRkIG1vcmUgaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmRzIChlZywgdG8gYW4gYXR0YWNrZXItY29udHJvbGxlZCB3YWxsZXQpLlxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBTZWUgdmVyaWZ5VHJhbnNhY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRyYW5zYWN0aW9uIHByZWJ1aWxkcyBhcmUgdmVyaWZpZWQgYmVmb3JlIHNpZ25pbmcuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKHdhbGxldC5taWdyYXRlZEZyb20oKSkgJiYgd2FsbGV0Lm1pZ3JhdGVkRnJvbSgpID09PSBjdXJyZW50QWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdmb3VuZCBhZGRyZXNzICVzIHdoaWNoIHdhcyBtaWdyYXRlZCBmcm9tIHYxIHdhbGxldCwgYWRkcmVzcyBpcyBub3QgZXh0ZXJuYWwnLCBjdXJyZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCB7IGV4dGVybmFsOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlYnVnKCdBZGRyZXNzICVzIHdhcyBmb3VuZCBvbiB3YWxsZXQgYnV0IGNvdWxkIG5vdCBiZSByZWNvbnN0cnVjdGVkJywgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgYWRkcmVzcyB3YXMgZm91bmQsIGJ1dCBub3Qgb24gdGhlIHdhbGxldCwgd2hpY2ggc2ltcGx5IG1lYW5zIGl0J3MgZXh0ZXJuYWxcbiAgICAgICAgICAgIGRlYnVnKCdBZGRyZXNzICVzIHByZXN1bWVkIGV4dGVybmFsJywgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCB7IGV4dGVybmFsOiB0cnVlIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIGVycm9ycy5JbnZhbGlkQWRkcmVzc0Rlcml2YXRpb25Qcm9wZXJ0eUVycm9yICYmIGN1cnJlbnRBZGRyZXNzID09PSB0eFBhcmFtcy5jaGFuZ2VBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBleHBlY3QgdG8gc2VlIHRoaXMgZXJyb3Igd2hlbiBwYXNzaW5nIGluIGEgY3VzdG9tIGNoYW5nZUFkZHJlc3Mgd2l0aCBubyBjaGFpbiBvciBpbmRleFxuICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCB7IGV4dGVybmFsOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmljYXRpb24gZmFpbGVkJywgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEl0IG1pZ2h0IGJlIGEgY29tcGxldGVseSBpbnZhbGlkIGFkZHJlc3Mgb3IgYSBiYWQgdmFsaWRhdGlvbiBhdHRlbXB0IG9yIHNvbWV0aGluZyBlbHNlIGNvbXBsZXRlbHksIGluXG4gICAgICAgICAgICogd2hpY2ggY2FzZSB3ZSBkbyBub3QgcHJvY2VlZCBhbmQgcmF0aGVyIHJldGhyb3cgdGhlIGVycm9yLCB3aGljaCBpcyBzYWZlciB0aGFuIGFzc3VtaW5nIHRoYXQgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgKiB2YWxpZGF0aW9uIGZhaWxlZCBzaW1wbHkgYmVjYXVzZSBpdCdzIGV4dGVybmFsIHRvIHRoZSB3YWxsZXQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICAgIGNvbnN0IGNoYW5nZU91dHB1dHMgPSBfLmZpbHRlcihhbGxPdXRwdXREZXRhaWxzLCB7IGV4dGVybmFsOiBmYWxzZSB9KTtcblxuICAgICAgLy8gdGhlc2UgYXJlIGFsbCB0aGUgb3V0cHV0cyB0aGF0IHdlcmUgbm90IG9yaWdpbmFsbHkgZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gcmVjaXBpZW50c1xuICAgICAgY29uc3QgaW1wbGljaXRPdXRwdXRzID0gQWJzdHJhY3RVdHhvQ29pbi5maW5kTWlzc2luZ091dHB1dHMoYWxsT3V0cHV0RGV0YWlscywgZXhwZWN0ZWRPdXRwdXRzKTtcblxuICAgICAgY29uc3QgZXhwbGljaXRPdXRwdXRzID0gQWJzdHJhY3RVdHhvQ29pbi5maW5kTWlzc2luZ091dHB1dHMoYWxsT3V0cHV0RGV0YWlscywgaW1wbGljaXRPdXRwdXRzKTtcblxuICAgICAgLy8gdGhlc2UgYXJlIGFsbCB0aGUgbm9uLXdhbGxldCBvdXRwdXRzIHRoYXQgaGFkIGJlZW4gb3JpZ2luYWxseSBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiByZWNpcGllbnRzXG4gICAgICBjb25zdCBleHBsaWNpdEV4dGVybmFsT3V0cHV0cyA9IF8uZmlsdGVyKGV4cGxpY2l0T3V0cHV0cywgeyBleHRlcm5hbDogdHJ1ZSB9KTtcblxuICAgICAgLy8gdGhpcyBpcyB0aGUgc3VtIG9mIGFsbCB0aGUgb3JpZ2luYWxseSBleHBsaWNpdGx5IHNwZWNpZmllZCBub24td2FsbGV0IG91dHB1dCB2YWx1ZXNcbiAgICAgIGNvbnN0IGV4cGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCA9IF8uc3VtQnkoZXhwbGljaXRFeHRlcm5hbE91dHB1dHMsICdhbW91bnQnKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2FsY3VsYXRpb24gb2YgdGhlIGltcGxpY2l0IGV4dGVybmFsIHNwZW5kIGFtb3VudCBwZXJ0YWlucyB0byB2ZXJpZnlpbmcgdGhlIHBheS1hcy15b3UtZ28tZmVlIEJpdEdvXG4gICAgICAgKiBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdG8gdHJhbnNhY3Rpb25zIHNlbmRpbmcgbW9uZXkgb3V0IG9mIHRoZSB3YWxsZXQuIFRoZSBsb2dpYyBpcyBmYWlybHkgc3RyYWlnaHRmb3J3YXJkXG4gICAgICAgKiBpbiB0aGF0IHdlIGNvbXBhcmUgdGhlIGV4dGVybmFsIHNwZW5kIGFtb3VudCB0aGF0IHdhcyBzcGVjaWZpZWQgZXhwbGljaXRseSBieSB0aGUgdXNlciB0byB0aGUgcG9ydGlvblxuICAgICAgICogdGhhdCB3YXMgc3BlY2lmaWVkIGltcGxpY2l0bHkuIFRvIHByb3RlY3QgY3VzdG9tZXJzIGZyb20gcGVvcGxlIHRhbXBlcmluZyB3aXRoIHRoZSB0cmFuc2FjdGlvbiBvdXRwdXRzLCB3ZVxuICAgICAgICogZGVmaW5lIGEgdGhyZXNob2xkIGZvciB0aGUgbWF4aW11bSBwZXJjZW50YWdlIG9mIHRoZSBpbXBsaWNpdCBleHRlcm5hbCBzcGVuZCBpbiByZWxhdGlvbiB0byB0aGUgZXhwbGljaXRcbiAgICAgICAqIGV4dGVybmFsIHNwZW5kLlxuICAgICAgICovXG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgZXh0cmEgYWRkcmVzc2VzIGFyZSBjaGFuZ2UgYWRkcmVzc2VzXG4gICAgICAvLyBnZXQgYWxsIHRoZSBhZGRpdGlvbmFsIGV4dGVybmFsIG91dHB1dHMgdGhlIHNlcnZlciBhZGRlZCBhbmQgY2FsY3VsYXRlIHRoZWlyIHZhbHVlc1xuICAgICAgY29uc3QgaW1wbGljaXRFeHRlcm5hbE91dHB1dHMgPSBfLmZpbHRlcihpbXBsaWNpdE91dHB1dHMsIHsgZXh0ZXJuYWw6IHRydWUgfSk7XG4gICAgICBjb25zdCBpbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQgPSBfLnN1bUJ5KGltcGxpY2l0RXh0ZXJuYWxPdXRwdXRzLCAnYW1vdW50Jyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGtleWNoYWlucyxcbiAgICAgICAga2V5U2lnbmF0dXJlcyxcbiAgICAgICAgb3V0cHV0czogYWxsT3V0cHV0RGV0YWlscyxcbiAgICAgICAgbWlzc2luZ091dHB1dHMsXG4gICAgICAgIGV4cGxpY2l0RXh0ZXJuYWxPdXRwdXRzLFxuICAgICAgICBpbXBsaWNpdEV4dGVybmFsT3V0cHV0cyxcbiAgICAgICAgY2hhbmdlT3V0cHV0cyxcbiAgICAgICAgZXhwbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50LFxuICAgICAgICBpbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgY29tcGxpZXMgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFBhcmFtcyBwYXJhbXMgb2JqZWN0IHBhc3NlZCB0byBzZW5kXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgc2VydmVyXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZC50eEhleCBwcmVidWlsdCB0cmFuc2FjdGlvbidzIHR4SGV4IGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgV2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gcGFyYW1zLnZlcmlmaWNhdGlvbiBPYmplY3Qgc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBwYXJhbXMudmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nIERpc2FsbG93IGZldGNoaW5nIGFueSBkYXRhIGZyb20gdGhlIGludGVybmV0IGZvciB2ZXJpZmljYXRpb24gcHVycG9zZXNcbiAgICogQHBhcmFtIHBhcmFtcy52ZXJpZmljYXRpb24ua2V5Y2hhaW5zIFBhc3Mga2V5Y2hhaW5zIG1hbnVhbGx5IHJhdGhlciB0aGFuIGZldGNoaW5nIHRoZW0gYnkgaWRcbiAgICogQHBhcmFtIHBhcmFtcy52ZXJpZmljYXRpb24uYWRkcmVzc2VzIEFkZHJlc3MgZGV0YWlscyB0byBwYXNzIGluIGZvciBvdXQtb2YtYmFuZCB2ZXJpZmljYXRpb25cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxib29sZWFuPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgeyB0eFBhcmFtcywgdHhQcmVidWlsZCwgd2FsbGV0LCB2ZXJpZmljYXRpb24gPSB7fSwgcmVxSWQgfSA9IHBhcmFtcztcbiAgICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG4gICAgICBjb25zdCBwYXJzZWRUcmFuc2FjdGlvbiA9IHlpZWxkIHNlbGYucGFyc2VUcmFuc2FjdGlvbih7IHR4UGFyYW1zLCB0eFByZWJ1aWxkLCB3YWxsZXQsIHZlcmlmaWNhdGlvbiwgcmVxSWQgfSk7XG5cbiAgICAgIGNvbnN0IGtleWNoYWlucyA9IHBhcnNlZFRyYW5zYWN0aW9uLmtleWNoYWlucztcblxuICAgICAgLy8gbGV0J3MgdmVyaWZ5IHRoZXNlIGtleWNoYWluc1xuICAgICAgY29uc3Qga2V5U2lnbmF0dXJlcyA9IHBhcnNlZFRyYW5zYWN0aW9uLmtleVNpZ25hdHVyZXM7XG4gICAgICBpZiAoIV8uaXNFbXB0eShrZXlTaWduYXR1cmVzKSkge1xuICAgICAgICAvLyBmaXJzdCwgbGV0J3MgdmVyaWZ5IHRoZSBpbnRlZ3JpdHkgb2YgdGhlIHVzZXIga2V5LCB3aG9zZSBwdWJsaWMga2V5IGlzIHVzZWQgZm9yIHN1YnNlcXVlbnQgdmVyaWZpY2F0aW9uc1xuICAgICAgICBjb25zdCB1c2VyUHViID0ga2V5Y2hhaW5zLnVzZXIucHViO1xuICAgICAgICBjb25zdCB1c2VyS2V5ID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OCh1c2VyUHViKTtcbiAgICAgICAgbGV0IHVzZXJQcnYgPSBrZXljaGFpbnMudXNlci5wcnY7XG4gICAgICAgIGlmIChfLmlzRW1wdHkodXNlclBydikpIHtcbiAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRQcnYgPSBrZXljaGFpbnMudXNlci5lbmNyeXB0ZWRQcnY7XG4gICAgICAgICAgaWYgKCFfLmlzRW1wdHkoZW5jcnlwdGVkUHJ2KSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGRlY3J5cHRpb24gZmFpbHMsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgIHVzZXJQcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgICBpbnB1dDogZW5jcnlwdGVkUHJ2LFxuICAgICAgICAgICAgICBwYXNzd29yZDogdHhQYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pc0VtcHR5KHVzZXJQcnYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ3VzZXIgcHJpdmF0ZSBrZXkgdW5hdmFpbGFibGUgZm9yIHZlcmlmaWNhdGlvbic7XG4gICAgICAgICAgaWYgKGRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdXNlclByaXZhdGVLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJQcnYpO1xuICAgICAgICAgIGlmICh1c2VyUHJpdmF0ZUtleS50b0Jhc2U1OCgpID09PSB1c2VyUHJpdmF0ZUtleS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlciBwcml2YXRlIGtleSBpcyBvbmx5IHB1YmxpYycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXNlclByaXZhdGVLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpICE9PSB1c2VyUHViKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXIgcHJpdmF0ZSBrZXkgZG9lcyBub3QgbWF0Y2ggcHVibGljIGtleScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhY2t1cFB1YlNpZ25hdHVyZSA9IGtleVNpZ25hdHVyZXMuYmFja3VwUHViO1xuICAgICAgICBjb25zdCBiaXRnb1B1YlNpZ25hdHVyZSA9IGtleVNpZ25hdHVyZXMuYml0Z29QdWI7XG5cbiAgICAgICAgLy8gdmVyaWZ5IHRoZSBzaWduYXR1cmVzIGFnYWluc3QgdGhlIHVzZXIgcHVibGljIGtleVxuICAgICAgICBjb25zdCBzaWduaW5nQWRkcmVzcyA9IHVzZXJLZXkua2V5UGFpci5nZXRBZGRyZXNzKCk7XG5cbiAgICAgICAgLy8gQkctNTcwMzogdXNlIEJUQyBtYWlubmV0IHByZWZpeCBmb3IgYWxsIGtleSBzaWduYXR1cmUgb3BlcmF0aW9uc1xuICAgICAgICAvLyAodGhpcyBtZWFucyBkbyBub3QgcGFzcyBhIHByZWZpeCBwYXJhbWV0ZXIsIGFuZCBsZXQgaXQgdXNlIHRoZSBkZWZhdWx0IHByZWZpeCBpbnN0ZWFkKVxuICAgICAgICBjb25zdCBpc1ZhbGlkQmFja3VwU2lnbmF0dXJlID0gYml0Y29pbk1lc3NhZ2UudmVyaWZ5KGtleWNoYWlucy5iYWNrdXAucHViLCBzaWduaW5nQWRkcmVzcywgQnVmZmVyLmZyb20oYmFja3VwUHViU2lnbmF0dXJlLCAnaGV4JykpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkQml0Z29TaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS52ZXJpZnkoa2V5Y2hhaW5zLmJpdGdvLnB1Yiwgc2lnbmluZ0FkZHJlc3MsIEJ1ZmZlci5mcm9tKGJpdGdvUHViU2lnbmF0dXJlLCAnaGV4JykpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZEJhY2t1cFNpZ25hdHVyZSB8fCAhaXNWYWxpZEJpdGdvU2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmRhcnkgcHVibGljIGtleSBzaWduYXR1cmVzIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgLy8gdGhlc2Uga2V5cyB3ZXJlIG9idGFpbmVkIG9ubGluZSBhbmQgdGhlaXIgc2lnbmF0dXJlcyB3ZXJlIG5vdCB2ZXJpZmllZFxuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGRhbmdlcm91c1xuICAgICAgICBjb25zb2xlLmxvZygndW5zaWduZWQga2V5cyBvYnRhaW5lZCBvbmxpbmUgYXJlIGJlaW5nIHVzZWQgZm9yIGFkZHJlc3MgdmVyaWZpY2F0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pc3NpbmdPdXRwdXRzID0gcGFyc2VkVHJhbnNhY3Rpb24ubWlzc2luZ091dHB1dHM7XG4gICAgICBpZiAobWlzc2luZ091dHB1dHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZXJlIGFyZSBzb21lIG91dHB1dHMgaW4gdGhlIHJlY2lwaWVudHMgbGlzdCB0aGF0IGhhdmUgbm90IG1hZGUgaXQgaW50byB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgb3V0cHV0cyBtaXNzaW5nIGluIHRyYW5zYWN0aW9uIHByZWJ1aWxkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGludGVuZGVkRXh0ZXJuYWxTcGVuZCA9IHBhcnNlZFRyYW5zYWN0aW9uLmV4cGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudDtcblxuICAgICAgLy8gdGhpcyBpcyBhIGxpbWl0IHdlIGltcG9zZSBmb3IgdGhlIHRvdGFsIHZhbHVlIHRoYXQgaXMgYW1lbmRlZCB0byB0aGUgdHJhbnNhY3Rpb24gYmV5b25kIHdoYXQgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWRcbiAgICAgIGNvbnN0IHBheUFzWW91R29MaW1pdCA9IGludGVuZGVkRXh0ZXJuYWxTcGVuZCAqIDAuMDE1OyAvLyAxNTAgYmFzaXMgcG9pbnRzIGlzIHRoZSBhYnNvbHV0ZSBwZXJtaXR0ZWQgbWF4aW11bVxuXG4gICAgICAvKlxuICAgICAgU29tZSBleHBsYW5hdGlvbiBmb3Igd2h5IHdlJ3JlIGRvaW5nIHdoYXQgd2UncmUgZG9pbmc6XG4gICAgICBTb21lIGN1c3RvbWVycyB3aWxsIGhhdmUgYW4gb3V0cHV0IHRvIEJpdEdvJ3MgUEFZR28gd2FsbGV0IGFkZGVkIHRvIHRoZWlyIHRyYW5zYWN0aW9uLCBhbmQgd2UgbmVlZCB0byBhY2NvdW50IGZvclxuICAgICAgaXQgaGVyZS4gVG8gcHJvdGVjdCBzb21lb25lIHRhbXBlcmluZyB3aXRoIHRoZSBvdXRwdXQgdG8gbWFrZSBpdCBzZW5kIG1vcmUgdGhhbiBpdCBzaG91bGQgdG8gQml0R28sIHdlIGRlZmluZSBhXG4gICAgICB0aHJlc2hvbGQgZm9yIHRoZSBvdXRwdXQncyB2YWx1ZSBhYm92ZSB3aGljaCB3ZSdsbCB0aHJvdyBhbiBlcnJvciwgYmVjYXVzZSB0aGUgcGF5Z28gb3V0cHV0IHNob3VsZCBuZXZlciBiZSB0aGF0XG4gICAgICBoaWdoLlxuICAgICAgICovXG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgZXh0cmEgYWRkcmVzc2VzIGFyZSBjaGFuZ2UgYWRkcmVzc2VzXG4gICAgICAvLyBnZXQgYWxsIHRoZSBhZGRpdGlvbmFsIGV4dGVybmFsIG91dHB1dHMgdGhlIHNlcnZlciBhZGRlZCBhbmQgY2FsY3VsYXRlIHRoZWlyIHZhbHVlc1xuICAgICAgY29uc3Qgbm9uQ2hhbmdlQW1vdW50ID0gcGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50O1xuXG4gICAgICAvLyB0aGUgYWRkaXRpb25hbCBleHRlcm5hbCBvdXRwdXRzIGNhbiBvbmx5IGJlIEJpdEdvJ3MgcGF5LWFzLXlvdS1nbyBmZWUsIGJ1dCB3ZSBjYW5ub3QgdmVyaWZ5IHRoZSB3YWxsZXQgYWRkcmVzc1xuICAgICAgaWYgKG5vbkNoYW5nZUFtb3VudCA+IHBheUFzWW91R29MaW1pdCkge1xuICAgICAgICAvLyB0aGVyZSBhcmUgc29tZSBhZGRyZXNzZXMgdGhhdCBhcmUgb3V0c2lkZSB0aGUgc2NvcGUgb2YgaW50ZW5kZWQgcmVjaXBpZW50cyB0aGF0IGFyZSBub3QgY2hhbmdlIGFkZHJlc3Nlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWJ1aWxkIGF0dGVtcHRzIHRvIHNwZW5kIHRvIHVuaW50ZW5kZWQgZXh0ZXJuYWwgcmVjaXBpZW50cycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbGxPdXRwdXRzID0gcGFyc2VkVHJhbnNhY3Rpb24ub3V0cHV0cztcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHR4UHJlYnVpbGQudHhIZXgsIHNlbGYubmV0d29yayk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkNhY2hlID0ge307XG4gICAgICBjb25zdCBpbnB1dHMgPSB5aWVsZCBCbHVlYmlyZC5tYXAodHJhbnNhY3Rpb24uaW5zLCBjbyhmdW5jdGlvbiAqKGN1cnJlbnRJbnB1dCkge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gKEJ1ZmZlci5mcm9tKGN1cnJlbnRJbnB1dC5oYXNoKS5yZXZlcnNlKCkgYXMgQnVmZmVyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIGNvbnN0IHR4SGV4ID0gXy5nZXQodHhQcmVidWlsZCwgYHR4SW5mby50eEhleGVzLiR7dHJhbnNhY3Rpb25JZH1gKTtcbiAgICAgICAgaWYgKHR4SGV4KSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxUeCA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleCh0eEhleCwgc2VsZi5uZXR3b3JrKTtcbiAgICAgICAgICBpZiAobG9jYWxUeC5nZXRJZCgpICE9PSB0cmFuc2FjdGlvbklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRyYW5zYWN0aW9uIGhleCBkb2VzIG5vdCBtYXRjaCBpZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXJyZW50T3V0cHV0ID0gbG9jYWxUeC5vdXRzW2N1cnJlbnRJbnB1dC5pbmRleF07XG4gICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGJpdGNvaW4uYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KGN1cnJlbnRPdXRwdXQuc2NyaXB0LCBzZWxmLm5ldHdvcmspO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRPdXRwdXQudmFsdWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghdHJhbnNhY3Rpb25DYWNoZVt0cmFuc2FjdGlvbklkXSkge1xuICAgICAgICAgIGlmIChkaXNhYmxlTmV0d29ya2luZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0aW5nIHRvIHJldHJpZXZlIHRyYW5zYWN0aW9uIGRldGFpbHMgZXh0ZXJuYWxseSB3aXRoIG5ldHdvcmtpbmcgZGlzYWJsZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcUlkKSB7XG4gICAgICAgICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2FjdGlvbkNhY2hlW3RyYW5zYWN0aW9uSWRdID0geWllbGQgc2VsZi5iaXRnby5nZXQoc2VsZi51cmwoYC9wdWJsaWMvdHgvJHt0cmFuc2FjdGlvbklkfWApKS5yZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkRldGFpbHMgPSB0cmFuc2FjdGlvbkNhY2hlW3RyYW5zYWN0aW9uSWRdO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25EZXRhaWxzLm91dHB1dHNbY3VycmVudElucHV0LmluZGV4XTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgICBjb25zdCBpbnB1dEFtb3VudCA9IF8uc3VtQnkoaW5wdXRzLCAndmFsdWUnKTtcbiAgICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IF8uc3VtQnkoYWxsT3V0cHV0cywgJ2Ftb3VudCcpO1xuICAgICAgY29uc3QgZmVlID0gaW5wdXRBbW91bnQgLSBvdXRwdXRBbW91bnQ7XG5cbiAgICAgIGlmIChmZWUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYXR0ZW1wdGluZyB0byBzcGVuZCAke291dHB1dEFtb3VudH0gc2F0b3NoaXMsIHdoaWNoIGV4Y2VlZHMgdGhlIGlucHV0IGFtb3VudCAoJHtpbnB1dEFtb3VudH0gc2F0b3NoaXMpIGJ5ICR7LWZlZX1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgYW4gYWRkcmVzcyBpcyB2YWxpZCBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBub3QuXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyBUaGUgYWRkcmVzcyBzdHJpbmcgb24gdGhlIG5ldHdvcmtcbiAgICogQHBhcmFtIHBhcmFtcy5hZGRyZXNzVHlwZVxuICAgKiBAcGFyYW0gcGFyYW1zLmtleWNoYWlucyBLZXljaGFpbiBvYmplY3RzIHdpdGggeHB1YnNcbiAgICogQHBhcmFtIHBhcmFtcy5jb2luU3BlY2lmaWMgQ29pbi1zcGVjaWZpYyBkZXRhaWxzIGZvciB0aGUgYWRkcmVzcyBzdWNoIGFzIGEgd2l0bmVzcyBzY3JpcHRcbiAgICogQHBhcmFtIHBhcmFtcy5jaGFpbiBEZXJpdmF0aW9uIGNoYWluXG4gICAqIEBwYXJhbSBwYXJhbXMuaW5kZXggRGVyaXZhdGlvbiBpbmRleFxuICAgKiBAdGhyb3dzIHtJbnZhbGlkQWRkcmVzc0Vycm9yfVxuICAgKiBAdGhyb3dzIHtJbnZhbGlkQWRkcmVzc0Rlcml2YXRpb25Qcm9wZXJ0eUVycm9yfVxuICAgKiBAdGhyb3dzIHtVbmV4cGVjdGVkQWRkcmVzc0Vycm9yfVxuICAgKi9cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBhZGRyZXNzVHlwZSwga2V5Y2hhaW5zLCBjb2luU3BlY2lmaWMsIGNoYWluLCBpbmRleCB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGlmICgoXy5pc1VuZGVmaW5lZChjaGFpbikgJiYgXy5pc1VuZGVmaW5lZChpbmRleCkpIHx8ICghKF8uaXNGaW5pdGUoY2hhaW4pICYmIF8uaXNGaW5pdGUoaW5kZXgpKSkpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFkZHJlc3NEZXJpdmF0aW9uUHJvcGVydHlFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6IGludmFsaWQgY2hhaW4gKCR7Y2hhaW59KSBvciBpbmRleCAoJHtpbmRleH0pYCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzT2JqZWN0KGNvaW5TcGVjaWZpYykpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFkZHJlc3NWZXJpZmljYXRpb25PYmplY3RQcm9wZXJ0eUVycm9yKCdhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogY29pblNwZWNpZmljIGZpZWxkIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSBrZXljaGFpbnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFkZHJlc3MgPSB0aGlzLmdlbmVyYXRlQWRkcmVzcyh7XG4gICAgICBhZGRyZXNzVHlwZSxcbiAgICAgIGtleWNoYWlucyxcbiAgICAgIHRocmVzaG9sZDogMixcbiAgICAgIGNoYWluLFxuICAgICAgaW5kZXgsXG4gICAgfSk7XG5cbiAgICBpZiAoZXhwZWN0ZWRBZGRyZXNzLmFkZHJlc3MgIT09IGFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6IGV4cGVjdGVkICR7ZXhwZWN0ZWRBZGRyZXNzLmFkZHJlc3N9IGJ1dCBnb3QgJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvaW4gc3VwcG9ydHMgYSBibG9jayB0YXJnZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c0Jsb2NrVGFyZ2V0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyB3cmFwcGVkIHNlZ3dpdCBvdXRwdXRzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNQMnNoUDJ3c2goKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyBuYXRpdmUgc2Vnd2l0IG91dHB1dHNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c1Ayd3NoKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPKEJHLTExNDg3KTogUmVtb3ZlIGFkZHJlc3NUeXBlLCBzZWd3aXQsIGFuZCBiZWNoMzIgcGFyYW1zIGluIFNES3Y2XG4gICAqIEdlbmVyYXRlIGFuIGFkZHJlc3MgZm9yIGEgd2FsbGV0IGJhc2VkIG9uIGEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzc1R5cGUge3N0cmluZ30gICBEZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW5zICAge1tvYmplY3RdfSBBcnJheSBvZiBvYmplY3RzIHdpdGggeHB1YnNcbiAgICogQHBhcmFtIHBhcmFtcy50aHJlc2hvbGQgICB7bnVtYmVyfSAgIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXNcbiAgICogQHBhcmFtIHBhcmFtcy5jaGFpbiAgICAgICB7bnVtYmVyfSAgIERlcml2YXRpb24gY2hhaW4gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vQml0R28vdW5zcGVudHMvYmxvYi9tYXN0ZXIvc3JjL2NvZGVzLnRzIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY29ycmVzcG9uZGluZyBhZGRyZXNzIHR5cGUgb2YgYSBnaXZlbiBjaGFpbiBjb2RlKVxuICAgKiBAcGFyYW0gcGFyYW1zLmluZGV4ICAgICAgIHtudW1iZXJ9ICAgRGVyaXZhdGlvbiBpbmRleFxuICAgKiBAcGFyYW0gcGFyYW1zLnNlZ3dpdCAgICAgIHtib29sZWFufSAgRGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zLmJlY2gzMiAgICAgIHtib29sZWFufSAgRGVwcmVjYXRlZFxuICAgKiBAcmV0dXJucyB7e2NoYWluOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGNvaW46IG51bWJlciwgY29pblNwZWNpZmljOiB7b3V0cHV0U2NyaXB0LCByZWRlZW1TY3JpcHR9fX1cbiAgICovXG4gIGdlbmVyYXRlQWRkcmVzcyhwYXJhbXM6IEdlbmVyYXRlQWRkcmVzc09wdGlvbnMpOiBBZGRyZXNzRGV0YWlscyB7XG4gICAgY29uc3QgeyBrZXljaGFpbnMsIHRocmVzaG9sZCwgY2hhaW4sIGluZGV4LCBzZWd3aXQgPSBmYWxzZSwgYmVjaDMyID0gZmFsc2UgfSA9IHBhcmFtcztcbiAgICBsZXQgZGVyaXZhdGlvbkNoYWluID0gMDtcbiAgICBpZiAoXy5pc051bWJlcihjaGFpbikgJiYgXy5pc0ludGVnZXIoY2hhaW4pICYmIGNoYWluID4gMCkge1xuICAgICAgZGVyaXZhdGlvbkNoYWluID0gY2hhaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydEZsYWdzVG9BZGRyZXNzVHlwZSgpOiBzdHJpbmcge1xuICAgICAgaWYgKF8uaXNCb29sZWFuKHNlZ3dpdCkgJiYgc2Vnd2l0KSB7XG4gICAgICAgIHJldHVybiBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoUDJ3c2gnKTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc0Jvb2xlYW4oYmVjaDMyKSAmJiBiZWNoMzIpIHtcbiAgICAgICAgcmV0dXJuIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayd3NoJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NUeXBlID0gcGFyYW1zLmFkZHJlc3NUeXBlIHx8IGNvbnZlcnRGbGFnc1RvQWRkcmVzc1R5cGUoKTtcblxuICAgIHN3aXRjaCAoYWRkcmVzc1R5cGUpIHtcbiAgICAgIGNhc2UgQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaCcpOlxuICAgICAgICBpZiAoIUNvZGVzLmlzUDJzaChkZXJpdmF0aW9uQ2hhaW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5BZGRyZXNzVHlwZUNoYWluTWlzbWF0Y2hFcnJvcihhZGRyZXNzVHlwZSwgZGVyaXZhdGlvbkNoYWluKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaFAyd3NoJyk6XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c1Ayc2hQMndzaCgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5QMnNoUDJ3c2hVbnN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUNvZGVzLmlzUDJzaFAyd3NoKGRlcml2YXRpb25DaGFpbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkFkZHJlc3NUeXBlQ2hhaW5NaXNtYXRjaEVycm9yKGFkZHJlc3NUeXBlLCBkZXJpdmF0aW9uQ2hhaW4pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMndzaCcpOlxuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNQMndzaCgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5QMndzaFVuc3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQ29kZXMuaXNQMndzaChkZXJpdmF0aW9uQ2hhaW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5BZGRyZXNzVHlwZUNoYWluTWlzbWF0Y2hFcnJvcihhZGRyZXNzVHlwZSwgZGVyaXZhdGlvbkNoYWluKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuVW5zdXBwb3J0ZWRBZGRyZXNzVHlwZUVycm9yKCk7XG4gICAgfVxuXG4gICAgbGV0IHNpZ25hdHVyZVRocmVzaG9sZCA9IDI7XG4gICAgaWYgKF8uaXNJbnRlZ2VyKHRocmVzaG9sZCkpIHtcbiAgICAgIHNpZ25hdHVyZVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBoYXMgdG8gYmUgcG9zaXRpdmUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPiBrZXljaGFpbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhyZXNob2xkIGNhbm5vdCBleGNlZWQgbnVtYmVyIG9mIGtleXMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGVyaXZhdGlvbkluZGV4ID0gMDtcbiAgICBpZiAoXy5pc0ludGVnZXIoaW5kZXgpICYmIGluZGV4ID4gMCkge1xuICAgICAgZGVyaXZhdGlvbkluZGV4ID0gaW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9ICdtLzAvMC8nICsgZGVyaXZhdGlvbkNoYWluICsgJy8nICsgZGVyaXZhdGlvbkluZGV4O1xuICAgIGNvbnN0IGhkTm9kZXMgPSBrZXljaGFpbnMubWFwKCh7IHB1YiB9KSA9PiBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHB1YikpO1xuICAgIGNvbnN0IGRlcml2ZWRLZXlzID0gaGROb2Rlcy5tYXAoaGROb2RlID0+IGhkUGF0aChoZE5vZGUpLmRlcml2ZUtleShwYXRoKS5nZXRQdWJsaWNLZXlCdWZmZXIoKSk7XG5cbiAgICBjb25zdCB7IG91dHB1dFNjcmlwdCwgcmVkZWVtU2NyaXB0LCB3aXRuZXNzU2NyaXB0LCBhZGRyZXNzIH0gPVxuICAgICAgdGhpcy5jcmVhdGVNdWx0aVNpZ0FkZHJlc3MoYWRkcmVzc1R5cGUsIHNpZ25hdHVyZVRocmVzaG9sZCwgZGVyaXZlZEtleXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBjaGFpbjogZGVyaXZhdGlvbkNoYWluLFxuICAgICAgaW5kZXg6IGRlcml2YXRpb25JbmRleCxcbiAgICAgIGNvaW46IHRoaXMuZ2V0Q2hhaW4oKSxcbiAgICAgIGNvaW5TcGVjaWZpYzoge1xuICAgICAgICBvdXRwdXRTY3JpcHQ6IG91dHB1dFNjcmlwdC50b1N0cmluZygnaGV4JyksXG4gICAgICAgIHJlZGVlbVNjcmlwdDogcmVkZWVtU2NyaXB0ICYmIHJlZGVlbVNjcmlwdC50b1N0cmluZygnaGV4JyksXG4gICAgICAgIHdpdG5lc3NTY3JpcHQ6IHdpdG5lc3NTY3JpcHQgJiYgd2l0bmVzc1NjcmlwdC50b1N0cmluZygnaGV4JyksXG4gICAgICB9LFxuICAgICAgYWRkcmVzc1R5cGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB0cmFuc2FjdGlvbiBwcmVidWlsZCBmcm9tIGJpdGdvIHNlcnZlclxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiBwcml2YXRlIGtleSB0byBiZSB1c2VkIGZvciBzaWduaW5nXG4gICAqIEBwYXJhbSBwYXJhbXMuaXNMYXN0U2lnbmF0dXJlIFRydWUgaWYgYFRyYW5zYWN0aW9uQnVpbGRlci5idWlsZCgpYCBzaG91bGQgYmUgY2FsbGVkIGFuZCBub3QgYFRyYW5zYWN0aW9uQnVpbGRlci5idWlsZEluY29tcGxldGUoKWBcbiAgICogQHJldHVybnMge3t0eEhleH19XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogeyB0eEhleDogc3RyaW5nIH0ge1xuICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcbiAgICBjb25zdCB1c2VyUHJ2ID0gcGFyYW1zLnBydjtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpIHx8ICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgJiYgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eFByZWJ1aWxkfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGxldCB0cmFuc2FjdGlvbiA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleCh0eFByZWJ1aWxkLnR4SGV4LCB0aGlzLm5ldHdvcmspO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLmlucy5sZW5ndGggIT09IHR4UHJlYnVpbGQudHhJbmZvLnVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2YgdW5zcGVudHMgYXJyYXkgc2hvdWxkIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb24gaW5wdXRzJyk7XG4gICAgfVxuXG4gICAgbGV0IGlzTGFzdFNpZ25hdHVyZSA9IGZhbHNlO1xuICAgIGlmIChfLmlzQm9vbGVhbihwYXJhbXMuaXNMYXN0U2lnbmF0dXJlKSkge1xuICAgICAgLy8gaWYgYnVpbGQgaXMgY2FsbGVkIGluc3RlYWQgb2YgYnVpbGRJbmNvbXBsZXRlLCBubyBzaWduYXR1cmUgcGxhY2Vob2xkZXJzIGFyZSBsZWZ0IGluIHRoZSBzaWcgc2NyaXB0XG4gICAgICBpc0xhc3RTaWduYXR1cmUgPSBwYXJhbXMuaXNMYXN0U2lnbmF0dXJlO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHVzZXJQcnYpIHx8ICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodXNlclBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgdXNlclBydn1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcnYgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXljaGFpbiA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgodXNlclBydik7XG4gICAgY29uc3Qga2V5Y2hhaW5IZFBhdGggPSBoZFBhdGgoa2V5Y2hhaW4pO1xuICAgIGNvbnN0IHR4YiA9IGJpdGNvaW4uVHJhbnNhY3Rpb25CdWlsZGVyLmZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgdGhpcy5uZXR3b3JrKTtcbiAgICB0aGlzLnByZXBhcmVUcmFuc2FjdGlvbkJ1aWxkZXIodHhiKTtcblxuICAgIGNvbnN0IGdldFNpZ25hdHVyZUNvbnRleHQgPSAodHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZCwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFVuc3BlbnQgPSB0eFByZWJ1aWxkLnR4SW5mby51bnNwZW50c1tpbmRleF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dEluZGV4OiBpbmRleCxcbiAgICAgICAgdW5zcGVudDogY3VycmVudFVuc3BlbnQsXG4gICAgICAgIHBhdGg6ICdtLzAvMC8nICsgY3VycmVudFVuc3BlbnQuY2hhaW4gKyAnLycgKyBjdXJyZW50VW5zcGVudC5pbmRleCxcbiAgICAgICAgaXNQMndzaDogIWN1cnJlbnRVbnNwZW50LnJlZGVlbVNjcmlwdCxcbiAgICAgICAgaXNCaXRHb1RhaW50ZWRVbnNwZW50OiB0aGlzLmlzQml0R29UYWludGVkVW5zcGVudChjdXJyZW50VW5zcGVudCksXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQgYXMgRXJyb3IgfCB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzaWduYXR1cmVJc3N1ZXM6IFJldHVyblR5cGU8dHlwZW9mIGdldFNpZ25hdHVyZUNvbnRleHQ+W10gPSBbXTtcbiAgICAvLyBTaWduIGlucHV0c1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0cmFuc2FjdGlvbi5pbnMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICBkZWJ1ZygnU2lnbmluZyBpbnB1dCAlZCBvZiAlZCcsIGluZGV4ICsgMSwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aCk7XG4gICAgICBjb25zdCBzaWduYXR1cmVDb250ZXh0ID0gZ2V0U2lnbmF0dXJlQ29udGV4dCh0eFByZWJ1aWxkLCBpbmRleCk7XG4gICAgICBpZiAoc2lnbmF0dXJlQ29udGV4dC5pc0JpdEdvVGFpbnRlZFVuc3BlbnQpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ1NraXBwaW5nIGlucHV0ICVkIG9mICVkICh1bnNwZW50IGZyb20gcmVwbGF5IHByb3RlY3Rpb24gYWRkcmVzcyB3aGljaCBpcyBwbGF0Zm9ybSBzaWduZWQgb25seSknLFxuICAgICAgICAgIGluZGV4ICsgMSwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByaXZLZXkgPSBrZXljaGFpbkhkUGF0aC5kZXJpdmVLZXkoc2lnbmF0dXJlQ29udGV4dC5wYXRoKTtcbiAgICAgIHByaXZLZXkubmV0d29yayA9IHRoaXMubmV0d29yaztcblxuICAgICAgZGVidWcoJ0lucHV0IGRldGFpbHM6ICVPJywgc2lnbmF0dXJlQ29udGV4dCk7XG5cbiAgICAgIGNvbnN0IHNpZ0hhc2hUeXBlID0gdGhpcy5kZWZhdWx0U2lnSGFzaFR5cGU7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2lnbmF0dXJlQ29udGV4dC5pc1Ayd3NoKSB7XG4gICAgICAgICAgZGVidWcoJ1NpZ25pbmcgcDJ3c2ggaW5wdXQnKTtcbiAgICAgICAgICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LndpdG5lc3NTY3JpcHQsICdoZXgnKTtcbiAgICAgICAgICBjb25zdCB3aXRuZXNzU2NyaXB0SGFzaCA9IGJpdGNvaW4uY3J5cHRvLnNoYTI1Nih3aXRuZXNzU2NyaXB0KTtcbiAgICAgICAgICBjb25zdCBwcmV2T3V0U2NyaXB0ID0gYml0Y29pbi5zY3JpcHQud2l0bmVzc1NjcmlwdEhhc2gub3V0cHV0LmVuY29kZSh3aXRuZXNzU2NyaXB0SGFzaCk7XG4gICAgICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHByZXZPdXRTY3JpcHQsIHNpZ0hhc2hUeXBlLCBzaWduYXR1cmVDb250ZXh0LnVuc3BlbnQudmFsdWUsIHdpdG5lc3NTY3JpcHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdCA9IG5ldyBCdWZmZXIoc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LnJlZGVlbVNjcmlwdCwgJ2hleCcpO1xuICAgICAgICAgIGNvbnN0IGlzUDJzaFAyd3NoID0gISFzaWduYXR1cmVDb250ZXh0LnVuc3BlbnQud2l0bmVzc1NjcmlwdDtcbiAgICAgICAgICBpZiAoaXNQMnNoUDJ3c2gpIHtcbiAgICAgICAgICAgIGRlYnVnKCdTaWduaW5nIHAyc2hQMndzaCBpbnB1dCcpO1xuICAgICAgICAgICAgY29uc3Qgd2l0bmVzc1NjcmlwdCA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZUNvbnRleHQudW5zcGVudC53aXRuZXNzU2NyaXB0LCAnaGV4Jyk7XG4gICAgICAgICAgICB0eGIuc2lnbihpbmRleCwgcHJpdktleSwgc3Vic2NyaXB0LCBzaWdIYXNoVHlwZSwgc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LnZhbHVlLCB3aXRuZXNzU2NyaXB0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoJ1NpZ25pbmcgcDJzaCBpbnB1dCcpO1xuICAgICAgICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHN1YnNjcmlwdCwgc2lnSGFzaFR5cGUsIHNpZ25hdHVyZUNvbnRleHQudW5zcGVudC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ0ZhaWxlZCB0byBzaWduIGlucHV0OicsIGUpO1xuICAgICAgICBzaWduYXR1cmVDb250ZXh0LmVycm9yID0gZTtcbiAgICAgICAgc2lnbmF0dXJlSXNzdWVzLnB1c2goc2lnbmF0dXJlQ29udGV4dCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZGVidWcoJ1N1Y2Nlc3NmdWxseSBzaWduZWQgaW5wdXQgJWQgb2YgJWQnLCBpbmRleCArIDEsIHRyYW5zYWN0aW9uLmlucy5sZW5ndGgpO1xuICAgIH1cblxuICAgIGlmIChpc0xhc3RTaWduYXR1cmUpIHtcbiAgICAgIHRyYW5zYWN0aW9uID0gdHhiLmJ1aWxkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uID0gdHhiLmJ1aWxkSW5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBpbnB1dCBzaWduYXR1cmVzXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRyYW5zYWN0aW9uLmlucy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIGRlYnVnKCdWZXJpZnlpbmcgaW5wdXQgc2lnbmF0dXJlICVkIG9mICVkJywgaW5kZXggKyAxLCB0cmFuc2FjdGlvbi5pbnMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUNvbnRleHQgPSBnZXRTaWduYXR1cmVDb250ZXh0KHR4UHJlYnVpbGQsIGluZGV4KTtcbiAgICAgIGlmIChzaWduYXR1cmVDb250ZXh0LmlzQml0R29UYWludGVkVW5zcGVudCkge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAnU2tpcHBpbmcgaW5wdXQgc2lnbmF0dXJlICVkIG9mICVkICh1bnNwZW50IGZyb20gcmVwbGF5IHByb3RlY3Rpb24gYWRkcmVzcyB3aGljaCBpcyBwbGF0Zm9ybSBzaWduZWQgb25seSknLFxuICAgICAgICAgIGluZGV4ICsgMSwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hdHVyZUNvbnRleHQuaXNQMndzaCkge1xuICAgICAgICB0cmFuc2FjdGlvbi5zZXRJbnB1dFNjcmlwdChpbmRleCwgQnVmZmVyLmFsbG9jKDApKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZSA9IHRoaXMudmVyaWZ5U2lnbmF0dXJlKHRyYW5zYWN0aW9uLCBpbmRleCwgc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LnZhbHVlKTtcbiAgICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgICBkZWJ1ZygnSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5lcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgICAgc2lnbmF0dXJlSXNzdWVzLnB1c2goc2lnbmF0dXJlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpZ25hdHVyZUlzc3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmYWlsZWRJbmRpY2VzID0gc2lnbmF0dXJlSXNzdWVzLm1hcChjdXJyZW50SXNzdWUgPT4gY3VycmVudElzc3VlLmlucHV0SW5kZXgpO1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNpZ24gaW5wdXRzIGF0IGluZGljZXMgJHtmYWlsZWRJbmRpY2VzLmpvaW4oJywgJyl9YCk7XG4gICAgICBlcnJvci5jb2RlID0gJ2lucHV0X3NpZ25hdHVyZV9mYWlsdXJlJztcbiAgICAgIGVycm9yLnNpZ25pbmdFcnJvcnMgPSBzaWduYXR1cmVJc3N1ZXM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHhIZXg6IHRyYW5zYWN0aW9uLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWx3YXlzIGZhbHNlIGZvciBjb2lucyBvdGhlciB0aGFuIEJDSCBhbmQgVEJDSC5cbiAgICogQHBhcmFtIHVuc3BlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0JpdEdvVGFpbnRlZFVuc3BlbnQodW5zcGVudDogVW5zcGVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIHRyYW5zYWN0aW9uIGJ1aWxkZXIgdG8gY29tcGx5IHdpdGggdGhlIHNwZWNpZmljIGNvaW4ncyByZXF1aXJlbWVudHMgc3VjaCBhcyB2ZXJzaW9uIGFuZCBicmFuY2ggaWRcbiAgICogQHBhcmFtIHR4QnVpbGRlclxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHByZXBhcmVUcmFuc2FjdGlvbkJ1aWxkZXIodHhCdWlsZGVyOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiB0eEJ1aWxkZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHNpZ2hhc2ggdHlwZSB0byBiZSB1c2VkIHdoZW4gc2lnbmluZyB0cmFuc2FjdGlvbnNcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBkZWZhdWx0U2lnSGFzaFR5cGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHRyYW5zYWN0aW9uJ3Mgc2lnbmF0dXJlIHNjcmlwdCB0byBvYnRhaW4gcHVibGljIGtleXMsIHNpZ25hdHVyZXMsIHRoZSBzaWcgc2NyaXB0LCBhbmQgb3RoZXIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGlucHV0SW5kZXhcbiAgICogQHJldHVybnMgeyBpc1NlZ3dpdElucHV0OiBib29sZWFuLCBpbnB1dENsYXNzaWZpY2F0aW9uOiBzdHJpbmcsIHNpZ25hdHVyZXM6IFtCdWZmZXJdLCBwdWJsaWNLZXlzOiBbQnVmZmVyXSwgcHViU2NyaXB0OiBCdWZmZXIgfVxuICAgKi9cbiAgcGFyc2VTaWduYXR1cmVTY3JpcHQodHJhbnNhY3Rpb246IGFueSwgaW5wdXRJbmRleDogbnVtYmVyKTogUGFyc2VkU2lnbmF0dXJlU2NyaXB0IHtcbiAgICBjb25zdCBjdXJyZW50SW5wdXQgPSB0cmFuc2FjdGlvbi5pbnNbaW5wdXRJbmRleF07XG4gICAgY29uc3QgaXNTZWd3aXRJbnB1dCA9IGN1cnJlbnRJbnB1dC53aXRuZXNzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgaXNOYXRpdmVTZWd3aXRJbnB1dCA9IGN1cnJlbnRJbnB1dC5zY3JpcHQubGVuZ3RoID09PSAwO1xuICAgIGxldCBkZWNvbXBpbGVkU2lnU2NyaXB0LCBpbnB1dENsYXNzaWZpY2F0aW9uO1xuICAgIGlmIChpc1NlZ3dpdElucHV0KSB7XG4gICAgICAvLyBUaGUgZGVjb21waWxlZFNpZ1NjcmlwdCBpcyB0aGUgc2NyaXB0IGNvbnRhaW5pbmcgdGhlIHNpZ25hdHVyZXMsIHB1YmxpYyBrZXlzLCBhbmQgdGhlIHNjcmlwdCB0aGF0IHdhcyBjb21taXR0ZWRcbiAgICAgIC8vIHRvIChwdWJTY3JpcHQpLiBJZiB0aGlzIGlzIGEgc2Vnd2l0IGlucHV0IHRoZSBkZWNvbXBpbGVkU2lnU2NyaXB0IGlzIGluIHRoZSB3aXRuZXNzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXRcbiAgICAgIC8vIGlzIG5hdGl2ZSBvciBub3QuIFRoZSBpbnB1dENsYXNzaWZpY2F0aW9uIGlzIGRldGVybWluZWQgYmFzZWQgb24gd2hldGhlciBvciBub3QgdGhlIGlucHV0IGlzIG5hdGl2ZSB0byBnaXZlIGFuXG4gICAgICAvLyBhY2N1cmF0ZSBjbGFzc2lmaWNhdGlvbi4gTm90ZSB0aGF0IHAyc2hQMndzaCBpbnB1dHMgd2lsbCBiZSBjbGFzc2lmaWVkIGFzIHAyc2ggYW5kIG5vdCBwMndzaC5cbiAgICAgIGRlY29tcGlsZWRTaWdTY3JpcHQgPSBjdXJyZW50SW5wdXQud2l0bmVzcztcbiAgICAgIGlmIChpc05hdGl2ZVNlZ3dpdElucHV0KSB7XG4gICAgICAgIGlucHV0Q2xhc3NpZmljYXRpb24gPSBiaXRjb2luLnNjcmlwdC5jbGFzc2lmeVdpdG5lc3MoYml0Y29pbi5zY3JpcHQuY29tcGlsZShkZWNvbXBpbGVkU2lnU2NyaXB0KSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dENsYXNzaWZpY2F0aW9uID0gYml0Y29pbi5zY3JpcHQuY2xhc3NpZnlJbnB1dChjdXJyZW50SW5wdXQuc2NyaXB0LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXRDbGFzc2lmaWNhdGlvbiA9IGJpdGNvaW4uc2NyaXB0LmNsYXNzaWZ5SW5wdXQoY3VycmVudElucHV0LnNjcmlwdCwgdHJ1ZSk7XG4gICAgICBkZWNvbXBpbGVkU2lnU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuZGVjb21waWxlKGN1cnJlbnRJbnB1dC5zY3JpcHQpO1xuICAgIH1cblxuICAgIGlmIChpbnB1dENsYXNzaWZpY2F0aW9uID09PSBiaXRjb2luLnNjcmlwdC50eXBlcy5QMlBLSCkge1xuICAgICAgY29uc3QgW3NpZ25hdHVyZSwgcHVibGljS2V5XSA9IGRlY29tcGlsZWRTaWdTY3JpcHQ7XG4gICAgICBjb25zdCBwdWJsaWNLZXlzID0gW3B1YmxpY0tleV07XG4gICAgICBjb25zdCBzaWduYXR1cmVzID0gW3NpZ25hdHVyZV07XG4gICAgICBjb25zdCBwdWJTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5wdWJLZXlIYXNoLm91dHB1dC5lbmNvZGUoYml0Y29pbi5jcnlwdG8uaGFzaDE2MChwdWJsaWNLZXkpKTtcblxuICAgICAgcmV0dXJuIHsgaXNTZWd3aXRJbnB1dCwgaW5wdXRDbGFzc2lmaWNhdGlvbiwgc2lnbmF0dXJlcywgcHVibGljS2V5cywgcHViU2NyaXB0IH07XG4gICAgfSBlbHNlIGlmIChpbnB1dENsYXNzaWZpY2F0aW9uID09PSBiaXRjb2luLnNjcmlwdC50eXBlcy5QMlNIXG4gICAgICAgIHx8IGlucHV0Q2xhc3NpZmljYXRpb24gPT09IGJpdGNvaW4uc2NyaXB0LnR5cGVzLlAyV1NIKSB7XG4gICAgICAvLyBOb3RlIHRoZSBhc3N1bXB0aW9uIGhlcmUgdGhhdCBpZiB3ZSBoYXZlIGEgcDJzaCBvciBwMndzaCBpbnB1dCBpdCB3aWxsIGJlIG11bHRpc2lnIChhcHByb3ByaWF0ZSBiZWNhdXNlIHRoZVxuICAgICAgLy8gQml0R28gcGxhdGZvcm0gb25seSBzdXBwb3J0cyBtdWx0aXNpZyB3aXRoaW4gdGhlc2UgdHlwZXMgb2YgaW5wdXRzKS4gU2lnbmF0dXJlcyBhcmUgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyeSBpblxuICAgICAgLy8gdGhlIGRlY29tcGlsZWRTaWdTY3JpcHQuIFRoZSByZWRlZW1TY3JpcHQvd2l0bmVzc1NjcmlwdCAoZGVwZW5kaW5nIG9uIHdoaWNoIHR5cGUgb2YgaW5wdXQgdGhpcyBpcykgaXMgdGhlIGxhc3RcbiAgICAgIC8vIGVudHJ5IGluIHRoZSBkZWNvbXBpbGVkU2lnU2NyaXB0IChkZW5vdGVkIGhlcmUgYXMgdGhlIHB1YlNjcmlwdCkuIFRoZSBwdWJsaWMga2V5cyBhcmUgdGhlIHNlY29uZCB0aHJvdWdoXG4gICAgICAvLyBhbnRlcGVudWx0aW1hdGUgZW50cmllcyBpbiB0aGUgZGVjb21waWxlZFB1YlNjcmlwdC4gU2VlIGJlbG93IGZvciBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwaWNhbCAyLW9mLTNcbiAgICAgIC8vIG11bHRpc2lnIHNldHVwOlxuICAgICAgLy9cbiAgICAgIC8vIGRlY29tcGlsZWRTaWdTY3JpcHQgPSAwIDxzaWcxPiA8c2lnMj4gPHB1YlNjcmlwdD5cbiAgICAgIC8vIGRlY29tcGlsZWRQdWJTY3JpcHQgPSAyIDxwdWIxPiA8cHViMj4gPHB1YjM+IDMgT1BfQ0hFQ0tNVUxUSVNJR1xuICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IGRlY29tcGlsZWRTaWdTY3JpcHQuc2xpY2UoMCwgLTEpO1xuICAgICAgY29uc3QgcHViU2NyaXB0ID0gXy5sYXN0PEJ1ZmZlcj4oZGVjb21waWxlZFNpZ1NjcmlwdCk7XG4gICAgICBjb25zdCBkZWNvbXBpbGVkUHViU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuZGVjb21waWxlKHB1YlNjcmlwdCk7XG4gICAgICBjb25zdCBwdWJsaWNLZXlzID0gZGVjb21waWxlZFB1YlNjcmlwdC5zbGljZSgxLCAtMik7XG5cbiAgICAgIC8vIE9wIGNvZGVzIDgxIHRocm91Z2ggOTYgcmVwcmVzZW50IG51bWJlcnMgMSB0aHJvdWdoIDE2IChzZWUgaHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvU2NyaXB0I09wY29kZXMpLCB3aGljaCBpc1xuICAgICAgLy8gd2h5IHdlIHN1YnRyYWN0IGJ5IDgwIHRvIGdldCB0aGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgKG4pIGFuZCB0aGUgbnVtYmVyIG9mIHB1YmxpYyBrZXlzIChtKSBpbiBhbiBuLW9mLW0gc2V0dXAuXG4gICAgICBjb25zdCBsZW4gPSBkZWNvbXBpbGVkUHViU2NyaXB0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IG5TaWduYXR1cmVzID0gZGVjb21waWxlZFB1YlNjcmlwdFswXSAtIDgwO1xuICAgICAgY29uc3QgblB1YktleXMgPSBkZWNvbXBpbGVkUHViU2NyaXB0W2xlbiAtIDJdIC0gODA7XG5cbiAgICAgIC8vIER1ZSB0byBhIGJ1ZyBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgbXVsdGlzaWduYXR1cmUgaW4gdGhlIGJpdGNvaW4gcHJvdG9jb2wsIGEgMCBpcyBhZGRlZCB0byB0aGUgc2lnbmF0dXJlXG4gICAgICAvLyBzY3JpcHQsIHNvIHdlIGFkZCAxIHdoZW4gYXNzZXJ0aW5nIHRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyBtYXRjaGVzIHRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyBleHBlY3RlZCBieSB0aGVcbiAgICAgIC8vIHB1YiBzY3JpcHQuIEFsc28sIG5vdGUgdGhhdCB3ZSBjb25zaWRlciBhIHNpZ25hdHVyZSBzY3JpcHQgd2l0aCB0aGUgdGhlIHNhbWUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgYXMgcHVibGljXG4gICAgICAvLyBrZXlzICgrMSBhcyBub3RlZCBhYm92ZSkgdmFsaWQgYmVjYXVzZSB3ZSB1c2UgcGxhY2Vob2xkZXIgc2lnbmF0dXJlcyB3aGVuIHBhcnNpbmcgYSBoYWxmLXNpZ25lZCBzaWduYXR1cmVcbiAgICAgIC8vIHNjcmlwdC5cbiAgICAgIGlmIChzaWduYXR1cmVzLmxlbmd0aCAhPT0gblNpZ25hdHVyZXMgKyAxICYmIHNpZ25hdHVyZXMubGVuZ3RoICE9PSBuUHViS2V5cyArIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke25TaWduYXR1cmVzfSBvciAke25QdWJLZXlzfSBzaWduYXR1cmVzLCBnb3QgJHtzaWduYXR1cmVzLmxlbmd0aCAtIDF9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwdWJsaWNLZXlzLmxlbmd0aCAhPT0gblB1YktleXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke25QdWJLZXlzfSBwdWJsaWMga2V5cywgZ290ICR7cHVibGljS2V5cy5sZW5ndGh9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhc3RPcENvZGUgPSBkZWNvbXBpbGVkUHViU2NyaXB0W2xlbiAtIDFdO1xuICAgICAgaWYgKGxhc3RPcENvZGUgIT09IGJpdGNvaW4ub3Bjb2Rlcy5PUF9DSEVDS01VTFRJU0lHKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgb3Bjb2RlICMke2JpdGNvaW4ub3Bjb2Rlcy5PUF9DSEVDS01VTFRJU0lHfSwgZ290IG9wY29kZSAjJHtsYXN0T3BDb2RlfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBpc1NlZ3dpdElucHV0LCBpbnB1dENsYXNzaWZpY2F0aW9uLCBzaWduYXR1cmVzLCBwdWJsaWNLZXlzLCBwdWJTY3JpcHQgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgaXNTZWd3aXRJbnB1dCwgaW5wdXRDbGFzc2lmaWNhdGlvbiB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGhhc2ggdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgYWdhaW5zdFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBpbnB1dEluZGV4XG4gICAqIEBwYXJhbSBwdWJTY3JpcHRcbiAgICogQHBhcmFtIGFtb3VudCBUaGUgcHJldmlvdXMgb3V0cHV0J3MgYW1vdW50XG4gICAqIEBwYXJhbSBoYXNoVHlwZVxuICAgKiBAcGFyYW0gaXNTZWd3aXRJbnB1dFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGNhbGN1bGF0ZVNpZ25hdHVyZUhhc2godHJhbnNhY3Rpb246IGFueSwgaW5wdXRJbmRleDogbnVtYmVyLCBwdWJTY3JpcHQ6IEJ1ZmZlciwgYW1vdW50OiBudW1iZXIsIGhhc2hUeXBlOiBudW1iZXIsIGlzU2Vnd2l0SW5wdXQ6IGJvb2xlYW4pOiBCdWZmZXIge1xuICAgIGlmIChpc1NlZ3dpdElucHV0KSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uaGFzaEZvcldpdG5lc3NWMChpbnB1dEluZGV4LCBwdWJTY3JpcHQsIGFtb3VudCwgaGFzaFR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uaGFzaEZvclNpZ25hdHVyZShpbnB1dEluZGV4LCBwdWJTY3JpcHQsIGhhc2hUeXBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBzaWduYXR1cmUgb24gYSAoaGFsZi1zaWduZWQpIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBiaXRjb2luanMtbGliIHR4IG9iamVjdFxuICAgKiBAcGFyYW0gaW5wdXRJbmRleCBUaGUgaW5wdXQgd2hlcmVyZm9yZSB0byBjaGVjayB0aGUgc2lnbmF0dXJlXG4gICAqIEBwYXJhbSBhbW91bnQgRm9yIHNlZ3dpdCBhbmQgQkNILCB0aGUgaW5wdXQgYW1vdW50IG5lZWRzIHRvIGJlIGtub3duIGZvciBzaWduYXR1cmUgdmVyaWZpY2F0aW9uXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5nc1xuICAgKiBAcGFyYW0gdmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5IChvbmx5IGl0ZXJhdGVzIG92ZXIgbm9uLWVtcHR5IHNpZ25hdHVyZXMpXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkgVGhlIGhleCBvZiB0aGUgcHVibGljIGtleSB0byB2ZXJpZnkgKHdpbGwgdmVyaWZ5IGFsbCBzaWduYXR1cmVzKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbjogYW55LCBpbnB1dEluZGV4OiBudW1iZXIsIGFtb3VudDogbnVtYmVyLCB2ZXJpZmljYXRpb25TZXR0aW5nczoge1xuICAgIHNpZ25hdHVyZUluZGV4PzogbnVtYmVyO1xuICAgIHB1YmxpY0tleT86IHN0cmluZztcbiAgfSA9IHt9KTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBzaWduYXR1cmVzLCBwdWJsaWNLZXlzLCBpc1NlZ3dpdElucHV0LCBpbnB1dENsYXNzaWZpY2F0aW9uLCBwdWJTY3JpcHQgfSA9XG4gICAgICAgIHRoaXMucGFyc2VTaWduYXR1cmVTY3JpcHQodHJhbnNhY3Rpb24sIGlucHV0SW5kZXgpO1xuXG4gICAgaWYgKCFbYml0Y29pbi5zY3JpcHQudHlwZXMuUDJXU0gsIGJpdGNvaW4uc2NyaXB0LnR5cGVzLlAyU0gsIGJpdGNvaW4uc2NyaXB0LnR5cGVzLlAyUEtIXS5pbmNsdWRlcyhpbnB1dENsYXNzaWZpY2F0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghcHVibGljS2V5cyB8fCBwdWJsaWNLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc1NlZ3dpdElucHV0ICYmICFhbW91bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGZpcnN0IG5vbi1lbXB0eSBzaWduYXR1cmUgYW5kIHZlcmlmeSBpdCBhZ2FpbnN0IGFsbCBwdWJsaWMga2V5c1xuICAgIGNvbnN0IG5vbkVtcHR5U2lnbmF0dXJlcyA9IF8uZmlsdGVyKHNpZ25hdHVyZXMsIHMgPT4gIV8uaXNFbXB0eShzKSk7XG5cbiAgICAvKlxuICAgIFdlIGVpdGhlciB3YW50IHRvIHZlcmlmeSBhbGwgc2lnbmF0dXJlL3B1YmtleSBjb21iaW5hdGlvbnMsIG9yIGRvIGFuIGV4cGxpY2l0IGNvbWJpbmF0aW9uXG5cbiAgICBJZiBhIHNpZ25hdHVyZSBpbmRleCBpcyBzcGVjaWZpZWQsIG9ubHkgdGhhdCBzaWduYXR1cmUgaXMgY2hlY2tlZC4gSXQncyB2ZXJpZmllZCBhZ2FpbnN0IGFsbCBwdWJsaWMga2V5cy5cbiAgICBJZiBhIHNpbmdsZSBwdWJsaWMga2V5IGlzIGZvdW5kIHRvIGJlIHZhbGlkLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLlxuXG4gICAgSWYgYSBwdWJsaWMga2V5IGlzIHNwZWNpZmllZCwgd2UgaXRlcmF0ZSBvdmVyIGFsbCBzaWduYXR1cmVzLiBJZiBhIHNpbmdsZSBvbmUgbWF0Y2hlcyB0aGUgcHVibGljIGtleSwgdGhlIGZ1bmN0aW9uXG4gICAgcmV0dXJucyB0cnVlLlxuXG4gICAgSWYgbmVpdGhlciBpcyBzcGVjaWZpZWQsIGFsbCBzaWduYXR1cmVzIGFyZSBjaGVja2VkIGFnYWluc3QgYWxsIHB1YmxpYyBrZXlzLiBFYWNoIHNpZ25hdHVyZSBtdXN0IGhhdmUgaXRzIG93biBkaXN0aW5jdFxuICAgIHB1YmxpYyBrZXkgdGhhdCBpdCBtYXRjaGVzIGZvciB0aGUgZnVuY3Rpb24gdG8gcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgbGV0IHNpZ25hdHVyZXNUb0NoZWNrID0gbm9uRW1wdHlTaWduYXR1cmVzO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCh2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCkpIHtcbiAgICAgIHNpZ25hdHVyZXNUb0NoZWNrID0gW25vbkVtcHR5U2lnbmF0dXJlc1t2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleF1dO1xuICAgIH1cblxuICAgIGNvbnN0IHB1YmxpY0tleUhleCA9IHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleTtcbiAgICBjb25zdCBtYXRjaGVkUHVibGljS2V5SW5kaWNlcyA9IHt9O1xuICAgIGxldCBhcmVBbGxTaWduYXR1cmVzVmFsaWQgPSB0cnVlO1xuXG4gICAgLy8gZ28gb3ZlciBhbGwgc2lnbmF0dXJlc1xuICAgIGZvciAoY29uc3Qgc2lnbmF0dXJlQnVmZmVyIG9mIHNpZ25hdHVyZXNUb0NoZWNrKSB7XG5cbiAgICAgIGxldCBpc1NpZ25hdHVyZVZhbGlkID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGhhc1NpZ25hdHVyZUJ1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihzaWduYXR1cmVCdWZmZXIpICYmIHNpZ25hdHVyZUJ1ZmZlci5sZW5ndGggPiAwO1xuICAgICAgaWYgKGhhc1NpZ25hdHVyZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocHViU2NyaXB0KSAmJiBwdWJTY3JpcHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBzbGljZSB0aGUgbGFzdCBieXRlIGZyb20gdGhlIHNpZ25hdHVyZSBoYXNoIGlucHV0IGJlY2F1c2UgaXQncyB0aGUgaGFzaCB0eXBlXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJpdGNvaW4uRUNTaWduYXR1cmUuZnJvbURFUihzaWduYXR1cmVCdWZmZXIuc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgY29uc3QgaGFzaFR5cGUgPSBfLmxhc3Qoc2lnbmF0dXJlQnVmZmVyKTtcbiAgICAgICAgaWYgKCFoYXNoVHlwZSkge1xuICAgICAgICAgIC8vIG1pc3NpbmcgaGFzaFR5cGUgYnl0ZSAtIHNpZ25hdHVyZSBjYW5ub3QgYmUgdmFsaWRhdGVkXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUhhc2ggPSB0aGlzLmNhbGN1bGF0ZVNpZ25hdHVyZUhhc2godHJhbnNhY3Rpb24sIGlucHV0SW5kZXgsIHB1YlNjcmlwdCwgYW1vdW50LCBoYXNoVHlwZSwgaXNTZWd3aXRJbnB1dCk7XG5cbiAgICAgICAgZm9yIChsZXQgcHVibGljS2V5SW5kZXggPSAwOyBwdWJsaWNLZXlJbmRleCA8IHB1YmxpY0tleXMubGVuZ3RoOyBwdWJsaWNLZXlJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcHVibGljS2V5QnVmZmVyID0gcHVibGljS2V5c1twdWJsaWNLZXlJbmRleF07XG4gICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHB1YmxpY0tleUhleCkgJiYgcHVibGljS2V5QnVmZmVyLnRvU3RyaW5nKCdoZXgnKSAhPT0gcHVibGljS2V5SGV4KSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgb25seSBsb29raW5nIHRvIHZlcmlmeSBvbmUgc3BlY2lmaWMgcHVibGljIGtleSdzIHNpZ25hdHVyZSAocHVibGljS2V5SGV4KVxuICAgICAgICAgICAgLy8gdGhpcyBwYXJ0aWN1bGFyIHB1YmxpYyBrZXkgaXMgbm90IHRoZSBvbmUgd2hvc2Ugc2lnbmF0dXJlIHdlJ3JlIHRyeWluZyB0byB2ZXJpZnlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVkUHVibGljS2V5SW5kaWNlc1twdWJsaWNLZXlJbmRleF0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGJpdGNvaW4uRUNQYWlyLmZyb21QdWJsaWNLZXlCdWZmZXIocHVibGljS2V5QnVmZmVyKTtcbiAgICAgICAgICBpZiAocHVibGljS2V5LnZlcmlmeShzaWduYXR1cmVIYXNoLCBzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICBpc1NpZ25hdHVyZVZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hdGNoZWRQdWJsaWNLZXlJbmRpY2VzW3B1YmxpY0tleUluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHB1YmxpY0tleUhleCkgJiYgaXNTaWduYXR1cmVWYWxpZCkge1xuICAgICAgICAvLyBXZSB3ZXJlIHRyeWluZyB0byBzZWUgaWYgYW55IG9mIHRoZSBzaWduYXR1cmVzIHdhcyB2YWxpZCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkuIEV2aWRlbnRseSB5ZXMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2lnbmF0dXJlVmFsaWQgJiYgXy5pc1VuZGVmaW5lZChwdWJsaWNLZXlIZXgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYXJlQWxsU2lnbmF0dXJlc1ZhbGlkID0gaXNTaWduYXR1cmVWYWxpZCAmJiBhcmVBbGxTaWduYXR1cmVzVmFsaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZUFsbFNpZ25hdHVyZXNWYWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXBvc2UgYSByYXcgdHJhbnNhY3Rpb24gaW50byB1c2VmdWwgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIHRvdGFsIGFtb3VudHMsXG4gICAqIGNoYW5nZSBhbW91bnRzLCBhbmQgdHJhbnNhY3Rpb24gb3V0cHV0cy5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgdHhIZXggPSBfLmdldChwYXJhbXMsICd0eEhleCcpO1xuICAgICAgaWYgKCF0eEhleCB8fCAhXy5pc1N0cmluZyh0eEhleCkgfHwgIXR4SGV4Lm1hdGNoKC9eKFthLWYwLTldezJ9KSskL2kpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0cmFuc2FjdGlvbiBoZXgsIG11c3QgYmUgYSB2YWxpZCBoZXggc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHR4SGV4LCBzZWxmLm5ldHdvcmspO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSB0cmFuc2FjdGlvbiBoZXgnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaWQgPSB0cmFuc2FjdGlvbi5nZXRJZCgpO1xuICAgICAgbGV0IGNoYW5nZUFkZHJlc3Nlczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGxldCBzcGVuZEFtb3VudCA9IDA7XG4gICAgICBsZXQgY2hhbmdlQW1vdW50ID0gMDtcbiAgICAgIGNvbnN0IHR4SW5mbyA9IF8uZ2V0KHBhcmFtcywgJ3R4SW5mbycpO1xuICAgICAgaWYgKHR4SW5mbyAmJiB0eEluZm8uY2hhbmdlQWRkcmVzc2VzKSB7XG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyA9IHR4SW5mby5jaGFuZ2VBZGRyZXNzZXM7XG4gICAgICB9XG4gICAgICBjb25zdCBleHBsYW5hdGlvbjogYW55ID0ge1xuICAgICAgICBkaXNwbGF5T3JkZXI6IFsnaWQnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnXSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICB9O1xuXG4gICAgICB0cmFuc2FjdGlvbi5vdXRzLmZvckVhY2goKGN1cnJlbnRPdXRwdXQpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEFkZHJlc3MgPSBzZWxmLmdldENvaW5MaWJyYXJ5KCkuYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KGN1cnJlbnRPdXRwdXQuc2NyaXB0LCBzZWxmLm5ldHdvcmspO1xuICAgICAgICBjb25zdCBjdXJyZW50QW1vdW50ID0gY3VycmVudE91dHB1dC52YWx1ZTtcblxuICAgICAgICBpZiAoY2hhbmdlQWRkcmVzc2VzLmluZGV4T2YoY3VycmVudEFkZHJlc3MpICE9PSAtMSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgY2hhbmdlXG4gICAgICAgICAgY2hhbmdlQW1vdW50ICs9IGN1cnJlbnRBbW91bnQ7XG4gICAgICAgICAgZXhwbGFuYXRpb24uY2hhbmdlT3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgICAgYW1vdW50OiBjdXJyZW50QW1vdW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwZW5kQW1vdW50ICs9IGN1cnJlbnRBbW91bnQ7XG4gICAgICAgIGV4cGxhbmF0aW9uLm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgYWRkcmVzczogY3VycmVudEFkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiBjdXJyZW50QW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZXhwbGFuYXRpb24ub3V0cHV0QW1vdW50ID0gc3BlbmRBbW91bnQ7XG4gICAgICBleHBsYW5hdGlvbi5jaGFuZ2VBbW91bnQgPSBjaGFuZ2VBbW91bnQ7XG5cbiAgICAgIC8vIGFkZCBmZWUgaW5mbyBpZiBhdmFpbGFibGVcbiAgICAgIGlmIChwYXJhbXMuZmVlSW5mbykge1xuICAgICAgICBleHBsYW5hdGlvbi5kaXNwbGF5T3JkZXIucHVzaCgnZmVlJyk7XG4gICAgICAgIGV4cGxhbmF0aW9uLmZlZSA9IHBhcmFtcy5mZWVJbmZvO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc0ludGVnZXIodHJhbnNhY3Rpb24ubG9ja3RpbWUpICYmIHRyYW5zYWN0aW9uLmxvY2t0aW1lID4gMCkge1xuICAgICAgICBleHBsYW5hdGlvbi5sb2NrdGltZSA9IHRyYW5zYWN0aW9uLmxvY2t0aW1lO1xuICAgICAgICBleHBsYW5hdGlvbi5kaXNwbGF5T3JkZXIucHVzaCgnbG9ja3RpbWUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW5zcGVudFZhbHVlcyA9IHt9O1xuXG4gICAgICAvLyBnZXQgaW5mb3JtYXRpb24gb24gdHggaW5wdXRzXG4gICAgICBjb25zdCBpbnB1dFNpZ25hdHVyZXMgPSB0cmFuc2FjdGlvbi5pbnMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc1NpZ1NjcmlwdCA9ICFfLmlzRW1wdHkoaW5wdXQuc2NyaXB0KTtcbiAgICAgICAgY29uc3QgaGFzV2l0bmVzc1NjcmlwdCA9ICFfLmlzRW1wdHkoaW5wdXQud2l0bmVzcyk7XG5cbiAgICAgICAgaWYgKCFoYXNTaWdTY3JpcHQgJiYgIWhhc1dpdG5lc3NTY3JpcHQpIHtcbiAgICAgICAgICAvLyBubyBzaWcgc2NyaXB0IG9yIHdpdG5lc3MgZGF0YSBmb3IgdGhpcyBpbnB1dFxuICAgICAgICAgIGRlYnVnKCdubyBzaWduYXR1cmUgc2NyaXB0IG9yIHdpdG5lc3Mgc2NyaXB0IGRhdGEgZm9yIGlucHV0ICVzJywgaWR4KTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJzZWRTaWdTY3JpcHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkU2lnU2NyaXB0ID0gc2VsZi5wYXJzZVNpZ25hdHVyZVNjcmlwdCh0cmFuc2FjdGlvbiwgaWR4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNXaXRuZXNzU2NyaXB0KSB7XG4gICAgICAgICAgaWYgKCF0eEluZm8gfHwgIXR4SW5mby51bnNwZW50cykge1xuICAgICAgICAgICAgLy8gc2Vnd2l0IHR4cyByZXF1aXJlIGlucHV0IHZhbHVlcywgY2Fubm90IHZhbGlkYXRlIHNpZ25hdHVyZXNcbiAgICAgICAgICAgIGRlYnVnKCd1bmFibGUgdG8gcmV0cmlldmUgaW5wdXQgYW1vdW50cyBmcm9tIHVuc3BlbnRzIC0gY2Fubm90IHZhbGlkYXRlIHNlZ3dpdCBpbnB1dCBzaWduYXR1cmVzJyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBsYXppbHkgcG9wdWxhdGUgdW5zcGVudCB2YWx1ZXNcbiAgICAgICAgICBpZiAoXy5pc0VtcHR5KHVuc3BlbnRWYWx1ZXMpKSB7XG4gICAgICAgICAgICB0eEluZm8udW5zcGVudHMuZm9yRWFjaCgodW5zcGVudCkgPT4ge1xuICAgICAgICAgICAgICB1bnNwZW50VmFsdWVzW3Vuc3BlbnQuaWRdID0gdW5zcGVudC52YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vbkVtcHR5U2lnbmF0dXJlcyA9IHBhcnNlZFNpZ1NjcmlwdC5zaWduYXR1cmVzLmZpbHRlcigoc2lnKSA9PiAhXy5pc0VtcHR5KHNpZykpO1xuICAgICAgICBjb25zdCB2YWxpZFNpZ25hdHVyZXMgPSBub25FbXB0eVNpZ25hdHVyZXMubWFwKChzaWcsIHNpZ0luZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKF8uaXNFbXB0eShzaWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcGFyZW50VHhJZCA9IChCdWZmZXIuZnJvbShpbnB1dC5oYXNoKS5yZXZlcnNlKCkgYXMgQnVmZmVyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgY29uc3QgaW5wdXRJZCA9IGAke3BhcmVudFR4SWR9OiR7aW5wdXQuaW5kZXh9YDtcbiAgICAgICAgICBjb25zdCBhbW91bnQgPSB1bnNwZW50VmFsdWVzW2lucHV0SWRdO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgaWR4LCBhbW91bnQsIHsgc2lnbmF0dXJlSW5kZXg6IHNpZ0luZGV4IH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWxpZFNpZ25hdHVyZXMucmVkdWNlKCh2YWxpZENvdW50LCBpc1ZhbGlkKSA9PiBpc1ZhbGlkID8gdmFsaWRDb3VudCArIDEgOiB2YWxpZENvdW50LCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBsYW5hdGlvbi5pbnB1dFNpZ25hdHVyZXMgPSBpbnB1dFNpZ25hdHVyZXM7XG4gICAgICBleHBsYW5hdGlvbi5zaWduYXR1cmVzID0gXy5tYXgoaW5wdXRTaWduYXR1cmVzKTtcbiAgICAgIHJldHVybiBleHBsYW5hdGlvbjtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG11bHRpc2lnIGFkZHJlc3Mgb2YgYSBnaXZlbiB0eXBlIGZyb20gYSBsaXN0IG9mIGtleWNoYWlucyBhbmQgYSBzaWduaW5nIHRocmVzaG9sZFxuICAgKiBAcGFyYW0gYWRkcmVzc1R5cGVcbiAgICogQHBhcmFtIHNpZ25hdHVyZVRocmVzaG9sZFxuICAgKiBAcGFyYW0ga2V5c1xuICAgKi9cbiAgY3JlYXRlTXVsdGlTaWdBZGRyZXNzKGFkZHJlc3NUeXBlOiBzdHJpbmcsIHNpZ25hdHVyZVRocmVzaG9sZDogbnVtYmVyLCBrZXlzOiBCdWZmZXJbXSk6IE11bHRpU2lnQWRkcmVzcyB7XG4gICAgZnVuY3Rpb24gY3JlYXRlV2l0bmVzc1Byb2dyYW0oaW5wdXRTY3JpcHQpIHtcbiAgICAgIGNvbnN0IHdpdG5lc3NTY3JpcHRIYXNoID0gYml0Y29pbi5jcnlwdG8uc2hhMjU2KGlucHV0U2NyaXB0KTtcbiAgICAgIHJldHVybiBiaXRjb2luLnNjcmlwdC53aXRuZXNzU2NyaXB0SGFzaC5vdXRwdXQuZW5jb2RlKHdpdG5lc3NTY3JpcHRIYXNoKTtcbiAgICB9XG5cbiAgICBjb25zdCBtdWx0aVNpZ1NjcmlwdCA9IGJpdGNvaW4uc2NyaXB0Lm11bHRpc2lnLm91dHB1dC5lbmNvZGUoc2lnbmF0dXJlVGhyZXNob2xkLCBrZXlzKTtcbiAgICBsZXQgb3V0cHV0U2NyaXB0LCByZWRlZW1TY3JpcHQsIHdpdG5lc3NTY3JpcHQ7XG4gICAgc3dpdGNoIChhZGRyZXNzVHlwZSkge1xuICAgICAgY2FzZSBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoJyk6XG4gICAgICAgIGNvbnN0IG11bHRpc2lnU2NyaXB0SGFzaCA9IGJpdGNvaW4uY3J5cHRvLmhhc2gxNjAobXVsdGlTaWdTY3JpcHQpO1xuICAgICAgICBvdXRwdXRTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5zY3JpcHRIYXNoLm91dHB1dC5lbmNvZGUobXVsdGlzaWdTY3JpcHRIYXNoKTtcbiAgICAgICAgcmVkZWVtU2NyaXB0ID0gbXVsdGlTaWdTY3JpcHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoUDJ3c2gnKTpcbiAgICAgICAgY29uc3Qgd2l0bmVzc1Byb2dyYW0gPSBjcmVhdGVXaXRuZXNzUHJvZ3JhbShtdWx0aVNpZ1NjcmlwdCk7XG4gICAgICAgIGNvbnN0IHdpdG5lc3NQcm9ncmFtSGFzaCA9IGJpdGNvaW4uY3J5cHRvLmhhc2gxNjAod2l0bmVzc1Byb2dyYW0pO1xuICAgICAgICBvdXRwdXRTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5zY3JpcHRIYXNoLm91dHB1dC5lbmNvZGUod2l0bmVzc1Byb2dyYW1IYXNoKTtcbiAgICAgICAgcmVkZWVtU2NyaXB0ID0gd2l0bmVzc1Byb2dyYW07XG4gICAgICAgIHdpdG5lc3NTY3JpcHQgPSBtdWx0aVNpZ1NjcmlwdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayd3NoJyk6XG4gICAgICAgIG91dHB1dFNjcmlwdCA9IGNyZWF0ZVdpdG5lc3NQcm9ncmFtKG11bHRpU2lnU2NyaXB0KTtcbiAgICAgICAgd2l0bmVzc1NjcmlwdCA9IG11bHRpU2lnU2NyaXB0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBhZGRyZXNzVHlwZSAke2FkZHJlc3NUeXBlfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXRTY3JpcHQsXG4gICAgICByZWRlZW1TY3JpcHQsXG4gICAgICB3aXRuZXNzU2NyaXB0LFxuICAgICAgYWRkcmVzczogYml0Y29pbi5hZGRyZXNzLmZyb21PdXRwdXRTY3JpcHQob3V0cHV0U2NyaXB0LCB0aGlzLm5ldHdvcmspLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHNjcmlwdEhhc2hTY3JpcHRcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIC8vIFRPRE8oQkctMTE2MzgpOiByZW1vdmUgaW4gbmV4dCBTREsgbWFqb3IgdmVyc2lvbiByZWxlYXNlXG4gIGNhbGN1bGF0ZVJlY292ZXJ5QWRkcmVzcyhzY3JpcHRIYXNoU2NyaXB0OiBCdWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb2luTGlicmFyeSgpLmFkZHJlc3MuZnJvbU91dHB1dFNjcmlwdChzY3JpcHRIYXNoU2NyaXB0LCB0aGlzLm5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0YXRpYyBmZWUgcmF0ZSB3aGljaCBpcyB1c2VkIGluIHJlY292ZXJ5IHNpdHVhdGlvbnNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoKTogQmx1ZWJpcmQ8bnVtYmVyPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoMTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB1cmwgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGRldGVybWluaW5nIHJlY292ZXJ5IGZlZSByYXRlc1xuICAgKi9cbiAgZ2V0UmVjb3ZlcnlGZWVSZWNvbW1lbmRhdGlvbkFwaUJhc2VVcmwoKTogQmx1ZWJpcmQ8c3RyaW5nPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChuZXcgRXJyb3IoJ0FidHJhY3RVdHhvQ29pbiBtZXRob2Qgbm90IGltcGxlbWVudGVkJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBtYXJrZXQgcHJpY2UgZnJvbSBhIHRoaXJkIHBhcnR5IHRvIGJlIHVzZWQgZm9yIHJlY292ZXJ5XG4gICAqL1xuICBnZXRSZWNvdmVyeU1hcmtldFByaWNlKCk6IEJsdWViaXJkPHN0cmluZz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdHJpbmc+KGZ1bmN0aW9uICpnZXRSZWNvdmVyeU1hcmtldFByaWNlKCkge1xuICAgICAgY29uc3QgYml0Y29pbkF2ZXJhZ2VVcmwgPSBjb25maWcuYml0Y29pbkF2ZXJhZ2VCYXNlVXJsICsgc2VsZi5nZXRGYW1pbHkoKS50b1VwcGVyQ2FzZSgpICsgJ1VTRCc7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3QuZ2V0KGJpdGNvaW5BdmVyYWdlVXJsKS5yZXRyeSgyKS5yZXN1bHQoKTtcblxuICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsIHx8IHR5cGVvZiByZXNwb25zZS5sYXN0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byByZWFjaCBCaXRjb2luQXZlcmFnZSBmb3IgcHJpY2UgZGF0YScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UubGFzdDtcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcmVjb3ZlcigpXG4gICAqIFRoaXMgdHJhbnNmb3JtcyB0aGUgdHhJbmZvIGZyb20gcmVjb3ZlciBpbnRvIHRoZSBmb3JtYXQgdGhhdCBvZmZsaW5lLXNpZ25pbmctdG9vbCBleHBlY3RzXG4gICAqIEBwYXJhbSB0eEluZm9cbiAgICogQHBhcmFtIHR4SGV4XG4gICAqIEByZXR1cm5zIHt7dHhIZXg6ICosIHR4SW5mbzoge3Vuc3BlbnRzOiAqfSwgZmVlSW5mbzoge30sIGNvaW46IHZvaWR9fVxuICAgKi9cbiAgZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KHR4SW5mbzogT2ZmbGluZVZhdWx0VHhJbmZvLCB0eEhleDogc3RyaW5nKTogRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgICBjb25zdCByZXNwb25zZTogRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvID0ge1xuICAgICAgdHhIZXgsXG4gICAgICB0eEluZm86IHtcbiAgICAgICAgdW5zcGVudHM6IHR4SW5mby5pbnB1dHMsXG4gICAgICB9LFxuICAgICAgZmVlSW5mbzoge30sXG4gICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgfTtcbiAgICBfLm1hcChyZXNwb25zZS50eEluZm8udW5zcGVudHMsIGZ1bmN0aW9uKHVuc3BlbnQpIHtcbiAgICAgIGNvbnN0IHBhdGhBcnJheSA9IHVuc3BlbnQuY2hhaW5QYXRoLnNwbGl0KCcvJyk7XG4gICAgICAvLyBOb3RlIHRoaXMgY29kZSB3b3JrcyBiZWNhdXNlIHdlIGFzc3VtZSBvdXIgY2hhaW5QYXRoIGlzIG0vMC8wL2NoYWluL2luZGV4IC0gdGhpcyB3aWxsIGJlIGluY29ycmVjdCBmb3IgY3VzdG9tIGRlcml2YXRpb24gc2NoZW1lc1xuICAgICAgdW5zcGVudC5pbmRleCA9IHBhdGhBcnJheVs0XTtcbiAgICAgIHVuc3BlbnQuY2hhaW4gPSBwYXRoQXJyYXlbM107XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldEFkZHJlc3NJbmZvRnJvbUV4cGxvcmVyKGFkZHJlc3M6IHN0cmluZyk6IEJsdWViaXJkPEFkZHJlc3NJbmZvPjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldFVuc3BlbnRJbmZvRnJvbUV4cGxvcmVyKGFkZHJlc3M6IHN0cmluZyk6IEJsdWViaXJkPFVuc3BlbnRJbmZvW10+O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB1c2VyS2V5OiBbZW5jcnlwdGVkXSB4cHJ2LCBvciB4cHViXG4gICAqIC0gYmFja3VwS2V5OiBbZW5jcnlwdGVkXSB4cHJ2LCBvciB4cHViIGlmIHRoZSB4cHJ2IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSB4cHJ2cyBpcyBlbmNyeXB0ZWRcbiAgICogLSBiaXRnb0tleTogeHB1YlxuICAgKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICAgKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIC0gc2NhbjogdGhlIGFtb3VudCBvZiBjb25zZWN1dGl2ZSBhZGRyZXNzZXMgd2l0aG91dCB1bnNwZW50cyB0byBzY2FuIHRocm91Z2ggYmVmb3JlIHN0b3BwaW5nXG4gICAqIC0gaWdub3JlQWRkcmVzc1R5cGVzOiAob3B0aW9uYWwpIGFycmF5IG9mIEFkZHJlc3NUeXBlcyB0byBpZ25vcmUsIHRoZXNlIGFyZSBzdHJpbmdzIGRlZmluZWQgaW4gQ29kZXMuVW5zcGVudFR5cGVUY29tYlxuICAgKiAgICAgICAgZm9yIGV4YW1wbGU6IFsncDJzaFAyd3NoJywgJ3Ayd3NoJ10gd2lsbCBwcmV2ZW50IGNvZGUgZnJvbSBjaGVja2luZyBmb3Igd3JhcHBlZC1zZWd3aXQgYW5kIG5hdGl2ZS1zZWd3aXQgY2hhaW5zIG9uIHRoZSBwdWJsaWMgYmxvY2sgZXhwbG9yZXJzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVjb3ZlcihwYXJhbXM6IFJlY292ZXJQYXJhbXMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKnJlY292ZXIoKSB7XG4gICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09SEVMUEVSIEZVTkNUSU9OUz09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIGZ1bmN0aW9uIGRlcml2ZUtleXMoa2V5QXJyYXk6IGJpdGNvaW4uSEROb2RlW10sIGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGtleUFycmF5Lm1hcCgoaykgPT4gay5kZXJpdmUoaW5kZXgpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcXVlcnlCbG9ja2NoYWluVW5zcGVudHNQYXRoKGtleUFycmF5OiBiaXRjb2luLkhETm9kZVtdLCBiYXNlUGF0aDogc3RyaW5nLCBhZGRyZXNzZXNCeUlkKSB7XG4gICAgICAgIHJldHVybiBjbyhmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGNvbnN0IE1BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYUyA9IHBhcmFtcy5zY2FuIHx8IDIwO1xuICAgICAgICAgIGxldCBudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cyA9IDA7XG5cbiAgICAgICAgICAvLyBnZXQgdW5zcGVudHMgZm9yIHRoZXNlIGFkZHJlc3Nlc1xuICAgICAgICAgIGNvbnN0IGdhdGhlclVuc3BlbnRzID0gY28oZnVuY3Rpb24qIGNvR2F0aGVyVW5zcGVudHMoYWRkckluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBkZXJpdmVkS2V5cyA9IGRlcml2ZUtleXMoa2V5QXJyYXksIGFkZHJJbmRleCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNoYWluID0gTnVtYmVyKGJhc2VQYXRoLnNwbGl0KCcvJykucG9wKCkpOyAvLyBleHRyYWN0cyB0aGUgY2hhaW4gZnJvbSB0aGUgYmFzZVBhdGhcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBkZXJpdmVkS2V5cy5tYXAoayA9PiBrLmdldFB1YmxpY0tleUJ1ZmZlcigpKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3M6IGFueSA9IHNlbGYuY3JlYXRlTXVsdGlTaWdBZGRyZXNzKENvZGVzLnR5cGVGb3JDb2RlKGNoYWluKSwgMiwga2V5cyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFkZHJJbmZvOiBBZGRyZXNzSW5mbyA9IHlpZWxkIHNlbGYuZ2V0QWRkcmVzc0luZm9Gcm9tRXhwbG9yZXIoYWRkcmVzcy5hZGRyZXNzKTtcblxuICAgICAgICAgICAgaWYgKGFkZHJJbmZvLnR4Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgbnVtU2VxdWVudGlhbEFkZHJlc3Nlc1dpdGhvdXRUeHMrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID0gMDtcblxuICAgICAgICAgICAgICBpZiAoYWRkckluZm8udG90YWxCYWxhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWRkcmVzcyBoYXMgYSBiYWxhbmNlLlxuICAgICAgICAgICAgICAgIGFkZHJlc3MuY2hhaW5QYXRoID0gYmFzZVBhdGggKyAnLycgKyBhZGRySW5kZXg7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy51c2VyS2V5ID0gZGVyaXZlZEtleXNbMF07XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5iYWNrdXBLZXkgPSBkZXJpdmVkS2V5c1sxXTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXNCeUlkW2FkZHJlc3MuYWRkcmVzc10gPSBhZGRyZXNzO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgdW5zcGVudHMgb24gaXQuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzc1Vuc3BlbnRzOiBVbnNwZW50SW5mb1tdID0geWllbGQgc2VsZi5nZXRVbnNwZW50SW5mb0Zyb21FeHBsb3JlcihhZGRyZXNzLmFkZHJlc3MpO1xuXG4gICAgICAgICAgICAgICAgYWRkcmVzc1Vuc3BlbnRzLmZvckVhY2goZnVuY3Rpb24gYWRkQWRkcmVzc1RvVW5zcGVudCh1bnNwZW50KSB7XG4gICAgICAgICAgICAgICAgICB1bnNwZW50LmFkZHJlc3MgPSBhZGRyZXNzLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICB3YWxsZXRVbnNwZW50cy5wdXNoKHVuc3BlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cyA+PSBNQVhfU0VRVUVOVElBTF9BRERSRVNTRVNfV0lUSE9VVF9UWFMpIHtcbiAgICAgICAgICAgICAgLy8gc3RvcCBzZWFyY2hpbmcgZm9yIGFkZHJlc3NlcyB3aXRoIHVuc3BlbnRzIGluIHRoZW0sIHdlJ3ZlIGZvdW5kIDUgaW4gYSByb3cgd2l0aCBub25lXG4gICAgICAgICAgICAgIC8vIHdlIGFyZSBkb25lXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdhdGhlclVuc3BlbnRzKGFkZHJJbmRleCArIDEpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3Qgd2FsbGV0VW5zcGVudHM6IFVuc3BlbnRJbmZvW10gPSBbXTtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgcG9wdWxhdGUgd2FsbGV0QWRkcmVzc2VzXG4gICAgICAgICAgeWllbGQgZ2F0aGVyVW5zcGVudHMoMCk7XG5cbiAgICAgICAgICBpZiAod2FsbGV0VW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBDb3VsZG4ndCBmaW5kIGFueSBhZGRyZXNzZXMgd2l0aCBmdW5kc1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3YWxsZXRVbnNwZW50cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PUxPR0lDPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnVzZXJLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5iYWNrdXBLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pIHx8ICFzZWxmLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnlEZXN0aW5hdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnNjYW4pICYmICghXy5pc0ludGVnZXIocGFyYW1zLnNjYW4pIHx8IHBhcmFtcy5zY2FuIDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FuIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzS3JzUmVjb3ZlcnkgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiAhcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuICAgICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuICAgICAgY29uc3Qga3JzUHJvdmlkZXIgPSBjb25maWcua3JzUHJvdmlkZXJzW3BhcmFtcy5rcnNQcm92aWRlcl07XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5ICYmIF8uaXNVbmRlZmluZWQoa3JzUHJvdmlkZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgcmVjb3Zlcnkgc2VydmljZSBwcm92aWRlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSAmJiAhKGtyc1Byb3ZpZGVyLnN1cHBvcnRlZENvaW5zLmluY2x1ZGVzKHNlbGYuZ2V0RmFtaWx5KCkpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwZWNpZmllZCBrZXkgcmVjb3Zlcnkgc2VydmljZSBkb2VzIG5vdCBzdXBwb3J0IHJlY292ZXJpZXMgZm9yIHRoaXMgY29pbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXlzID0geWllbGQgc2VsZi5pbml0aWF0ZVJlY292ZXJ5KHBhcmFtcyk7XG5cbiAgICAgIGNvbnN0IGJhc2VLZXlQYXRoID0gZGVyaXZlS2V5cyhkZXJpdmVLZXlzKGtleXMsIDApLCAwKTtcblxuICAgICAgY29uc3QgcXVlcmllczogYW55W10gPSBbXTtcbiAgICAgIGNvbnN0IGFkZHJlc3Nlc0J5SWQgPSB7fTtcblxuICAgICAgXy5mb3JFYWNoKE9iamVjdC5rZXlzKENvZGVzLlVuc3BlbnRUeXBlVGNvbWIubWV0YS5tYXApLCBmdW5jdGlvbihhZGRyZXNzVHlwZSkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgaWdub3JpbmcgdGhlIGFkZHJlc3MgdHlwZSwgd2UgZGVyaXZlIHRoZSBwdWJsaWMga2V5IGFuZCBjb25zdHJ1Y3QgdGhlIHF1ZXJ5IGZvciB0aGUgZXh0ZXJuYWwgYW5kXG4gICAgICAgIC8vIGludGVybmFsIGluZGljZXNcbiAgICAgICAgaWYgKCFfLmluY2x1ZGVzKHBhcmFtcy5pZ25vcmVBZGRyZXNzVHlwZXMsIGFkZHJlc3NUeXBlKSkge1xuICAgICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaFAyd3NoJykgJiYgIXNlbGYuc3VwcG9ydHNQMnNoUDJ3c2goKSkge1xuICAgICAgICAgICAgLy8gUDJzaFAyd3NoIGlzIG5vdCBzdXBwb3J0ZWQuIFNraXAuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFkZHJlc3NUeXBlID09PSBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMndzaCcpICYmICFzZWxmLnN1cHBvcnRzUDJ3c2goKSkge1xuICAgICAgICAgICAgLy8gUDJ3c2ggaXMgbm90IHN1cHBvcnRlZC4gU2tpcC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgY29kZXM7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvZGVzID0gQ29kZXMuZm9yVHlwZShDb2Rlcy5VbnNwZW50VHlwZVRjb21iKGFkZHJlc3NUeXBlKSBhcyBhbnkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1bnNwZW50IHR5cGUgaXMgbm90IHN1cHBvcnRlZCBieSBiaXRnbyBzbyBhdHRlbXB0aW5nIHRvIGdldCBpdHMgY2hhaW4gY29kZXMgdGhyb3dzLiBDYXRjaCB0aGF0IGVycm9yXG4gICAgICAgICAgICAvLyBhbmQgY29udGludWUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4dGVybmFsQ2hhaW5Db2RlID0gY29kZXMuZXh0ZXJuYWw7XG4gICAgICAgICAgY29uc3QgaW50ZXJuYWxDaGFpbkNvZGUgPSBjb2Rlcy5pbnRlcm5hbDtcbiAgICAgICAgICBjb25zdCBleHRlcm5hbEtleSA9IGRlcml2ZUtleXMoYmFzZUtleVBhdGgsIGV4dGVybmFsQ2hhaW5Db2RlKTtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGRlcml2ZUtleXMoYmFzZUtleVBhdGgsIGludGVybmFsQ2hhaW5Db2RlKTtcbiAgICAgICAgICBxdWVyaWVzLnB1c2gocXVlcnlCbG9ja2NoYWluVW5zcGVudHNQYXRoKGV4dGVybmFsS2V5LCAnLzAvMC8nICsgZXh0ZXJuYWxDaGFpbkNvZGUsIGFkZHJlc3Nlc0J5SWQpKTtcbiAgICAgICAgICBxdWVyaWVzLnB1c2gocXVlcnlCbG9ja2NoYWluVW5zcGVudHNQYXRoKGludGVybmFsS2V5LCAnLzAvMC8nICsgaW50ZXJuYWxDaGFpbkNvZGUsIGFkZHJlc3Nlc0J5SWQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEV4ZWN1dGUgdGhlIHF1ZXJpZXMgYW5kIGdhdGhlciB0aGUgdW5zcGVudHNcbiAgICAgIGNvbnN0IHF1ZXJ5UmVzcG9uc2VzID0geWllbGQgUHJvbWlzZS5hbGwocXVlcmllcyk7XG4gICAgICBjb25zdCB1bnNwZW50czogYW55W10gPSBfLmZsYXR0ZW4ocXVlcnlSZXNwb25zZXMpOyAvLyB0aGlzIGZsYXR0ZW5zIHRoZSBhcnJheSAodHVybnMgYW4gYXJyYXkgb2YgYXJyYXlzIGludG8ganVzdCBvbmUgYXJyYXkpXG4gICAgICBjb25zdCB0b3RhbElucHV0QW1vdW50ID0gXy5zdW1CeSh1bnNwZW50cywgJ2Ftb3VudCcpO1xuICAgICAgaWYgKHRvdGFsSW5wdXRBbW91bnQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0IHRvIHJlY292ZXIgLSBhYm9ydGluZyEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkJ1aWxkZXIgPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbkJ1aWxkZXIoc2VsZi5uZXR3b3JrKTtcbiAgICAgIHNlbGYucHJlcGFyZVRyYW5zYWN0aW9uQnVpbGRlcih0cmFuc2FjdGlvbkJ1aWxkZXIpO1xuICAgICAgY29uc3QgdHhJbmZvOiBhbnkgPSB7fTtcblxuICAgICAgY29uc3QgZmVlUGVyQnl0ZSA9IHlpZWxkIHNlbGYuZ2V0UmVjb3ZlcnlGZWVQZXJCeXRlcygpO1xuXG4gICAgICAvLyBLUlMgcmVjb3ZlcnkgdHJhbnNhY3Rpb25zIGhhdmUgYSAybmQgb3V0cHV0IHRvIHBheSB0aGUgcmVjb3ZlcnkgZmVlLCBsaWtlIHBheWdvIGZlZXMuIFVzZSBwMndzaCBvdXRwdXRzIGJlY2F1c2VcbiAgICAgIC8vIHRoZXkgYXJlIHRoZSBsYXJnZXN0IG91dHB1dHMgYW5kIHRodXMgdGhlIG1vc3QgY29uc2VydmF0aXZlIGVzdGltYXRlIHRvIHVzZSBpbiBjYWxjdWxhdGluZyBmZWVzLiBBbHNvIHVzZVxuICAgICAgLy8gc2Vnd2l0IG92ZXJoZWFkIHNpemUgYW5kIHAyc2ggaW5wdXRzIGZvciB0aGUgc2FtZSByZWFzb24uXG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gKGlzS3JzUmVjb3ZlcnkgPyAyIDogMSkgKiBWaXJ0dWFsU2l6ZXMudHhQMndzaE91dHB1dFNpemU7XG4gICAgICBjb25zdCBhcHByb3hpbWF0ZVNpemUgPVxuICAgICAgICBWaXJ0dWFsU2l6ZXMudHhTZWdPdmVyaGVhZFZTaXplICsgb3V0cHV0U2l6ZSArIChWaXJ0dWFsU2l6ZXMudHhQMnNoSW5wdXRTaXplICogdW5zcGVudHMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGFwcHJveGltYXRlRmVlID0gYXBwcm94aW1hdGVTaXplICogZmVlUGVyQnl0ZTtcblxuICAgICAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb25cbiAgICAgIHR4SW5mby5pbnB1dHMgPSB1bnNwZW50cy5tYXAoZnVuY3Rpb24gYWRkSW5wdXRGb3JVbnNwZW50KHVuc3BlbnQpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGFkZHJlc3Nlc0J5SWRbdW5zcGVudC5hZGRyZXNzXTtcblxuICAgICAgICB0cmFuc2FjdGlvbkJ1aWxkZXIuYWRkSW5wdXQodW5zcGVudC50eGlkLCB1bnNwZW50Lm4sIDB4ZmZmZmZmZmYsIGFkZHJlc3Mub3V0cHV0U2NyaXB0KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluUGF0aDogYWRkcmVzcy5jaGFpblBhdGgsXG4gICAgICAgICAgcmVkZWVtU2NyaXB0OiBhZGRyZXNzLnJlZGVlbVNjcmlwdCAmJiBhZGRyZXNzLnJlZGVlbVNjcmlwdC50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgd2l0bmVzc1NjcmlwdDogYWRkcmVzcy53aXRuZXNzU2NyaXB0ICYmIGFkZHJlc3Mud2l0bmVzc1NjcmlwdC50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgdmFsdWU6IHVuc3BlbnQuYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIGxldCByZWNvdmVyeUFtb3VudCA9IHRvdGFsSW5wdXRBbW91bnQgLSBhcHByb3hpbWF0ZUZlZTtcbiAgICAgIGxldCBrcnNGZWU7XG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGtyc0ZlZSA9IHlpZWxkIHNlbGYuY2FsY3VsYXRlRmVlQW1vdW50KHsgcHJvdmlkZXI6IHBhcmFtcy5rcnNQcm92aWRlciwgYW1vdW50OiByZWNvdmVyeUFtb3VudCB9KTtcbiAgICAgICAgICByZWNvdmVyeUFtb3VudCAtPSBrcnNGZWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIERvbid0IGxldCB0aGlzIGVycm9yIGJsb2NrIHRoZSByZWNvdmVyeSAtIFxuICAgICAgICAgIGNvbnNvbGUuZGlyKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY292ZXJ5QW1vdW50IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgd2FsbGV0XFwncyBiYWxhbmNlIGlzIHRvbyBsb3cgdG8gcGF5IHRoZSBmZWVzIHNwZWNpZmllZCBieSB0aGUgS1JTIHByb3ZpZGVyJyk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zYWN0aW9uQnVpbGRlci5hZGRPdXRwdXQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sIHJlY292ZXJ5QW1vdW50KTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYga3JzRmVlID4gMCkge1xuICAgICAgICBjb25zdCBrcnNGZWVBZGRyZXNzID0ga3JzUHJvdmlkZXIuZmVlQWRkcmVzc2VzW3NlbGYuZ2V0Q2hhaW4oKV07XG5cbiAgICAgICAgaWYgKCFrcnNGZWVBZGRyZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzIEtSUyBwcm92aWRlciBoYXMgbm90IGNvbmZpZ3VyZWQgdGhlaXIgZmVlIHN0cnVjdHVyZSB5ZXQgLSByZWNvdmVyeSBjYW5ub3QgYmUgY29tcGxldGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2FjdGlvbkJ1aWxkZXIuYWRkT3V0cHV0KGtyc0ZlZUFkZHJlc3MsIGtyc0ZlZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgY29uc3QgdHhIZXggPSB0cmFuc2FjdGlvbkJ1aWxkZXIuYnVpbGRJbmNvbXBsZXRlKCkudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIHJldHVybiBzZWxmLmZvcm1hdEZvck9mZmxpbmVWYXVsdCh0eEluZm8sIHR4SGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZFR4ID0gc2VsZi5zaWduUmVjb3ZlcnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkJ1aWxkZXIsIHVuc3BlbnRzLCBhZGRyZXNzZXNCeUlkLCAhaXNLcnNSZWNvdmVyeSk7XG4gICAgICAgIHR4SW5mby50cmFuc2FjdGlvbkhleCA9IHNpZ25lZFR4LmJ1aWxkKCkudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHhJbmZvLnR4ID0geWllbGQgc2VsZi52ZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uKHR4SW5mbyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBlcnJvcnMuTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcikpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgY29pbnMgZG9uJ3QgaGF2ZSBhIHJlbGlhYmxlIHRoaXJkIHBhcnR5IHZlcmlmaWNhdGlvbiBlbmRwb2ludCwgc28gd2UgY29udGludWUgd2l0aG91dCB2ZXJpZmljYXRpb24gZm9yIHRob3NlIGNvaW5zXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCB2ZXJpZnkgcmVjb3ZlcnkgdHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgdHhJbmZvLmNvaW4gPSBzZWxmLmdldENoYWluKCk7XG4gICAgICAgIHR4SW5mby5iYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5O1xuICAgICAgICB0eEluZm8ucmVjb3ZlcnlBbW91bnQgPSByZWNvdmVyeUFtb3VudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR4SW5mbztcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHNpZ25hdHVyZXMgdG8gYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB1c2luZyB1c2VyICsgYmFja3VwIGtleVxuICAgKiBAcGFyYW0gdHhiIHtPYmplY3R9IGEgdHJhbnNhY3Rpb24gYnVpbGRlciBvYmplY3QgKHdpdGggaW5wdXRzIGFuZCBvdXRwdXRzKVxuICAgKiBAcGFyYW0gdW5zcGVudHMge0FycmF5fSB0aGUgdW5zcGVudHMgdG8gdXNlIGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYWRkcmVzc2VzIHtBcnJheX0gdGhlIGFkZHJlc3MgYW5kIHJlZGVlbSBzY3JpcHQgaW5mbyBmb3IgdGhlIHVuc3BlbnRzXG4gICAqIEBwYXJhbSBjb3NpZ24ge0Jvb2xlYW59IHdoZXRoZXIgdG8gY29zaWduIHRoaXMgdHJhbnNhY3Rpb24gd2l0aCB0aGUgdXNlcidzIGJhY2t1cCBrZXkgKGZhbHNlIGlmIEtSUyByZWNvdmVyeSlcbiAgICogQHJldHVybnMgdGhlIHRyYW5zYWN0aW9uIGJ1aWxkZXIgb3JpZ2luYWxseSBwYXNzZWQgaW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBzaWduUmVjb3ZlcnlUcmFuc2FjdGlvbih0eGI6IGFueSwgdW5zcGVudHM6IE91dHB1dFtdLCBhZGRyZXNzZXM6IGFueSwgY29zaWduOiBib29sZWFuKTogYW55IHtcbiAgICBpbnRlcmZhY2UgU2lnbmF0dXJlSXNzdWUge1xuICAgICAgaW5wdXRJbmRleDogbnVtYmVyO1xuICAgICAgdW5zcGVudDogT3V0cHV0O1xuICAgICAgZXJyb3I6IEVycm9yIHwgbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduYXR1cmVJc3N1ZXM6IFNpZ25hdHVyZUlzc3VlW10gPSBbXTtcbiAgICB1bnNwZW50cy5mb3JFYWNoKCh1bnNwZW50LCBpKSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc2VzW3Vuc3BlbnQuYWRkcmVzc107XG4gICAgICBjb25zdCBiYWNrdXBQcml2YXRlS2V5ID0gYWRkcmVzcy5iYWNrdXBLZXkua2V5UGFpcjtcbiAgICAgIGNvbnN0IHVzZXJQcml2YXRlS2V5ID0gYWRkcmVzcy51c2VyS2V5LmtleVBhaXI7XG4gICAgICAvLyBmb3JjZS1vdmVycmlkZSBuZXR3b3Jrc1xuICAgICAgYmFja3VwUHJpdmF0ZUtleS5uZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xuICAgICAgdXNlclByaXZhdGVLZXkubmV0d29yayA9IHRoaXMubmV0d29yaztcblxuICAgICAgY29uc3QgY3VycmVudFNpZ25hdHVyZUlzc3VlOiBTaWduYXR1cmVJc3N1ZSA9IHtcbiAgICAgICAgaW5wdXRJbmRleDogaSxcbiAgICAgICAgdW5zcGVudDogdW5zcGVudCxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29zaWduKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHhiLnNpZ24oaSwgYmFja3VwUHJpdmF0ZUtleSwgYWRkcmVzcy5yZWRlZW1TY3JpcHQsIHRoaXMuZGVmYXVsdFNpZ0hhc2hUeXBlLCB1bnNwZW50LmFtb3VudCwgYWRkcmVzcy53aXRuZXNzU2NyaXB0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGN1cnJlbnRTaWduYXR1cmVJc3N1ZS5lcnJvciA9IGU7XG4gICAgICAgICAgc2lnbmF0dXJlSXNzdWVzLnB1c2goY3VycmVudFNpZ25hdHVyZUlzc3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0eGIuc2lnbihpLCB1c2VyUHJpdmF0ZUtleSwgYWRkcmVzcy5yZWRlZW1TY3JpcHQsIHRoaXMuZGVmYXVsdFNpZ0hhc2hUeXBlLCB1bnNwZW50LmFtb3VudCwgYWRkcmVzcy53aXRuZXNzU2NyaXB0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY3VycmVudFNpZ25hdHVyZUlzc3VlLmVycm9yID0gZTtcbiAgICAgICAgc2lnbmF0dXJlSXNzdWVzLnB1c2goY3VycmVudFNpZ25hdHVyZUlzc3VlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzaWduYXR1cmVJc3N1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmFpbGVkSW5kaWNlcyA9IHNpZ25hdHVyZUlzc3Vlcy5tYXAoY3VycmVudElzc3VlID0+IGN1cnJlbnRJc3N1ZS5pbnB1dEluZGV4KTtcbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBzaWduIGlucHV0cyBhdCBpbmRpY2VzICR7ZmFpbGVkSW5kaWNlcy5qb2luKCcsICcpfWApO1xuICAgICAgZXJyb3IuY29kZSA9ICdpbnB1dF9zaWduYXR1cmVfZmFpbHVyZSc7XG4gICAgICBlcnJvci5zaWduaW5nRXJyb3JzID0gc2lnbmF0dXJlSXNzdWVzO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR4YjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhbW91bnQgKGluIGJhc2UgdW5pdHMpIHRvIHBheSBhIEtSUyBwcm92aWRlciB3aGVuIGJ1aWxkaW5nIGEgcmVjb3ZlcnkgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnByb3ZpZGVyIHtTdHJpbmd9IHRoZSBLUlMgcHJvdmlkZXIgdGhhdCBob2xkcyB0aGUgYmFja3VwIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zLmFtb3VudCB7TnVtYmVyfSBhbW91bnQgKGluIGJhc2UgdW5pdHMpIHRvIGJlIHJlY292ZXJlZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBjYWxjdWxhdGVGZWVBbW91bnQocGFyYW1zOiB7IHByb3ZpZGVyOiBzdHJpbmcsIGFtb3VudD86IG51bWJlciB9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxudW1iZXI+KTogQmx1ZWJpcmQ8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPG51bWJlcj4oZnVuY3Rpb24gKmNhbGN1bGF0ZUZlZUFtb3VudCgpIHtcbiAgICAgIGNvbnN0IGtyc1Byb3ZpZGVyID0gY29uZmlnLmtyc1Byb3ZpZGVyc1twYXJhbXMucHJvdmlkZXJdO1xuXG4gICAgICBpZiAoa3JzUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGZlZSBzdHJ1Y3R1cmUgc3BlY2lmaWVkIGZvciBwcm92aWRlciAke3BhcmFtcy5wcm92aWRlcn1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtyc1Byb3ZpZGVyLmZlZVR5cGUgPT09ICdmbGF0VXNkJykge1xuICAgICAgICBjb25zdCBmZWVBbW91bnRVc2QgPSBrcnNQcm92aWRlci5mZWVBbW91bnQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcmljZSA9IHlpZWxkIHNlbGYuZ2V0UmVjb3ZlcnlNYXJrZXRQcmljZSgpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGZlZUFtb3VudFVzZCAvIGN1cnJlbnRQcmljZSAqIHNlbGYuZ2V0QmFzZUZhY3RvcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGNhbiBhZGQgbW9yZSBmZWUgc3RydWN0dXJlcyBoZXJlIGFzIG5lZWRlZCBmb3IgZGlmZmVyZW50IHByb3ZpZGVycywgc3VjaCBhcyBwZXJjZW50YWdlIG9mIHJlY292ZXJ5IGFtb3VudFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZSBzdHJ1Y3R1cmUgbm90IGltcGxlbWVudGVkJyk7XG4gICAgICB9XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvdmVyIEJUQyB0aGF0IHdhcyBzZW50IHRvIHRoZSB3cm9uZyBjaGFpblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhpZCBUaGUgdHhpZCBvZiB0aGUgZmF1bHR5IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMucmVjb3ZlcnlBZGRyZXNzIGFkZHJlc3MgdG8gc2VuZCByZWNvdmVyZWQgZnVuZHMgdG9cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgdGhlIHdhbGxldCB0aGF0IHJlY2VpdmVkIHRoZSBmdW5kc1xuICAgKiBAcGFyYW0gcGFyYW1zLnJlY292ZXJ5Q29pbiB0aGUgY29pbiB0eXBlIG9mIHRoZSB3YWxsZXQgdGhhdCByZWNlaXZlZCB0aGUgZnVuZHNcbiAgICogQHBhcmFtIHBhcmFtcy5zaWduZWQgcmV0dXJuIGEgaGFsZi1zaWduZWQgdHJhbnNhY3Rpb24gKGRlZmF1bHQ9dHJ1ZSlcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0gcGFyYW1zLnhwcnYgdGhlIHVuZW5jcnlwdGVkIHhwcnYgKHVzZWQgaW5zdGVhZCBvZiB3YWxsZXQgcGFzc3BocmFzZSlcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcmVjb3ZlckZyb21Xcm9uZ0NoYWluKHBhcmFtczogUmVjb3ZlckZyb21Xcm9uZ0NoYWluT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqcmVjb3ZlckZyb21Xcm9uZ0NoYWluKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eGlkLFxuICAgICAgICByZWNvdmVyeUFkZHJlc3MsXG4gICAgICAgIHdhbGxldCxcbiAgICAgICAgd2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgeHBydixcbiAgICAgIH0gPSBwYXJhbXM7XG5cbiAgICAgIC8vIHBhcmFtcy5yZWNvdmVyeUNvaW4gdXNlZCB0byBiZSBwYXJhbXMuY29pbiwgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIGNvbnN0IHJlY292ZXJ5Q29pbiA9IHBhcmFtcy5jb2luIHx8IHBhcmFtcy5yZWNvdmVyeUNvaW47XG4gICAgICBpZiAoIXJlY292ZXJ5Q29pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgb2JqZWN0IHJlY292ZXJ5Q29pbicpO1xuICAgICAgfVxuICAgICAgLy8gc2lnbmVkIHNob3VsZCBkZWZhdWx0IHRvIHRydWUsIGFuZCBvbmx5IGJlIGRpc2FibGVkIGlmIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlIChub3QgdW5kZWZpbmVkKVxuICAgICAgY29uc3Qgc2lnbmVkID0gcGFyYW1zLnNpZ25lZCAhPT0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IHNvdXJjZUNvaW5GYW1pbHkgPSBzZWxmLmdldEZhbWlseSgpO1xuICAgICAgY29uc3QgcmVjb3ZlcnlDb2luRmFtaWx5ID0gcmVjb3ZlcnlDb2luLmdldEZhbWlseSgpO1xuICAgICAgY29uc3Qgc3VwcG9ydGVkUmVjb3ZlcnlDb2lucyA9IGNvbmZpZy5zdXBwb3J0ZWRDcm9zc0NoYWluUmVjb3Zlcmllc1tzb3VyY2VDb2luRmFtaWx5XTtcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoc3VwcG9ydGVkUmVjb3ZlcnlDb2lucykgfHwgIXN1cHBvcnRlZFJlY292ZXJ5Q29pbnMuaW5jbHVkZXMocmVjb3ZlcnlDb2luRmFtaWx5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY292ZXJ5IG9mICR7c291cmNlQ29pbkZhbWlseX0gYmFsYW5jZXMgZnJvbSAke3JlY292ZXJ5Q29pbkZhbWlseX0gd2FsbGV0cyBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWNvdmVyeVRvb2wgPSBuZXcgQ3Jvc3NDaGFpblJlY292ZXJ5VG9vbCh7XG4gICAgICAgIGJpdGdvOiBzZWxmLmJpdGdvLFxuICAgICAgICBzb3VyY2VDb2luOiBzZWxmLFxuICAgICAgICByZWNvdmVyeUNvaW46IHJlY292ZXJ5Q29pbixcbiAgICAgICAgbG9nZ2luZzogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgeWllbGQgcmVjb3ZlcnlUb29sLmJ1aWxkVHJhbnNhY3Rpb24oe1xuICAgICAgICB3YWxsZXQ6IHdhbGxldCxcbiAgICAgICAgZmF1bHR5VHhJZDogdHhpZCxcbiAgICAgICAgcmVjb3ZlcnlBZGRyZXNzOiByZWNvdmVyeUFkZHJlc3MsXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICB5aWVsZCByZWNvdmVyeVRvb2wuc2lnblRyYW5zYWN0aW9uKHsgcGFzc3BocmFzZTogd2FsbGV0UGFzc3BocmFzZSwgcHJ2OiB4cHJ2IH0pO1xuICAgICAgICByZXR1cm4gcmVjb3ZlcnlUb29sLmV4cG9ydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHJlY292ZXJ5VG9vbC5idWlsZFVuc2lnbmVkKCk7XG4gICAgICB9XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBzZWNwMjU2azEga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiBhbmQgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZDogQnVmZmVyKTogeyBwdWI6IHN0cmluZywgcHJ2OiBzdHJpbmcgfSB7XG4gICAgaWYgKCFzZWVkKSB7XG4gICAgICAvLyBBbiBleHRlbmRlZCBwcml2YXRlIGtleSBoYXMgYm90aCBhIG5vcm1hbCAyNTYgYml0IHByaXZhdGUga2V5IGFuZCBhIDI1NlxuICAgICAgLy8gYml0IGNoYWluIGNvZGUsIGJvdGggb2Ygd2hpY2ggbXVzdCBiZSByYW5kb20uIDUxMiBiaXRzIGlzIHRoZXJlZm9yZSB0aGVcbiAgICAgIC8vIG1heGltdW0gZW50cm9weSBhbmQgZ2l2ZXMgdXMgbWF4aW11bSBzZWN1cml0eSBhZ2FpbnN0IGNyYWNraW5nLlxuICAgICAgc2VlZCA9IGNyeXB0by5yYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5kZWRLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tU2VlZEJ1ZmZlcihzZWVkKTtcbiAgICBjb25zdCB4cHViID0gZXh0ZW5kZWRLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHhwdWIsXG4gICAgICBwcnY6IGV4dGVuZGVkS2V5LnRvQmFzZTU4KCksXG4gICAgfTtcbiAgfVxuXG4gIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe30pLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgcHJlQ3JlYXRlQml0R28ocGFyYW1zOiBQcmVjcmVhdGVCaXRHb09wdGlvbnMpOiB2b2lkIHt9XG5cbiAgcHJlc2lnblRyYW5zYWN0aW9uKHBhcmFtczogUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiAoZXJyOiBFcnJvciwgcmVzOiBhbnkpID0+IHZvaWQpOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShwYXJhbXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucywga2V5Y2hhaW5zOiBLZXljaGFpbnNUcmlwbGV0KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUod2FsbGV0UGFyYW1zKTtcbiAgfVxuXG4gIHRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZlcmlmeVJlY292ZXJ5VHJhbnNhY3Rpb24odHhJbmZvOiBWZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucyk6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QobmV3IGVycm9ycy5NZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCkpO1xuICB9XG5cbiAgc2lnbk1lc3NhZ2Uoa2V5OiB7IHBydjogc3RyaW5nIH0sIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgoa2V5LnBydikuZ2V0S2V5KCk7XG4gICAgY29uc3QgcHJpdmF0ZUtleUJ1ZmZlciA9IHByaXZhdGVLZXkuZC50b0J1ZmZlcigzMik7XG4gICAgY29uc3QgaXNDb21wcmVzc2VkID0gcHJpdmF0ZUtleS5jb21wcmVzc2VkO1xuICAgIGNvbnN0IHByZWZpeCA9IGJpdGNvaW4ubmV0d29ya3MuYml0Y29pbi5tZXNzYWdlUHJlZml4O1xuICAgIHJldHVybiBiaXRjb2luTWVzc2FnZS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXlCdWZmZXIsIGlzQ29tcHJlc3NlZCwgcHJlZml4KTtcbiAgfVxufVxuIl19