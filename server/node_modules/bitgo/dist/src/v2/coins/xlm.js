"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var bitcoin = require("bitgo-utxo-lib");
var querystring = require("querystring");
var url = require("url");
var Bluebird = require("bluebird");
var request = require("superagent");
var stellar = require("stellar-sdk");
var bignumber_js_1 = require("bignumber.js");
var keychains_1 = require("../keychains");
var keyDeriver_1 = require("../internal/keyDeriver");
var config = require("../../config");
var common = require("../../common");
var errors_1 = require("../../errors");
var baseCoin_1 = require("../baseCoin");
var co = Bluebird.coroutine;
var Xlm = /** @class */ (function (_super) {
    __extends(Xlm, _super);
    function Xlm(bitgo) {
        var _this = _super.call(this, bitgo) || this;
        _this.homeDomain = 'bitgo.com'; // used for reverse federation lookup
        stellar.Network.use(new stellar.Network(stellar.Networks.PUBLIC));
        return _this;
    }
    Xlm.createInstance = function (bitgo) {
        return new Xlm(bitgo);
    };
    /**
     * Factor between the base unit and its smallest subdivison
     */
    Xlm.prototype.getBaseFactor = function () {
        return 1e7;
    };
    /**
     * Identifier for the blockchain which supports this coin
     */
    Xlm.prototype.getChain = function () {
        return 'xlm';
    };
    /**
     * Identifier for the coin family
     */
    Xlm.prototype.getFamily = function () {
        return 'xlm';
    };
    /**
     * Complete human-readable name of this coin
     */
    Xlm.prototype.getFullName = function () {
        return 'Stellar';
    };
    /**
     * Url at which the stellar federation server can be reached
     */
    Xlm.prototype.getFederationServerUrl = function () {
        return common.Environments[this.bitgo.getEnv()].stellarFederationServerUrl;
    };
    /**
     * Url at which horizon can be reached
     */
    Xlm.prototype.getHorizonUrl = function () {
        return 'https://horizon.stellar.org';
    };
    /**
     * Generate a new key pair on the ed25519 curve
     * @param seed
     * @returns generated pub and prv
     */
    Xlm.prototype.generateKeyPair = function (seed) {
        var pair = seed ? stellar.Keypair.fromRawEd25519Seed(seed) : stellar.Keypair.random();
        return {
            pub: pair.publicKey(),
            prv: pair.secret(),
        };
    };
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub Raw public key
     * @returns Encoded public key
     */
    Xlm.prototype.getPubFromRaw = function (pub) {
        return stellar.StrKey.encodeEd25519PublicKey(Buffer.from(pub, 'hex'));
    };
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv Raw private key
     * @returns Encoded private key
     */
    Xlm.prototype.getPrvFromRaw = function (prv) {
        return stellar.StrKey.encodeEd25519SecretSeed(Buffer.from(prv, 'hex'));
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub the pub to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidPub = function (pub) {
        return stellar.StrKey.isValidEd25519PublicKey(pub);
    };
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidPrv = function (prv) {
        return stellar.StrKey.isValidEd25519SecretSeed(prv);
    };
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    Xlm.prototype.isValidMemoId = function (memoId) {
        var memoIdNumber;
        try {
            stellar.Memo.id(memoId); // throws if the value is not valid memo id
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return (memoIdNumber.gte(0) && memoIdNumber.lt(Xlm.maxMemoId));
    };
    /**
     * Evaluates whether a memo is valid
     *
     * @param value value of the memo
     * @param type type of the memo
     * @returns true if value and type are a valid
     */
    Xlm.prototype.isValidMemo = function (_a) {
        var value = _a.value, type = _a.type;
        if (!value || !type) {
            return false;
        }
        try {
            // throws if the value is not valid for the type
            // valid types are: 'id', 'text', 'hash', 'return'
            // See https://www.stellar.org/developers/guides/concepts/transactions.html#memo
            stellar.Memo[type](value);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns minimum balance in stroops
     */
    Xlm.prototype.getMinimumReserve = function () {
        var self = this;
        return co(function () {
            var server, horizonLedgerInfo, baseReserve;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = new stellar.Server(self.getHorizonUrl());
                        return [4 /*yield*/, server
                                .ledgers()
                                .order('desc')
                                .limit(1)
                                .call()];
                    case 1:
                        horizonLedgerInfo = _a.sent();
                        if (!horizonLedgerInfo) {
                            throw new Error('unable to connect to Horizon for reserve requirement data');
                        }
                        baseReserve = horizonLedgerInfo.records[0].base_reserve_in_stroops;
                        // 2-of-3 wallets have a minimum reserve of 5x the base reserve
                        return [2 /*return*/, 5 * baseReserve];
                }
            });
        }).call(this);
    };
    /**
     * Transaction fee for each operation
     * @returns transaction fee in stroops
     */
    Xlm.prototype.getBaseTransactionFee = function () {
        var self = this;
        return co(function () {
            var server, horizonLedgerInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = new stellar.Server(self.getHorizonUrl());
                        return [4 /*yield*/, server
                                .ledgers()
                                .order('desc')
                                .limit(1)
                                .call()];
                    case 1:
                        horizonLedgerInfo = _a.sent();
                        if (!horizonLedgerInfo) {
                            throw new Error('unable to connect to Horizon for reserve requirement data');
                        }
                        return [2 /*return*/, horizonLedgerInfo.records[0].base_fee_in_stroops];
                }
            });
        }).call(this);
    };
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    Xlm.prototype.getAddressDetails = function (address) {
        var destinationDetails = url.parse(address);
        var destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !stellar.StrKey.isValidEd25519PublicKey(destinationAddress)) {
            throw new Error("invalid address: " + address);
        }
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        var queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new errors_1.InvalidAddressError("memoId may only be given at most once, but found " + queryDetails.memoId.length + " instances in address " + address);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new errors_1.InvalidAddressError("invalid address '" + address + "', must contain exactly one memoId");
        }
        var memoId = _.castArray(queryDetails.memoId)[0];
        if (!this.isValidMemoId(memoId)) {
            throw new errors_1.InvalidMemoIdError("invalid address: '" + address + "', memoId is not valid");
        }
        return {
            address: destinationAddress,
            memoId: memoId,
        };
    };
    /**
     * Validate and return address with appended memo id
     *
     * @param address address
     * @param memoId memo id
     * @returns address with memo id
     */
    Xlm.prototype.normalizeAddress = function (_a) {
        var address = _a.address, memoId = _a.memoId;
        if (!stellar.StrKey.isValidEd25519PublicKey(address)) {
            throw new Error("invalid address details: " + address);
        }
        if (memoId && this.isValidMemoId(memoId)) {
            return address + "?memoId=" + memoId;
        }
        return address;
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address the pub to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Return a Stellar Asset in coin:token form (i.e. (t)xlm:<code>-<issuer>)
     * If the asset is XLM, return the chain
     * @param {stellar.Asset} asset - instance of Stellar Asset
     */
    Xlm.prototype.getTokenNameFromStellarAsset = function (asset) {
        var code = asset.getCode();
        var issuer = asset.getIssuer();
        if (asset.isNative()) {
            return this.getChain();
        }
        return "" + this.getChain() + baseCoin_1.BaseCoin.coinTokenPatternSeparator + code + Xlm.tokenPatternSeparator + issuer;
    };
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param username - stellar username
     * @return true if stellar username is valid
     */
    Xlm.prototype.isValidStellarUsername = function (username) {
        return /^[a-z0-9\-_.+@]+$/.test(username);
    };
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns instance of BitGo Federation Server
     */
    Xlm.prototype.getBitGoFederationServer = function () {
        // Identify the URI scheme in case we need to allow connecting to HTTP server.
        var isNonSecureEnv = !_.startsWith(common.Environments[this.bitgo.env].uri, 'https');
        var federationServerOptions = { allowHttp: isNonSecureEnv };
        return new stellar.FederationServer(this.getFederationServerUrl(), 'bitgo.com', federationServerOptions);
    };
    /**
     * Perform federation lookups
     * Our federation server handles lookups for bitgo as well as for other federation domains
     *
     * @param {String} [address] - address to look up
     * @param {String} [accountId] - account id to look up
     */
    Xlm.prototype.federationLookup = function (_a) {
        var address = _a.address, accountId = _a.accountId;
        var self = this;
        return co(function () {
            var federationServer, e_1, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 6, , 7]);
                        federationServer = self.getBitGoFederationServer();
                        if (!address) return [3 /*break*/, 2];
                        return [4 /*yield*/, federationServer.resolveAddress(address)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        if (!accountId) return [3 /*break*/, 4];
                        return [4 /*yield*/, federationServer.resolveAccountId(accountId)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4: throw new Error('invalid argument - must provide Stellar address or account id');
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        e_1 = _a.sent();
                        error = _.get(e_1, 'response.data.detail');
                        if (error) {
                            throw new errors_1.StellarFederationUserNotFoundError(error);
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 7];
                    case 7: return [2 /*return*/];
                }
            });
        }).call(this);
    };
    /**
     * Attempt to resolve a stellar address into a stellar account
     *
     * @param {String} address - stellar address to look for
     */
    Xlm.prototype.federationLookupByName = function (address) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (!address) {
                    throw new Error('invalid Stellar address');
                }
                return [2 /*return*/, self.federationLookup({ address: address })];
            });
        }).call(this);
    };
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     */
    Xlm.prototype.federationLookupByAccountId = function (accountId) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (!accountId) {
                    throw new Error('invalid Stellar account');
                }
                return [2 /*return*/, self.federationLookup({ accountId: accountId })];
            });
        }).call(this);
    };
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    Xlm.prototype.verifyAddress = function (_a) {
        var address = _a.address, rootAddress = _a.rootAddress;
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        var addressDetails = this.getAddressDetails(address);
        var rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError("address validation failure: " + addressDetails.address + " vs " + rootAddressDetails.address);
        }
        return true;
    };
    /**
     * Get extra parameters for prebuilding a tx
     * Set empty recipients array in trustline txs
     */
    Xlm.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        var params = {};
        if (buildParams.type === 'trustline') {
            params.recipients = [];
        }
        return Bluebird.resolve(params).asCallback(callback);
    };
    /**
     * Generates Stellar keypairs from the user key and backup key
     * @param params
     */
    Xlm.prototype.initiateRecovery = function (params) {
        var self = this;
        return co(function () {
            var keys, userKey, backupKey, isKrsRecovery, isUnsignedSweep, userKeyPair;
            return __generator(this, function (_a) {
                keys = [];
                userKey = params.userKey;
                backupKey = params.backupKey;
                isKrsRecovery = backupKey.startsWith('G') && !userKey.startsWith('G');
                isUnsignedSweep = backupKey.startsWith('G') && userKey.startsWith('G');
                if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                    throw new errors_1.KeyRecoveryServiceError("Unknown key recovery service provider - " + params.krsProvider);
                }
                if (isKrsRecovery && params.krsProvider && !config.krsProviders[params.krsProvider].supportedCoins.includes(self.getFamily())) {
                    throw new errors_1.KeyRecoveryServiceError("Specified key recovery service does not support recoveries for " + self.getChain());
                }
                if (!self.isValidAddress(params.recoveryDestination)) {
                    throw new errors_1.InvalidAddressError('Invalid destination address!');
                }
                try {
                    if (!userKey.startsWith('S') && !userKey.startsWith('G')) {
                        userKey = self.bitgo.decrypt({
                            input: userKey,
                            password: params.walletPassphrase,
                        });
                    }
                    userKeyPair = isUnsignedSweep ?
                        stellar.Keypair.fromPublicKey(userKey) :
                        stellar.Keypair.fromSecret(userKey);
                    keys.push(userKeyPair);
                }
                catch (e) {
                    throw new Error('Failed to decrypt user key with passcode - try again!');
                }
                try {
                    if (!backupKey.startsWith('S') && !isKrsRecovery && !isUnsignedSweep) {
                        backupKey = this.bitgo.decrypt({
                            input: backupKey,
                            password: params.walletPassphrase,
                        });
                    }
                    if (isKrsRecovery || isUnsignedSweep) {
                        keys.push(stellar.Keypair.fromPublicKey(backupKey));
                    }
                    else {
                        keys.push(stellar.Keypair.fromSecret(backupKey));
                    }
                }
                catch (e) {
                    throw new Error('Failed to decrypt backup key with passcode - try again!');
                }
                return [2 /*return*/, keys];
            });
        }).call(this);
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    Xlm.prototype.recover = function (params, callback) {
        var self = this;
        return co(function () {
            var _a, userKey, backupKey, isKrsRecovery, isUnsignedSweep, accountDataUrl, destinationUrl, accountData, e_2, unfundedDestination, e_3, account, nativeBalanceInfo, walletBalance, minimumReserve, baseTxFee, recoveryAmount, formattedRecoveryAmount, txBuilder, operation, tx, transaction;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        _a = _b.sent(), userKey = _a[0], backupKey = _a[1];
                        isKrsRecovery = params.backupKey.startsWith('G') && !params.userKey.startsWith('G');
                        isUnsignedSweep = params.backupKey.startsWith('G') && params.userKey.startsWith('G');
                        if (!params.rootAddress || !stellar.StrKey.isValidEd25519PublicKey(params.rootAddress)) {
                            throw new Error("Invalid wallet address: " + params.rootAddress);
                        }
                        accountDataUrl = self.getHorizonUrl() + "/accounts/" + params.rootAddress;
                        destinationUrl = self.getHorizonUrl() + "/accounts/" + params.recoveryDestination;
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, request.get(accountDataUrl).result()];
                    case 3:
                        accountData = _b.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _b.sent();
                        throw new Error('Unable to reach the Stellar network via Horizon.');
                    case 5:
                        unfundedDestination = false;
                        _b.label = 6;
                    case 6:
                        _b.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, request.get(destinationUrl)];
                    case 7:
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        e_3 = _b.sent();
                        if (e_3.status === 404) {
                            // If the destination account does not yet exist, horizon responds with 404
                            unfundedDestination = true;
                        }
                        return [3 /*break*/, 9];
                    case 9:
                        if (!accountData.sequence || !accountData.balances) {
                            throw new Error('Horizon server error - unable to retrieve sequence ID or account balance');
                        }
                        account = new stellar.Account(params.rootAddress, accountData.sequence);
                        nativeBalanceInfo = accountData.balances.find(function (assetBalance) { return assetBalance['asset_type'] === 'native'; });
                        if (!nativeBalanceInfo) {
                            throw new Error('Provided wallet has a balance of 0 XLM, recovery aborted');
                        }
                        walletBalance = Number(self.bigUnitsToBaseUnits(nativeBalanceInfo.balance));
                        return [4 /*yield*/, self.getMinimumReserve()];
                    case 10:
                        minimumReserve = _b.sent();
                        return [4 /*yield*/, self.getBaseTransactionFee()];
                    case 11:
                        baseTxFee = _b.sent();
                        recoveryAmount = walletBalance - minimumReserve - baseTxFee;
                        formattedRecoveryAmount = self.baseUnitsToBigUnits(recoveryAmount).toString();
                        txBuilder = new stellar.TransactionBuilder(account);
                        operation = unfundedDestination ?
                            // In this case, we need to create the account
                            stellar.Operation.createAccount({
                                destination: params.recoveryDestination,
                                startingBalance: formattedRecoveryAmount,
                            }) :
                            // Otherwise if the account already exists, we do a normal send
                            stellar.Operation.payment({
                                destination: params.recoveryDestination,
                                asset: stellar.Asset.native(),
                                amount: formattedRecoveryAmount,
                            });
                        tx = txBuilder.addOperation(operation).build();
                        if (!isUnsignedSweep) {
                            tx.sign(userKey);
                        }
                        if (!isKrsRecovery && !isUnsignedSweep) {
                            tx.sign(backupKey);
                        }
                        transaction = {
                            tx: Xlm.txToString(tx),
                            recoveryAmount: recoveryAmount,
                        };
                        if (isKrsRecovery) {
                            transaction.backupKey = params.backupKey;
                            transaction.coin = self.getChain();
                        }
                        return [2 /*return*/, transaction];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     */
    Xlm.prototype.signTransaction = function (params) {
        var txPrebuild = params.txPrebuild, prv = params.prv;
        if (_.isUndefined(txPrebuild)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isObject(txPrebuild)) {
            throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error("prv must be a string, got type " + typeof prv);
        }
        var keyPair = stellar.Keypair.fromSecret(prv);
        var tx = new stellar.Transaction(txPrebuild.txBase64);
        tx.sign(keyPair);
        return {
            halfSigned: {
                txBase64: Xlm.txToString(tx),
            },
        };
    };
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * Stellar wallets have three keychains on them. Two are generated by the platform, and the last is generated by the user.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root prv is not provided, a random one is generated.
     */
    Xlm.prototype.supplementGenerateWallet = function (walletParams) {
        var self = this;
        return co(function () {
            var seed, rootPrv, keyPair;
            return __generator(this, function (_a) {
                rootPrv = walletParams.rootPrivateKey;
                if (rootPrv) {
                    if (!self.isValidPrv(rootPrv)) {
                        throw new Error('rootPrivateKey needs to be valid ed25519 secret seed');
                    }
                    seed = stellar.StrKey.decodeEd25519SecretSeed(rootPrv);
                }
                keyPair = self.generateKeyPair(seed);
                // extend the wallet initialization params
                walletParams.rootPrivateKey = keyPair.prv;
                return [2 /*return*/, walletParams];
            });
        }).call(this);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    Xlm.prototype.signMessage = function (key, message) {
        if (!this.isValidPrv(key.prv)) {
            throw new Error("invalid prv: " + key.prv);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        var keypair = stellar.Keypair.fromSecret(key.prv);
        return keypair.sign(message);
    };
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub public key
     * @param message signed message
     * @param signature signature to verify
     * @returns true if signature is valid.
     */
    Xlm.prototype.verifySignature = function (pub, message, signature) {
        if (!this.isValidPub(pub)) {
            throw new Error("invalid pub: " + pub);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        var keyPair = stellar.Keypair.fromPublicKey(pub);
        return keyPair.verify(message, signature);
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Xlm.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txBase64, tx, id, memo, spendAmount, spendAmounts, outputs, operations, outputAmount, outputAmounts, fee;
            return __generator(this, function (_a) {
                txBase64 = params.txBase64;
                try {
                    tx = new stellar.Transaction(txBase64);
                }
                catch (e) {
                    throw new Error('txBase64 needs to be a valid tx encoded as base64 string');
                }
                id = tx.hash().toString('hex');
                memo = _.result(tx, '_memo.value') && _.result(tx, '_memo.arm') ?
                    {
                        value: _.result(tx, '_memo.value').toString(),
                        type: _.result(tx, '_memo.arm'),
                    } : {};
                spendAmount = new bignumber_js_1.BigNumber(0);
                spendAmounts = {};
                if (_.isEmpty(tx.operations)) {
                    throw new Error('missing operations');
                }
                outputs = [];
                operations = [];
                _.forEach(tx.operations, function (op) {
                    if (op.type === 'createAccount' || op.type === 'payment') {
                        // TODO Remove memoId from address
                        // Get memo to attach to address, if type is 'id'
                        var memoId = _.get(memo, 'type') === 'id' && !_.get(memo, 'value') ?
                            "?memoId=" + memo.value :
                            '';
                        var asset = op.type === 'payment' ? op.asset : stellar.Asset.native();
                        var coin = self.getTokenNameFromStellarAsset(asset); // coin or token id
                        var output = {
                            amount: self.bigUnitsToBaseUnits(op.startingBalance || op.amount),
                            address: op.destination + memoId,
                            coin: coin,
                        };
                        if (!_.isUndefined(spendAmounts[coin])) {
                            spendAmounts[coin] = spendAmounts[coin].plus(output.amount);
                        }
                        else {
                            spendAmounts[coin] = new bignumber_js_1.BigNumber(output.amount);
                        }
                        if (asset.isNative()) {
                            spendAmount = spendAmount.plus(output.amount);
                        }
                        outputs.push(output);
                    }
                    else if (op.type === 'changeTrust') {
                        operations.push({
                            type: op.type,
                            coin: self.getTokenNameFromStellarAsset(op.line),
                            asset: op.line,
                            limit: self.bigUnitsToBaseUnits(op.limit),
                        });
                    }
                });
                outputAmount = spendAmount.toFixed(0);
                outputAmounts = _.mapValues(spendAmounts, function (amount) { return amount.toFixed(0); });
                fee = {
                    fee: tx.fee.toFixed(0),
                    feeRate: null,
                    size: null,
                };
                return [2 /*return*/, {
                        displayOrder: ['id', 'outputAmount', 'outputAmounts', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'memo', 'operations'],
                        id: id,
                        outputs: outputs,
                        outputAmount: outputAmount,
                        outputAmounts: outputAmounts,
                        changeOutputs: [],
                        changeAmount: '0',
                        memo: memo,
                        fee: fee,
                        operations: operations,
                    }];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    Xlm.prototype.verifyTrustlineTxOperations = function (operations, txParams) {
        var _this = this;
        var trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'trustlines', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, function (op) {
            var opToken = _this.getTokenNameFromStellarAsset(op.line);
            var tokenTrustline = _.find(txParams.trustlines, function (trustline) {
                // trustline params use limits in base units
                var opLimitBaseUnits = _this.bigUnitsToBaseUnits(op.limit);
                // Prepare the conditions to check for
                // Limit will always be set in the operation, even if it was omitted from txParams in the following cases:
                // 1. Action is 'add' - limit is set to Xlm.maxTrustlineLimit by default
                // 2. Action is 'remove' - limit is set to '0'
                var noLimit = _.isUndefined(trustline.limit);
                var addTrustlineWithDefaultLimit = (trustline.action === 'add' && opLimitBaseUnits === Xlm.maxTrustlineLimit);
                var removeTrustline = (trustline.action === 'remove' && opLimitBaseUnits === '0');
                return (trustline.token === opToken &&
                    (trustline.limit === opLimitBaseUnits || (noLimit && (addTrustlineWithDefaultLimit || removeTrustline))));
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param options
     * @param options.txPrebuild prebuild object returned by platform
     * @param options.txPrebuild.txBase64 prebuilt transaction encoded as base64 string
     * @param options.wallet wallet object to obtain keys to verify against
     * @param options.verification specifying some verification parameters
     * @param options.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param options.verification.keychains Pass keychains manually rather than fetching them by id
     * @param callback
     */
    Xlm.prototype.verifyTransaction = function (options, callback) {
        // TODO BG-5600 Add parseTransaction / improve verification
        var self = this;
        return co(function () {
            var txParams, txPrebuild, wallet, _a, verification, disableNetworking, tx, outputOperations, userSignature, keychains;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txParams = options.txParams, txPrebuild = options.txPrebuild, wallet = options.wallet, _a = options.verification, verification = _a === void 0 ? {} : _a;
                        disableNetworking = !!verification.disableNetworking;
                        if (!txPrebuild.txBase64) {
                            throw new Error('missing required tx prebuild property txBase64');
                        }
                        tx = new stellar.Transaction(txPrebuild.txBase64);
                        if (txParams.recipients && txParams.recipients.length > 1) {
                            throw new Error('cannot specify more than 1 recipient');
                        }
                        outputOperations = _.filter(tx.operations, function (operation) {
                            return operation.type === 'createAccount' || operation.type === 'payment';
                        });
                        if (txParams.type === 'trustline') {
                            this.verifyTrustlineTxOperations(tx.operations, txParams);
                        }
                        else {
                            if (_.isEmpty(outputOperations)) {
                                throw new Error('transaction prebuild does not have any operations');
                            }
                            _.forEach(txParams.recipients, function (expectedOutput, index) {
                                var expectedOutputAddress = self.getAddressDetails(expectedOutput.address);
                                var output = outputOperations[index];
                                if (output.destination !== expectedOutputAddress.address) {
                                    throw new Error('transaction prebuild does not match expected recipient');
                                }
                                var expectedOutputAmount = new bignumber_js_1.BigNumber(expectedOutput.amount);
                                // The output amount is expressed as startingBalance in createAccount operations and as amount in payment operations.
                                var outputAmountString = (output.type === 'createAccount') ? output.startingBalance : output.amount;
                                var outputAmount = new bignumber_js_1.BigNumber(self.bigUnitsToBaseUnits(outputAmountString));
                                if (!outputAmount.eq(expectedOutputAmount)) {
                                    throw new Error('transaction prebuild does not match expected amount');
                                }
                            });
                        }
                        if (!!_.isEmpty(tx.signatures)) return [3 /*break*/, 4];
                        userSignature = tx.signatures[0].signature();
                        keychains = verification.keychains;
                        if (!(!keychains && disableNetworking)) return [3 /*break*/, 1];
                        throw new Error('cannot fetch keychains without networking');
                    case 1:
                        if (!!keychains) return [3 /*break*/, 3];
                        return [4 /*yield*/, Bluebird.props({
                                user: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.USER] }),
                                backup: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BACKUP] }),
                            })];
                    case 2:
                        keychains = _b.sent();
                        _b.label = 3;
                    case 3:
                        if (!keychains || !keychains.backup || !keychains.user) {
                            throw new Error('keychains are required, but could not be fetched');
                        }
                        if (self.verifySignature(keychains.backup.pub, tx.hash(), userSignature)) {
                            throw new Error('transaction signed with wrong key');
                        }
                        if (!self.verifySignature(keychains.user.pub, tx.hash(), userSignature)) {
                            throw new Error('transaction signature invalid');
                        }
                        _b.label = 4;
                    case 4: return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Derive a hardened child public key from a master key seed using an additional seed for randomness.
     *
     * Due to technical differences between keypairs on the ed25519 curve and the secp256k1 curve,
     * only hardened private key derivation is supported.
     *
     * @param key seed for the master key. Note: Not the public key or encoded private key. This is the raw seed.
     * @param entropySeed random seed which is hashed to generate the derivation path
     */
    Xlm.prototype.deriveKeyWithSeed = function (_a) {
        var key = _a.key, seed = _a.seed;
        var derivationPathInput = bitcoin.crypto.hash256("" + seed).toString('hex');
        var derivationPathParts = [
            999999,
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        var derivationPath = 'm/' + derivationPathParts
            .map(function (part) { return part + "'"; })
            .join('/');
        var derivedKey = keyDeriver_1.Ed25519KeyDeriver.derivePath(derivationPath, key).key;
        var keypair = stellar.Keypair.fromRawEd25519Seed(derivedKey);
        return {
            key: keypair.publicKey(),
            derivationPath: derivationPath,
        };
    };
    Xlm.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Xlm.tokenPatternSeparator = '-'; // separator for token code and issuer
    Xlm.maxMemoId = '0xFFFFFFFFFFFFFFFF'; // max unsigned 64-bit number = 18446744073709551615
    // max int64 number supported by the network (2^63)-1
    // See: https://www.stellar.org/developers/guides/concepts/assets.html#amount-precision-and-representation
    Xlm.maxTrustlineLimit = '9223372036854775807';
    /**
     * stellar-sdk has two overloads for toXDR, and typescript can't seem to figure out the
     * correct one to use, so we have to be very explicit as to which one we want.
     * @param tx transaction to convert
     */
    Xlm.txToString = function (tx) { return tx.toEnvelope().toXDR('base64'); };
    return Xlm;
}(baseCoin_1.BaseCoin));
exports.Xlm = Xlm;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3hsbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwQkFBNEI7QUFDNUIsd0NBQTBDO0FBQzFDLHlDQUEyQztBQUMzQyx5QkFBMkI7QUFDM0IsbUNBQXFDO0FBQ3JDLG9DQUFzQztBQUN0QyxxQ0FBdUM7QUFDdkMsNkNBQXlDO0FBRXpDLDBDQUEwQztBQUUxQyxxREFBMkQ7QUFDM0QscUNBQXVDO0FBQ3ZDLHFDQUF1QztBQUN2Qyx1Q0FNc0I7QUFDdEIsd0NBWXFCO0FBSXJCLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFtRzlCO0lBQXlCLHVCQUFRO0lBUS9CLGFBQVksS0FBWTtRQUF4QixZQUNFLGtCQUFNLEtBQUssQ0FBQyxTQUdiO1FBRkMsS0FBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxxQ0FBcUM7UUFDcEUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzs7SUFDcEUsQ0FBQztJQUVNLGtCQUFjLEdBQXJCLFVBQXNCLEtBQVk7UUFDaEMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSCwyQkFBYSxHQUFiO1FBQ0UsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCx1QkFBUyxHQUFUO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCx5QkFBVyxHQUFYO1FBQ0UsT0FBTyxTQUFTLENB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O0lBQ25ELENBQUM7SUF2NkJzQix5QkFBcUIsR0FBRyxHQUFHLENBQUMsQ0FBQyxzQ0FBc0M7SUFDMUUsYUFBUyxHQUFXLG9CQUFvQixDQUFDLENBQUMsb0RBQW9EO0lBQzlHLHFEQUFxRDtJQUNyRCwwR0FBMEc7SUFDMUYscUJBQWlCLEdBQVcscUJBQXFCLENBQUM7SUEwNUJsRTs7OztPQUlHO0lBQ2MsY0FBVSxHQUFHLFVBQUMsRUFBdUIsSUFBYSxPQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxLQUFpQyxDQUFDLFFBQVEsQ0FBQyxFQUE1RCxDQUE0RCxDQUFDO0lBS2xJLFVBQUM7Q0FBQSxBQTE2QkQsQ0FBeUIsbUJBQVEsR0EwNkJoQztBQTE2Qlksa0JBQUciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ2JpdGdvLXV0eG8tbGliJztcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmltcG9ydCAqIGFzIHVybCBmcm9tICd1cmwnO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgS2V5SW5kaWNlcyB9IGZyb20gJy4uL2tleWNoYWlucyc7XG5cbmltcG9ydCB7IEVkMjU1MTlLZXlEZXJpdmVyIH0gZnJvbSAnLi4vaW50ZXJuYWwva2V5RGVyaXZlcic7XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuLi8uLi9jb21tb24nO1xuaW1wb3J0IHtcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgSW52YWxpZE1lbW9JZEVycm9yLFxuICBLZXlSZWNvdmVyeVNlcnZpY2VFcnJvcixcbiAgVW5leHBlY3RlZEFkZHJlc3NFcnJvcixcbiAgU3RlbGxhckZlZGVyYXRpb25Vc2VyTm90Rm91bmRFcnJvcixcbn0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBUcmFuc2FjdGlvblJlY2lwaWVudCBhcyBCYXNlVHJhbnNhY3Rpb25PdXRwdXQsXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gYXMgQmFzZVRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIEtleVBhaXIsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zIGFzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMgYXMgQmFzZVZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25QYXJhbXMgYXMgQmFzZVRyYW5zYWN0aW9uUGFyYW1zLCBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucyxcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnLi4vd2FsbGV0JztcblxuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbmludGVyZmFjZSBBZGRyZXNzRGV0YWlscyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgbWVtb0lkPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTWVtbyB7XG4gIHR5cGU6IHN0ZWxsYXIuTWVtb1R5cGU7XG4gIHZhbHVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMgZXh0ZW5kcyBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyB7XG4gIHJvb3RBZGRyZXNzPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlUcmFuc2FjdGlvbiB7XG4gIHR4OiBzdHJpbmc7XG4gIHJlY292ZXJ5QW1vdW50OiBudW1iZXI7XG4gIGJhY2t1cEtleT86IHN0cmluZztcbiAgY29pbj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEJ1aWxkT3B0aW9ucyB7XG4gIHdhbGxldD86IFdhbGxldDtcbiAgcmVjaXBpZW50cz86IG9iamVjdFtdO1xuICB0eXBlPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhCYXNlNjQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4QmFzZTY0OiBzdHJpbmc7XG4gIH1cbn1cblxuaW50ZXJmYWNlIFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMge1xuICByb290UHJpdmF0ZUtleT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEJhc2U2NDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25NZW1vIHtcbiAgdmFsdWU/OiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk9wZXJhdGlvbiB7XG4gIHR5cGU6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBsaW1pdD86IHN0cmluZztcbiAgYXNzZXQ/OiBzdGVsbGFyLkFzc2V0O1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25PdXRwdXQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25PdXRwdXQge1xuICBjb2luOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBtZW1vOiBUcmFuc2FjdGlvbk1lbW87XG59XG5cbmludGVyZmFjZSBWZXJpZnlBZGRyZXNzT3B0aW9ucyBleHRlbmRzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyB7XG4gIHJvb3RBZGRyZXNzOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcnVzdGxpbmVPcHRpb25zIHtcbiAgdG9rZW46IHN0cmluZztcbiAgYWN0aW9uOiBzdHJpbmc7XG4gIGxpbWl0Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25QYXJhbXMgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QYXJhbXMge1xuICB0cnVzdGxpbmVzPzogVHJ1c3RsaW5lT3B0aW9uc1tdO1xufVxuXG5pbnRlcmZhY2UgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcztcbn1cblxuZXhwb3J0IGNsYXNzIFhsbSBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIHJlYWRvbmx5IGhvbWVEb21haW46IHN0cmluZztcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSB0b2tlblBhdHRlcm5TZXBhcmF0b3IgPSAnLSc7IC8vIHNlcGFyYXRvciBmb3IgdG9rZW4gY29kZSBhbmQgaXNzdWVyXG4gIHN0YXRpYyByZWFkb25seSBtYXhNZW1vSWQ6IHN0cmluZyA9ICcweEZGRkZGRkZGRkZGRkZGRkYnOyAvLyBtYXggdW5zaWduZWQgNjQtYml0IG51bWJlciA9IDE4NDQ2NzQ0MDczNzA5NTUxNjE1XG4gIC8vIG1heCBpbnQ2NCBudW1iZXIgc3VwcG9ydGVkIGJ5IHRoZSBuZXR3b3JrICgyXjYzKS0xXG4gIC8vIFNlZTogaHR0cHM6Ly93d3cuc3RlbGxhci5vcmcvZGV2ZWxvcGVycy9ndWlkZXMvY29uY2VwdHMvYXNzZXRzLmh0bWwjYW1vdW50LXByZWNpc2lvbi1hbmQtcmVwcmVzZW50YXRpb25cbiAgc3RhdGljIHJlYWRvbmx5IG1heFRydXN0bGluZUxpbWl0OiBzdHJpbmcgPSAnOTIyMzM3MjAzNjg1NDc3NTgwNyc7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICAgIHRoaXMuaG9tZURvbWFpbiA9ICdiaXRnby5jb20nOyAvLyB1c2VkIGZvciByZXZlcnNlIGZlZGVyYXRpb24gbG9va3VwXG4gICAgc3RlbGxhci5OZXR3b3JrLnVzZShuZXcgc3RlbGxhci5OZXR3b3JrKHN0ZWxsYXIuTmV0d29ya3MuUFVCTElDKSk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgWGxtKGJpdGdvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKi9cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gMWU3O1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIHdoaWNoIHN1cHBvcnRzIHRoaXMgY29pblxuICAgKi9cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hsbSc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGNvaW4gZmFtaWx5XG4gICAqL1xuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hsbSc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGlzIGNvaW5cbiAgICovXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdTdGVsbGFyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcmwgYXQgd2hpY2ggdGhlIHN0ZWxsYXIgZmVkZXJhdGlvbiBzZXJ2ZXIgY2FuIGJlIHJlYWNoZWRcbiAgICovXG4gIGdldEZlZGVyYXRpb25TZXJ2ZXJVcmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcmwgYXQgd2hpY2ggaG9yaXpvbiBjYW4gYmUgcmVhY2hlZFxuICAgKi9cbiAgZ2V0SG9yaXpvblVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnaHR0cHM6Ly9ob3Jpem9uLnN0ZWxsYXIub3JnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBrZXkgcGFpciBvbiB0aGUgZWQyNTUxOSBjdXJ2ZVxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyBnZW5lcmF0ZWQgcHViIGFuZCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkOiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBwYWlyID0gc2VlZCA/IHN0ZWxsYXIuS2V5cGFpci5mcm9tUmF3RWQyNTUxOVNlZWQoc2VlZCkgOiBzdGVsbGFyLktleXBhaXIucmFuZG9tKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogcGFpci5wdWJsaWNLZXkoKSxcbiAgICAgIHBydjogcGFpci5zZWNyZXQoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkZWNvZGVkIGVkMjU1MTkgcHVibGljIGtleSBmcm9tIHJhdyBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBwdWIgUmF3IHB1YmxpYyBrZXlcbiAgICogQHJldHVybnMgRW5jb2RlZCBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRQdWJGcm9tUmF3KHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuZW5jb2RlRWQyNTUxOVB1YmxpY0tleShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRlY29kZWQgZWQyNTUxOSBwcml2YXRlIGtleSBmcm9tIHJhdyBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgUmF3IHByaXZhdGUga2V5XG4gICAqIEByZXR1cm5zIEVuY29kZWQgcHJpdmF0ZSBrZXlcbiAgICovXG4gIGdldFBydkZyb21SYXcocHJ2OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5lbmNvZGVFZDI1NTE5U2VjcmV0U2VlZChCdWZmZXIuZnJvbShwcnYsICdoZXgnKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkocHViKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHJpdmF0ZSBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVNlY3JldFNlZWQocHJ2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSBtZW1vIGlkIGlzIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSBtZW1vSWQgbWVtbyBpZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIG1lbW8gaWQgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRNZW1vSWQobWVtb0lkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBsZXQgbWVtb0lkTnVtYmVyO1xuICAgIHRyeSB7XG4gICAgICBzdGVsbGFyLk1lbW8uaWQobWVtb0lkKTsgLy8gdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQgbWVtbyBpZFxuICAgICAgbWVtb0lkTnVtYmVyID0gbmV3IEJpZ051bWJlcihtZW1vSWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKG1lbW9JZE51bWJlci5ndGUoMCkgJiYgbWVtb0lkTnVtYmVyLmx0KFhsbS5tYXhNZW1vSWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciBhIG1lbW8gaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIHRoZSBtZW1vXG4gICAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdGhlIG1lbW9cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBhbmQgdHlwZSBhcmUgYSB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZE1lbW8oeyB2YWx1ZSwgdHlwZSB9OiBNZW1vKTogYm9vbGVhbiB7XG4gICAgaWYgKCF2YWx1ZSB8fCAhdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSB0eXBlXG4gICAgICAvLyB2YWxpZCB0eXBlcyBhcmU6ICdpZCcsICd0ZXh0JywgJ2hhc2gnLCAncmV0dXJuJ1xuICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3RyYW5zYWN0aW9ucy5odG1sI21lbW9cbiAgICAgIHN0ZWxsYXIuTWVtb1t0eXBlXSh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGJhbGFuY2Ugb2YgYSAyLW9mLTMgbXVsdGlzaWcgd2FsbGV0XG4gICAqIEByZXR1cm5zIG1pbmltdW0gYmFsYW5jZSBpbiBzdHJvb3BzXG4gICAqL1xuICBnZXRNaW5pbXVtUmVzZXJ2ZSgpOiBCbHVlYmlyZDxudW1iZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288bnVtYmVyPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3Qgc2VydmVyID0gbmV3IHN0ZWxsYXIuU2VydmVyKHNlbGYuZ2V0SG9yaXpvblVybCgpKTtcblxuICAgICAgY29uc3QgaG9yaXpvbkxlZGdlckluZm8gPSB5aWVsZCBzZXJ2ZXJcbiAgICAgICAgLmxlZGdlcnMoKVxuICAgICAgICAub3JkZXIoJ2Rlc2MnKVxuICAgICAgICAubGltaXQoMSlcbiAgICAgICAgLmNhbGwoKTtcblxuICAgICAgaWYgKCFob3Jpem9uTGVkZ2VySW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBjb25uZWN0IHRvIEhvcml6b24gZm9yIHJlc2VydmUgcmVxdWlyZW1lbnQgZGF0YScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYXNlUmVzZXJ2ZTogbnVtYmVyID0gaG9yaXpvbkxlZGdlckluZm8ucmVjb3Jkc1swXS5iYXNlX3Jlc2VydmVfaW5fc3Ryb29wcztcblxuICAgICAgLy8gMi1vZi0zIHdhbGxldHMgaGF2ZSBhIG1pbmltdW0gcmVzZXJ2ZSBvZiA1eCB0aGUgYmFzZSByZXNlcnZlXG4gICAgICByZXR1cm4gNSAqIGJhc2VSZXNlcnZlO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNhY3Rpb24gZmVlIGZvciBlYWNoIG9wZXJhdGlvblxuICAgKiBAcmV0dXJucyB0cmFuc2FjdGlvbiBmZWUgaW4gc3Ryb29wc1xuICAgKi9cbiAgZ2V0QmFzZVRyYW5zYWN0aW9uRmVlKCk6IEJsdWViaXJkPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxudW1iZXI+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgc3RlbGxhci5TZXJ2ZXIoc2VsZi5nZXRIb3Jpem9uVXJsKCkpO1xuXG4gICAgICBjb25zdCBob3Jpem9uTGVkZ2VySW5mbyA9IHlpZWxkIHNlcnZlclxuICAgICAgICAubGVkZ2VycygpXG4gICAgICAgIC5vcmRlcignZGVzYycpXG4gICAgICAgIC5saW1pdCgxKVxuICAgICAgICAuY2FsbCgpO1xuXG4gICAgICBpZiAoIWhvcml6b25MZWRnZXJJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGNvbm5lY3QgdG8gSG9yaXpvbiBmb3IgcmVzZXJ2ZSByZXF1aXJlbWVudCBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBob3Jpem9uTGVkZ2VySW5mby5yZWNvcmRzWzBdLmJhc2VfZmVlX2luX3N0cm9vcHM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFkZHJlc3MgaW50byBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAgICovXG4gIGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3M6IHN0cmluZyk6IEFkZHJlc3NEZXRhaWxzIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UoYWRkcmVzcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lO1xuICAgIGlmICghZGVzdGluYXRpb25BZGRyZXNzIHx8ICFzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShkZXN0aW5hdGlvbkFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICAvLyBhZGRyZXNzIGRvZXNuJ3QgaGF2ZSBhIG1lbW8gaWRcbiAgICBpZiAoZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lID09PSBhZGRyZXNzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBtZW1vSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeURldGFpbHMgPSBxdWVyeXN0cmluZy5wYXJzZShkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpO1xuICAgIGlmICghcXVlcnlEZXRhaWxzLm1lbW9JZCkge1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllcywgdGhlIHF1ZXJ5IGRldGFpbHMgbmVlZCB0byBjb250YWluIHRoZSBtZW1vIGlkIHByb3BlcnR5XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKFxuICAgICAgICBgbWVtb0lkIG1heSBvbmx5IGJlIGdpdmVuIGF0IG1vc3Qgb25jZSwgYnV0IGZvdW5kICR7cXVlcnlEZXRhaWxzLm1lbW9JZC5sZW5ndGh9IGluc3RhbmNlcyBpbiBhZGRyZXNzICR7YWRkcmVzc31gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpICYmIHF1ZXJ5RGV0YWlscy5tZW1vSWQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAvLyB2YWxpZCBhZGRyZXNzZXMgY2FuIG9ubHkgY29udGFpbiBvbmUgbWVtbyBpZFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzcyAnJHthZGRyZXNzfScsIG11c3QgY29udGFpbiBleGFjdGx5IG9uZSBtZW1vSWRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBbbWVtb0lkXSA9IF8uY2FzdEFycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkTWVtb0lkKG1lbW9JZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVtb0lkRXJyb3IoYGludmFsaWQgYWRkcmVzczogJyR7YWRkcmVzc30nLCBtZW1vSWQgaXMgbm90IHZhbGlkYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IGRlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgIG1lbW9JZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFuZCByZXR1cm4gYWRkcmVzcyB3aXRoIGFwcGVuZGVkIG1lbW8gaWRcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgYWRkcmVzc1xuICAgKiBAcGFyYW0gbWVtb0lkIG1lbW8gaWRcbiAgICogQHJldHVybnMgYWRkcmVzcyB3aXRoIG1lbW8gaWRcbiAgICovXG4gIG5vcm1hbGl6ZUFkZHJlc3MoeyBhZGRyZXNzLCBtZW1vSWQgfTogQWRkcmVzc0RldGFpbHMpOiBzdHJpbmcge1xuICAgIGlmICghc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhZGRyZXNzIGRldGFpbHM6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgaWYgKG1lbW9JZCAmJiB0aGlzLmlzVmFsaWRNZW1vSWQobWVtb0lkKSkge1xuICAgICAgcmV0dXJuIGAke2FkZHJlc3N9P21lbW9JZD0ke21lbW9JZH1gO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICAgIHJldHVybiBhZGRyZXNzID09PSB0aGlzLm5vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzc0RldGFpbHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgU3RlbGxhciBBc3NldCBpbiBjb2luOnRva2VuIGZvcm0gKGkuZS4gKHQpeGxtOjxjb2RlPi08aXNzdWVyPilcbiAgICogSWYgdGhlIGFzc2V0IGlzIFhMTSwgcmV0dXJuIHRoZSBjaGFpblxuICAgKiBAcGFyYW0ge3N0ZWxsYXIuQXNzZXR9IGFzc2V0IC0gaW5zdGFuY2Ugb2YgU3RlbGxhciBBc3NldFxuICAgKi9cbiAgZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChhc3NldDogc3RlbGxhci5Bc3NldCkge1xuICAgIGNvbnN0IGNvZGUgPSBhc3NldC5nZXRDb2RlKCk7XG4gICAgY29uc3QgaXNzdWVyID0gYXNzZXQuZ2V0SXNzdWVyKCk7XG4gICAgaWYgKGFzc2V0LmlzTmF0aXZlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENoYWluKCk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmdldENoYWluKCl9JHtCYXNlQ29pbi5jb2luVG9rZW5QYXR0ZXJuU2VwYXJhdG9yfSR7Y29kZX0ke1hsbS50b2tlblBhdHRlcm5TZXBhcmF0b3J9JHtpc3N1ZXJ9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB3aGV0aGVyIGEgc3RlbGxhciB1c2VybmFtZSBoYXMgdmFsaWQgZm9ybWF0XG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIGNsaWVudCB3aGVuIGEgc3RlbGxhciBhZGRyZXNzIGlzIGJlaW5nIGFkZGVkIHRvIGEgd2FsbGV0XG4gICAqIEV4YW1wbGUgb2YgYSBjb21tb24gc3RlbGxhciB1c2VybmFtZTogZm9vQGJhci5iYXpcbiAgICogVGhlIGFib3ZlIGV4YW1wbGUgd291bGQgcmVzdWx0IGluIHRoZSBTdGVsbGFyIGFkZHJlc3M6IGZvb0BiYXIuYmF6KmJpdGdvLmNvbVxuICAgKlxuICAgKiBAcGFyYW0gdXNlcm5hbWUgLSBzdGVsbGFyIHVzZXJuYW1lXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBzdGVsbGFyIHVzZXJuYW1lIGlzIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkU3RlbGxhclVzZXJuYW1lKHVzZXJuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL15bYS16MC05XFwtXy4rQF0rJC8udGVzdCh1c2VybmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZlZGVyYXRpb25TZXJ2ZXIgZm9yIEJpdEdvIGxvb2t1cHNcbiAgICpcbiAgICogQHJldHVybnMgaW5zdGFuY2Ugb2YgQml0R28gRmVkZXJhdGlvbiBTZXJ2ZXJcbiAgICovXG4gIGdldEJpdEdvRmVkZXJhdGlvblNlcnZlcigpOiBzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIge1xuICAgIC8vIElkZW50aWZ5IHRoZSBVUkkgc2NoZW1lIGluIGNhc2Ugd2UgbmVlZCB0byBhbGxvdyBjb25uZWN0aW5nIHRvIEhUVFAgc2VydmVyLlxuICAgIGNvbnN0IGlzTm9uU2VjdXJlRW52ID0gIV8uc3RhcnRzV2l0aChjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZW52XS51cmksICdodHRwcycpO1xuICAgIGNvbnN0IGZlZGVyYXRpb25TZXJ2ZXJPcHRpb25zID0geyBhbGxvd0h0dHA6IGlzTm9uU2VjdXJlRW52IH07XG4gICAgcmV0dXJuIG5ldyBzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIodGhpcy5nZXRGZWRlcmF0aW9uU2VydmVyVXJsKCksICdiaXRnby5jb20nLCBmZWRlcmF0aW9uU2VydmVyT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBmZWRlcmF0aW9uIGxvb2t1cHNcbiAgICogT3VyIGZlZGVyYXRpb24gc2VydmVyIGhhbmRsZXMgbG9va3VwcyBmb3IgYml0Z28gYXMgd2VsbCBhcyBmb3Igb3RoZXIgZmVkZXJhdGlvbiBkb21haW5zXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYWRkcmVzc10gLSBhZGRyZXNzIHRvIGxvb2sgdXBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFthY2NvdW50SWRdIC0gYWNjb3VudCBpZCB0byBsb29rIHVwXG4gICAqL1xuICBwcml2YXRlIGZlZGVyYXRpb25Mb29rdXAoeyBhZGRyZXNzLCBhY2NvdW50SWQgfTogeyBhZGRyZXNzPzogc3RyaW5nLCBhY2NvdW50SWQ/OiBzdHJpbmcgfSk6IEJsdWViaXJkPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4oZnVuY3Rpb24gKigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZlZGVyYXRpb25TZXJ2ZXIgPSBzZWxmLmdldEJpdEdvRmVkZXJhdGlvblNlcnZlcigpO1xuICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgIHJldHVybiB5aWVsZCBmZWRlcmF0aW9uU2VydmVyLnJlc29sdmVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGFjY291bnRJZCkge1xuICAgICAgICAgIHJldHVybiB5aWVsZCBmZWRlcmF0aW9uU2VydmVyLnJlc29sdmVBY2NvdW50SWQoYWNjb3VudElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgLSBtdXN0IHByb3ZpZGUgU3RlbGxhciBhZGRyZXNzIG9yIGFjY291bnQgaWQnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IF8uZ2V0KGUsICdyZXNwb25zZS5kYXRhLmRldGFpbCcpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3RlbGxhckZlZGVyYXRpb25Vc2VyTm90Rm91bmRFcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byByZXNvbHZlIGEgc3RlbGxhciBhZGRyZXNzIGludG8gYSBzdGVsbGFyIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBzdGVsbGFyIGFkZHJlc3MgdG8gbG9vayBmb3JcbiAgICovXG4gIGZlZGVyYXRpb25Mb29rdXBCeU5hbWUoYWRkcmVzczogc3RyaW5nKTogQmx1ZWJpcmQ8c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTdGVsbGFyIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuZmVkZXJhdGlvbkxvb2t1cCh7IGFkZHJlc3MgfSk7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHJlc29sdmUgYW4gYWNjb3VudCBpZCBpbnRvIGEgc3RlbGxhciBhY2NvdW50XG4gICAqIE9ubHkgd29ya3MgZm9yIGFjY291bnRzIHRoYXQgY2FuIGJlIHJlc29sdmVkIGJ5IG91ciBmZWRlcmF0aW9uIHNlcnZlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIC0gc3RlbGxhciBhY2NvdW50IGlkXG4gICAqL1xuICBmZWRlcmF0aW9uTG9va3VwQnlBY2NvdW50SWQoYWNjb3VudElkOiBzdHJpbmcpOiBCbHVlYmlyZDxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU3RlbGxhciBhY2NvdW50Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5mZWRlcmF0aW9uTG9va3VwKHsgYWNjb3VudElkIH0pO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYWRkcmVzcyBpcyBhIHZhbGlkIFhMTSBhZGRyZXNzLCBhbmQgdGhlbiBtYWtlIHN1cmUgaXQgbWF0Y2hlcyB0aGUgcm9vdCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgYWRkcmVzcyB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHJvb3RBZGRyZXNzIHtTdHJpbmd9IHRoZSB3YWxsZXQncyByb290IGFkZHJlc3NcbiAgICovXG4gIHZlcmlmeUFkZHJlc3MoeyBhZGRyZXNzLCByb290QWRkcmVzcyB9OiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICBjb25zdCByb290QWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKHJvb3RBZGRyZXNzKTtcblxuICAgIGlmIChhZGRyZXNzRGV0YWlscy5hZGRyZXNzICE9PSByb290QWRkcmVzc0RldGFpbHMuYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAke2FkZHJlc3NEZXRhaWxzLmFkZHJlc3N9IHZzICR7cm9vdEFkZHJlc3NEZXRhaWxzLmFkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGV4dHJhIHBhcmFtZXRlcnMgZm9yIHByZWJ1aWxkaW5nIGEgdHhcbiAgICogU2V0IGVtcHR5IHJlY2lwaWVudHMgYXJyYXkgaW4gdHJ1c3RsaW5lIHR4c1xuICAgKi9cbiAgZ2V0RXh0cmFQcmVidWlsZFBhcmFtcyhidWlsZFBhcmFtczogRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJ1aWxkT3B0aW9ucz4pOiBCbHVlYmlyZDxCdWlsZE9wdGlvbnM+IHtcbiAgICBjb25zdCBwYXJhbXM6IHsgcmVjaXBpZW50cz86IG9iamVjdFtdIH0gPSB7fTtcbiAgICBpZiAoYnVpbGRQYXJhbXMudHlwZSA9PT0gJ3RydXN0bGluZScpIHtcbiAgICAgIHBhcmFtcy5yZWNpcGllbnRzID0gW107XG4gICAgfVxuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHBhcmFtcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIFN0ZWxsYXIga2V5cGFpcnMgZnJvbSB0aGUgdXNlciBrZXkgYW5kIGJhY2t1cCBrZXlcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgaW5pdGlhdGVSZWNvdmVyeShwYXJhbXM6IFJlY292ZXJ5T3B0aW9ucyk6IEJsdWViaXJkPHN0ZWxsYXIuS2V5cGFpcltdPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHN0ZWxsYXIuS2V5cGFpcltdPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3Qga2V5czogc3RlbGxhci5LZXlwYWlyW10gPSBbXTtcbiAgICAgIGxldCB1c2VyS2V5ID0gcGFyYW1zLnVzZXJLZXk7XG4gICAgICBsZXQgYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcblxuICAgICAgLy8gU3RlbGxhcidzIEVkMjU1MTkgcHVibGljIGtleXMgc3RhcnQgd2l0aCBhIEcsIHdoaWxlIHByaXZhdGUga2V5cyBzdGFydCB3aXRoIGFuIFNcbiAgICAgIGNvbnN0IGlzS3JzUmVjb3ZlcnkgPSBiYWNrdXBLZXkuc3RhcnRzV2l0aCgnRycpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ0cnKTtcbiAgICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9IGJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgdXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG5cblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyICYmIF8uaXNVbmRlZmluZWQoY29uZmlnLmtyc1Byb3ZpZGVyc1twYXJhbXMua3JzUHJvdmlkZXJdKSkge1xuICAgICAgICB0aHJvdyBuZXcgS2V5UmVjb3ZlcnlTZXJ2aWNlRXJyb3IoYFVua25vd24ga2V5IHJlY292ZXJ5IHNlcnZpY2UgcHJvdmlkZXIgLSAke3BhcmFtcy5rcnNQcm92aWRlcn1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyICYmICFjb25maWcua3JzUHJvdmlkZXJzW3BhcmFtcy5rcnNQcm92aWRlcl0uc3VwcG9ydGVkQ29pbnMuaW5jbHVkZXMoc2VsZi5nZXRGYW1pbHkoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEtleVJlY292ZXJ5U2VydmljZUVycm9yKGBTcGVjaWZpZWQga2V5IHJlY292ZXJ5IHNlcnZpY2UgZG9lcyBub3Qgc3VwcG9ydCByZWNvdmVyaWVzIGZvciAke3NlbGYuZ2V0Q2hhaW4oKX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXVzZXJLZXkuc3RhcnRzV2l0aCgnUycpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ0cnKSkge1xuICAgICAgICAgIHVzZXJLZXkgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1c2VyS2V5UGFpciA9IGlzVW5zaWduZWRTd2VlcCA/XG4gICAgICAgICAgc3RlbGxhci5LZXlwYWlyLmZyb21QdWJsaWNLZXkodXNlcktleSkgOlxuICAgICAgICAgIHN0ZWxsYXIuS2V5cGFpci5mcm9tU2VjcmV0KHVzZXJLZXkpO1xuICAgICAgICBrZXlzLnB1c2godXNlcktleVBhaXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IHVzZXIga2V5IHdpdGggcGFzc2NvZGUgLSB0cnkgYWdhaW4hJyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ1MnKSAmJiAhaXNLcnNSZWNvdmVyeSAmJiAhaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgICAgYmFja3VwS2V5ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICAgIGlucHV0OiBiYWNrdXBLZXksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNLcnNSZWNvdmVyeSB8fCBpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgICBrZXlzLnB1c2goc3RlbGxhci5LZXlwYWlyLmZyb21QdWJsaWNLZXkoYmFja3VwS2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5cy5wdXNoKHN0ZWxsYXIuS2V5cGFpci5mcm9tU2VjcmV0KGJhY2t1cEtleSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgYmFja3VwIGtleSB3aXRoIHBhc3Njb2RlIC0gdHJ5IGFnYWluIScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHVzZXJLZXk6IFtlbmNyeXB0ZWRdIFN0ZWxsYXIgcHJpdmF0ZSBrZXlcbiAgICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIFN0ZWxsYXIgcHJpdmF0ZSBrZXksIG9yIHB1YmxpYyBrZXkgaWYgdGhlIHByaXZhdGUga2V5IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSBwcml2YXRlIGtleXMgaXMgZW5jcnlwdGVkXG4gICAqIC0gcm9vdEFkZHJlc3M6IGJhc2UgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHRvIHJlY292ZXIgZnVuZHMgZnJvbVxuICAgKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICAgKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVjb3ZlcihwYXJhbXM6IFJlY292ZXJ5T3B0aW9ucywgY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxSZWNvdmVyeVRyYW5zYWN0aW9uPik6IEJsdWViaXJkPFJlY292ZXJ5VHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UmVjb3ZlcnlUcmFuc2FjdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IFt1c2VyS2V5LCBiYWNrdXBLZXldID0geWllbGQgc2VsZi5pbml0aWF0ZVJlY292ZXJ5KHBhcmFtcyk7XG4gICAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ0cnKTtcbiAgICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgnRycpICYmIHBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ0cnKTtcblxuICAgICAgaWYgKCFwYXJhbXMucm9vdEFkZHJlc3MgfHwgIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KHBhcmFtcy5yb290QWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdhbGxldCBhZGRyZXNzOiAke3BhcmFtcy5yb290QWRkcmVzc31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWNjb3VudERhdGFVcmwgPSBgJHtzZWxmLmdldEhvcml6b25VcmwoKX0vYWNjb3VudHMvJHtwYXJhbXMucm9vdEFkZHJlc3N9YDtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uVXJsID0gYCR7c2VsZi5nZXRIb3Jpem9uVXJsKCl9L2FjY291bnRzLyR7cGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb259YDtcblxuICAgICAgbGV0IGFjY291bnREYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWNjb3VudERhdGEgPSB5aWVsZCByZXF1ZXN0LmdldChhY2NvdW50RGF0YVVybCkucmVzdWx0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlYWNoIHRoZSBTdGVsbGFyIG5ldHdvcmsgdmlhIEhvcml6b24uJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgZGVzdGluYXRpb24gYWNjb3VudCBpcyBlbXB0eSBvciBub3RcbiAgICAgIGxldCB1bmZ1bmRlZERlc3RpbmF0aW9uID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCByZXF1ZXN0LmdldChkZXN0aW5hdGlvblVybCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlc3RpbmF0aW9uIGFjY291bnQgZG9lcyBub3QgeWV0IGV4aXN0LCBob3Jpem9uIHJlc3BvbmRzIHdpdGggNDA0XG4gICAgICAgICAgdW5mdW5kZWREZXN0aW5hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhY2NvdW50RGF0YS5zZXF1ZW5jZSB8fCAhYWNjb3VudERhdGEuYmFsYW5jZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb3Jpem9uIHNlcnZlciBlcnJvciAtIHVuYWJsZSB0byByZXRyaWV2ZSBzZXF1ZW5jZSBJRCBvciBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWNjb3VudCA9IG5ldyBzdGVsbGFyLkFjY291bnQocGFyYW1zLnJvb3RBZGRyZXNzLCBhY2NvdW50RGF0YS5zZXF1ZW5jZSk7XG5cbiAgICAgIC8vIFN0ZWxsYXIgc3VwcG9ydHMgbXVsdGlwbGUgYXNzZXRzIG9uIGNoYWluLCB3ZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIGJhbGFuY2VzIGVudHJ5IHdob3NlIHR5cGUgaXMgXCJuYXRpdmVcIiAoWExNKVxuICAgICAgY29uc3QgbmF0aXZlQmFsYW5jZUluZm8gPSBhY2NvdW50RGF0YS5iYWxhbmNlcy5maW5kKGFzc2V0QmFsYW5jZSA9PiBhc3NldEJhbGFuY2VbJ2Fzc2V0X3R5cGUnXSA9PT0gJ25hdGl2ZScpO1xuXG4gICAgICBpZiAoIW5hdGl2ZUJhbGFuY2VJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgd2FsbGV0IGhhcyBhIGJhbGFuY2Ugb2YgMCBYTE0sIHJlY292ZXJ5IGFib3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2FsbGV0QmFsYW5jZSA9IE51bWJlcihzZWxmLmJpZ1VuaXRzVG9CYXNlVW5pdHMobmF0aXZlQmFsYW5jZUluZm8uYmFsYW5jZSkpO1xuICAgICAgY29uc3QgbWluaW11bVJlc2VydmU6IG51bWJlciA9IHlpZWxkIHNlbGYuZ2V0TWluaW11bVJlc2VydmUoKTtcbiAgICAgIGNvbnN0IGJhc2VUeEZlZTogbnVtYmVyID0geWllbGQgc2VsZi5nZXRCYXNlVHJhbnNhY3Rpb25GZWUoKTtcbiAgICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gd2FsbGV0QmFsYW5jZSAtIG1pbmltdW1SZXNlcnZlIC0gYmFzZVR4RmVlO1xuICAgICAgY29uc3QgZm9ybWF0dGVkUmVjb3ZlcnlBbW91bnQgPSBzZWxmLmJhc2VVbml0c1RvQmlnVW5pdHMocmVjb3ZlcnlBbW91bnQpLnRvU3RyaW5nKCk7XG5cbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IG5ldyBzdGVsbGFyLlRyYW5zYWN0aW9uQnVpbGRlcihhY2NvdW50KTtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHVuZnVuZGVkRGVzdGluYXRpb24gP1xuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBhY2NvdW50XG4gICAgICAgIHN0ZWxsYXIuT3BlcmF0aW9uLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgIGRlc3RpbmF0aW9uOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgICBzdGFydGluZ0JhbGFuY2U6IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50LFxuICAgICAgICB9KSA6XG4gICAgICAgIC8vIE90aGVyd2lzZSBpZiB0aGUgYWNjb3VudCBhbHJlYWR5IGV4aXN0cywgd2UgZG8gYSBub3JtYWwgc2VuZFxuICAgICAgICBzdGVsbGFyLk9wZXJhdGlvbi5wYXltZW50KHtcbiAgICAgICAgICBkZXN0aW5hdGlvbjogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgICAgYXNzZXQ6IHN0ZWxsYXIuQXNzZXQubmF0aXZlKCksXG4gICAgICAgICAgYW1vdW50OiBmb3JtYXR0ZWRSZWNvdmVyeUFtb3VudCxcbiAgICAgICAgfSk7XG4gICAgICBjb25zdCB0eCA9IHR4QnVpbGRlci5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKS5idWlsZCgpO1xuXG4gICAgICBpZiAoIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICB0eC5zaWduKHVzZXJLZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzS3JzUmVjb3ZlcnkgJiYgIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICB0eC5zaWduKGJhY2t1cEtleSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBSZWNvdmVyeVRyYW5zYWN0aW9uID0ge1xuICAgICAgICB0eDogWGxtLnR4VG9TdHJpbmcodHgpLFxuICAgICAgICByZWNvdmVyeUFtb3VudCxcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNvaW4gPSBzZWxmLmdldENoYWluKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4UHJlYnVpbGQge09iamVjdH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB7IHR4UHJlYnVpbGQsIHBydiB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhQcmVidWlsZH1gKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGlmICghXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiBwcnZ9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5UGFpciA9IHN0ZWxsYXIuS2V5cGFpci5mcm9tU2VjcmV0KHBydik7XG4gICAgY29uc3QgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eFByZWJ1aWxkLnR4QmFzZTY0KTtcbiAgICB0eC5zaWduKGtleVBhaXIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgICAgdHhCYXNlNjQ6IFhsbS50eFRvU3RyaW5nKHR4KSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgd2FsbGV0UGFyYW1zIHdpdGggZXh0cmEgcGFyYW1zIHJlcXVpcmVkIGZvciBnZW5lcmF0aW5nIGFuIFhMTSB3YWxsZXRcbiAgICpcbiAgICogU3RlbGxhciB3YWxsZXRzIGhhdmUgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZW0uIFR3byBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBwbGF0Zm9ybSwgYW5kIHRoZSBsYXN0IGlzIGdlbmVyYXRlZCBieSB0aGUgdXNlci5cbiAgICogSW5pdGlhbGx5LCB3ZSBuZWVkIGEgcm9vdCBwcnYgdG8gZ2VuZXJhdGUgdGhlIGFjY291bnQsIHdoaWNoIG11c3QgYmUgZGlzdGluY3QgZnJvbSBhbGwgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZSB3YWxsZXQuXG4gICAqIElmIGEgcm9vdCBwcnYgaXMgbm90IHByb3ZpZGVkLCBhIHJhbmRvbSBvbmUgaXMgZ2VuZXJhdGVkLlxuICAgKi9cbiAgc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyk6IEJsdWViaXJkPFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnM+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288U3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucz4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGxldCBzZWVkO1xuICAgICAgY29uc3Qgcm9vdFBydiA9IHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleTtcbiAgICAgIGlmIChyb290UHJ2KSB7XG4gICAgICAgIGlmICghc2VsZi5pc1ZhbGlkUHJ2KHJvb3RQcnYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb290UHJpdmF0ZUtleSBuZWVkcyB0byBiZSB2YWxpZCBlZDI1NTE5IHNlY3JldCBzZWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IHN0ZWxsYXIuU3RyS2V5LmRlY29kZUVkMjU1MTlTZWNyZXRTZWVkKHJvb3RQcnYpO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5UGFpciA9IHNlbGYuZ2VuZXJhdGVLZXlQYWlyKHNlZWQpO1xuICAgICAgLy8gZXh0ZW5kIHRoZSB3YWxsZXQgaW5pdGlhbGl6YXRpb24gcGFyYW1zXG4gICAgICB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkgPSBrZXlQYWlyLnBydjtcbiAgICAgIHJldHVybiB3YWxsZXRQYXJhbXM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIG1lc3NhZ2Ugd2l0aCBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqL1xuICBzaWduTWVzc2FnZShrZXk6IEtleVBhaXIsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRQcnYoa2V5LnBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwcnY6ICR7a2V5LnBydn1gKTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3Qga2V5cGFpciA9IHN0ZWxsYXIuS2V5cGFpci5mcm9tU2VjcmV0KGtleS5wcnYpO1xuICAgIHJldHVybiBrZXlwYWlyLnNpZ24obWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgaWYgc2lnbmF0dXJlIGZvciBtZXNzYWdlIGlzIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0gcHViIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2Ugc2lnbmVkIG1lc3NhZ2VcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBzaWduYXR1cmUgdG8gdmVyaWZ5XG4gICAqIEByZXR1cm5zIHRydWUgaWYgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlKHB1Yjogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIsIHNpZ25hdHVyZTogQnVmZmVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRQdWIocHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHB1YjogJHtwdWJ9YCk7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhaXIgPSBzdGVsbGFyLktleXBhaXIuZnJvbVB1YmxpY0tleShwdWIpO1xuICAgIHJldHVybiBrZXlQYWlyLnZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4vcGFyc2UgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgeyB0eEJhc2U2NCB9ID0gcGFyYW1zO1xuICAgICAgbGV0IHR4OiBzdGVsbGFyLlRyYW5zYWN0aW9uO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0eCA9IG5ldyBzdGVsbGFyLlRyYW5zYWN0aW9uKHR4QmFzZTY0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eEJhc2U2NCBuZWVkcyB0byBiZSBhIHZhbGlkIHR4IGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZycpO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSB0eC5oYXNoKCkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgICAvLyBJbiBhIFN0ZWxsYXIgdHgsIHRoZSBfbWVtbyBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgbWV0aG9kczpcbiAgICAgIC8vIHZhbHVlKCkgYW5kIGFybSgpIHRoYXQgcHJvdmlkZSBtZW1vIHZhbHVlIGFuZCB0eXBlLCByZXNwZWN0aXZlbHkuXG4gICAgICBjb25zdCBtZW1vOiBUcmFuc2FjdGlvbk1lbW8gPSBfLnJlc3VsdCh0eCwgJ19tZW1vLnZhbHVlJykgJiYgXy5yZXN1bHQodHgsICdfbWVtby5hcm0nKSA/XG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogKF8ucmVzdWx0KHR4LCAnX21lbW8udmFsdWUnKSBhcyBhbnkpLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogXy5yZXN1bHQodHgsICdfbWVtby5hcm0nKSxcbiAgICAgICAgfSA6IHt9O1xuXG4gICAgICBsZXQgc3BlbmRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApOyAvLyBhbW91bnQgb2YgWExNIHVzZWQgaW4gWExNLW9ubHkgdHhzXG4gICAgICBjb25zdCBzcGVuZEFtb3VudHMgPSB7fTsgLy8gdHJhY2sgYm90aCB4bG0gYW5kIHRva2VuIGFtb3VudHNcbiAgICAgIGlmIChfLmlzRW1wdHkodHgub3BlcmF0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9wZXJhdGlvbnMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0czogVHJhbnNhY3Rpb25PdXRwdXRbXSA9IFtdO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uczogVHJhbnNhY3Rpb25PcGVyYXRpb25bXSA9IFtdOyAvLyBub24tcGF5bWVudCBvcGVyYXRpb25zXG5cbiAgICAgIF8uZm9yRWFjaCh0eC5vcGVyYXRpb25zLCBvcCA9PiB7XG4gICAgICAgIGlmIChvcC50eXBlID09PSAnY3JlYXRlQWNjb3VudCcgfHwgb3AudHlwZSA9PT0gJ3BheW1lbnQnKSB7XG4gICAgICAgICAgLy8gVE9ETyBSZW1vdmUgbWVtb0lkIGZyb20gYWRkcmVzc1xuICAgICAgICAgIC8vIEdldCBtZW1vIHRvIGF0dGFjaCB0byBhZGRyZXNzLCBpZiB0eXBlIGlzICdpZCdcbiAgICAgICAgICBjb25zdCBtZW1vSWQgPSBfLmdldChtZW1vLCAndHlwZScpID09PSAnaWQnICYmICEgXy5nZXQobWVtbywgJ3ZhbHVlJykgP1xuICAgICAgICAgICAgYD9tZW1vSWQ9JHttZW1vLnZhbHVlfWAgOlxuICAgICAgICAgICAgJyc7XG4gICAgICAgICAgY29uc3QgYXNzZXQgPSBvcC50eXBlID09PSAncGF5bWVudCcgPyBvcC5hc3NldCA6IHN0ZWxsYXIuQXNzZXQubmF0aXZlKCk7XG4gICAgICAgICAgY29uc3QgY29pbiA9IHNlbGYuZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChhc3NldCk7IC8vIGNvaW4gb3IgdG9rZW4gaWRcbiAgICAgICAgICBjb25zdCBvdXRwdXQ6IFRyYW5zYWN0aW9uT3V0cHV0ID0ge1xuICAgICAgICAgICAgYW1vdW50OiBzZWxmLmJpZ1VuaXRzVG9CYXNlVW5pdHMoXG4gICAgICAgICAgICAgIChvcCBhcyBzdGVsbGFyLk9wZXJhdGlvbi5DcmVhdGVBY2NvdW50KS5zdGFydGluZ0JhbGFuY2UgfHwgKG9wIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLlBheW1lbnQpLmFtb3VudFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IG9wLmRlc3RpbmF0aW9uICsgbWVtb0lkLFxuICAgICAgICAgICAgY29pbixcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHNwZW5kQW1vdW50c1tjb2luXSkpIHtcbiAgICAgICAgICAgIHNwZW5kQW1vdW50c1tjb2luXSA9IHNwZW5kQW1vdW50c1tjb2luXS5wbHVzKG91dHB1dC5hbW91bnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGVuZEFtb3VudHNbY29pbl0gPSBuZXcgQmlnTnVtYmVyKG91dHB1dC5hbW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXNzZXQuaXNOYXRpdmUoKSkge1xuICAgICAgICAgICAgc3BlbmRBbW91bnQgPSBzcGVuZEFtb3VudC5wbHVzKG91dHB1dC5hbW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvcC50eXBlID09PSAnY2hhbmdlVHJ1c3QnKSB7XG4gICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IG9wLnR5cGUsXG4gICAgICAgICAgICBjb2luOiBzZWxmLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQob3AubGluZSksXG4gICAgICAgICAgICBhc3NldDogb3AubGluZSxcbiAgICAgICAgICAgIGxpbWl0OiBzZWxmLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3AubGltaXQpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gc3BlbmRBbW91bnQudG9GaXhlZCgwKTtcbiAgICAgIGNvbnN0IG91dHB1dEFtb3VudHMgPSBfLm1hcFZhbHVlcyhzcGVuZEFtb3VudHMsIChhbW91bnQ6IEJpZ051bWJlcikgPT4gYW1vdW50LnRvRml4ZWQoMCkpO1xuICAgICAgY29uc3QgZmVlID0ge1xuICAgICAgICBmZWU6IHR4LmZlZS50b0ZpeGVkKDApLFxuICAgICAgICBmZWVSYXRlOiBudWxsLFxuICAgICAgICBzaXplOiBudWxsLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyOiBbJ2lkJywgJ291dHB1dEFtb3VudCcsICdvdXRwdXRBbW91bnRzJywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnLCAnZmVlJywgJ21lbW8nLCAnb3BlcmF0aW9ucyddLFxuICAgICAgICBpZCxcbiAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgb3V0cHV0QW1vdW50LFxuICAgICAgICBvdXRwdXRBbW91bnRzLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsXG4gICAgICAgIG1lbW8sXG4gICAgICAgIGZlZSxcbiAgICAgICAgb3BlcmF0aW9ucyxcbiAgICAgIH07XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHR4IHByZWJ1aWxkJ3Mgb3BlcmF0aW9ucyBjb21wbHkgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqIEBwYXJhbSB7c3RlbGxhci5PcGVyYXRpb259IG9wZXJhdGlvbnMgLSB0eCBvcGVyYXRpb25zXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25QYXJhbXN9IHR4UGFyYW1zIC0gcGFyYW1zIHVzZWQgdG8gYnVpbGQgdGhlIHR4XG4gICAqL1xuICB2ZXJpZnlUcnVzdGxpbmVUeE9wZXJhdGlvbnMob3BlcmF0aW9uczogc3RlbGxhci5PcGVyYXRpb25bXSwgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zKTogdm9pZCB7XG4gICAgY29uc3QgdHJ1c3RsaW5lT3BlcmF0aW9ucyA9IF8uZmlsdGVyKG9wZXJhdGlvbnMsIFsndHlwZScsICdjaGFuZ2VUcnVzdCddKSBhcyBzdGVsbGFyLk9wZXJhdGlvbi5DaGFuZ2VUcnVzdFtdO1xuICAgIGlmICh0cnVzdGxpbmVPcGVyYXRpb25zLmxlbmd0aCAhPT0gXy5nZXQodHhQYXJhbXMsICd0cnVzdGxpbmVzJywgW10pLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCB0cnVzdGxpbmUgb3BlcmF0aW9ucycpO1xuICAgIH1cbiAgICBfLmZvckVhY2godHJ1c3RsaW5lT3BlcmF0aW9ucywgb3AgPT4ge1xuICAgICAgY29uc3Qgb3BUb2tlbiA9IHRoaXMuZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChvcC5saW5lKTtcbiAgICAgIGNvbnN0IHRva2VuVHJ1c3RsaW5lID0gXy5maW5kKHR4UGFyYW1zLnRydXN0bGluZXMsIHRydXN0bGluZSA9PiB7XG4gICAgICAgIC8vIHRydXN0bGluZSBwYXJhbXMgdXNlIGxpbWl0cyBpbiBiYXNlIHVuaXRzXG4gICAgICAgIGNvbnN0IG9wTGltaXRCYXNlVW5pdHMgPSB0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3AubGltaXQpO1xuICAgICAgICAvLyBQcmVwYXJlIHRoZSBjb25kaXRpb25zIHRvIGNoZWNrIGZvclxuICAgICAgICAvLyBMaW1pdCB3aWxsIGFsd2F5cyBiZSBzZXQgaW4gdGhlIG9wZXJhdGlvbiwgZXZlbiBpZiBpdCB3YXMgb21pdHRlZCBmcm9tIHR4UGFyYW1zIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgIC8vIDEuIEFjdGlvbiBpcyAnYWRkJyAtIGxpbWl0IGlzIHNldCB0byBYbG0ubWF4VHJ1c3RsaW5lTGltaXQgYnkgZGVmYXVsdFxuICAgICAgICAvLyAyLiBBY3Rpb24gaXMgJ3JlbW92ZScgLSBsaW1pdCBpcyBzZXQgdG8gJzAnXG4gICAgICAgIGNvbnN0IG5vTGltaXQgPSBfLmlzVW5kZWZpbmVkKHRydXN0bGluZS5saW1pdCk7XG4gICAgICAgIGNvbnN0IGFkZFRydXN0bGluZVdpdGhEZWZhdWx0TGltaXQgPSAodHJ1c3RsaW5lLmFjdGlvbiA9PT0gJ2FkZCcgJiYgb3BMaW1pdEJhc2VVbml0cyA9PT0gWGxtLm1heFRydXN0bGluZUxpbWl0KTtcbiAgICAgICAgY29uc3QgcmVtb3ZlVHJ1c3RsaW5lID0gKHRydXN0bGluZS5hY3Rpb24gPT09ICdyZW1vdmUnICYmIG9wTGltaXRCYXNlVW5pdHMgPT09ICcwJyk7XG4gICAgICAgIHJldHVybiAodHJ1c3RsaW5lLnRva2VuID09PSBvcFRva2VuICYmXG4gICAgICAgICAgKHRydXN0bGluZS5saW1pdCA9PT0gb3BMaW1pdEJhc2VVbml0cyB8fCAobm9MaW1pdCAmJiAoYWRkVHJ1c3RsaW5lV2l0aERlZmF1bHRMaW1pdCB8fCByZW1vdmVUcnVzdGxpbmUpKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0b2tlblRydXN0bGluZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSB0b2tlbnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkLnR4QmFzZTY0IHByZWJ1aWx0IHRyYW5zYWN0aW9uIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXQgd2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJpZmljYXRpb24gc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZyBEaXNhbGxvdyBmZXRjaGluZyBhbnkgZGF0YSBmcm9tIHRoZSBpbnRlcm5ldCBmb3IgdmVyaWZpY2F0aW9uIHB1cnBvc2VzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5rZXljaGFpbnMgUGFzcyBrZXljaGFpbnMgbWFudWFsbHkgcmF0aGVyIHRoYW4gZmV0Y2hpbmcgdGhlbSBieSBpZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHZlcmlmeVRyYW5zYWN0aW9uKG9wdGlvbnM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Ym9vbGVhbj4pOiBCbHVlYmlyZDxib29sZWFuPiB7XG4gICAgLy8gVE9ETyBCRy01NjAwIEFkZCBwYXJzZVRyYW5zYWN0aW9uIC8gaW1wcm92ZSB2ZXJpZmljYXRpb25cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288Ym9vbGVhbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgIHR4UHJlYnVpbGQsXG4gICAgICAgIHdhbGxldCxcbiAgICAgICAgdmVyaWZpY2F0aW9uID0ge30sXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG5cbiAgICAgIGlmICghdHhQcmVidWlsZC50eEJhc2U2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHggcHJlYnVpbGQgcHJvcGVydHkgdHhCYXNlNjQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eFByZWJ1aWxkLnR4QmFzZTY0KTtcblxuICAgICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMgJiYgdHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgbW9yZSB0aGFuIDEgcmVjaXBpZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0ZWxsYXIgdHhzIGFyZSBtYWRlIHVwIG9mIG9wZXJhdGlvbnMuIFdlIG9ubHkgY2FyZSBhYm91dCBDcmVhdGUgQWNjb3VudCBhbmQgUGF5bWVudCBmb3Igc2VuZGluZyBmdW5kcy5cbiAgICAgIGNvbnN0IG91dHB1dE9wZXJhdGlvbnMgPSBfLmZpbHRlcih0eC5vcGVyYXRpb25zLCBvcGVyYXRpb24gPT5cbiAgICAgICAgb3BlcmF0aW9uLnR5cGUgPT09ICdjcmVhdGVBY2NvdW50JyB8fCBvcGVyYXRpb24udHlwZSA9PT0gJ3BheW1lbnQnXG4gICAgICApO1xuXG4gICAgICBpZiAodHhQYXJhbXMudHlwZSA9PT0gJ3RydXN0bGluZScpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlUcnVzdGxpbmVUeE9wZXJhdGlvbnModHgub3BlcmF0aW9ucywgdHhQYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF8uaXNFbXB0eShvdXRwdXRPcGVyYXRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgaGF2ZSBhbnkgb3BlcmF0aW9ucycpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5mb3JFYWNoKHR4UGFyYW1zLnJlY2lwaWVudHMsIChleHBlY3RlZE91dHB1dCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZE91dHB1dEFkZHJlc3MgPSBzZWxmLmdldEFkZHJlc3NEZXRhaWxzKGV4cGVjdGVkT3V0cHV0LmFkZHJlc3MpO1xuICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dE9wZXJhdGlvbnNbaW5kZXhdIGFzIChzdGVsbGFyLk9wZXJhdGlvbi5QYXltZW50IHwgc3RlbGxhci5PcGVyYXRpb24uQ3JlYXRlQWNjb3VudCk7XG4gICAgICAgICAgaWYgKG91dHB1dC5kZXN0aW5hdGlvbiAhPT0gZXhwZWN0ZWRPdXRwdXRBZGRyZXNzLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgcmVjaXBpZW50Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGV4cGVjdGVkT3V0cHV0LmFtb3VudCk7XG4gICAgICAgICAgLy8gVGhlIG91dHB1dCBhbW91bnQgaXMgZXhwcmVzc2VkIGFzIHN0YXJ0aW5nQmFsYW5jZSBpbiBjcmVhdGVBY2NvdW50IG9wZXJhdGlvbnMgYW5kIGFzIGFtb3VudCBpbiBwYXltZW50IG9wZXJhdGlvbnMuXG4gICAgICAgICAgY29uc3Qgb3V0cHV0QW1vdW50U3RyaW5nID0gKG91dHB1dC50eXBlID09PSAnY3JlYXRlQWNjb3VudCcpID8gb3V0cHV0LnN0YXJ0aW5nQmFsYW5jZSA6IG91dHB1dC5hbW91bnQ7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gbmV3IEJpZ051bWJlcihzZWxmLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3V0cHV0QW1vdW50U3RyaW5nKSk7XG5cbiAgICAgICAgICBpZiAoIW91dHB1dEFtb3VudC5lcShleHBlY3RlZE91dHB1dEFtb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgYW1vdW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IHRoZSB1c2VyIHNpZ25hdHVyZSwgaWYgdGhlIHR4IGlzIGhhbGYtc2lnbmVkXG4gICAgICBpZiAoIV8uaXNFbXB0eSh0eC5zaWduYXR1cmVzKSkge1xuICAgICAgICBjb25zdCB1c2VyU2lnbmF0dXJlID0gdHguc2lnbmF0dXJlc1swXS5zaWduYXR1cmUoKTtcblxuICAgICAgICAvLyBvYnRhaW4gdGhlIGtleWNoYWlucyBhbmQga2V5IHNpZ25hdHVyZXNcbiAgICAgICAgbGV0IGtleWNoYWlucyA9IHZlcmlmaWNhdGlvbi5rZXljaGFpbnM7XG4gICAgICAgIGlmICgha2V5Y2hhaW5zICYmIGRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmV0Y2gga2V5Y2hhaW5zIHdpdGhvdXQgbmV0d29ya2luZycpO1xuICAgICAgICB9IGVsc2UgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgICAgICBrZXljaGFpbnMgPSB5aWVsZCBCbHVlYmlyZC5wcm9wcyh7XG4gICAgICAgICAgICB1c2VyOiBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5VU0VSXSB9KSxcbiAgICAgICAgICAgIGJhY2t1cDogc2VsZi5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuQkFDS1VQXSB9KSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5Y2hhaW5zIHx8ICFrZXljaGFpbnMuYmFja3VwIHx8ICFrZXljaGFpbnMudXNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW5zIGFyZSByZXF1aXJlZCwgYnV0IGNvdWxkIG5vdCBiZSBmZXRjaGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi52ZXJpZnlTaWduYXR1cmUoa2V5Y2hhaW5zLmJhY2t1cC5wdWIsIHR4Lmhhc2goKSwgdXNlclNpZ25hdHVyZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHNpZ25lZCB3aXRoIHdyb25nIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi52ZXJpZnlTaWduYXR1cmUoa2V5Y2hhaW5zLnVzZXIucHViLCB0eC5oYXNoKCksIHVzZXJTaWduYXR1cmUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBzaWduYXR1cmUgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgaGFyZGVuZWQgY2hpbGQgcHVibGljIGtleSBmcm9tIGEgbWFzdGVyIGtleSBzZWVkIHVzaW5nIGFuIGFkZGl0aW9uYWwgc2VlZCBmb3IgcmFuZG9tbmVzcy5cbiAgICpcbiAgICogRHVlIHRvIHRlY2huaWNhbCBkaWZmZXJlbmNlcyBiZXR3ZWVuIGtleXBhaXJzIG9uIHRoZSBlZDI1NTE5IGN1cnZlIGFuZCB0aGUgc2VjcDI1NmsxIGN1cnZlLFxuICAgKiBvbmx5IGhhcmRlbmVkIHByaXZhdGUga2V5IGRlcml2YXRpb24gaXMgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IHNlZWQgZm9yIHRoZSBtYXN0ZXIga2V5LiBOb3RlOiBOb3QgdGhlIHB1YmxpYyBrZXkgb3IgZW5jb2RlZCBwcml2YXRlIGtleS4gVGhpcyBpcyB0aGUgcmF3IHNlZWQuXG4gICAqIEBwYXJhbSBlbnRyb3B5U2VlZCByYW5kb20gc2VlZCB3aGljaCBpcyBoYXNoZWQgdG8gZ2VuZXJhdGUgdGhlIGRlcml2YXRpb24gcGF0aFxuICAgKi9cbiAgZGVyaXZlS2V5V2l0aFNlZWQoeyBrZXksIHNlZWQgfTogeyBrZXk6IHN0cmluZzsgc2VlZDogc3RyaW5nIH0pOiB7IGRlcml2YXRpb25QYXRoOiBzdHJpbmc7IGtleTogc3RyaW5nIH0ge1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoSW5wdXQgPSBiaXRjb2luLmNyeXB0by5oYXNoMjU2KGAke3NlZWR9YCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoUGFydHMgPSBbXG4gICAgICA5OTk5OTksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDAsIDcpLCAxNiksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDcsIDE0KSwgMTYpLFxuICAgIF07XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSAnbS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0c1xuICAgICAgLm1hcCgocGFydCkgPT4gYCR7cGFydH0nYClcbiAgICAgIC5qb2luKCcvJyk7XG4gICAgY29uc3QgZGVyaXZlZEtleSA9IEVkMjU1MTlLZXlEZXJpdmVyLmRlcml2ZVBhdGgoZGVyaXZhdGlvblBhdGgsIGtleSkua2V5O1xuICAgIGNvbnN0IGtleXBhaXIgPSBzdGVsbGFyLktleXBhaXIuZnJvbVJhd0VkMjU1MTlTZWVkKGRlcml2ZWRLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleXBhaXIucHVibGljS2V5KCksXG4gICAgICBkZXJpdmF0aW9uUGF0aCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIHN0ZWxsYXItc2RrIGhhcyB0d28gb3ZlcmxvYWRzIGZvciB0b1hEUiwgYW5kIHR5cGVzY3JpcHQgY2FuJ3Qgc2VlbSB0byBmaWd1cmUgb3V0IHRoZVxuICAgKiBjb3JyZWN0IG9uZSB0byB1c2UsIHNvIHdlIGhhdmUgdG8gYmUgdmVyeSBleHBsaWNpdCBhcyB0byB3aGljaCBvbmUgd2Ugd2FudC5cbiAgICogQHBhcmFtIHR4IHRyYW5zYWN0aW9uIHRvIGNvbnZlcnRcbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgdHhUb1N0cmluZyA9ICh0eDogc3RlbGxhci5UcmFuc2FjdGlvbik6IHN0cmluZyA9PiAodHgudG9FbnZlbG9wZSgpLnRvWERSIGFzICgoXzogc3RyaW5nKSA9PiBzdHJpbmcpKSgnYmFzZTY0Jyk7XG5cbiAgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19