"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ofc_1 = require("./ofc");
var lodash_1 = require("lodash");
var publicIdRegex = /^[a-f\d]{32}$/i;
var OfcToken = /** @class */ (function (_super) {
    __extends(OfcToken, _super);
    function OfcToken(bitgo, tokenConfig) {
        var _this = _super.call(this, bitgo) || this;
        _this.tokenConfig = tokenConfig;
        return _this;
    }
    Object.defineProperty(OfcToken.prototype, "coin", {
        get: function () {
            return this.tokenConfig.coin;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfcToken.prototype, "decimalPlaces", {
        get: function () {
            return this.tokenConfig.decimalPlaces;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfcToken.prototype, "name", {
        get: function () {
            return this.tokenConfig.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfcToken.prototype, "backingCoin", {
        get: function () {
            return this.tokenConfig.backingCoin;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfcToken.prototype, "isFiat", {
        get: function () {
            return this.tokenConfig.isFiat;
        },
        enumerable: true,
        configurable: true
    });
    OfcToken.prototype.getChain = function () {
        return this.type;
    };
    OfcToken.prototype.getFullName = function () {
        return this.name;
    };
    OfcToken.prototype.getBaseFactor = function () {
        return String(Math.pow(10, this.decimalPlaces));
    };
    Object.defineProperty(OfcToken.prototype, "type", {
        get: function () {
            return this.tokenConfig.type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    OfcToken.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    OfcToken.createTokenConstructor = function (config) {
        return function (bitgo) { return new OfcToken(bitgo, config); };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     */
    OfcToken.prototype.signTransaction = function (params) {
        var txPrebuild = params.txPrebuild;
        var payload = txPrebuild.payload;
        var signatureBuffer = this.signMessage(params, payload);
        var signature = signatureBuffer.toString('hex');
        return { halfSigned: { payload: payload, signature: signature } };
    };
    /**
     * Check if an address is valid for this ofc token.
     *
     * These addresses are either bg-<publicid>, where public id is the internal address to send to,
     * or are an address which is valid on the backing coin of this ofc token.
     * @param address address to check for validity
     */
    OfcToken.prototype.isValidAddress = function (address) {
        if (!lodash_1.isString(address)) {
            return false;
        }
        if (address.startsWith('bg-')) {
            var parts = address.split('-');
            var accountId = parts[1];
            return parts.length === 2 && publicIdRegex.test(accountId);
        }
        else {
            var backingCoin = this.bitgo.coin(this.backingCoin);
            return backingCoin.isValidAddress(address);
        }
    };
    return OfcToken;
}(ofc_1.Ofc));
exports.OfcToken = OfcToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjVG9rZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvY29pbnMvb2ZjVG9rZW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsNkJBQTRCO0FBQzVCLGlDQUFrQztBQW1CbEMsSUFBTSxhQUFhLEdBQUcsZ0JBQWdCLENBQUM7QUFDdkM7SUFBOEIsNEJBQUc7SUFHL0Isa0JBQVksS0FBWSxFQUFFLFdBQTJCO1FBQXJELFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBRWI7UUFEQyxLQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzs7SUFDakMsQ0FBQztJQUVELHNCQUFJLDBCQUFJO2FBQVI7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1FBQy9CLENBQUM7OztPQUFBO0lBRUQsc0JBQUksbUNBQWE7YUFBakI7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDO1FBQ3hDLENBQUM7OztPQUFBO0lBRUQsc0JBQUksMEJBQUk7YUFBUjtZQUNFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7UUFDL0IsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxpQ0FBVzthQUFmO1lBQ0UsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQztRQUN0QyxDQUFDOzs7T0FBQTtJQUVELHNCQUFJLDRCQUFNO2FBQVY7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDO1FBQ2pDLENBQUM7OztPQUFBO0lBRUQsMkJBQVEsR0FBUjtRQUNFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQsOEJBQVcsR0FBWDtRQUNFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQsZ0NBQWEsR0FBYjtRQUNFLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRCxzQkFBVywwQkFBSTthQUFmO1lBQ0UsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztRQUMvQixDQUFDOzs7T0FBQTtJQUVEOzs7T0FHRztJQUNILDJDQUF3QixHQUF4QjtRQUNFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVNLCtCQUFzQixHQUE3QixVQUE4QixNQUFzQjtRQUNsRCxPQUFPLFVBQUMsS0FBWSxJQUFLLE9BQUEsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUEzQixDQUEyQixDQUFDO0lBQ3ZELENBQUM7SUFFRDs7O09BR0c7SUFDSCxrQ0FBZSxHQUFmLFVBQWdCLE1BQThCO1FBQzVDLElBQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7UUFDckMsSUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQztRQUNuQyxJQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMxRCxJQUFNLFNBQVMsR0FBVyxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFELE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxPQUFPLFNBQUEsRUFBRSxTQUFTLFdBQUEsRUFBRSxFQUFFLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGlDQUFjLEdBQWQsVUFBZSxPQUFnQjtRQUM3QixJQUFJLENBQUMsaUJBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN0QixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzdCLElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakMsSUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNCLE9BQU8sS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUM1RDthQUFNO1lBQ0wsSUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sV0FBVyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUM1QztJQUNILENBQUM7SUFDSCxlQUFDO0FBQUQsQ0FBQyxBQXhGRCxDQUE4QixTQUFHLEdBd0ZoQztBQXhGWSw0QkFBUSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgQ29pbkNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vY29pbkZhY3RvcnknO1xuaW1wb3J0IHsgT2ZjIH0gZnJvbSAnLi9vZmMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB9IGZyb20gJy4uL2Jhc2VDb2luJztcblxuZXhwb3J0IGludGVyZmFjZSBPZmNUb2tlbkNvbmZpZyB7XG4gIHR5cGU6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBkZWNpbWFsUGxhY2VzOiBudW1iZXI7XG4gIG5hbWU6IHN0cmluZztcbiAgYmFja2luZ0NvaW46IHN0cmluZztcbiAgaXNGaWF0OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IHtcbiAgICBwYXlsb2FkOiBzdHJpbmc7XG4gIH07XG4gIHBydjogc3RyaW5nO1xufVxuXG5jb25zdCBwdWJsaWNJZFJlZ2V4ID0gL15bYS1mXFxkXXszMn0kL2k7XG5leHBvcnQgY2xhc3MgT2ZjVG9rZW4gZXh0ZW5kcyBPZmMge1xuICBwdWJsaWMgcmVhZG9ubHkgdG9rZW5Db25maWc6IE9mY1Rva2VuQ29uZmlnO1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgdG9rZW5Db25maWc6IE9mY1Rva2VuQ29uZmlnKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICAgIHRoaXMudG9rZW5Db25maWcgPSB0b2tlbkNvbmZpZztcbiAgfVxuXG4gIGdldCBjb2luKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLmNvaW47XG4gIH1cblxuICBnZXQgZGVjaW1hbFBsYWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5kZWNpbWFsUGxhY2VzO1xuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcubmFtZTtcbiAgfVxuXG4gIGdldCBiYWNraW5nQ29pbigpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5iYWNraW5nQ29pbjtcbiAgfVxuXG4gIGdldCBpc0ZpYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcuaXNGaWF0O1xuICB9XG5cbiAgZ2V0Q2hhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiBTdHJpbmcoTWF0aC5wb3coMTAsIHRoaXMuZGVjaW1hbFBsYWNlcykpO1xuICB9XG5cbiAgcHVibGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlVG9rZW5Db25zdHJ1Y3Rvcihjb25maWc6IE9mY1Rva2VuQ29uZmlnKTogQ29pbkNvbnN0cnVjdG9yIHtcbiAgICByZXR1cm4gKGJpdGdvOiBCaXRHbykgPT4gbmV3IE9mY1Rva2VuKGJpdGdvLCBjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucykge1xuICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcbiAgICBjb25zdCBwYXlsb2FkID0gdHhQcmVidWlsZC5wYXlsb2FkO1xuICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IHRoaXMuc2lnbk1lc3NhZ2UocGFyYW1zLCBwYXlsb2FkKTtcbiAgICBjb25zdCBzaWduYXR1cmU6IHN0cmluZyA9IHNpZ25hdHVyZUJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG4gICAgcmV0dXJuIHsgaGFsZlNpZ25lZDogeyBwYXlsb2FkLCBzaWduYXR1cmUgfSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGFkZHJlc3MgaXMgdmFsaWQgZm9yIHRoaXMgb2ZjIHRva2VuLlxuICAgKlxuICAgKiBUaGVzZSBhZGRyZXNzZXMgYXJlIGVpdGhlciBiZy08cHVibGljaWQ+LCB3aGVyZSBwdWJsaWMgaWQgaXMgdGhlIGludGVybmFsIGFkZHJlc3MgdG8gc2VuZCB0byxcbiAgICogb3IgYXJlIGFuIGFkZHJlc3Mgd2hpY2ggaXMgdmFsaWQgb24gdGhlIGJhY2tpbmcgY29pbiBvZiB0aGlzIG9mYyB0b2tlbi5cbiAgICogQHBhcmFtIGFkZHJlc3MgYWRkcmVzcyB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M/OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWlzU3RyaW5nKGFkZHJlc3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgoJ2JnLScpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy0nKTtcbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IHBhcnRzWzFdO1xuICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMiAmJiBwdWJsaWNJZFJlZ2V4LnRlc3QoYWNjb3VudElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFja2luZ0NvaW4gPSB0aGlzLmJpdGdvLmNvaW4odGhpcy5iYWNraW5nQ29pbik7XG4gICAgICByZXR1cm4gYmFja2luZ0NvaW4uaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICB9XG59XG4iXX0=