"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var bitgo_utxo_lib_1 = require("bitgo-utxo-lib");
var Bluebird = require("bluebird");
var crypto = require("crypto");
var _ = require("lodash");
var url = require("url");
var querystring = require("querystring");
var rippleAddressCodec = require("ripple-address-codec");
var rippleBinaryCodec = require("ripple-binary-codec");
var hashes_1 = require("ripple-lib/dist/npm/common/hashes");
var rippleKeypairs = require("ripple-keypairs");
var baseCoin_1 = require("../baseCoin");
var config = require("../../config");
var errors_1 = require("../../errors");
var ripple = require('../../ripple');
var sjcl = require('../../vendor/sjcl.min.js');
var co = Bluebird.coroutine;
var Xrp = /** @class */ (function (_super) {
    __extends(Xrp, _super);
    function Xrp(bitgo) {
        return _super.call(this, bitgo) || this;
    }
    Xrp.createInstance = function (bitgo) {
        return new Xrp(bitgo);
    };
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    Xrp.prototype.getBaseFactor = function () {
        return 1e6;
    };
    /**
     * Identifier for the blockchain which supports this coin
     */
    Xrp.prototype.getChain = function () {
        return 'xrp';
    };
    /**
     * Identifier for the coin family
     */
    Xrp.prototype.getFamily = function () {
        return 'xrp';
    };
    /**
     * Complete human-readable name of this coin
     */
    Xrp.prototype.getFullName = function () {
        return 'Ripple';
    };
    /**
     * Parse an address string into address and destination tag
     */
    Xrp.prototype.getAddressDetails = function (address) {
        var destinationDetails = url.parse(address);
        var destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !rippleAddressCodec.isValidClassicAddress(destinationAddress)) {
            throw new errors_1.InvalidAddressError("destination address \"" + destinationAddress + "\" is not valid");
        }
        // there are no other properties like destination tags
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                destinationTag: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new errors_1.InvalidAddressError('no query params present');
        }
        var queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.dt) {
            // if there are more properties, the query details need to contain the destination tag property.
            throw new errors_1.InvalidAddressError('destination tag missing');
        }
        if (Array.isArray(queryDetails.dt)) {
            // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
            throw new errors_1.InvalidAddressError("destination tag can appear at most once, but " + queryDetails.dt.length + " destination tags were found");
        }
        var parsedTag = parseInt(queryDetails.dt, 10);
        if (!Number.isSafeInteger(parsedTag)) {
            throw new errors_1.InvalidAddressError('invalid destination tag');
        }
        if (parsedTag > 0xFFFFFFFF || parsedTag < 0) {
            throw new errors_1.InvalidAddressError('destination tag out of range');
        }
        return {
            address: destinationAddress,
            destinationTag: parsedTag,
        };
    };
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    Xrp.prototype.normalizeAddress = function (_a) {
        var address = _a.address, destinationTag = _a.destinationTag;
        if (!_.isString(address)) {
            throw new errors_1.InvalidAddressError('invalid address details');
        }
        if (_.isInteger(destinationTag)) {
            return address + "?dt=" + destinationTag;
        }
        return address;
    };
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    Xrp.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Xrp.prototype.isValidPub = function (pub) {
        try {
            bitgo_utxo_lib_1.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Get fee info from server
     */
    Xrp.prototype.getFeeInfo = function (_, callback) {
        return this.bitgo.get(this.url('/public/feeinfo'))
            .result()
            .nodeify(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    Xrp.prototype.signTransaction = function (_a) {
        var txPrebuild = _a.txPrebuild, prv = _a.prv;
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
            }
            throw new Error('missing txPrebuild parameter');
        }
        if (_.isUndefined(prv) || !_.isString(prv)) {
            if (!_.isUndefined(prv) && !_.isString(prv)) {
                throw new Error("prv must be a string, got type " + typeof prv);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        var userKey = bitgo_utxo_lib_1.HDNode.fromBase58(prv).getKey();
        var userPrivateKey = userKey.getPrivateKeyBuffer();
        var userAddress = rippleKeypairs.deriveAddress(userKey.getPublicKeyBuffer().toString('hex'));
        var rippleLib = ripple();
        var halfSigned = rippleLib.signWithPrivateKey(txPrebuild.txHex, userPrivateKey.toString('hex'), { signAs: userAddress });
        return { halfSigned: { txHex: halfSigned.signedTransaction } };
    };
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     * @param keychains
     */
    Xrp.prototype.supplementGenerateWallet = function (walletParams, keychains) {
        return co(function () {
            var userKeychain, backupKeychain, bitgoKeychain, userKey, userAddress, backupKey, backupAddress, bitgoKey, bitgoAddress, keyPair, rootPrivateKey, privateKey, publicKey, rootAddress, self, rippleLib, feeInfo, openLedgerFee, medianFee, fee, multisigAssignmentTx, signedMultisigAssignmentTx, destinationTagTx, signedDestinationTagTx, masterDeactivationTx, signedMasterDeactivationTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userKeychain = keychains.userKeychain, backupKeychain = keychains.backupKeychain, bitgoKeychain = keychains.bitgoKeychain;
                        userKey = bitgo_utxo_lib_1.HDNode.fromBase58(userKeychain.pub).getKey();
                        userAddress = rippleKeypairs.deriveAddress(userKey.getPublicKeyBuffer().toString('hex'));
                        backupKey = bitgo_utxo_lib_1.HDNode.fromBase58(backupKeychain.pub).getKey();
                        backupAddress = rippleKeypairs.deriveAddress(backupKey.getPublicKeyBuffer().toString('hex'));
                        bitgoKey = bitgo_utxo_lib_1.HDNode.fromBase58(bitgoKeychain.pub).getKey();
                        bitgoAddress = rippleKeypairs.deriveAddress(bitgoKey.getPublicKeyBuffer().toString('hex'));
                        keyPair = bitgo_utxo_lib_1.ECPair.makeRandom();
                        if (walletParams.rootPrivateKey) {
                            rootPrivateKey = walletParams.rootPrivateKey;
                            if (typeof rootPrivateKey !== 'string' || rootPrivateKey.length !== 64) {
                                throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
                            }
                            keyPair = bitgo_utxo_lib_1.ECPair.fromPrivateKeyBuffer(Buffer.from(walletParams.rootPrivateKey, 'hex'));
                        }
                        privateKey = keyPair.getPrivateKeyBuffer();
                        publicKey = keyPair.getPublicKeyBuffer();
                        rootAddress = rippleKeypairs.deriveAddress(publicKey.toString('hex'));
                        self = this;
                        rippleLib = ripple();
                        return [4 /*yield*/, self.getFeeInfo()];
                    case 1:
                        feeInfo = _a.sent();
                        openLedgerFee = new bignumber_js_1.BigNumber(feeInfo.xrpOpenLedgerFee);
                        medianFee = new bignumber_js_1.BigNumber(feeInfo.xrpMedianFee);
                        fee = bignumber_js_1.BigNumber.max(openLedgerFee, medianFee).times(1.5).toFixed(0);
                        multisigAssignmentTx = {
                            TransactionType: 'SignerListSet',
                            Account: rootAddress,
                            SignerQuorum: 2,
                            SignerEntries: [
                                {
                                    SignerEntry: {
                                        Account: userAddress,
                                        SignerWeight: 1
                                    }
                                },
                                {
                                    SignerEntry: {
                                        Account: backupAddress,
                                        SignerWeight: 1
                                    }
                                },
                                {
                                    SignerEntry: {
                                        Account: bitgoAddress,
                                        SignerWeight: 1
                                    }
                                }
                            ],
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 1
                        };
                        signedMultisigAssignmentTx = rippleLib.signWithPrivateKey(JSON.stringify(multisigAssignmentTx), privateKey.toString('hex'));
                        destinationTagTx = {
                            TransactionType: 'AccountSet',
                            Account: rootAddress,
                            SetFlag: 1,
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 2
                        };
                        signedDestinationTagTx = rippleLib.signWithPrivateKey(JSON.stringify(destinationTagTx), privateKey.toString('hex'));
                        masterDeactivationTx = {
                            TransactionType: 'AccountSet',
                            Account: rootAddress,
                            SetFlag: 4,
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 3
                        };
                        signedMasterDeactivationTx = rippleLib.signWithPrivateKey(JSON.stringify(masterDeactivationTx), privateKey.toString('hex'));
                        // extend the wallet initialization params
                        walletParams.rootPub = publicKey.toString('hex');
                        walletParams.initializationTxs = {
                            setMultisig: signedMultisigAssignmentTx.signedTransaction,
                            disableMasterKey: signedMasterDeactivationTx.signedTransaction,
                            forceDestinationTag: signedDestinationTagTx.signedTransaction
                        };
                        return [2 /*return*/, walletParams];
                }
            });
        }).call(this);
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Xrp.prototype.explainTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        return co(function () {
            var transaction, txHex, id, address;
            return __generator(this, function (_a) {
                if (!params.txHex) {
                    throw new Error('missing required param txHex');
                }
                try {
                    transaction = rippleBinaryCodec.decode(params.txHex);
                    txHex = params.txHex;
                }
                catch (e) {
                    try {
                        transaction = JSON.parse(params.txHex);
                        txHex = rippleBinaryCodec.encode(transaction);
                    }
                    catch (e) {
                        throw new Error('txHex needs to be either hex or JSON string for XRP');
                    }
                }
                id = hashes_1.computeBinaryTransactionHash(txHex);
                address = transaction.Destination + ((transaction.DestinationTag >= 0) ? '?dt=' + transaction.DestinationTag : '');
                return [2 /*return*/, {
                        displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'],
                        id: id,
                        changeOutputs: [],
                        outputAmount: transaction.Amount,
                        changeAmount: 0,
                        outputs: [
                            {
                                address: address,
                                amount: transaction.Amount
                            }
                        ],
                        fee: {
                            fee: transaction.Fee,
                            feeRate: null,
                            size: txHex.length / 2
                        }
                    }];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @param callback
     * @returns {boolean}
     */
    Xrp.prototype.verifyTransaction = function (_a, callback) {
        var txParams = _a.txParams, txPrebuild = _a.txPrebuild;
        var self = this;
        return co(function () {
            var explanation, output, expectedOutput, comparator;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.explainTransaction({
                            txHex: txPrebuild.txHex
                        })];
                    case 1:
                        explanation = _a.sent();
                        output = explanation.outputs.concat(explanation.changeOutputs)[0];
                        expectedOutput = txParams.recipients && txParams.recipients[0];
                        comparator = function (recipient1, recipient2) {
                            if (recipient1.address !== recipient2.address) {
                                return false;
                            }
                            var amount1 = new bignumber_js_1.BigNumber(recipient1.amount);
                            var amount2 = new bignumber_js_1.BigNumber(recipient2.amount);
                            return amount1.toFixed() === amount2.toFixed();
                        };
                        if (!comparator(output, expectedOutput)) {
                            throw new Error('transaction prebuild does not match expected output');
                        }
                        return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    Xrp.prototype.verifyAddress = function (_a) {
        var address = _a.address, rootAddress = _a.rootAddress;
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("address verification failure: address \"" + address + "\" is not valid");
        }
        var addressDetails = this.getAddressDetails(address);
        var rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError("address validation failure: " + addressDetails.address + " vs. " + rootAddressDetails.address);
        }
        return true;
    };
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    Xrp.prototype.getRippledUrl = function () {
        return 'https://s1.ripple.com:51234';
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    Xrp.prototype.recover = function (params, callback) {
        var self = this;
        return co(function explainTransaction() {
            var rippledUrl, isKrsRecovery, isUnsignedSweep, accountInfoParams, _a, keys, addressDetails, feeDetails, serverDetails, openLedgerFee, baseReserve, reserveDelta, currentLedger, sequenceId, balance, signerLists, accountFlags, userAddress, backupAddress, signerList, foundAddresses, signerEntries, _i, signerEntries_1, SignerEntry, weight, address, USER_KEY_SETTING_FLAG, MASTER_KEY_DEACTIVATION_FLAG, REQUIRE_DESTINATION_TAG_FLAG, reserve, recoverableBalance, rawDestination, destinationDetails, destinationAddress, destinationTag, queryDetails, parsedTag, transaction, txJSON, rippleLib, userKey, userSignature, signedTransaction, backupKey, backupSignature, transactionExplanation;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        rippledUrl = self.getRippledUrl();
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        accountInfoParams = {
                            method: 'account_info',
                            params: [{
                                    account: params.rootAddress,
                                    strict: true,
                                    ledger_index: 'current',
                                    queue: true,
                                    signer_lists: true,
                                }],
                        };
                        return [4 /*yield*/, Bluebird.props({
                                keys: self.initiateRecovery(params),
                                addressDetails: self.bitgo.post(rippledUrl).send(accountInfoParams),
                                feeDetails: self.bitgo.post(rippledUrl).send({ method: 'fee' }),
                                serverDetails: self.bitgo.post(rippledUrl).send({ method: 'server_info' }),
                            })];
                    case 1:
                        _a = _b.sent(), keys = _a.keys, addressDetails = _a.addressDetails, feeDetails = _a.feeDetails, serverDetails = _a.serverDetails;
                        openLedgerFee = new bignumber_js_1.BigNumber(feeDetails.body.result.drops.open_ledger_fee);
                        baseReserve = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_base_xrp).times(self.getBaseFactor());
                        reserveDelta = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_inc_xrp).times(self.getBaseFactor());
                        currentLedger = serverDetails.body.result.info.validated_ledger.seq;
                        sequenceId = addressDetails.body.result.account_data.Sequence;
                        balance = new bignumber_js_1.BigNumber(addressDetails.body.result.account_data.Balance);
                        signerLists = addressDetails.body.result.account_data.signer_lists;
                        accountFlags = addressDetails.body.result.account_data.Flags;
                        // make sure there is only one signer list set
                        if (signerLists.length !== 1) {
                            throw new Error('unexpected set of signer lists');
                        }
                        userAddress = rippleKeypairs.deriveAddress(keys[0].getPublicKeyBuffer().toString('hex'));
                        backupAddress = rippleKeypairs.deriveAddress(keys[1].getPublicKeyBuffer().toString('hex'));
                        signerList = signerLists[0];
                        if (signerList.SignerQuorum !== 2) {
                            throw new Error('invalid minimum signature count');
                        }
                        foundAddresses = {};
                        signerEntries = signerList.SignerEntries;
                        if (signerEntries.length !== 3) {
                            throw new Error('invalid signer list length');
                        }
                        for (_i = 0, signerEntries_1 = signerEntries; _i < signerEntries_1.length; _i++) {
                            SignerEntry = signerEntries_1[_i].SignerEntry;
                            weight = SignerEntry.SignerWeight;
                            address = SignerEntry.Account;
                            if (weight !== 1) {
                                throw new Error('invalid signer weight');
                            }
                            // if it's a dupe of an address we already know, block
                            if (foundAddresses[address] >= 1) {
                                throw new Error('duplicate signer address');
                            }
                            foundAddresses[address] = (foundAddresses[address] || 0) + 1;
                        }
                        if (foundAddresses[userAddress] !== 1) {
                            throw new Error('unexpected incidence frequency of user signer address');
                        }
                        if (foundAddresses[backupAddress] !== 1) {
                            throw new Error('unexpected incidence frequency of user signer address');
                        }
                        USER_KEY_SETTING_FLAG = 65536;
                        MASTER_KEY_DEACTIVATION_FLAG = 1048576;
                        REQUIRE_DESTINATION_TAG_FLAG = 131072;
                        if ((accountFlags & USER_KEY_SETTING_FLAG) !== 0) {
                            throw new Error('a custom user key has been set');
                        }
                        if ((accountFlags & MASTER_KEY_DEACTIVATION_FLAG) !== MASTER_KEY_DEACTIVATION_FLAG) {
                            throw new Error('the master key has not been deactivated');
                        }
                        if ((accountFlags & REQUIRE_DESTINATION_TAG_FLAG) !== REQUIRE_DESTINATION_TAG_FLAG) {
                            throw new Error('the destination flag requirement has not been activated');
                        }
                        reserve = baseReserve.plus(reserveDelta.times(5));
                        recoverableBalance = balance.minus(reserve);
                        rawDestination = params.recoveryDestination;
                        destinationDetails = url.parse(rawDestination);
                        destinationAddress = destinationDetails.pathname;
                        if (destinationDetails.query) {
                            queryDetails = querystring.parse(destinationDetails.query);
                            if (Array.isArray(queryDetails.dt)) {
                                // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
                                throw new errors_1.InvalidAddressError("destination tag can appear at most once, but " + queryDetails.dt.length + " destination tags were found");
                            }
                            parsedTag = parseInt(queryDetails.dt, 10);
                            if (Number.isInteger(parsedTag)) {
                                destinationTag = parsedTag;
                            }
                        }
                        transaction = {
                            TransactionType: 'Payment',
                            Account: params.rootAddress,
                            Destination: destinationAddress,
                            DestinationTag: destinationTag,
                            Amount: recoverableBalance.toFixed(0),
                            Flags: 2147483648,
                            LastLedgerSequence: currentLedger + 1000000,
                            Fee: openLedgerFee.times(3).toFixed(0),
                            Sequence: sequenceId,
                        };
                        txJSON = JSON.stringify(transaction);
                        if (isUnsignedSweep) {
                            return [2 /*return*/, txJSON];
                        }
                        rippleLib = ripple();
                        userKey = keys[0].getKey().getPrivateKeyBuffer().toString('hex');
                        userSignature = rippleLib.signWithPrivateKey(txJSON, userKey, { signAs: userAddress });
                        if (isKrsRecovery) {
                            signedTransaction = userSignature;
                        }
                        else {
                            backupKey = keys[1].getKey().getPrivateKeyBuffer().toString('hex');
                            backupSignature = rippleLib.signWithPrivateKey(txJSON, backupKey, { signAs: backupAddress });
                            signedTransaction = rippleLib.combine([userSignature.signedTransaction, backupSignature.signedTransaction]);
                        }
                        return [4 /*yield*/, self.explainTransaction({
                                txHex: signedTransaction.signedTransaction,
                            })];
                    case 2:
                        transactionExplanation = _b.sent();
                        transactionExplanation.txHex = signedTransaction.signedTransaction;
                        if (isKrsRecovery) {
                            transactionExplanation.backupKey = params.backupKey;
                            transactionExplanation.coin = self.getChain();
                        }
                        return [2 /*return*/, transactionExplanation];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Prepare and validate all keychains from the keycard for recovery
     */
    Xrp.prototype.initiateRecovery = function (params) {
        var self = this;
        return co(function initiateRecovery() {
            var keys, userKey, backupKey, bitgoXpub, destinationAddress, passphrase, isKrsRecovery, isUnsignedSweep, validatePassphraseKey, key, backupHDNode, bitgoHDNode;
            return __generator(this, function (_a) {
                keys = [];
                userKey = params.userKey;
                backupKey = params.backupKey;
                bitgoXpub = params.bitgoKey;
                destinationAddress = params.recoveryDestination;
                passphrase = params.walletPassphrase;
                isKrsRecovery = backupKey.startsWith('xpub') && !userKey.startsWith('xpub');
                isUnsignedSweep = backupKey.startsWith('xpub') && userKey.startsWith('xpub');
                if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                    throw new Error('unknown key recovery service provider');
                }
                validatePassphraseKey = function (userKey, passphrase) {
                    try {
                        if (!userKey.startsWith('xprv') && !isUnsignedSweep) {
                            userKey = sjcl.decrypt(passphrase, userKey);
                        }
                        return bitgo_utxo_lib_1.HDNode.fromBase58(userKey);
                    }
                    catch (e) {
                        throw new Error('Failed to decrypt user key with passcode - try again!');
                    }
                };
                key = validatePassphraseKey(userKey, passphrase);
                keys.push(key);
                // Validate the backup key
                try {
                    if (!backupKey.startsWith('xprv') && !isKrsRecovery && !isUnsignedSweep) {
                        backupKey = sjcl.decrypt(passphrase, backupKey);
                    }
                    backupHDNode = bitgo_utxo_lib_1.HDNode.fromBase58(backupKey);
                    keys.push(backupHDNode);
                }
                catch (e) {
                    throw new Error('Failed to decrypt backup key with passcode - try again!');
                }
                try {
                    bitgoHDNode = bitgo_utxo_lib_1.HDNode.fromBase58(bitgoXpub);
                    keys.push(bitgoHDNode);
                }
                catch (e) {
                    if (self.getFamily() !== 'xrp') {
                        // in XRP recoveries, the BitGo xpub is optional
                        throw new Error('Failed to parse bitgo xpub!');
                    }
                }
                // Validate the destination address
                if (!self.isValidAddress(destinationAddress)) {
                    throw new Error('Invalid destination address!');
                }
                return [2 /*return*/, keys];
            });
        }).call(this);
    };
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    Xrp.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = bitgo_utxo_lib_1.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    Xrp.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    return Xrp;
}(baseCoin_1.BaseCoin));
exports.Xrp = Xrp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHJwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3hycC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2Q0FBeUM7QUFDekMsaURBQWdEO0FBQ2hELG1DQUFxQztBQUNyQywrQkFBaUM7QUFDakMsMEJBQTRCO0FBQzVCLHlCQUEyQjtBQUMzQix5Q0FBMkM7QUFHM0MseURBQTJEO0FBQzNELHVEQUF5RDtBQUN6RCw0REFBaUY7QUFDakYsZ0RBQWtEO0FBRWxELHdDQVVxQjtBQUNyQixxQ0FBdUM7QUFFdkMsdUNBQTJFO0FBRTNFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN2QyxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUVqRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBcUQ5QjtJQUF5Qix1QkFBUTtJQUMvQixhQUFzQixLQUFZO2VBQ2hDLGtCQUFNLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksMkJBQWEsR0FBcEI7UUFDRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNJLHNCQUFRLEdBQWY7UUFDRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLHVCQUFTLEdBQWhCO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSSx5QkFBVyxHQUFsQjtRQUNFLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNJLCtCQUFpQixHQUF4QixVQUF5QixPQUFlO1FBQ3RDLElB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QUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNwQztRQUNELElBQU0sV0FBVyxHQUFHLHVCQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hELElBQU0sSUFBSSxHQUFHLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMvQyxPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUk7WUFDVCxHQUFHLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRTtTQUM1QixDQUFDO0lBQ0osQ0FBQztJQUVELDhCQUFnQixHQUFoQixVQUFpQixNQUErQixFQUFFLFFBQTBDO1FBQzFGLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUNILFVBQUM7QUFBRCxDQUFDLEFBem5CRCxDQUF5QixtQkFBUSxHQXluQmhDO0FBem5CWSxrQkFBRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBIRE5vZGUsIEVDUGFpciB9IGZyb20gJ2JpdGdvLXV0eG8tbGliJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcblxuaW1wb3J0ICogYXMgcmlwcGxlQWRkcmVzc0NvZGVjIGZyb20gJ3JpcHBsZS1hZGRyZXNzLWNvZGVjJztcbmltcG9ydCAqIGFzIHJpcHBsZUJpbmFyeUNvZGVjIGZyb20gJ3JpcHBsZS1iaW5hcnktY29kZWMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uSGFzaCB9IGZyb20gJ3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL2hhc2hlcyc7XG5pbXBvcnQgKiBhcyByaXBwbGVLZXlwYWlycyBmcm9tICdyaXBwbGUta2V5cGFpcnMnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgS2V5UGFpcixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMgYXMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMgYXMgQmFzZUluaXRpYXRlUmVjb3ZlcnlPcHRpb25zLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEludmFsaWRBZGRyZXNzRXJyb3IsIFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5jb25zdCByaXBwbGUgPSByZXF1aXJlKCcuLi8uLi9yaXBwbGUnKTtcbmNvbnN0IHNqY2wgPSByZXF1aXJlKCcuLi8uLi92ZW5kb3Ivc2pjbC5taW4uanMnKTtcblxuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbmludGVyZmFjZSBBZGRyZXNzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBkZXN0aW5hdGlvblRhZz86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEZlZUluZm8ge1xuICBkYXRlOiBzdHJpbmc7XG4gIGhlaWdodDogbnVtYmVyO1xuICBiYXNlUmVzZXJ2ZTogc3RyaW5nO1xuICBiYXNlRmVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBWZXJpZnlBZGRyZXNzT3B0aW9ucyBleHRlbmRzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyB7XG4gIHJvb3RBZGRyZXNzOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZWNvdmVyeUluZm8gZXh0ZW5kcyBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgYmFja3VwS2V5Pzogc3RyaW5nO1xuICBjb2luPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIGV4dGVuZHMgQmFzZUluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIHtcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlPcHRpb25zIHtcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBiaXRnb0tleT86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEhhbGZTaWduZWRUcmFuc2FjdGlvbiB7XG4gIGhhbGZTaWduZWQ6IHtcbiAgICB0eEhleDogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFhycCBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbykge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBYcnAoYml0Z28pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvciBiZXR3ZWVuIHRoZSBjb2luJ3MgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKi9cbiAgcHVibGljIGdldEJhc2VGYWN0b3IoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gMWU2O1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIHdoaWNoIHN1cHBvcnRzIHRoaXMgY29pblxuICAgKi9cbiAgcHVibGljIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd4cnAnO1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBjb2luIGZhbWlseVxuICAgKi9cbiAgcHVibGljIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAneHJwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoaXMgY29pblxuICAgKi9cbiAgcHVibGljIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdSaXBwbGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGFkZHJlc3Mgc3RyaW5nIGludG8gYWRkcmVzcyBhbmQgZGVzdGluYXRpb24gdGFnXG4gICAqL1xuICBwdWJsaWMgZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzczogc3RyaW5nKTogQWRkcmVzcyB7XG4gICAgY29uc3QgZGVzdGluYXRpb25EZXRhaWxzID0gdXJsLnBhcnNlKGFkZHJlc3MpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQWRkcmVzcyA9IGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZTtcbiAgICBpZiAoIWRlc3RpbmF0aW9uQWRkcmVzcyB8fCAhcmlwcGxlQWRkcmVzc0NvZGVjLmlzVmFsaWRDbGFzc2ljQWRkcmVzcyhkZXN0aW5hdGlvbkFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgZGVzdGluYXRpb24gYWRkcmVzcyBcIiR7ZGVzdGluYXRpb25BZGRyZXNzfVwiIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cbiAgICAvLyB0aGVyZSBhcmUgbm8gb3RoZXIgcHJvcGVydGllcyBsaWtlIGRlc3RpbmF0aW9uIHRhZ3NcbiAgICBpZiAoZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lID09PSBhZGRyZXNzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBkZXN0aW5hdGlvblRhZzogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ25vIHF1ZXJ5IHBhcmFtcyBwcmVzZW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlEZXRhaWxzID0gcXVlcnlzdHJpbmcucGFyc2UoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5RGV0YWlscy5kdCkge1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllcywgdGhlIHF1ZXJ5IGRldGFpbHMgbmVlZCB0byBjb250YWluIHRoZSBkZXN0aW5hdGlvbiB0YWcgcHJvcGVydHkuXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignZGVzdGluYXRpb24gdGFnIG1pc3NpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMuZHQpKSB7XG4gICAgICAvLyBpZiBxdWVyeURldGFpbHMuZHQgaXMgYW4gYXJyYXksIHRoYXQgbWVhbnMgZHQgd2FzIGdpdmVuIG11bHRpcGxlIHRpbWVzLCB3aGljaCBpcyBub3QgdmFsaWRcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBkZXN0aW5hdGlvbiB0YWcgY2FuIGFwcGVhciBhdCBtb3N0IG9uY2UsIGJ1dCAke3F1ZXJ5RGV0YWlscy5kdC5sZW5ndGh9IGRlc3RpbmF0aW9uIHRhZ3Mgd2VyZSBmb3VuZGApO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZFRhZyA9IHBhcnNlSW50KHF1ZXJ5RGV0YWlscy5kdCwgMTApO1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocGFyc2VkVGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2ludmFsaWQgZGVzdGluYXRpb24gdGFnJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlZFRhZyA+IDB4RkZGRkZGRkYgfHwgcGFyc2VkVGFnIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2Rlc3RpbmF0aW9uIHRhZyBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgZGVzdGluYXRpb25UYWc6IHBhcnNlZFRhZyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIGZ1bGwsIG5vcm1hbGl6ZWQgYWRkcmVzcyBmcm9tIGFuIGFkZHJlc3MgYW5kIGRlc3RpbmF0aW9uIHRhZ1xuICAgKi9cbiAgcHVibGljIG5vcm1hbGl6ZUFkZHJlc3MoeyBhZGRyZXNzLCBkZXN0aW5hdGlvblRhZyB9OiBBZGRyZXNzKTogc3RyaW5nIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdpbnZhbGlkIGFkZHJlc3MgZGV0YWlscycpO1xuICAgIH1cbiAgICBpZiAoXy5pc0ludGVnZXIoZGVzdGluYXRpb25UYWcpKSB7XG4gICAgICByZXR1cm4gYCR7YWRkcmVzc30/ZHQ9JHtkZXN0aW5hdGlvblRhZ31gO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciBhbiBhZGRyZXNzIHN0cmluZyBpcyB2YWxpZCBmb3IgdGhpcyBjb2luXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBwdWJsaWMgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICAgIHJldHVybiBhZGRyZXNzID09PSB0aGlzLm5vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzc0RldGFpbHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBwdWJsaWMgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBIRE5vZGUuZnJvbUJhc2U1OChwdWIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmVlIGluZm8gZnJvbSBzZXJ2ZXJcbiAgICovXG4gIHB1YmxpYyBnZXRGZWVJbmZvKF8/LCBjYWxsYmFjaz8pOiBQcm9taXNlPEZlZUluZm8+IHtcbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy9wdWJsaWMvZmVlaW5mbycpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIHBydlxuICAgKiBAcmV0dXJucyB7e3R4SGV4fX1cbiAgICovXG4gIHB1YmxpYyBzaWduVHJhbnNhY3Rpb24oeyB0eFByZWJ1aWxkLCBwcnYgfTogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IEhhbGZTaWduZWRUcmFuc2FjdGlvbiB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgfHwgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSAmJiAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpIHx8ICFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwcnYpICYmICFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgcHJ2fWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJLZXkgPSBIRE5vZGUuZnJvbUJhc2U1OChwcnYpLmdldEtleSgpO1xuICAgIGNvbnN0IHVzZXJQcml2YXRlS2V5OiBCdWZmZXIgPSB1c2VyS2V5LmdldFByaXZhdGVLZXlCdWZmZXIoKTtcbiAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHJpcHBsZUtleXBhaXJzLmRlcml2ZUFkZHJlc3ModXNlcktleS5nZXRQdWJsaWNLZXlCdWZmZXIoKS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG4gICAgY29uc3QgaGFsZlNpZ25lZCA9IHJpcHBsZUxpYi5zaWduV2l0aFByaXZhdGVLZXkodHhQcmVidWlsZC50eEhleCwgdXNlclByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpLCB7IHNpZ25BczogdXNlckFkZHJlc3MgfSk7XG4gICAgcmV0dXJuIHsgaGFsZlNpZ25lZDogeyB0eEhleDogaGFsZlNpZ25lZC5zaWduZWRUcmFuc2FjdGlvbiB9IH07XG4gIH1cblxuICAvKipcbiAgICogUmlwcGxlIHJlcXVpcmVzIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3Igd2FsbGV0IGdlbmVyYXRpb24gdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLiBUaGUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGFyZVxuICAgKiB0aGUgcm9vdCBwdWJsaWMga2V5LCB3aGljaCBpcyB0aGUgYmFzaXMgb2YgdGhlIHJvb3QgYWRkcmVzcywgdHdvIHNpZ25lZCwgYW5kIG9uZSBoYWxmLXNpZ25lZCBpbml0aWFsaXphdGlvbiB0eHNcbiAgICogQHBhcmFtIHdhbGxldFBhcmFtc1xuICAgKiAtIHJvb3RQcml2YXRlS2V5OiBvcHRpb25hbCBoZXgtZW5jb2RlZCBSaXBwbGUgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIGtleWNoYWluc1xuICAgKi9cbiAgc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtcywga2V5Y2hhaW5zKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCB7IHVzZXJLZXljaGFpbiwgYmFja3VwS2V5Y2hhaW4sIGJpdGdvS2V5Y2hhaW4gfSA9IGtleWNoYWlucztcblxuICAgICAgY29uc3QgdXNlcktleSA9IEhETm9kZS5mcm9tQmFzZTU4KHVzZXJLZXljaGFpbi5wdWIpLmdldEtleSgpO1xuICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKHVzZXJLZXkuZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgY29uc3QgYmFja3VwS2V5ID0gSEROb2RlLmZyb21CYXNlNTgoYmFja3VwS2V5Y2hhaW4ucHViKS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGJhY2t1cEFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKGJhY2t1cEtleS5nZXRQdWJsaWNLZXlCdWZmZXIoKS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgICBjb25zdCBiaXRnb0tleSA9IEhETm9kZS5mcm9tQmFzZTU4KGJpdGdvS2V5Y2hhaW4ucHViKS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGJpdGdvQWRkcmVzcyA9IHJpcHBsZUtleXBhaXJzLmRlcml2ZUFkZHJlc3MoYml0Z29LZXkuZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgLy8gaW5pdGlhbGx5LCB3ZSBuZWVkIHRvIGdlbmVyYXRlIGEgcmFuZG9tIHJvb3QgYWRkcmVzcyB3aGljaCBoYXMgdG8gYmUgZGlzdGluY3QgZnJvbSBhbGwgdGhyZWUga2V5Y2hhaW5zXG4gICAgICBsZXQga2V5UGFpciA9IEVDUGFpci5tYWtlUmFuZG9tKCk7XG4gICAgICBpZiAod2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5KSB7XG4gICAgICAgIGNvbnN0IHJvb3RQcml2YXRlS2V5ID0gd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5O1xuICAgICAgICBpZiAodHlwZW9mIHJvb3RQcml2YXRlS2V5ICE9PSAnc3RyaW5nJyB8fCByb290UHJpdmF0ZUtleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb290UHJpdmF0ZUtleSBuZWVkcyB0byBiZSBhIGhleGFkZWNpbWFsIHByaXZhdGUga2V5IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGtleVBhaXIgPSBFQ1BhaXIuZnJvbVByaXZhdGVLZXlCdWZmZXIoQnVmZmVyLmZyb20od2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5LCAnaGV4JykpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJpdmF0ZUtleTogQnVmZmVyID0ga2V5UGFpci5nZXRQcml2YXRlS2V5QnVmZmVyKCk7XG4gICAgICBjb25zdCBwdWJsaWNLZXk6IEJ1ZmZlciA9IGtleVBhaXIuZ2V0UHVibGljS2V5QnVmZmVyKCk7XG4gICAgICBjb25zdCByb290QWRkcmVzcyA9IHJpcHBsZUtleXBhaXJzLmRlcml2ZUFkZHJlc3MocHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKSk7XG5cbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG5cbiAgICAgIGNvbnN0IGZlZUluZm8gPSB5aWVsZCBzZWxmLmdldEZlZUluZm8oKTtcbiAgICAgIGNvbnN0IG9wZW5MZWRnZXJGZWUgPSBuZXcgQmlnTnVtYmVyKGZlZUluZm8ueHJwT3BlbkxlZGdlckZlZSk7XG4gICAgICBjb25zdCBtZWRpYW5GZWUgPSBuZXcgQmlnTnVtYmVyKGZlZUluZm8ueHJwTWVkaWFuRmVlKTtcbiAgICAgIGNvbnN0IGZlZSA9IEJpZ051bWJlci5tYXgob3BlbkxlZGdlckZlZSwgbWVkaWFuRmVlKS50aW1lcygxLjUpLnRvRml4ZWQoMCk7XG5cbiAgICAgIC8vIGNvbmZpZ3VyZSBtdWx0aXNpZ25lcnNcbiAgICAgIGNvbnN0IG11bHRpc2lnQXNzaWdubWVudFR4ID0ge1xuICAgICAgICBUcmFuc2FjdGlvblR5cGU6ICdTaWduZXJMaXN0U2V0JyxcbiAgICAgICAgQWNjb3VudDogcm9vdEFkZHJlc3MsXG4gICAgICAgIFNpZ25lclF1b3J1bTogMixcbiAgICAgICAgU2lnbmVyRW50cmllczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFNpZ25lckVudHJ5OiB7XG4gICAgICAgICAgICAgIEFjY291bnQ6IHVzZXJBZGRyZXNzLFxuICAgICAgICAgICAgICBTaWduZXJXZWlnaHQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFNpZ25lckVudHJ5OiB7XG4gICAgICAgICAgICAgIEFjY291bnQ6IGJhY2t1cEFkZHJlc3MsXG4gICAgICAgICAgICAgIFNpZ25lcldlaWdodDogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgU2lnbmVyRW50cnk6IHtcbiAgICAgICAgICAgICAgQWNjb3VudDogYml0Z29BZGRyZXNzLFxuICAgICAgICAgICAgICBTaWduZXJXZWlnaHQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIEZsYWdzOiAyMTQ3NDgzNjQ4LFxuICAgICAgICAvLyBMYXN0TGVkZ2VyU2VxdWVuY2U6IGxlZGdlclZlcnNpb24gKyAxMCxcbiAgICAgICAgRmVlOiBmZWUsXG4gICAgICAgIFNlcXVlbmNlOiAxXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2lnbmVkTXVsdGlzaWdBc3NpZ25tZW50VHggPSByaXBwbGVMaWIuc2lnbldpdGhQcml2YXRlS2V5KEpTT04uc3RyaW5naWZ5KG11bHRpc2lnQXNzaWdubWVudFR4KSwgcHJpdmF0ZUtleS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgICAvLyBlbmZvcmNlIGRlc3RpbmF0aW9uIHRhZ3NcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uVGFnVHggPSB7XG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ0FjY291bnRTZXQnLFxuICAgICAgICBBY2NvdW50OiByb290QWRkcmVzcyxcbiAgICAgICAgU2V0RmxhZzogMSxcbiAgICAgICAgRmxhZ3M6IDIxNDc0ODM2NDgsXG4gICAgICAgIC8vIExhc3RMZWRnZXJTZXF1ZW5jZTogbGVkZ2VyVmVyc2lvbiArIDEwLFxuICAgICAgICBGZWU6IGZlZSxcbiAgICAgICAgU2VxdWVuY2U6IDJcbiAgICAgIH07XG4gICAgICBjb25zdCBzaWduZWREZXN0aW5hdGlvblRhZ1R4ID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleShKU09OLnN0cmluZ2lmeShkZXN0aW5hdGlvblRhZ1R4KSwgcHJpdmF0ZUtleS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgICAvLyBkaXNhYmxlIG1hc3RlciBrZXlcbiAgICAgIGNvbnN0IG1hc3RlckRlYWN0aXZhdGlvblR4ID0ge1xuICAgICAgICBUcmFuc2FjdGlvblR5cGU6ICdBY2NvdW50U2V0JyxcbiAgICAgICAgQWNjb3VudDogcm9vdEFkZHJlc3MsXG4gICAgICAgIFNldEZsYWc6IDQsXG4gICAgICAgIEZsYWdzOiAyMTQ3NDgzNjQ4LFxuICAgICAgICAvLyBMYXN0TGVkZ2VyU2VxdWVuY2U6IGxlZGdlclZlcnNpb24gKyAxMCxcbiAgICAgICAgRmVlOiBmZWUsXG4gICAgICAgIFNlcXVlbmNlOiAzXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2lnbmVkTWFzdGVyRGVhY3RpdmF0aW9uVHggPSByaXBwbGVMaWIuc2lnbldpdGhQcml2YXRlS2V5KEpTT04uc3RyaW5naWZ5KG1hc3RlckRlYWN0aXZhdGlvblR4KSwgcHJpdmF0ZUtleS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgICAvLyBleHRlbmQgdGhlIHdhbGxldCBpbml0aWFsaXphdGlvbiBwYXJhbXNcbiAgICAgIHdhbGxldFBhcmFtcy5yb290UHViID0gcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIHdhbGxldFBhcmFtcy5pbml0aWFsaXphdGlvblR4cyA9IHtcbiAgICAgICAgc2V0TXVsdGlzaWc6IHNpZ25lZE11bHRpc2lnQXNzaWdubWVudFR4LnNpZ25lZFRyYW5zYWN0aW9uLFxuICAgICAgICBkaXNhYmxlTWFzdGVyS2V5OiBzaWduZWRNYXN0ZXJEZWFjdGl2YXRpb25UeC5zaWduZWRUcmFuc2FjdGlvbixcbiAgICAgICAgZm9yY2VEZXN0aW5hdGlvblRhZzogc2lnbmVkRGVzdGluYXRpb25UYWdUeC5zaWduZWRUcmFuc2FjdGlvblxuICAgICAgfTtcbiAgICAgIHJldHVybiB3YWxsZXRQYXJhbXM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFwYXJhbXMudHhIZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIHR4SGV4Jyk7XG4gICAgICB9XG4gICAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgICBsZXQgdHhIZXg7XG4gICAgICB0cnkge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IHJpcHBsZUJpbmFyeUNvZGVjLmRlY29kZShwYXJhbXMudHhIZXgpO1xuICAgICAgICB0eEhleCA9IHBhcmFtcy50eEhleDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IEpTT04ucGFyc2UocGFyYW1zLnR4SGV4KTtcbiAgICAgICAgICB0eEhleCA9IHJpcHBsZUJpbmFyeUNvZGVjLmVuY29kZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4SGV4IG5lZWRzIHRvIGJlIGVpdGhlciBoZXggb3IgSlNPTiBzdHJpbmcgZm9yIFhSUCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvbkhhc2godHhIZXgpO1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHRyYW5zYWN0aW9uLkRlc3RpbmF0aW9uICsgKCh0cmFuc2FjdGlvbi5EZXN0aW5hdGlvblRhZyA+PSAwKSA/ICc/ZHQ9JyArIHRyYW5zYWN0aW9uLkRlc3RpbmF0aW9uVGFnIDogJycpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyOiBbJ2lkJywgJ291dHB1dEFtb3VudCcsICdjaGFuZ2VBbW91bnQnLCAnb3V0cHV0cycsICdjaGFuZ2VPdXRwdXRzJywgJ2ZlZSddLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IHRyYW5zYWN0aW9uLkFtb3VudCxcbiAgICAgICAgY2hhbmdlQW1vdW50OiAwLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudDogdHJhbnNhY3Rpb24uQW1vdW50XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBmZWU6IHtcbiAgICAgICAgICBmZWU6IHRyYW5zYWN0aW9uLkZlZSxcbiAgICAgICAgICBmZWVSYXRlOiBudWxsLFxuICAgICAgICAgIHNpemU6IHR4SGV4Lmxlbmd0aCAvIDJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgY29tcGxpZXMgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqIEBwYXJhbSB0eFBhcmFtcyBwYXJhbXMgb2JqZWN0IHBhc3NlZCB0byBzZW5kXG4gICAqIEBwYXJhbSB0eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBzZXJ2ZXJcbiAgICogQHBhcmFtIHdhbGxldFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBwdWJsaWMgdmVyaWZ5VHJhbnNhY3Rpb24oeyB0eFBhcmFtcywgdHhQcmVidWlsZCB9OiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrKTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxib29sZWFuPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSB5aWVsZCBzZWxmLmV4cGxhaW5UcmFuc2FjdGlvbih7XG4gICAgICAgIHR4SGV4OiB0eFByZWJ1aWxkLnR4SGV4XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgb3V0cHV0ID0gWy4uLmV4cGxhbmF0aW9uLm91dHB1dHMsIC4uLmV4cGxhbmF0aW9uLmNoYW5nZU91dHB1dHNdWzBdO1xuICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXQgPSB0eFBhcmFtcy5yZWNpcGllbnRzICYmIHR4UGFyYW1zLnJlY2lwaWVudHNbMF07XG5cbiAgICAgIGNvbnN0IGNvbXBhcmF0b3IgPSAocmVjaXBpZW50MSwgcmVjaXBpZW50MikgPT4ge1xuICAgICAgICBpZiAocmVjaXBpZW50MS5hZGRyZXNzICE9PSByZWNpcGllbnQyLmFkZHJlc3MpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW1vdW50MSA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50MS5hbW91bnQpO1xuICAgICAgICBjb25zdCBhbW91bnQyID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnQyLmFtb3VudCk7XG4gICAgICAgIHJldHVybiBhbW91bnQxLnRvRml4ZWQoKSA9PT0gYW1vdW50Mi50b0ZpeGVkKCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWNvbXBhcmF0b3Iob3V0cHV0LCBleHBlY3RlZE91dHB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBvdXRwdXQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGlzIGEgdmFsaWQgWFJQIGFkZHJlc3MsIGFuZCB0aGVuIG1ha2Ugc3VyZSB0aGUgcm9vdCBhZGRyZXNzZXMgbWF0Y2guXG4gICAqIFRoaXMgcHJldmVudHMgYXR0YWNrcyB3aGVyZSBhbiBhdHRhY2sgbWF5IHN3aXRjaCBvdXQgdGhlIG5ldyBhZGRyZXNzIGZvciBvbmUgb2YgdGhlaXIgb3duXG4gICAqIEBwYXJhbSBhZGRyZXNzIHtTdHJpbmd9IHRoZSBhZGRyZXNzIHRvIHZlcmlmeVxuICAgKiBAcGFyYW0gcm9vdEFkZHJlc3Mge1N0cmluZ30gdGhlIHdhbGxldCdzIHJvb3QgYWRkcmVzc1xuICAgKi9cbiAgcHVibGljIHZlcmlmeUFkZHJlc3MoeyBhZGRyZXNzLCByb290QWRkcmVzcyB9OiBWZXJpZnlBZGRyZXNzT3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmVyaWZpY2F0aW9uIGZhaWx1cmU6IGFkZHJlc3MgXCIke2FkZHJlc3N9XCIgaXMgbm90IHZhbGlkYCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgIGNvbnN0IHJvb3RBZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMocm9vdEFkZHJlc3MpO1xuXG4gICAgaWYgKGFkZHJlc3NEZXRhaWxzLmFkZHJlc3MgIT09IHJvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6ICR7YWRkcmVzc0RldGFpbHMuYWRkcmVzc30gdnMuICR7cm9vdEFkZHJlc3NEZXRhaWxzLmFkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVVJMIG9mIGEgd2VsbC1rbm93biwgcHVibGljIGZhY2luZyAobm9uLWJpdGdvKSByaXBwbGVkIGluc3RhbmNlIHdoaWNoIGNhbiBiZSB1c2VkIGZvciByZWNvdmVyeVxuICAgKi9cbiAgcHVibGljIGdldFJpcHBsZWRVcmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2h0dHBzOi8vczEucmlwcGxlLmNvbTo1MTIzNCc7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gcm9vdEFkZHJlc3M6IHJvb3QgWFJQIHdhbGxldCBhZGRyZXNzIHRvIHJlY292ZXIgZnVuZHMgZnJvbVxuICAgKiAtIHVzZXJLZXk6IFtlbmNyeXB0ZWRdIHhwcnZcbiAgICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIHhwcnYsIG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICAgKiAtIHdhbGxldFBhc3NwaHJhc2U6IG5lY2Vzc2FyeSBpZiBvbmUgb2YgdGhlIHhwcnZzIGlzIGVuY3J5cHRlZFxuICAgKiAtIGJpdGdvS2V5OiB4cHViXG4gICAqIC0ga3JzUHJvdmlkZXI6IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gICAqIC0gcmVjb3ZlcnlEZXN0aW5hdGlvbjogdGFyZ2V0IGFkZHJlc3MgdG8gc2VuZCByZWNvdmVyZWQgZnVuZHMgdG9cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgcmVjb3ZlcihwYXJhbXM6IFJlY292ZXJ5T3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UmVjb3ZlcnlJbmZvIHwgc3RyaW5nPik6IEJsdWViaXJkPFJlY292ZXJ5SW5mbyB8IHN0cmluZz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxSZWNvdmVyeUluZm8gfCBzdHJpbmc+KGZ1bmN0aW9uICpleHBsYWluVHJhbnNhY3Rpb24oKSB7XG4gICAgICBjb25zdCByaXBwbGVkVXJsID0gc2VsZi5nZXRSaXBwbGVkVXJsKCk7XG4gICAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcbiAgICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmIHBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcblxuICAgICAgY29uc3QgYWNjb3VudEluZm9QYXJhbXMgPSB7XG4gICAgICAgIG1ldGhvZDogJ2FjY291bnRfaW5mbycsXG4gICAgICAgIHBhcmFtczogW3tcbiAgICAgICAgICBhY2NvdW50OiBwYXJhbXMucm9vdEFkZHJlc3MsXG4gICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgIGxlZGdlcl9pbmRleDogJ2N1cnJlbnQnLFxuICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgIHNpZ25lcl9saXN0czogdHJ1ZSxcbiAgICAgICAgfV0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGtleXMsIGFkZHJlc3NEZXRhaWxzLCBmZWVEZXRhaWxzLCBzZXJ2ZXJEZXRhaWxzIH0gPSB5aWVsZCBCbHVlYmlyZC5wcm9wcyh7XG4gICAgICAgIGtleXM6IHNlbGYuaW5pdGlhdGVSZWNvdmVyeShwYXJhbXMpLFxuICAgICAgICBhZGRyZXNzRGV0YWlsczogc2VsZi5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoYWNjb3VudEluZm9QYXJhbXMpLFxuICAgICAgICBmZWVEZXRhaWxzOiBzZWxmLmJpdGdvLnBvc3QocmlwcGxlZFVybCkuc2VuZCh7IG1ldGhvZDogJ2ZlZScgfSksXG4gICAgICAgIHNlcnZlckRldGFpbHM6IHNlbGYuYml0Z28ucG9zdChyaXBwbGVkVXJsKS5zZW5kKHsgbWV0aG9kOiAnc2VydmVyX2luZm8nIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG9wZW5MZWRnZXJGZWUgPSBuZXcgQmlnTnVtYmVyKGZlZURldGFpbHMuYm9keS5yZXN1bHQuZHJvcHMub3Blbl9sZWRnZXJfZmVlKTtcbiAgICAgIGNvbnN0IGJhc2VSZXNlcnZlID0gbmV3IEJpZ051bWJlcihzZXJ2ZXJEZXRhaWxzLmJvZHkucmVzdWx0LmluZm8udmFsaWRhdGVkX2xlZGdlci5yZXNlcnZlX2Jhc2VfeHJwKS50aW1lcyhzZWxmLmdldEJhc2VGYWN0b3IoKSk7XG4gICAgICBjb25zdCByZXNlcnZlRGVsdGEgPSBuZXcgQmlnTnVtYmVyKHNlcnZlckRldGFpbHMuYm9keS5yZXN1bHQuaW5mby52YWxpZGF0ZWRfbGVkZ2VyLnJlc2VydmVfaW5jX3hycCkudGltZXMoc2VsZi5nZXRCYXNlRmFjdG9yKCkpO1xuICAgICAgY29uc3QgY3VycmVudExlZGdlciA9IHNlcnZlckRldGFpbHMuYm9keS5yZXN1bHQuaW5mby52YWxpZGF0ZWRfbGVkZ2VyLnNlcTtcbiAgICAgIGNvbnN0IHNlcXVlbmNlSWQgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuU2VxdWVuY2U7XG4gICAgICBjb25zdCBiYWxhbmNlID0gbmV3IEJpZ051bWJlcihhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuQmFsYW5jZSk7XG4gICAgICBjb25zdCBzaWduZXJMaXN0cyA9IGFkZHJlc3NEZXRhaWxzLmJvZHkucmVzdWx0LmFjY291bnRfZGF0YS5zaWduZXJfbGlzdHM7XG4gICAgICBjb25zdCBhY2NvdW50RmxhZ3MgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuRmxhZ3M7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBvbmx5IG9uZSBzaWduZXIgbGlzdCBzZXRcbiAgICAgIGlmIChzaWduZXJMaXN0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHNldCBvZiBzaWduZXIgbGlzdHMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBzaWduZXJzIGFyZSB1c2VyLCBiYWNrdXAsIGJpdGdvXG4gICAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHJpcHBsZUtleXBhaXJzLmRlcml2ZUFkZHJlc3Moa2V5c1swXS5nZXRQdWJsaWNLZXlCdWZmZXIoKS50b1N0cmluZygnaGV4JykpO1xuICAgICAgY29uc3QgYmFja3VwQWRkcmVzcyA9IHJpcHBsZUtleXBhaXJzLmRlcml2ZUFkZHJlc3Moa2V5c1sxXS5nZXRQdWJsaWNLZXlCdWZmZXIoKS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgICBjb25zdCBzaWduZXJMaXN0ID0gc2lnbmVyTGlzdHNbMF07XG4gICAgICBpZiAoc2lnbmVyTGlzdC5TaWduZXJRdW9ydW0gIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1pbmltdW0gc2lnbmF0dXJlIGNvdW50Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCBmb3VuZEFkZHJlc3NlcyA9IHt9O1xuXG4gICAgICBjb25zdCBzaWduZXJFbnRyaWVzID0gc2lnbmVyTGlzdC5TaWduZXJFbnRyaWVzO1xuICAgICAgaWYgKHNpZ25lckVudHJpZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduZXIgbGlzdCBsZW5ndGgnKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgeyBTaWduZXJFbnRyeSB9IG9mIHNpZ25lckVudHJpZXMpIHtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0gU2lnbmVyRW50cnkuU2lnbmVyV2VpZ2h0O1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gU2lnbmVyRW50cnkuQWNjb3VudDtcbiAgICAgICAgaWYgKHdlaWdodCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduZXIgd2VpZ2h0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpdCdzIGEgZHVwZSBvZiBhbiBhZGRyZXNzIHdlIGFscmVhZHkga25vdywgYmxvY2tcbiAgICAgICAgaWYgKGZvdW5kQWRkcmVzc2VzW2FkZHJlc3NdID49IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cGxpY2F0ZSBzaWduZXIgYWRkcmVzcycpO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kQWRkcmVzc2VzW2FkZHJlc3NdID0gKGZvdW5kQWRkcmVzc2VzW2FkZHJlc3NdIHx8IDApICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kQWRkcmVzc2VzW3VzZXJBZGRyZXNzXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgaW5jaWRlbmNlIGZyZXF1ZW5jeSBvZiB1c2VyIHNpZ25lciBhZGRyZXNzJyk7XG4gICAgICB9XG4gICAgICBpZiAoZm91bmRBZGRyZXNzZXNbYmFja3VwQWRkcmVzc10gIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGluY2lkZW5jZSBmcmVxdWVuY3kgb2YgdXNlciBzaWduZXIgYWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGZsYWdzIGRpc2FibGUgdGhlIG1hc3RlciBrZXkgYW5kIGVuZm9yY2UgZGVzdGluYXRpb24gdGFnc1xuICAgICAgY29uc3QgVVNFUl9LRVlfU0VUVElOR19GTEFHID0gNjU1MzY7XG4gICAgICBjb25zdCBNQVNURVJfS0VZX0RFQUNUSVZBVElPTl9GTEFHID0gMTA0ODU3NjtcbiAgICAgIGNvbnN0IFJFUVVJUkVfREVTVElOQVRJT05fVEFHX0ZMQUcgPSAxMzEwNzI7XG4gICAgICBpZiAoKGFjY291bnRGbGFncyAmIFVTRVJfS0VZX1NFVFRJTkdfRkxBRykgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIGN1c3RvbSB1c2VyIGtleSBoYXMgYmVlbiBzZXQnKTtcbiAgICAgIH1cbiAgICAgIGlmICgoYWNjb3VudEZsYWdzICYgTUFTVEVSX0tFWV9ERUFDVElWQVRJT05fRkxBRykgIT09IE1BU1RFUl9LRVlfREVBQ1RJVkFUSU9OX0ZMQUcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgbWFzdGVyIGtleSBoYXMgbm90IGJlZW4gZGVhY3RpdmF0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICgoYWNjb3VudEZsYWdzICYgUkVRVUlSRV9ERVNUSU5BVElPTl9UQUdfRkxBRykgIT09IFJFUVVJUkVfREVTVElOQVRJT05fVEFHX0ZMQUcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgZGVzdGluYXRpb24gZmxhZyByZXF1aXJlbWVudCBoYXMgbm90IGJlZW4gYWN0aXZhdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlY292ZXIgdGhlIGZ1bmRzXG4gICAgICBjb25zdCByZXNlcnZlID0gYmFzZVJlc2VydmUucGx1cyhyZXNlcnZlRGVsdGEudGltZXMoNSkpO1xuICAgICAgY29uc3QgcmVjb3ZlcmFibGVCYWxhbmNlID0gYmFsYW5jZS5taW51cyhyZXNlcnZlKTtcblxuICAgICAgY29uc3QgcmF3RGVzdGluYXRpb24gPSBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbjtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IHVybC5wYXJzZShyYXdEZXN0aW5hdGlvbik7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWU7XG5cbiAgICAgIC8vIHBhcnNlIGRlc3RpbmF0aW9uIHRhZyBmcm9tIHF1ZXJ5XG4gICAgICBsZXQgZGVzdGluYXRpb25UYWc6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpIHtcbiAgICAgICAgY29uc3QgcXVlcnlEZXRhaWxzID0gcXVlcnlzdHJpbmcucGFyc2UoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLmR0KSkge1xuICAgICAgICAgIC8vIGlmIHF1ZXJ5RGV0YWlscy5kdCBpcyBhbiBhcnJheSwgdGhhdCBtZWFucyBkdCB3YXMgZ2l2ZW4gbXVsdGlwbGUgdGltZXMsIHdoaWNoIGlzIG5vdCB2YWxpZFxuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBkZXN0aW5hdGlvbiB0YWcgY2FuIGFwcGVhciBhdCBtb3N0IG9uY2UsIGJ1dCAke3F1ZXJ5RGV0YWlscy5kdC5sZW5ndGh9IGRlc3RpbmF0aW9uIHRhZ3Mgd2VyZSBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyc2VkVGFnID0gcGFyc2VJbnQocXVlcnlEZXRhaWxzLmR0LCAxMCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHBhcnNlZFRhZykpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvblRhZyA9IHBhcnNlZFRhZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlOiAnUGF5bWVudCcsXG4gICAgICAgIEFjY291bnQ6IHBhcmFtcy5yb290QWRkcmVzcywgLy8gc291cmNlIGFkZHJlc3NcbiAgICAgICAgRGVzdGluYXRpb246IGRlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgICAgRGVzdGluYXRpb25UYWc6IGRlc3RpbmF0aW9uVGFnLFxuICAgICAgICBBbW91bnQ6IHJlY292ZXJhYmxlQmFsYW5jZS50b0ZpeGVkKDApLFxuICAgICAgICBGbGFnczogMjE0NzQ4MzY0OCxcbiAgICAgICAgTGFzdExlZGdlclNlcXVlbmNlOiBjdXJyZW50TGVkZ2VyICsgMTAwMDAwMCwgLy8gZ2l2ZSBpdCAxIG1pbGxpb24gbGVkZ2VycycgdGltZSAofjEgbW9udGgsIHN1aXRhYmxlIGZvciBLUlMpXG4gICAgICAgIEZlZTogb3BlbkxlZGdlckZlZS50aW1lcygzKS50b0ZpeGVkKDApLCAvLyB0aGUgZmFjdG9yIHRocmVlIGlzIGZvciB0aGUgbXVsdGlzaWduaW5nXG4gICAgICAgIFNlcXVlbmNlOiBzZXF1ZW5jZUlkLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHR4SlNPTjogc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb24pO1xuXG4gICAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIHJldHVybiB0eEpTT047XG4gICAgICB9XG4gICAgICBjb25zdCByaXBwbGVMaWIgPSByaXBwbGUoKTtcbiAgICAgIGNvbnN0IHVzZXJLZXkgPSBrZXlzWzBdLmdldEtleSgpLmdldFByaXZhdGVLZXlCdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBjb25zdCB1c2VyU2lnbmF0dXJlID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eEpTT04sIHVzZXJLZXksIHsgc2lnbkFzOiB1c2VyQWRkcmVzcyB9KTtcblxuICAgICAgbGV0IHNpZ25lZFRyYW5zYWN0aW9uO1xuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHVzZXJTaWduYXR1cmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBiYWNrdXBLZXkgPSBrZXlzWzFdLmdldEtleSgpLmdldFByaXZhdGVLZXlCdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIGNvbnN0IGJhY2t1cFNpZ25hdHVyZSA9IHJpcHBsZUxpYi5zaWduV2l0aFByaXZhdGVLZXkodHhKU09OLCBiYWNrdXBLZXksIHsgc2lnbkFzOiBiYWNrdXBBZGRyZXNzIH0pO1xuICAgICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHJpcHBsZUxpYi5jb21iaW5lKFt1c2VyU2lnbmF0dXJlLnNpZ25lZFRyYW5zYWN0aW9uLCBiYWNrdXBTaWduYXR1cmUuc2lnbmVkVHJhbnNhY3Rpb25dKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbjogUmVjb3ZlcnlJbmZvID0geWllbGQgc2VsZi5leHBsYWluVHJhbnNhY3Rpb24oe1xuICAgICAgICB0eEhleDogc2lnbmVkVHJhbnNhY3Rpb24uc2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24udHhIZXggPSBzaWduZWRUcmFuc2FjdGlvbi5zaWduZWRUcmFuc2FjdGlvbjtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5iYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5O1xuICAgICAgICB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uLmNvaW4gPSBzZWxmLmdldENoYWluKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb25FeHBsYW5hdGlvbjtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgYW5kIHZhbGlkYXRlIGFsbCBrZXljaGFpbnMgZnJvbSB0aGUga2V5Y2FyZCBmb3IgcmVjb3ZlcnlcbiAgICovXG4gIGluaXRpYXRlUmVjb3ZlcnkocGFyYW1zOiBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyk6IEJsdWViaXJkPEhETm9kZVtdPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEhETm9kZVtdPihmdW5jdGlvbiAqaW5pdGlhdGVSZWNvdmVyeSgpIHtcbiAgICAgIGNvbnN0IGtleXM6IEhETm9kZVtdID0gW107XG4gICAgICBjb25zdCB1c2VyS2V5ID0gcGFyYW1zLnVzZXJLZXk7IC8vIEJveCBBXG4gICAgICBsZXQgYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTsgLy8gQm94IEJcbiAgICAgIGNvbnN0IGJpdGdvWHB1YiA9IHBhcmFtcy5iaXRnb0tleTsgLy8gQm94IENcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQWRkcmVzcyA9IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uO1xuICAgICAgY29uc3QgcGFzc3BocmFzZSA9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlO1xuXG4gICAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiAhdXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBiYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmIHVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSAmJiBwYXJhbXMua3JzUHJvdmlkZXIgJiYgXy5pc1VuZGVmaW5lZChjb25maWcua3JzUHJvdmlkZXJzW3BhcmFtcy5rcnNQcm92aWRlcl0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgcmVjb3Zlcnkgc2VydmljZSBwcm92aWRlcicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxpZGF0ZVBhc3NwaHJhc2VLZXkgPSBmdW5jdGlvbih1c2VyS2V5LCBwYXNzcGhyYXNlKTogSEROb2RlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXVzZXJLZXkuc3RhcnRzV2l0aCgneHBydicpICYmICFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgICAgIHVzZXJLZXkgPSBzamNsLmRlY3J5cHQocGFzc3BocmFzZSwgdXNlcktleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBIRE5vZGUuZnJvbUJhc2U1OCh1c2VyS2V5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgdXNlciBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qga2V5ID0gdmFsaWRhdGVQYXNzcGhyYXNlS2V5KHVzZXJLZXksIHBhc3NwaHJhc2UpO1xuXG4gICAgICBrZXlzLnB1c2goa2V5KTtcblxuICAgICAgLy8gVmFsaWRhdGUgdGhlIGJhY2t1cCBrZXlcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwcnYnKSAmJiAhaXNLcnNSZWNvdmVyeSAmJiAhaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgICAgYmFja3VwS2V5ID0gc2pjbC5kZWNyeXB0KHBhc3NwaHJhc2UsIGJhY2t1cEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFja3VwSEROb2RlID0gSEROb2RlLmZyb21CYXNlNTgoYmFja3VwS2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGJhY2t1cEhETm9kZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgYmFja3VwIGtleSB3aXRoIHBhc3Njb2RlIC0gdHJ5IGFnYWluIScpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYml0Z29IRE5vZGUgPSBIRE5vZGUuZnJvbUJhc2U1OChiaXRnb1hwdWIpO1xuICAgICAgICBrZXlzLnB1c2goYml0Z29IRE5vZGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc2VsZi5nZXRGYW1pbHkoKSAhPT0gJ3hycCcpIHtcbiAgICAgICAgICAvLyBpbiBYUlAgcmVjb3ZlcmllcywgdGhlIEJpdEdvIHhwdWIgaXMgb3B0aW9uYWxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBiaXRnbyB4cHViIScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgZGVzdGluYXRpb24gYWRkcmVzc1xuICAgICAgaWYgKCFzZWxmLmlzVmFsaWRBZGRyZXNzKGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRlc3RpbmF0aW9uIGFkZHJlc3MhJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcga2V5cGFpciBmb3IgdGhpcyBjb2luLlxuICAgKiBAcGFyYW0gc2VlZCBTZWVkIGZyb20gd2hpY2ggdGhlIG5ldyBrZXlwYWlyIHNob3VsZCBiZSBnZW5lcmF0ZWQsIG90aGVyd2lzZSBhIHJhbmRvbSBzZWVkIGlzIHVzZWRcbiAgICovXG4gIHB1YmxpYyBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTZcbiAgICAgIC8vIGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmUgcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlXG4gICAgICAvLyBtYXhpbXVtIGVudHJvcHkgYW5kIGdpdmVzIHVzIG1heGltdW0gc2VjdXJpdHkgYWdhaW5zdCBjcmFja2luZy5cbiAgICAgIHNlZWQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gSEROb2RlLmZyb21TZWVkQnVmZmVyKHNlZWQpO1xuICAgIGNvbnN0IHhwdWIgPSBleHRlbmRlZEtleS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogeHB1YixcbiAgICAgIHBydjogZXh0ZW5kZWRLZXkudG9CYXNlNTgoKSxcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19