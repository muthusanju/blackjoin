"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var bitcoin = require("bitgo-utxo-lib");
var common = require("../common");
var wallet_1 = require("./wallet");
var Bluebird = require("bluebird");
var _ = require("lodash");
var bitcoin_1 = require("../bitcoin");
var util_1 = require("./internal/util");
var co = Bluebird.coroutine;
var Wallets = /** @class */ (function () {
    function Wallets(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a wallet by ID (proxy for getWallet)
     * @param params
     * @param callback
     */
    Wallets.prototype.get = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.getWallet(params, callback);
    };
    /**
     * List a user's wallets
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.list = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var queryObject, body;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        queryObject = {};
                        if (params.skip && params.prevId) {
                            throw new Error('cannot specify both skip and prevId');
                        }
                        if (params.getbalances) {
                            if (!_.isBoolean(params.getbalances)) {
                                throw new Error('invalid getbalances argument, expecting boolean');
                            }
                            queryObject.getbalances = params.getbalances;
                        }
                        if (params.prevId) {
                            if (!_.isString(params.prevId)) {
                                throw new Error('invalid prevId argument, expecting string');
                            }
                            queryObject.prevId = params.prevId;
                        }
                        if (params.limit) {
                            if (!_.isNumber(params.limit)) {
                                throw new Error('invalid limit argument, expecting number');
                            }
                            queryObject.limit = params.limit;
                        }
                        if (params.allTokens) {
                            if (!_.isBoolean(params.allTokens)) {
                                throw new Error('invalid allTokens argument, expecting boolean');
                            }
                            queryObject.allTokens = params.allTokens;
                        }
                        return [4 /*yield*/, self.bitgo
                                .get(self.baseCoin.url('/wallet'))
                                .query(queryObject)
                                .result()];
                    case 1:
                        body = _a.sent();
                        body.wallets = body.wallets.map(function (w) { return new wallet_1.Wallet(self.bitgo, self.baseCoin, w); });
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * add
     * Add a new wallet (advanced mode).
     * This allows you to manually submit the keys, type, m and n of the wallet
     * Parameters include:
     *    "label": label of the wallet to be shown in UI
     *    "m": number of keys required to unlock wallet (2)
     *    "n": number of keys available on the wallet (3)
     *    "keys": array of keychain ids
     */
    Wallets.prototype.add = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var walletParams, newWallet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['label', 'enterprise', 'type'], callback);
                        // no need to pass keys for (single) custodial wallets
                        if (params.type !== 'custodial') {
                            if (Array.isArray(params.keys) === false || !_.isNumber(params.m) || !_.isNumber(params.n)) {
                                throw new Error('invalid argument');
                            }
                            // TODO: support more types of multisig
                            if (!self.baseCoin.isValidMofNSetup(params)) {
                                throw new Error('unsupported multi-sig type');
                            }
                        }
                        if (params.tags && Array.isArray(params.tags) === false) {
                            throw new Error('invalid argument for tags - array expected');
                        }
                        if (params.clientFlags && Array.isArray(params.clientFlags) === false) {
                            throw new Error('invalid argument for clientFlags - array expected');
                        }
                        if (params.isCold && !_.isBoolean(params.isCold)) {
                            throw new Error('invalid argument for isCold - boolean expected');
                        }
                        if (params.isCustodial && !_.isBoolean(params.isCustodial)) {
                            throw new Error('invalid argument for isCustodial - boolean expected');
                        }
                        if (params.address && (!_.isString(params.address) || !this.baseCoin.isValidAddress(params.address))) {
                            throw new Error('invalid argument for address - valid address string expected');
                        }
                        walletParams = _.pick(params, [
                            'label',
                            'm',
                            'n',
                            'keys',
                            'enterprise',
                            'isCold',
                            'isCustodial',
                            'tags',
                            'clientFlags',
                            'type',
                            'address',
                        ]);
                        // Additional params needed for xrp
                        if (params.rootPub) {
                            walletParams.rootPub = params.rootPub;
                        }
                        // In XLM this private key is used only for wallet creation purposes, once the wallet is initialized then we
                        // update its weight to 0 making it an invalid key.
                        // https://www.stellar.org/developers/guides/concepts/multi-sig.html#additional-signing-keys
                        if (params.rootPrivateKey) {
                            walletParams.rootPrivateKey = params.rootPrivateKey;
                        }
                        if (params.initializationTxs) {
                            walletParams.initializationTxs = params.initializationTxs;
                        }
                        if (params.disableTransactionNotifications) {
                            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
                        }
                        return [4 /*yield*/, self.bitgo
                                .post(self.baseCoin.url('/wallet'))
                                .send(walletParams)
                                .result()];
                    case 1:
                        newWallet = _a.sent();
                        return [2 /*return*/, {
                                wallet: new wallet_1.Wallet(self.bitgo, self.baseCoin, newWallet),
                            }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Generate a new wallet
     * 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
     * 2. If no pub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
     * 3. Uploads the encrypted user and backup keychains to BitGo
     * 4. Creates the BitGo key on the service
     * 5. Creates the wallet on BitGo with the 3 public keys above
     * @param params
     * @param params.label
     * @param params.passphrase
     * @param params.userKey User xpub
     * @param params.backupXpub Backup xpub
     * @param params.backupXpubProvider
     * @param params.enterprise
     * @param params.disableTransactionNotifications
     * @param params.passcodeEncryptionCode
     * @param params.coldDerivationSeed
     * @param params.gasPrice
     * @param params.disableKRSEmail
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.generateWallet = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var label, passphrase, canEncrypt, isCold, walletParams, hasBackupXpub, hasBackupXpubProvider, krsSpecific, derivationPath, reqId, userKeychainPromise, backupKeychainPromise, _a, userKeychain, backupKeychain, bitgoKeychain, prv, keychains, finalWalletParams, newWallet, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        common.validateParams(params, ['label'], ['passphrase', 'userKey', 'backupXpub'], callback);
                        if (!_.isString(params.label)) {
                            throw new Error('missing required string parameter label');
                        }
                        label = params.label;
                        passphrase = params.passphrase;
                        canEncrypt = !!passphrase && typeof passphrase === 'string';
                        isCold = !canEncrypt || !!params.userKey;
                        walletParams = {
                            label: label,
                            m: 2,
                            n: 3,
                            keys: [],
                            isCold: isCold,
                        };
                        hasBackupXpub = !!params.backupXpub;
                        hasBackupXpubProvider = !!params.backupXpubProvider;
                        if (hasBackupXpub && hasBackupXpubProvider) {
                            throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
                        }
                        if (!_.isUndefined(params.passcodeEncryptionCode)) {
                            if (!_.isString(params.passcodeEncryptionCode)) {
                                throw new Error('passcodeEncryptionCode must be a string');
                            }
                        }
                        if (!_.isUndefined(params.enterprise)) {
                            if (!_.isString(params.enterprise)) {
                                throw new Error('invalid enterprise argument, expecting string');
                            }
                            walletParams.enterprise = params.enterprise;
                        }
                        if (!_.isUndefined(params.disableTransactionNotifications)) {
                            if (!_.isBoolean(params.disableTransactionNotifications)) {
                                throw new Error('invalid disableTransactionNotifications argument, expecting boolean');
                            }
                            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
                        }
                        if (!_.isUndefined(params.gasPrice)) {
                            if (!_.isNumber(params.gasPrice)) {
                                throw new Error('invalid gas price argument, expecting number');
                            }
                            walletParams.gasPrice = params.gasPrice;
                        }
                        if (!_.isUndefined(params.disableKRSEmail)) {
                            if (!_.isBoolean(params.disableKRSEmail)) {
                                throw new Error('invalid disableKRSEmail argument, expecting boolean');
                            }
                            walletParams.disableKRSEmail = params.disableKRSEmail;
                        }
                        krsSpecific = params.krsSpecific;
                        if (!_.isUndefined(krsSpecific)) {
                            Object.keys(krsSpecific).forEach(function (key) {
                                var val = krsSpecific[key];
                                if (!_.isBoolean(val) && !_.isString(val) && !_.isNumber(val)) {
                                    throw new Error('krsSpecific object contains illegal values. values must be strings, booleans, or numbers');
                                }
                            });
                        }
                        derivationPath = undefined;
                        reqId = new util_1.RequestTracer();
                        userKeychainPromise = co(function () {
                            var userKeychainParams, userKeychain, derivation, newUserKeychain;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        // User provided user key
                                        if (params.userKey) {
                                            userKeychain = { pub: params.userKey };
                                            userKeychainParams = userKeychain;
                                            if (params.coldDerivationSeed) {
                                                derivation = self.baseCoin.deriveKeyWithSeed({
                                                    key: params.userKey,
                                                    seed: params.coldDerivationSeed,
                                                });
                                                derivationPath = derivation.derivationPath;
                                                userKeychain.pub = derivation.key;
                                            }
                                        }
                                        else {
                                            if (!canEncrypt) {
                                                throw new Error('cannot generate user keypair without passphrase');
                                            }
                                            // Create the user key.
                                            userKeychain = self.baseCoin.keychains().create();
                                            userKeychain.encryptedPrv = self.bitgo.encrypt({ password: passphrase, input: userKeychain.prv });
                                            userKeychainParams = {
                                                pub: userKeychain.pub,
                                                encryptedPrv: userKeychain.encryptedPrv,
                                                originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                                            };
                                        }
                                        userKeychainParams.reqId = reqId;
                                        return [4 /*yield*/, self.baseCoin.keychains().add(userKeychainParams)];
                                    case 1:
                                        newUserKeychain = _a.sent();
                                        return [2 /*return*/, _.extend({}, newUserKeychain, userKeychain)];
                                }
                            });
                        }).call(this);
                        backupKeychainPromise = co(function () {
                            return __generator(this, function (_a) {
                                if (params.backupXpubProvider || self.baseCoin.getFamily() === 'rmg') {
                                    // If requested, use a KRS or backup key provider
                                    return [2 /*return*/, self.baseCoin.keychains().createBackup({
                                            provider: params.backupXpubProvider || 'defaultRMGBackupProvider',
                                            disableKRSEmail: params.disableKRSEmail,
                                            krsSpecific: params.krsSpecific,
                                            type: self.baseCoin.getChain(),
                                            reqId: reqId,
                                        })];
                                }
                                // User provided backup xpub
                                if (params.backupXpub) {
                                    // user provided backup ethereum address
                                    return [2 /*return*/, self.baseCoin.keychains().add({
                                            pub: params.backupXpub,
                                            source: 'backup',
                                            reqId: reqId,
                                        })];
                                }
                                else {
                                    if (!canEncrypt) {
                                        throw new Error('cannot generate backup keypair without passphrase');
                                    }
                                    // No provided backup xpub or address, so default to creating one here
                                    return [2 /*return*/, self.baseCoin.keychains().createBackup({ reqId: reqId })];
                                }
                                return [2 /*return*/];
                            });
                        }).call(this);
                        return [4 /*yield*/, Bluebird.props({
                                userKeychain: userKeychainPromise,
                                backupKeychain: backupKeychainPromise,
                                bitgoKeychain: self.baseCoin.keychains().createBitGo({ enterprise: params.enterprise, reqId: reqId }),
                            })];
                    case 1:
                        _a = _b.sent(), userKeychain = _a.userKeychain, backupKeychain = _a.backupKeychain, bitgoKeychain = _a.bitgoKeychain;
                        walletParams.keys = [userKeychain.id, backupKeychain.id, bitgoKeychain.id];
                        walletParams.isCold = isCold;
                        prv = userKeychain.prv;
                        if (_.isString(prv)) {
                            walletParams.keySignatures = {
                                backup: self.baseCoin.signMessage({ prv: prv }, backupKeychain.pub).toString('hex'),
                                bitgo: self.baseCoin.signMessage({ prv: prv }, bitgoKeychain.pub).toString('hex'),
                            };
                        }
                        if (_.includes(['xrp', 'xlm'], self.baseCoin.getFamily()) && !_.isUndefined(params.rootPrivateKey)) {
                            walletParams.rootPrivateKey = params.rootPrivateKey;
                        }
                        keychains = {
                            userKeychain: userKeychain,
                            backupKeychain: backupKeychain,
                            bitgoKeychain: bitgoKeychain,
                        };
                        return [4 /*yield*/, self.baseCoin.supplementGenerateWallet(walletParams, keychains)];
                    case 2:
                        finalWalletParams = _b.sent();
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, self.bitgo
                                .post(self.baseCoin.url('/wallet'))
                                .send(finalWalletParams)
                                .result()];
                    case 3:
                        newWallet = _b.sent();
                        result = {
                            wallet: new wallet_1.Wallet(self.bitgo, self.baseCoin, newWallet),
                            userKeychain: userKeychain,
                            backupKeychain: backupKeychain,
                            bitgoKeychain: bitgoKeychain,
                        };
                        if (!_.isUndefined(backupKeychain.prv)) {
                            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
                        }
                        if (!_.isUndefined(derivationPath)) {
                            userKeychain.derivationPath = derivationPath;
                        }
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * List the user's wallet shares
     * @param params
     * @param callback
     */
    Wallets.prototype.listShares = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo
            .get(this.baseCoin.url('/walletshare'))
            .result()
            .asCallback(callback);
    };
    /**
     * Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
     * @param params
     * @param params.walletShareId - the wallet share to get information on
     * @param callback
     */
    Wallets.prototype.getShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['walletShareId'], [], callback);
        return this.bitgo
            .get(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .result()
            .nodeify(callback);
    };
    /**
     * Update a wallet share
     * @param params.walletShareId - the wallet share to update
     * @param params.state - the new state of the wallet share
     * @param params
     * @param callback
     */
    Wallets.prototype.updateShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['walletShareId'], [], callback);
        return this.bitgo
            .post(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Resend a wallet share invitation email
     * @param params
     * @param params.walletShareId - the wallet share whose invitiation should be resent
     * @param callback
     */
    Wallets.prototype.resendShareInvite = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var urlParts;
            return __generator(this, function (_a) {
                common.validateParams(params, ['walletShareId'], [], callback);
                urlParts = params.walletShareId + '/resendemail';
                return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/walletshare/' + urlParts)).result()];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Cancel a wallet share
     * @param params
     * @param params.walletShareId - the wallet share to update
     * @param callback
     */
    Wallets.prototype.cancelShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['walletShareId'], [], callback);
        return this.bitgo
            .del(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send()
            .result()
            .nodeify(callback);
    };
    /**
     * Accepts a wallet share, adding the wallet to the user's list
     * Needs a user's password to decrypt the shared key
     *
     * @param params
     * @param params.walletShareId - the wallet share to accept
     * @param params.userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
     * @param params.newWalletPassphrase - new wallet passphrase for saving the shared wallet prv.
     *                                     If left blank and a wallet with more than view permissions was shared,
     *                                     then the user's login password is used.
     * @param params.overrideEncryptedPrv - set only if the prv was received out-of-band.
     * @param callback
     */
    Wallets.prototype.acceptShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var encryptedPrv, walletShare, sharingKeychain, rootExtKey, privKey, secret, decryptedSharedWalletPrv, newWalletPassphrase, updateParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['walletShareId'], ['overrideEncryptedPrv', 'userPassword', 'newWalletPassphrase'], callback);
                        encryptedPrv = params.overrideEncryptedPrv;
                        return [4 /*yield*/, self.getShare({ walletShareId: params.walletShareId })];
                    case 1:
                        walletShare = _a.sent();
                        // Return right away if there is no keychain to decrypt, or if explicit encryptedPrv was provided
                        if (!walletShare.keychain || !walletShare.keychain.encryptedPrv || encryptedPrv) {
                            return [2 /*return*/, self.updateShare({
                                    walletShareId: params.walletShareId,
                                    state: 'accepted',
                                })];
                        }
                        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
                        if (_.isUndefined(params.userPassword)) {
                            throw new Error('userPassword param must be provided to decrypt shared key');
                        }
                        return [4 /*yield*/, self.bitgo.getECDHSharingKeychain()];
                    case 2:
                        sharingKeychain = _a.sent();
                        if (_.isUndefined(sharingKeychain.encryptedXprv)) {
                            throw new Error('encryptedXprv was not found on sharing keychain');
                        }
                        // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
                        sharingKeychain.prv = self.bitgo.decrypt({
                            password: params.userPassword,
                            input: sharingKeychain.encryptedXprv,
                        });
                        rootExtKey = bitcoin.HDNode.fromBase58(sharingKeychain.prv);
                        privKey = bitcoin_1.hdPath(rootExtKey).deriveKey(walletShare.keychain.path);
                        secret = self.bitgo.getECDHSecret({
                            eckey: privKey,
                            otherPubKeyHex: walletShare.keychain.fromPubKey,
                        });
                        decryptedSharedWalletPrv = self.bitgo.decrypt({
                            password: secret,
                            input: walletShare.keychain.encryptedPrv,
                        });
                        newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
                        encryptedPrv = self.bitgo.encrypt({
                            password: newWalletPassphrase,
                            input: decryptedSharedWalletPrv,
                        });
                        updateParams = {
                            walletShareId: params.walletShareId,
                            state: 'accepted',
                        };
                        if (encryptedPrv) {
                            updateParams.encryptedPrv = encryptedPrv;
                        }
                        return [2 /*return*/, self.updateShare(updateParams)];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Get a wallet by its ID
     * @param params
     * @param params.id wallet id
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.getWallet = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var query, wallet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['id'], [], callback);
                        query = {};
                        if (params.allTokens) {
                            if (!_.isBoolean(params.allTokens)) {
                                throw new Error('invalid allTokens argument, expecting boolean');
                            }
                            query.allTokens = params.allTokens;
                        }
                        self.bitgo.setRequestTracer(params.reqId || new util_1.RequestTracer());
                        return [4 /*yield*/, self.bitgo
                                .get(self.baseCoin.url('/wallet/' + params.id))
                                .query(query)
                                .result()];
                    case 1:
                        wallet = _a.sent();
                        return [2 /*return*/, new wallet_1.Wallet(self.bitgo, self.baseCoin, wallet)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Get a wallet by its address
     * @param params
     * @param params.address wallet address
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.getWalletByAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var wallet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['address'], [], callback);
                        self.bitgo.setRequestTracer(params.reqId || new util_1.RequestTracer());
                        return [4 /*yield*/, self.bitgo.get(self.baseCoin.url('/wallet/address/' + params.address)).result()];
                    case 1:
                        wallet = _a.sent();
                        return [2 /*return*/, new wallet_1.Wallet(self.bitgo, self.baseCoin, wallet)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * For any given supported coin, get total balances for all wallets of that
     * coin type on the account.
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.getTotalBalances = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo
            .get(this.baseCoin.url('/wallet/balances'))
            .result()
            .asCallback(callback);
    };
    return Wallets;
}());
exports.Wallets = Wallets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92Mi93YWxsZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCx3Q0FBMEM7QUFFMUMsa0NBQW9DO0FBR3BDLG1DQUFxRDtBQUNyRCxtQ0FBcUM7QUFDckMsMEJBQTRCO0FBQzVCLHNDQUFvQztBQUVwQyx3Q0FBZ0Q7QUFFaEQsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQXVFOUI7SUFJRSxpQkFBWSxLQUFZLEVBQUUsUUFBa0I7UUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxxQkFBRyxHQUFILFVBQUksTUFBNkIsRUFBRSxRQUErQjtRQUE5RCx1QkFBQSxFQUFBLFdBQTZCO1FBQy9CLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsc0JBQUksR0FBSixVQUNFLE1BQThCLEVBQzlCLFFBQThDO1FBRDlDLHVCQUFBLEVBQUEsV0FBOEI7UUFHOUIsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUF3Qjs7Ozs7d0JBQ3pCLFdBQVcsR0FBc0IsRUFBRSxDQUFDO3dCQUUxQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTs0QkFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO3lCQUN4RDt3QkFFRCxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUU7NEJBQ3RCLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRTtn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QyxDQUFDO3dCQUVsRCxxQkFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBQTs7d0JBQTlGLE1BQU0sR0FBRyxTQUFxRjt3QkFDcEcsc0JBQU8sSUFBSSxlQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxFQUFDOzs7U0FDdEQsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGtDQUFnQixHQUFoQixVQUFpQixNQUFlLEVBQUUsUUFBNEI7UUFBN0MsdUJBQUEsRUFBQSxXQUFlO1FBQzlCLE9BQU8sSUFBSSxDQUFDLEtBQUs7YUFDZCxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUMxQyxNQUFNLEVBQUU7YUFDUixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUNILGNBQUM7QUFBRCxDQUFDLEFBeG1CRCxJQXdtQkM7QUF4bUJZLDBCQUFPIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgYml0Y29pbiBmcm9tICdiaXRnby11dHhvLWxpYic7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uL2JpdGdvJztcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgQmFzZUNvaW4sIEtleWNoYWluc1RyaXBsZXQsIFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMgfSBmcm9tICcuL2Jhc2VDb2luJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgUGFnaW5hdGlvbk9wdGlvbnMsIFdhbGxldCB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGhkUGF0aCB9IGZyb20gJy4uL2JpdGNvaW4nO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciBhcyBJUmVxdWVzdFRyYWNlciB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4vaW50ZXJuYWwvdXRpbCc7XG5cbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldFdpdGhLZXljaGFpbnMgZXh0ZW5kcyBLZXljaGFpbnNUcmlwbGV0IHtcbiAgd2FsbGV0OiBXYWxsZXQ7XG4gIHdhcm5pbmc/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0V2FsbGV0T3B0aW9ucyB7XG4gIGFsbFRva2Vucz86IGJvb2xlYW47XG4gIHJlcUlkPzogSVJlcXVlc3RUcmFjZXI7XG4gIGlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB7XG4gIGxhYmVsPzogc3RyaW5nO1xuICBwYXNzcGhyYXNlPzogc3RyaW5nO1xuICB1c2VyS2V5Pzogc3RyaW5nO1xuICBiYWNrdXBYcHViPzogc3RyaW5nO1xuICBiYWNrdXBYcHViUHJvdmlkZXI/OiBzdHJpbmc7XG4gIHBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmc7XG4gIGVudGVycHJpc2U/OiBzdHJpbmc7XG4gIGRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM/OiBzdHJpbmc7XG4gIGdhc1ByaWNlPzogc3RyaW5nO1xuICBkaXNhYmxlS1JTRW1haWw/OiBib29sZWFuO1xuICBrcnNTcGVjaWZpYz86IHtcbiAgICBbaW5kZXg6IHN0cmluZ106IGJvb2xlYW4gfCBzdHJpbmcgfCBudW1iZXI7XG4gIH07XG4gIGNvbGREZXJpdmF0aW9uU2VlZD86IHN0cmluZztcbiAgcm9vdFByaXZhdGVLZXk/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0V2FsbGV0QnlBZGRyZXNzT3B0aW9ucyB7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG4gIHJlcUlkPzogUmVxdWVzdFRyYWNlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVTaGFyZU9wdGlvbnMge1xuICB3YWxsZXRTaGFyZUlkPzogc3RyaW5nO1xuICBzdGF0ZT86IHN0cmluZztcbiAgZW5jcnlwdGVkUHJ2Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjY2VwdFNoYXJlT3B0aW9ucyB7XG4gIG92ZXJyaWRlRW5jcnlwdGVkUHJ2Pzogc3RyaW5nO1xuICB3YWxsZXRTaGFyZUlkPzogc3RyaW5nO1xuICB1c2VyUGFzc3dvcmQ/OiBzdHJpbmc7XG4gIG5ld1dhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRkV2FsbGV0T3B0aW9ucyB7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIGtleXM/OiBzdHJpbmdbXTtcbiAgbT86IG51bWJlcjtcbiAgbj86IG51bWJlcjtcbiAgdGFncz86IHN0cmluZ1tdO1xuICBjbGllbnRGbGFncz86IHN0cmluZ1tdO1xuICBpc0NvbGQ/OiBib29sZWFuO1xuICBpc0N1c3RvZGlhbD86IGJvb2xlYW47XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG4gIHJvb3RQdWI/OiBzdHJpbmc7XG4gIHJvb3RQcml2YXRlS2V5Pzogc3RyaW5nO1xuICBpbml0aWFsaXphdGlvblR4cz86IGFueTtcbiAgZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFdhbGxldE9wdGlvbnMgZXh0ZW5kcyBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIHNraXA/OiBudW1iZXI7XG4gIGdldGJhbGFuY2VzPzogYm9vbGVhbjtcbiAgYWxsVG9rZW5zPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIFdhbGxldHMge1xuICBwcml2YXRlIHJlYWRvbmx5IGJpdGdvOiBCaXRHbztcbiAgcHJpdmF0ZSByZWFkb25seSBiYXNlQ29pbjogQmFzZUNvaW47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBiYXNlQ29pbjogQmFzZUNvaW4pIHtcbiAgICB0aGlzLmJpdGdvID0gYml0Z287XG4gICAgdGhpcy5iYXNlQ29pbiA9IGJhc2VDb2luO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHdhbGxldCBieSBJRCAocHJveHkgZm9yIGdldFdhbGxldClcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldChwYXJhbXM6IEdldFdhbGxldE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8V2FsbGV0Pik6IEJsdWViaXJkPFdhbGxldD4ge1xuICAgIHJldHVybiB0aGlzLmdldFdhbGxldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IGEgdXNlcidzIHdhbGxldHNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBsaXN0KFxuICAgIHBhcmFtczogTGlzdFdhbGxldE9wdGlvbnMgPSB7fSxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazx7IHdhbGxldHM6IFdhbGxldFtdIH0+XG4gICk6IEJsdWViaXJkPHsgd2FsbGV0czogV2FsbGV0W10gfT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzx7IHdhbGxldHM6IFdhbGxldFtdIH0+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5T2JqZWN0OiBMaXN0V2FsbGV0T3B0aW9ucyA9IHt9O1xuXG4gICAgICBpZiAocGFyYW1zLnNraXAgJiYgcGFyYW1zLnByZXZJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IGJvdGggc2tpcCBhbmQgcHJldklkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuZ2V0YmFsYW5jZXMpIHtcbiAgICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuZ2V0YmFsYW5jZXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGdldGJhbGFuY2VzIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5T2JqZWN0LmdldGJhbGFuY2VzID0gcGFyYW1zLmdldGJhbGFuY2VzO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5T2JqZWN0LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnlPYmplY3QubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuYWxsVG9rZW5zKSB7XG4gICAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmFsbFRva2VucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5T2JqZWN0LmFsbFRva2VucyA9IHBhcmFtcy5hbGxUb2tlbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCBzZWxmLmJpdGdvXG4gICAgICAgIC5nZXQoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSlcbiAgICAgICAgLnF1ZXJ5KHF1ZXJ5T2JqZWN0KVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBib2R5LndhbGxldHMgPSBib2R5LndhbGxldHMubWFwKHcgPT4gbmV3IFdhbGxldChzZWxmLmJpdGdvLCBzZWxmLmJhc2VDb2luLCB3KSk7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhZGRcbiAgICogQWRkIGEgbmV3IHdhbGxldCAoYWR2YW5jZWQgbW9kZSkuXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBtYW51YWxseSBzdWJtaXQgdGhlIGtleXMsIHR5cGUsIG0gYW5kIG4gb2YgdGhlIHdhbGxldFxuICAgKiBQYXJhbWV0ZXJzIGluY2x1ZGU6XG4gICAqICAgIFwibGFiZWxcIjogbGFiZWwgb2YgdGhlIHdhbGxldCB0byBiZSBzaG93biBpbiBVSVxuICAgKiAgICBcIm1cIjogbnVtYmVyIG9mIGtleXMgcmVxdWlyZWQgdG8gdW5sb2NrIHdhbGxldCAoMilcbiAgICogICAgXCJuXCI6IG51bWJlciBvZiBrZXlzIGF2YWlsYWJsZSBvbiB0aGUgd2FsbGV0ICgzKVxuICAgKiAgICBcImtleXNcIjogYXJyYXkgb2Yga2V5Y2hhaW4gaWRzXG4gICAqL1xuICBhZGQocGFyYW1zOiBBZGRXYWxsZXRPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnbGFiZWwnLCAnZW50ZXJwcmlzZScsICd0eXBlJ10sIGNhbGxiYWNrKTtcblxuICAgICAgLy8gbm8gbmVlZCB0byBwYXNzIGtleXMgZm9yIChzaW5nbGUpIGN1c3RvZGlhbCB3YWxsZXRzXG4gICAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdjdXN0b2RpYWwnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5rZXlzKSA9PT0gZmFsc2UgfHwgIV8uaXNOdW1iZXIocGFyYW1zLm0pIHx8ICFfLmlzTnVtYmVyKHBhcmFtcy5uKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBtb3JlIHR5cGVzIG9mIG11bHRpc2lnXG4gICAgICAgIGlmICghc2VsZi5iYXNlQ29pbi5pc1ZhbGlkTW9mTlNldHVwKHBhcmFtcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIG11bHRpLXNpZyB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy50YWdzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLnRhZ3MpID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIHRhZ3MgLSBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNsaWVudEZsYWdzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLmNsaWVudEZsYWdzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBjbGllbnRGbGFncyAtIGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuaXNDb2xkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaXNDb2xkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGlzQ29sZCAtIGJvb2xlYW4gZXhwZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5pc0N1c3RvZGlhbCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmlzQ3VzdG9kaWFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGlzQ3VzdG9kaWFsIC0gYm9vbGVhbiBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmFkZHJlc3MgJiYgKCFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSB8fCAhdGhpcy5iYXNlQ29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMuYWRkcmVzcykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgYWRkcmVzcyAtIHZhbGlkIGFkZHJlc3Mgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdhbGxldFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFtcbiAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgJ20nLFxuICAgICAgICAnbicsXG4gICAgICAgICdrZXlzJyxcbiAgICAgICAgJ2VudGVycHJpc2UnLFxuICAgICAgICAnaXNDb2xkJyxcbiAgICAgICAgJ2lzQ3VzdG9kaWFsJyxcbiAgICAgICAgJ3RhZ3MnLFxuICAgICAgICAnY2xpZW50RmxhZ3MnLFxuICAgICAgICAndHlwZScsXG4gICAgICAgICdhZGRyZXNzJyxcbiAgICAgIF0pO1xuXG4gICAgICAvLyBBZGRpdGlvbmFsIHBhcmFtcyBuZWVkZWQgZm9yIHhycFxuICAgICAgaWYgKHBhcmFtcy5yb290UHViKSB7XG4gICAgICAgIHdhbGxldFBhcmFtcy5yb290UHViID0gcGFyYW1zLnJvb3RQdWI7XG4gICAgICB9XG5cbiAgICAgIC8vIEluIFhMTSB0aGlzIHByaXZhdGUga2V5IGlzIHVzZWQgb25seSBmb3Igd2FsbGV0IGNyZWF0aW9uIHB1cnBvc2VzLCBvbmNlIHRoZSB3YWxsZXQgaXMgaW5pdGlhbGl6ZWQgdGhlbiB3ZVxuICAgICAgLy8gdXBkYXRlIGl0cyB3ZWlnaHQgdG8gMCBtYWtpbmcgaXQgYW4gaW52YWxpZCBrZXkuXG4gICAgICAvLyBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy9tdWx0aS1zaWcuaHRtbCNhZGRpdGlvbmFsLXNpZ25pbmcta2V5c1xuICAgICAgaWYgKHBhcmFtcy5yb290UHJpdmF0ZUtleSkge1xuICAgICAgICB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkgPSBwYXJhbXMucm9vdFByaXZhdGVLZXk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuaW5pdGlhbGl6YXRpb25UeHMpIHtcbiAgICAgICAgd2FsbGV0UGFyYW1zLmluaXRpYWxpemF0aW9uVHhzID0gcGFyYW1zLmluaXRpYWxpemF0aW9uVHhzO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgd2FsbGV0UGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMgPSBwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3V2FsbGV0ID0geWllbGQgc2VsZi5iaXRnb1xuICAgICAgICAucG9zdChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKVxuICAgICAgICAuc2VuZCh3YWxsZXRQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdhbGxldDogbmV3IFdhbGxldChzZWxmLmJpdGdvLCBzZWxmLmJhc2VDb2luLCBuZXdXYWxsZXQpLFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyB3YWxsZXRcbiAgICogMS4gQ3JlYXRlcyB0aGUgdXNlciBrZXljaGFpbiBsb2NhbGx5IG9uIHRoZSBjbGllbnQsIGFuZCBlbmNyeXB0cyBpdCB3aXRoIHRoZSBwcm92aWRlZCBwYXNzcGhyYXNlXG4gICAqIDIuIElmIG5vIHB1YiB3YXMgcHJvdmlkZWQsIGNyZWF0ZXMgdGhlIGJhY2t1cCBrZXljaGFpbiBsb2NhbGx5IG9uIHRoZSBjbGllbnQsIGFuZCBlbmNyeXB0cyBpdCB3aXRoIHRoZSBwcm92aWRlZCBwYXNzcGhyYXNlXG4gICAqIDMuIFVwbG9hZHMgdGhlIGVuY3J5cHRlZCB1c2VyIGFuZCBiYWNrdXAga2V5Y2hhaW5zIHRvIEJpdEdvXG4gICAqIDQuIENyZWF0ZXMgdGhlIEJpdEdvIGtleSBvbiB0aGUgc2VydmljZVxuICAgKiA1LiBDcmVhdGVzIHRoZSB3YWxsZXQgb24gQml0R28gd2l0aCB0aGUgMyBwdWJsaWMga2V5cyBhYm92ZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMubGFiZWxcbiAgICogQHBhcmFtIHBhcmFtcy5wYXNzcGhyYXNlXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcktleSBVc2VyIHhwdWJcbiAgICogQHBhcmFtIHBhcmFtcy5iYWNrdXBYcHViIEJhY2t1cCB4cHViXG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyXG4gICAqIEBwYXJhbSBwYXJhbXMuZW50ZXJwcmlzZVxuICAgKiBAcGFyYW0gcGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlXG4gICAqIEBwYXJhbSBwYXJhbXMuY29sZERlcml2YXRpb25TZWVkXG4gICAqIEBwYXJhbSBwYXJhbXMuZ2FzUHJpY2VcbiAgICogQHBhcmFtIHBhcmFtcy5kaXNhYmxlS1JTRW1haWxcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZ2VuZXJhdGVXYWxsZXQoXG4gICAgcGFyYW1zOiBHZW5lcmF0ZVdhbGxldE9wdGlvbnMgPSB7fSxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxXYWxsZXRXaXRoS2V5Y2hhaW5zPlxuICApOiBCbHVlYmlyZDxXYWxsZXRXaXRoS2V5Y2hhaW5zPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFdhbGxldFdpdGhLZXljaGFpbnM+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnbGFiZWwnXSwgWydwYXNzcGhyYXNlJywgJ3VzZXJLZXknLCAnYmFja3VwWHB1YiddLCBjYWxsYmFjayk7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmxhYmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciBsYWJlbCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWwgPSBwYXJhbXMubGFiZWw7XG4gICAgICBjb25zdCBwYXNzcGhyYXNlID0gcGFyYW1zLnBhc3NwaHJhc2U7XG4gICAgICBjb25zdCBjYW5FbmNyeXB0ID0gISFwYXNzcGhyYXNlICYmIHR5cGVvZiBwYXNzcGhyYXNlID09PSAnc3RyaW5nJztcbiAgICAgIGNvbnN0IGlzQ29sZCA9ICFjYW5FbmNyeXB0IHx8ICEhcGFyYW1zLnVzZXJLZXk7XG5cbiAgICAgIGNvbnN0IHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyA9IHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBtOiAyLFxuICAgICAgICBuOiAzLFxuICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgaXNDb2xkLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgaGFzQmFja3VwWHB1YiA9ICEhcGFyYW1zLmJhY2t1cFhwdWI7XG4gICAgICBjb25zdCBoYXNCYWNrdXBYcHViUHJvdmlkZXIgPSAhIXBhcmFtcy5iYWNrdXBYcHViUHJvdmlkZXI7XG4gICAgICBpZiAoaGFzQmFja3VwWHB1YiAmJiBoYXNCYWNrdXBYcHViUHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcHJvdmlkZSBtb3JlIHRoYW4gb25lIGJhY2t1cFhwdWIgb3IgYmFja3VwWHB1YlByb3ZpZGVyIGZsYWcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSkge1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnBhc3Njb2RlRW5jcnlwdGlvbkNvZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzY29kZUVuY3J5cHRpb25Db2RlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpKSB7XG4gICAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuZW50ZXJwcmlzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW50ZXJwcmlzZSBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHdhbGxldFBhcmFtcy5lbnRlcnByaXNlID0gcGFyYW1zLmVudGVycHJpc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucykpIHtcbiAgICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucyBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICAgICAgfVxuICAgICAgICB3YWxsZXRQYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucyA9IHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmdhc1ByaWNlKSkge1xuICAgICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmdhc1ByaWNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBnYXMgcHJpY2UgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICB3YWxsZXRQYXJhbXMuZ2FzUHJpY2UgPSBwYXJhbXMuZ2FzUHJpY2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZGlzYWJsZUtSU0VtYWlsKSkge1xuICAgICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5kaXNhYmxlS1JTRW1haWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRpc2FibGVLUlNFbWFpbCBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICAgICAgfVxuICAgICAgICB3YWxsZXRQYXJhbXMuZGlzYWJsZUtSU0VtYWlsID0gcGFyYW1zLmRpc2FibGVLUlNFbWFpbDtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIGVhY2gga3JzU3BlY2lmaWMgcGFyYW0gaXMgZWl0aGVyIGEgc3RyaW5nLCBib29sZWFuLCBvciBudW1iZXJcbiAgICAgIGNvbnN0IHsga3JzU3BlY2lmaWMgfSA9IHBhcmFtcztcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChrcnNTcGVjaWZpYykpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoa3JzU3BlY2lmaWMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBjb25zdCB2YWwgPSBrcnNTcGVjaWZpY1trZXldO1xuICAgICAgICAgIGlmICghXy5pc0Jvb2xlYW4odmFsKSAmJiAhXy5pc1N0cmluZyh2YWwpICYmICFfLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna3JzU3BlY2lmaWMgb2JqZWN0IGNvbnRhaW5zIGlsbGVnYWwgdmFsdWVzLiB2YWx1ZXMgbXVzdCBiZSBzdHJpbmdzLCBib29sZWFucywgb3IgbnVtYmVycycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBkZXJpdmF0aW9uUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gICAgICBjb25zdCByZXFJZCA9IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG5cbiAgICAgIC8vIEFkZCB0aGUgdXNlciBrZXljaGFpblxuICAgICAgY29uc3QgdXNlcktleWNoYWluUHJvbWlzZSA9IGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgbGV0IHVzZXJLZXljaGFpblBhcmFtcztcbiAgICAgICAgbGV0IHVzZXJLZXljaGFpbjtcbiAgICAgICAgLy8gVXNlciBwcm92aWRlZCB1c2VyIGtleVxuICAgICAgICBpZiAocGFyYW1zLnVzZXJLZXkpIHtcbiAgICAgICAgICB1c2VyS2V5Y2hhaW4gPSB7IHB1YjogcGFyYW1zLnVzZXJLZXkgfTtcbiAgICAgICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMgPSB1c2VyS2V5Y2hhaW47XG4gICAgICAgICAgaWYgKHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBkZXJpdmF0aW9uIG9ubHkgbWFrZXMgc2Vuc2Ugd2hlbiBhIGtleSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgY29uc3QgZGVyaXZhdGlvbiA9IHNlbGYuYmFzZUNvaW4uZGVyaXZlS2V5V2l0aFNlZWQoe1xuICAgICAgICAgICAgICBrZXk6IHBhcmFtcy51c2VyS2V5LFxuICAgICAgICAgICAgICBzZWVkOiBwYXJhbXMuY29sZERlcml2YXRpb25TZWVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZXJpdmF0aW9uUGF0aCA9IGRlcml2YXRpb24uZGVyaXZhdGlvblBhdGg7XG4gICAgICAgICAgICB1c2VyS2V5Y2hhaW4ucHViID0gZGVyaXZhdGlvbi5rZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2FuRW5jcnlwdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2VuZXJhdGUgdXNlciBrZXlwYWlyIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHVzZXIga2V5LlxuICAgICAgICAgIHVzZXJLZXljaGFpbiA9IHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlKCk7XG4gICAgICAgICAgdXNlcktleWNoYWluLmVuY3J5cHRlZFBydiA9IHNlbGYuYml0Z28uZW5jcnlwdCh7IHBhc3N3b3JkOiBwYXNzcGhyYXNlLCBpbnB1dDogdXNlcktleWNoYWluLnBydiB9KTtcbiAgICAgICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMgPSB7XG4gICAgICAgICAgICBwdWI6IHVzZXJLZXljaGFpbi5wdWIsXG4gICAgICAgICAgICBlbmNyeXB0ZWRQcnY6IHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRQcnYsXG4gICAgICAgICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMucmVxSWQgPSByZXFJZDtcbiAgICAgICAgY29uc3QgbmV3VXNlcktleWNoYWluID0geWllbGQgc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5hZGQodXNlcktleWNoYWluUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBuZXdVc2VyS2V5Y2hhaW4sIHVzZXJLZXljaGFpbik7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuXG4gICAgICBjb25zdCBiYWNrdXBLZXljaGFpblByb21pc2UgPSBjbyhmdW5jdGlvbiooKSB7XG4gICAgICAgIGlmIChwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyIHx8IHNlbGYuYmFzZUNvaW4uZ2V0RmFtaWx5KCkgPT09ICdybWcnKSB7XG4gICAgICAgICAgLy8gSWYgcmVxdWVzdGVkLCB1c2UgYSBLUlMgb3IgYmFja3VwIGtleSBwcm92aWRlclxuICAgICAgICAgIHJldHVybiBzZWxmLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZUJhY2t1cCh7XG4gICAgICAgICAgICBwcm92aWRlcjogcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlciB8fCAnZGVmYXVsdFJNR0JhY2t1cFByb3ZpZGVyJyxcbiAgICAgICAgICAgIGRpc2FibGVLUlNFbWFpbDogcGFyYW1zLmRpc2FibGVLUlNFbWFpbCxcbiAgICAgICAgICAgIGtyc1NwZWNpZmljOiBwYXJhbXMua3JzU3BlY2lmaWMsXG4gICAgICAgICAgICB0eXBlOiBzZWxmLmJhc2VDb2luLmdldENoYWluKCksXG4gICAgICAgICAgICByZXFJZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZXIgcHJvdmlkZWQgYmFja3VwIHhwdWJcbiAgICAgICAgaWYgKHBhcmFtcy5iYWNrdXBYcHViKSB7XG4gICAgICAgICAgLy8gdXNlciBwcm92aWRlZCBiYWNrdXAgZXRoZXJldW0gYWRkcmVzc1xuICAgICAgICAgIHJldHVybiBzZWxmLmJhc2VDb2luLmtleWNoYWlucygpLmFkZCh7XG4gICAgICAgICAgICBwdWI6IHBhcmFtcy5iYWNrdXBYcHViLFxuICAgICAgICAgICAgc291cmNlOiAnYmFja3VwJyxcbiAgICAgICAgICAgIHJlcUlkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2FuRW5jcnlwdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2VuZXJhdGUgYmFja3VwIGtleXBhaXIgd2l0aG91dCBwYXNzcGhyYXNlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vIHByb3ZpZGVkIGJhY2t1cCB4cHViIG9yIGFkZHJlc3MsIHNvIGRlZmF1bHQgdG8gY3JlYXRpbmcgb25lIGhlcmVcbiAgICAgICAgICByZXR1cm4gc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGVCYWNrdXAoeyByZXFJZCB9KTtcbiAgICAgICAgfVxuICAgICAgfSkuY2FsbCh0aGlzKTtcblxuICAgICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH06IEtleWNoYWluc1RyaXBsZXQgPSB5aWVsZCBCbHVlYmlyZC5wcm9wcyh7XG4gICAgICAgIHVzZXJLZXljaGFpbjogdXNlcktleWNoYWluUHJvbWlzZSxcbiAgICAgICAgYmFja3VwS2V5Y2hhaW46IGJhY2t1cEtleWNoYWluUHJvbWlzZSxcbiAgICAgICAgYml0Z29LZXljaGFpbjogc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGVCaXRHbyh7IGVudGVycHJpc2U6IHBhcmFtcy5lbnRlcnByaXNlLCByZXFJZCB9KSxcbiAgICAgIH0pO1xuXG4gICAgICB3YWxsZXRQYXJhbXMua2V5cyA9IFt1c2VyS2V5Y2hhaW4uaWQsIGJhY2t1cEtleWNoYWluLmlkLCBiaXRnb0tleWNoYWluLmlkXTtcblxuICAgICAgd2FsbGV0UGFyYW1zLmlzQ29sZCA9IGlzQ29sZDtcblxuICAgICAgY29uc3QgeyBwcnYgfSA9IHVzZXJLZXljaGFpbjtcbiAgICAgIGlmIChfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgICAgd2FsbGV0UGFyYW1zLmtleVNpZ25hdHVyZXMgPSB7XG4gICAgICAgICAgYmFja3VwOiBzZWxmLmJhc2VDb2luLnNpZ25NZXNzYWdlKHsgcHJ2IH0sIGJhY2t1cEtleWNoYWluLnB1YikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIGJpdGdvOiBzZWxmLmJhc2VDb2luLnNpZ25NZXNzYWdlKHsgcHJ2IH0sIGJpdGdvS2V5Y2hhaW4ucHViKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmluY2x1ZGVzKFsneHJwJywgJ3hsbSddLCBzZWxmLmJhc2VDb2luLmdldEZhbWlseSgpKSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMucm9vdFByaXZhdGVLZXkpKSB7XG4gICAgICAgIHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSA9IHBhcmFtcy5yb290UHJpdmF0ZUtleTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5Y2hhaW5zID0ge1xuICAgICAgICB1c2VyS2V5Y2hhaW4sXG4gICAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgICBiaXRnb0tleWNoYWluLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmFsV2FsbGV0UGFyYW1zID0geWllbGQgc2VsZi5iYXNlQ29pbi5zdXBwbGVtZW50R2VuZXJhdGVXYWxsZXQod2FsbGV0UGFyYW1zLCBrZXljaGFpbnMpO1xuICAgICAgc2VsZi5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICAgIGNvbnN0IG5ld1dhbGxldCA9IHlpZWxkIHNlbGYuYml0Z29cbiAgICAgICAgLnBvc3Qoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSlcbiAgICAgICAgLnNlbmQoZmluYWxXYWxsZXRQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcblxuICAgICAgY29uc3QgcmVzdWx0OiBXYWxsZXRXaXRoS2V5Y2hhaW5zID0ge1xuICAgICAgICB3YWxsZXQ6IG5ldyBXYWxsZXQoc2VsZi5iaXRnbywgc2VsZi5iYXNlQ29pbiwgbmV3V2FsbGV0KSxcbiAgICAgICAgdXNlcktleWNoYWluOiB1c2VyS2V5Y2hhaW4sXG4gICAgICAgIGJhY2t1cEtleWNoYWluOiBiYWNrdXBLZXljaGFpbixcbiAgICAgICAgYml0Z29LZXljaGFpbjogYml0Z29LZXljaGFpbixcbiAgICAgIH07XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChiYWNrdXBLZXljaGFpbi5wcnYpKSB7XG4gICAgICAgIHJlc3VsdC53YXJuaW5nID0gJ0JlIHN1cmUgdG8gYmFja3VwIHRoZSBiYWNrdXAga2V5Y2hhaW4gLS0gaXQgaXMgbm90IHN0b3JlZCBhbnl3aGVyZSBlbHNlISc7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChkZXJpdmF0aW9uUGF0aCkpIHtcbiAgICAgICAgdXNlcktleWNoYWluLmRlcml2YXRpb25QYXRoID0gZGVyaXZhdGlvblBhdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0aGUgdXNlcidzIHdhbGxldCBzaGFyZXNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxpc3RTaGFyZXMocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZScpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHdhbGxldCBzaGFyZSBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nIHRoZSBlbmNyeXB0ZWQgc2hhcmluZyBrZXljaGFpbi4gcmVxdWlyZXMgdW5sb2NrIGlmIGtleWNoYWluIGlzIHByZXNlbnQuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byBnZXQgaW5mb3JtYXRpb24gb25cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRTaGFyZShwYXJhbXM6IHsgd2FsbGV0U2hhcmVJZD86IHN0cmluZyB9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAuZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0c2hhcmUvJyArIHBhcmFtcy53YWxsZXRTaGFyZUlkKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHdhbGxldCBzaGFyZVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gcGFyYW1zLnN0YXRlIC0gdGhlIG5ldyBzdGF0ZSBvZiB0aGUgd2FsbGV0IHNoYXJlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB1cGRhdGVTaGFyZShwYXJhbXM6IFVwZGF0ZVNoYXJlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZW5kIGEgd2FsbGV0IHNoYXJlIGludml0YXRpb24gZW1haWxcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHdob3NlIGludml0aWF0aW9uIHNob3VsZCBiZSByZXNlbnRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZXNlbmRTaGFyZUludml0ZShwYXJhbXM6IHsgd2FsbGV0U2hhcmVJZD86IHN0cmluZyB9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICAgIGNvbnN0IHVybFBhcnRzID0gcGFyYW1zLndhbGxldFNoYXJlSWQgKyAnL3Jlc2VuZGVtYWlsJztcbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLnBvc3Qoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgdXJsUGFydHMpKS5yZXN1bHQoKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYSB3YWxsZXQgc2hhcmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNhbmNlbFNoYXJlKHBhcmFtczogeyB3YWxsZXRTaGFyZUlkPzogc3RyaW5nIH0gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5kZWwodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKVxuICAgICAgLnNlbmQoKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIHdhbGxldCBzaGFyZSwgYWRkaW5nIHRoZSB3YWxsZXQgdG8gdGhlIHVzZXIncyBsaXN0XG4gICAqIE5lZWRzIGEgdXNlcidzIHBhc3N3b3JkIHRvIGRlY3J5cHQgdGhlIHNoYXJlZCBrZXlcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIGFjY2VwdFxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJQYXNzd29yZCAtIChyZXF1aXJlZCBpZiBtb3JlIGEga2V5Y2hhaW4gd2FzIHNoYXJlZCkgdXNlcidzIHBhc3N3b3JkIHRvIGRlY3J5cHQgdGhlIHNoYXJlZCB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtcy5uZXdXYWxsZXRQYXNzcGhyYXNlIC0gbmV3IHdhbGxldCBwYXNzcGhyYXNlIGZvciBzYXZpbmcgdGhlIHNoYXJlZCB3YWxsZXQgcHJ2LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBsZWZ0IGJsYW5rIGFuZCBhIHdhbGxldCB3aXRoIG1vcmUgdGhhbiB2aWV3IHBlcm1pc3Npb25zIHdhcyBzaGFyZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gdGhlIHVzZXIncyBsb2dpbiBwYXNzd29yZCBpcyB1c2VkLlxuICAgKiBAcGFyYW0gcGFyYW1zLm92ZXJyaWRlRW5jcnlwdGVkUHJ2IC0gc2V0IG9ubHkgaWYgdGhlIHBydiB3YXMgcmVjZWl2ZWQgb3V0LW9mLWJhbmQuXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgYWNjZXB0U2hhcmUocGFyYW1zOiBBY2NlcHRTaGFyZU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMoXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgWyd3YWxsZXRTaGFyZUlkJ10sXG4gICAgICAgIFsnb3ZlcnJpZGVFbmNyeXB0ZWRQcnYnLCAndXNlclBhc3N3b3JkJywgJ25ld1dhbGxldFBhc3NwaHJhc2UnXSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG5cbiAgICAgIGxldCBlbmNyeXB0ZWRQcnYgPSBwYXJhbXMub3ZlcnJpZGVFbmNyeXB0ZWRQcnY7XG5cbiAgICAgIGNvbnN0IHdhbGxldFNoYXJlID0geWllbGQgc2VsZi5nZXRTaGFyZSh7IHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkIH0pO1xuXG4gICAgICAvLyBSZXR1cm4gcmlnaHQgYXdheSBpZiB0aGVyZSBpcyBubyBrZXljaGFpbiB0byBkZWNyeXB0LCBvciBpZiBleHBsaWNpdCBlbmNyeXB0ZWRQcnYgd2FzIHByb3ZpZGVkXG4gICAgICBpZiAoIXdhbGxldFNoYXJlLmtleWNoYWluIHx8ICF3YWxsZXRTaGFyZS5rZXljaGFpbi5lbmNyeXB0ZWRQcnYgfHwgZW5jcnlwdGVkUHJ2KSB7XG4gICAgICAgIHJldHVybiBzZWxmLnVwZGF0ZVNoYXJlKHtcbiAgICAgICAgICB3YWxsZXRTaGFyZUlkOiBwYXJhbXMud2FsbGV0U2hhcmVJZCxcbiAgICAgICAgICBzdGF0ZTogJ2FjY2VwdGVkJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1vcmUgdGhhbiB2aWV3aW5nIHdhcyByZXF1ZXN0ZWQsIHNvIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgd2FsbGV0IGtleXMgdXNpbmcgdGhlIHNoYXJlZCBlY2RoIHNjaGVtZVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnVzZXJQYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyUGFzc3dvcmQgcGFyYW0gbXVzdCBiZSBwcm92aWRlZCB0byBkZWNyeXB0IHNoYXJlZCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hhcmluZ0tleWNoYWluID0geWllbGQgc2VsZi5iaXRnby5nZXRFQ0RIU2hhcmluZ0tleWNoYWluKCk7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzaGFyaW5nS2V5Y2hhaW4uZW5jcnlwdGVkWHBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNyeXB0ZWRYcHJ2IHdhcyBub3QgZm91bmQgb24gc2hhcmluZyBrZXljaGFpbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgd2UgaGF2ZSB0aGUgc2hhcmluZyBrZXljaGFpbiwgd2UgY2FuIHdvcmsgb3V0IHRoZSBzZWNyZXQgdXNlZCBmb3Igc2hhcmluZyB0aGUgd2FsbGV0IHdpdGggdXNcbiAgICAgIHNoYXJpbmdLZXljaGFpbi5wcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBwYXNzd29yZDogcGFyYW1zLnVzZXJQYXNzd29yZCxcbiAgICAgICAgaW5wdXQ6IHNoYXJpbmdLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2LFxuICAgICAgfSk7XG4gICAgICBjb25zdCByb290RXh0S2V5ID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChzaGFyaW5nS2V5Y2hhaW4ucHJ2KTtcblxuICAgICAgLy8gRGVyaXZlIGtleSBieSBwYXRoICh3aGljaCBpcyB1c2VkIGJldHdlZW4gdGhlc2UgMiB1c2VycyBvbmx5KVxuICAgICAgY29uc3QgcHJpdktleSA9IGhkUGF0aChyb290RXh0S2V5KS5kZXJpdmVLZXkod2FsbGV0U2hhcmUua2V5Y2hhaW4ucGF0aCk7XG4gICAgICBjb25zdCBzZWNyZXQgPSBzZWxmLmJpdGdvLmdldEVDREhTZWNyZXQoe1xuICAgICAgICBlY2tleTogcHJpdktleSxcbiAgICAgICAgb3RoZXJQdWJLZXlIZXg6IHdhbGxldFNoYXJlLmtleWNoYWluLmZyb21QdWJLZXksXG4gICAgICB9KTtcblxuICAgICAgLy8gWWVzISBXZSBnb3QgdGhlIHNlY3JldCBzdWNjZXNzZnVsbHkgaGVyZSwgbm93IGRlY3J5cHQgdGhlIHNoYXJlZCB3YWxsZXQgcHJ2XG4gICAgICBjb25zdCBkZWNyeXB0ZWRTaGFyZWRXYWxsZXRQcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBwYXNzd29yZDogc2VjcmV0LFxuICAgICAgICBpbnB1dDogd2FsbGV0U2hhcmUua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFdlIHdpbGwgbm93IHJlLWVuY3J5cHQgdGhlIHdhbGxldCB3aXRoIG91ciBvd24gcGFzc3dvcmRcbiAgICAgIGNvbnN0IG5ld1dhbGxldFBhc3NwaHJhc2UgPSBwYXJhbXMubmV3V2FsbGV0UGFzc3BocmFzZSB8fCBwYXJhbXMudXNlclBhc3N3b3JkO1xuICAgICAgZW5jcnlwdGVkUHJ2ID0gc2VsZi5iaXRnby5lbmNyeXB0KHtcbiAgICAgICAgcGFzc3dvcmQ6IG5ld1dhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIGlucHV0OiBkZWNyeXB0ZWRTaGFyZWRXYWxsZXRQcnYsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHVwZGF0ZVBhcmFtczogVXBkYXRlU2hhcmVPcHRpb25zID0ge1xuICAgICAgICB3YWxsZXRTaGFyZUlkOiBwYXJhbXMud2FsbGV0U2hhcmVJZCxcbiAgICAgICAgc3RhdGU6ICdhY2NlcHRlZCcsXG4gICAgICB9O1xuXG4gICAgICBpZiAoZW5jcnlwdGVkUHJ2KSB7XG4gICAgICAgIHVwZGF0ZVBhcmFtcy5lbmNyeXB0ZWRQcnYgPSBlbmNyeXB0ZWRQcnY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnVwZGF0ZVNoYXJlKHVwZGF0ZVBhcmFtcyk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgd2FsbGV0IGJ5IGl0cyBJRFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuaWQgd2FsbGV0IGlkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldFdhbGxldChwYXJhbXM6IEdldFdhbGxldE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8V2FsbGV0Pik6IEJsdWViaXJkPFdhbGxldD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxXYWxsZXQ+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgICAgY29uc3QgcXVlcnk6IEdldFdhbGxldE9wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChwYXJhbXMuYWxsVG9rZW5zKSB7XG4gICAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmFsbFRva2VucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5LmFsbFRva2VucyA9IHBhcmFtcy5hbGxUb2tlbnM7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKSk7XG5cbiAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHNlbGYuYml0Z29cbiAgICAgICAgLmdldChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgcGFyYW1zLmlkKSlcbiAgICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICByZXR1cm4gbmV3IFdhbGxldChzZWxmLmJpdGdvLCBzZWxmLmJhc2VDb2luLCB3YWxsZXQpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHdhbGxldCBieSBpdHMgYWRkcmVzc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyB3YWxsZXQgYWRkcmVzc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBnZXRXYWxsZXRCeUFkZHJlc3MocGFyYW1zOiBHZXRXYWxsZXRCeUFkZHJlc3NPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFdhbGxldD4pOiBCbHVlYmlyZDxXYWxsZXQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288V2FsbGV0PihmdW5jdGlvbiooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgICAgc2VsZi5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpKTtcblxuICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgc2VsZi5iaXRnby5nZXQoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXQvYWRkcmVzcy8nICsgcGFyYW1zLmFkZHJlc3MpKS5yZXN1bHQoKTtcbiAgICAgIHJldHVybiBuZXcgV2FsbGV0KHNlbGYuYml0Z28sIHNlbGYuYmFzZUNvaW4sIHdhbGxldCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGFueSBnaXZlbiBzdXBwb3J0ZWQgY29pbiwgZ2V0IHRvdGFsIGJhbGFuY2VzIGZvciBhbGwgd2FsbGV0cyBvZiB0aGF0XG4gICAqIGNvaW4gdHlwZSBvbiB0aGUgYWNjb3VudC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBnZXRUb3RhbEJhbGFuY2VzKHBhcmFtczoge30gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAuZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0L2JhbGFuY2VzJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19