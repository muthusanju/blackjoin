"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("../common");
var Bluebird = require("bluebird");
var _ = require("lodash");
var co = Bluebird.coroutine;
var PendingApproval = /** @class */ (function () {
    function PendingApproval(bitgo, baseCoin, pendingApprovalData, wallet) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this.wallet = wallet;
        this._pendingApproval = pendingApprovalData;
    }
    /**
     * Get the id for this PendingApproval
     */
    PendingApproval.prototype.id = function () {
        return this._pendingApproval.id;
    };
    /**
     * Get the owner type (wallet or enterprise)
     * Pending approvals can be approved or modified by different scopes (depending on how they were created)
     * If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
     * If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
     */
    PendingApproval.prototype.ownerType = function () {
        if (this._pendingApproval.wallet) {
            return "wallet" /* WALLET */;
        }
        else if (this._pendingApproval.enterprise) {
            return "enterprise" /* ENTERPRISE */;
        }
        else {
            throw new Error('unexpected pending approval owner: neither wallet nor enterprise was present');
        }
    };
    /**
     * Get the id of the wallet which is associated with this PendingApproval
     */
    PendingApproval.prototype.walletId = function () {
        return this._pendingApproval.wallet;
    };
    /**
     * Get the enterprise ID that is associated with this PendingApproval
     */
    PendingApproval.prototype.enterpriseId = function () {
        return this._pendingApproval.enterprise;
    };
    /**
     * Get the state of this PendingApproval
     */
    PendingApproval.prototype.state = function () {
        return this._pendingApproval.state;
    };
    /**
     * Get the id of the user that performed the action resulting in this PendingApproval
     */
    PendingApproval.prototype.creator = function () {
        return this._pendingApproval.creator;
    };
    /**
     * Get the type of the pending approval (what it approves)
     */
    PendingApproval.prototype.type = function () {
        if (!this._pendingApproval.info) {
            throw new Error('pending approval info is not available');
        }
        return this._pendingApproval.info.type;
    };
    /**
     * Get information about this PendingApproval
     */
    PendingApproval.prototype.info = function () {
        return this._pendingApproval.info;
    };
    /**
     * Get the number of approvals that are required for this PendingApproval to be approved.
     * Defaults to 1 if approvalsRequired doesn't exist on the object
     */
    PendingApproval.prototype.approvalsRequired = function () {
        return this._pendingApproval.approvalsRequired || 1;
    };
    /**
     * Generate a url for this PendingApproval for making requests to the server.
     * @param extra
     */
    PendingApproval.prototype.url = function (extra) {
        if (extra === void 0) { extra = ''; }
        return this.baseCoin.url('/pendingapprovals/' + this.id() + extra);
    };
    /**
     * Refetches this PendingApproval from the server and returns it.
     *
     * Note that this mutates the PendingApproval object in place.
     * @param params
     * @param callback
     */
    PendingApproval.prototype.get = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = self;
                        return [4 /*yield*/, self.bitgo.get(self.url()).result()];
                    case 1:
                        _a._pendingApproval = _b.sent();
                        return [2 /*return*/, self];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Helper function to ensure that self.wallet is set
     */
    PendingApproval.prototype.populateWallet = function () {
        var self = this;
        return co(function () {
            var transactionRequest, updatedWallet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        transactionRequest = self.info().transactionRequest;
                        if (_.isUndefined(transactionRequest)) {
                            throw new Error('missing required object property transactionRequest');
                        }
                        if (!_.isUndefined(self.wallet)) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.baseCoin.wallets().get({ id: transactionRequest.sourceWallet })];
                    case 1:
                        updatedWallet = _a.sent();
                        if (_.isUndefined(updatedWallet)) {
                            throw new Error('unexpected - unable to get wallet using sourcewallet');
                        }
                        self.wallet = updatedWallet;
                        _a.label = 2;
                    case 2:
                        if (self.wallet.id() !== transactionRequest.sourceWallet) {
                            throw new Error('unexpected source wallet for pending approval');
                        }
                        return [2 /*return*/];
                }
            });
        }).call(this);
    };
    /**
     * Sets this PendingApproval to an approved state
     */
    PendingApproval.prototype.approve = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            /*
             * Internal helper function to get the serialized transaction which is being approved
             */
            function getApprovalTransaction() {
                return co(function () {
                    var transaction;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(self.type() === 'transactionRequest')) return [3 /*break*/, 3];
                                /*
                                 * If this is a request for approving a transaction, depending on whether this user has a private key to the wallet
                                 * (some admins may not have the spend permission), the transaction could either be rebroadcast as is, or it could
                                 * be reconstructed. It is preferable to reconstruct a tx in order to adhere to the latest network conditions
                                 * such as newer unspents, different fees, or a higher sequence id
                                 */
                                if (params.tx) {
                                    // the approval tx was reconstructed and explicitly specified - pass it through
                                    return [2 /*return*/, {
                                            txHex: params.tx,
                                        }];
                                }
                                transaction = _.get(self.info(), "transactionRequest.coinSpecific." + self.baseCoin.type);
                                // this user may not have spending privileges or a passphrase may not have been passed in
                                if (!canRecreateTransaction) {
                                    if (!_.isObject(transaction)) {
                                        throw new Error('there is neither an original transaction object nor can a new one be recreated');
                                    }
                                    return [2 /*return*/, transaction];
                                }
                                return [4 /*yield*/, self.populateWallet()];
                            case 1:
                                _a.sent();
                                return [4 /*yield*/, self.recreateAndSignTransaction(params)];
                            case 2: return [2 /*return*/, _a.sent()];
                            case 3: return [2 /*return*/];
                        }
                    });
                }).call(this);
            }
            /*
             * Internal helper function to prepare the approval payload and send it to bitgo
             */
            function sendApproval(transaction) {
                return co(function () {
                    var approvalParams;
                    return __generator(this, function (_a) {
                        approvalParams = { state: 'approved', otp: params.otp };
                        if (transaction) {
                            // if the transaction already has a half signed property, we take that directly
                            approvalParams.halfSigned = transaction.halfSigned || transaction;
                        }
                        return [2 /*return*/, self.bitgo
                                .put(self.url())
                                .send(approvalParams)
                                .result()
                                .nodeify(callback)];
                    });
                }).call(this);
            }
            var canRecreateTransaction, isColdWallet, isOFCWallet, approvalTransaction, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common_1.validateParams(params, [], ['walletPassphrase', 'otp'], callback);
                        canRecreateTransaction = true;
                        isColdWallet = !!_.get(self.wallet, '_wallet.isCold');
                        isOFCWallet = self.baseCoin.getFamily() === 'ofc';
                        if (!params.xprv && !(params.walletPassphrase && !isColdWallet && !isOFCWallet)) {
                            canRecreateTransaction = false;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, getApprovalTransaction()];
                    case 2:
                        approvalTransaction = _a.sent();
                        return [4 /*yield*/, sendApproval(approvalTransaction)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        e_1 = _a.sent();
                        if (!canRecreateTransaction &&
                            (e_1.message.indexOf('could not find unspent output for input') !== -1 ||
                                e_1.message.indexOf('transaction conflicts with an existing transaction in the send queue') !== -1)) {
                            throw new Error('unspents expired, wallet passphrase or xprv required to recreate transaction');
                        }
                        throw e_1;
                    case 5: return [2 /*return*/];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Sets this PendingApproval to a rejected state
     * @param params
     * @param callback
     */
    PendingApproval.prototype.reject = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo
            .put(this.url())
            .send({ state: 'rejected' })
            .result()
            .nodeify(callback);
    };
    /**
     * Alias for PendingApproval.reject()
     *
     * @deprecated
     * @param params
     * @param callback
     */
    PendingApproval.prototype.cancel = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.reject(params, callback);
    };
    /**
     * Recreate a transaction for a pending approval to respond to updated network conditions
     * @param params
     * @param callback
     */
    PendingApproval.prototype.recreateAndSignTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var transactionRequest, originalPrebuild, recipients, prebuildParams, signedTransaction, originalParsedTransaction, recreatedParsedTransaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        transactionRequest = self.info().transactionRequest;
                        if (_.isUndefined(transactionRequest)) {
                            throw new Error('cannot recreate transaction without transaction request');
                        }
                        if (_.isUndefined(self.wallet)) {
                            throw new Error('cannot recreate transaction without wallet');
                        }
                        originalPrebuild = transactionRequest.coinSpecific[self.baseCoin.type];
                        recipients = transactionRequest.recipients;
                        prebuildParams = _.extend({}, params, { recipients: recipients }, transactionRequest.buildParams);
                        if (!_.isUndefined(originalPrebuild.hopTransaction)) {
                            prebuildParams.hop = true;
                        }
                        return [4 /*yield*/, self.wallet.prebuildAndSignTransaction(prebuildParams)];
                    case 1:
                        signedTransaction = _a.sent();
                        return [4 /*yield*/, self.baseCoin.parseTransaction({
                                txParams: prebuildParams,
                                wallet: self.wallet,
                                txPrebuild: originalPrebuild,
                            })];
                    case 2:
                        originalParsedTransaction = _a.sent();
                        return [4 /*yield*/, self.baseCoin.parseTransaction({
                                txParams: prebuildParams,
                                wallet: self.wallet,
                                txPrebuild: signedTransaction,
                            })];
                    case 3:
                        recreatedParsedTransaction = _a.sent();
                        if (_.isUndefined(recreatedParsedTransaction.implicitExternalSpendAmount)) {
                            return [2 /*return*/, signedTransaction];
                        }
                        if (!_.isFinite(recreatedParsedTransaction.implicitExternalSpendAmount)) {
                            throw new Error('implicit external spend amount could not be determined');
                        }
                        if (!_.isUndefined(originalParsedTransaction.implicitExternalSpendAmount) &&
                            recreatedParsedTransaction.implicitExternalSpendAmount > originalParsedTransaction.implicitExternalSpendAmount) {
                            throw new Error('recreated transaction is using a higher pay-as-you-go-fee');
                        }
                        return [2 /*return*/, signedTransaction];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return PendingApproval;
}());
exports.PendingApproval = PendingApproval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ0FwcHJvdmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL3BlbmRpbmdBcHByb3ZhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLG9DQUEyQztBQUMzQyxtQ0FBcUM7QUFDckMsMEJBQTRCO0FBTTVCLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFxRDlCO0lBTUUseUJBQVksS0FBWSxFQUFFLFFBQWtCLEVBQUUsbUJBQXdDLEVBQUUsTUFBZTtRQUNyRyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsbUJBQW1CLENBQUM7SUFDOUMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsNEJBQUUsR0FBRjtRQUNFLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxtQ0FBUyxHQUFUO1FBQ0UsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFO1lBQ2hDLDZCQUF3QjtTQUN6QjthQUFNLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRTtZQUMzQyxxQ0FBNEI7U0FDN0I7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsOEVBQThFLENBQUMsQ0FBQztTQUNqRztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILGtDQUFRLEdBQVI7UUFDRSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7SUFDdEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsc0NBQVksR0FBWjtRQUNFLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQztJQUMx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Qjs2QkFDOUIsQ0FBQyxFQUFBOzt3QkFKSSwwQkFBMEIsR0FBRyxTQUlqQzt3QkFFRixJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsMEJBQTBCLENBQUMsMkJBQTJCLENBQUMsRUFBRTs0QkFDekUsc0JBQU8saUJBQWlCLEVBQUM7eUJBQzFCO3dCQUVELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLDBCQUEwQixDQUFDLDJCQUEyQixDQUFDLEVBQUU7NEJBQ3ZFLE1BQU0sSUFBSSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQzt5QkFDM0U7d0JBQ0QsSUFDRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMseUJBQXlCLENBQUMsMkJBQTJCLENBQUM7NEJBQ3JFLDBCQUEwQixDQUFDLDJCQUEyQixHQUFHLHlCQUF5QixDQUFDLDJCQUEyQixFQUM5Rzs0QkFDQSxNQUFNLElBQUksS0FBSyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7eUJBQzlFO3dCQUNELHNCQUFPLGlCQUFpQixFQUFDOzs7U0FDMUIsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0FBQyxBQWxVRCxJQWtVQztBQWxVWSwwQ0FBZSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vYml0Z28nO1xuaW1wb3J0IHsgdmFsaWRhdGVQYXJhbXMgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCB7IEJhc2VDb2luIH0gZnJvbSAnLi9iYXNlQ29pbic7XG5cbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBlbmRpbmdBcHByb3ZhbEluZm8ge1xuICB0eXBlOiBUeXBlO1xuICB0cmFuc2FjdGlvblJlcXVlc3Q/OiB7XG4gICAgY29pblNwZWNpZmljOiBhbnk7XG4gICAgcmVjaXBpZW50czogYW55O1xuICAgIGJ1aWxkUGFyYW1zOiBhbnk7XG4gICAgc291cmNlV2FsbGV0Pzogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBlbmRpbmdBcHByb3ZhbERhdGEge1xuICBpZDogc3RyaW5nO1xuICB3YWxsZXQ/OiBzdHJpbmc7XG4gIGVudGVycHJpc2U/OiBzdHJpbmc7XG4gIHN0YXRlOiBTdGF0ZTtcbiAgY3JlYXRvcjogc3RyaW5nO1xuICBpbmZvOiBQZW5kaW5nQXBwcm92YWxJbmZvO1xuICBhcHByb3ZhbHNSZXF1aXJlZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gT3duZXJUeXBlIHtcbiAgV0FMTEVUID0gJ3dhbGxldCcsXG4gIEVOVEVSUFJJU0UgPSAnZW50ZXJwcmlzZScsXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIFN0YXRlIHtcbiAgUEVORElORyA9ICdwZW5kaW5nJyxcbiAgQVdBSVRJTkdfU0lHTkFUVVJFID0gJ2F3YWl0aW5nU2lnbmF0dXJlJyxcbiAgUEVORElOR19CSVRHT19BRE1JTl9BUFBST1ZBTCA9ICdwZW5kaW5nQml0R29BZG1pbkFwcHJvdmFsJyxcbiAgUEVORElOR19JRF9WRVJJRklDQVRJT04gPSAncGVuZGluZ0lkVmVyaWZpY2F0aW9uJyxcbiAgUEVORElOR19DVVNUT0RJQU5fQVBQUk9WQUwgPSAncGVuZGluZ0N1c3RvZGlhbkFwcHJvdmFsJyxcbiAgUEVORElOR19GSU5BTF9BUFBST1ZBTCA9ICdwZW5kaW5nRmluYWxBcHByb3ZhbCcsXG4gIEFQUFJPVkVEID0gJ2FwcHJvdmVkJyxcbiAgUFJPQ0VTU0lORyA9ICdwcm9jZXNzaW5nJyxcbiAgUkVKRUNURUQgPSAncmVqZWN0ZWQnLFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBUeXBlIHtcbiAgVVNFUl9DSEFOR0VfUkVRVUVTVCA9ICd1c2VyQ2hhbmdlUmVxdWVzdCcsXG4gIFRSQU5TQUNUSU9OX1JFUVVFU1QgPSAndHJhbnNhY3Rpb25SZXF1ZXN0JyxcbiAgUE9MSUNZX1JVTEVfUkVRVUVTVCA9ICdwb2xpY3lSdWxlUmVxdWVzdCcsXG4gIFVQREFURV9BUFBST1ZBTFNfUkVRVUlSRURfUkVRVUVTVCA9ICd1cGRhdGVBcHByb3ZhbHNSZXF1aXJlZFJlcXVlc3QnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFwcHJvdmVPcHRpb25zIHtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xuICB0eD86IHN0cmluZztcbiAgeHBydj86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFBlbmRpbmdBcHByb3ZhbCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBCYXNlQ29pbjtcbiAgcHJpdmF0ZSB3YWxsZXQ/OiBXYWxsZXQ7XG4gIHByaXZhdGUgX3BlbmRpbmdBcHByb3ZhbDogUGVuZGluZ0FwcHJvdmFsRGF0YTtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIGJhc2VDb2luOiBCYXNlQ29pbiwgcGVuZGluZ0FwcHJvdmFsRGF0YTogUGVuZGluZ0FwcHJvdmFsRGF0YSwgd2FsbGV0PzogV2FsbGV0KSB7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICAgIHRoaXMuYmFzZUNvaW4gPSBiYXNlQ29pbjtcbiAgICB0aGlzLndhbGxldCA9IHdhbGxldDtcbiAgICB0aGlzLl9wZW5kaW5nQXBwcm92YWwgPSBwZW5kaW5nQXBwcm92YWxEYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQgZm9yIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuaWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvd25lciB0eXBlICh3YWxsZXQgb3IgZW50ZXJwcmlzZSlcbiAgICogUGVuZGluZyBhcHByb3ZhbHMgY2FuIGJlIGFwcHJvdmVkIG9yIG1vZGlmaWVkIGJ5IGRpZmZlcmVudCBzY29wZXMgKGRlcGVuZGluZyBvbiBob3cgdGhleSB3ZXJlIGNyZWF0ZWQpXG4gICAqIElmIGEgcGVuZGluZyBhcHByb3ZhbCBpcyBvd25lZCBieSBhIHdhbGxldCwgdGhlbiBpdCBjYW4gYmUgYXBwcm92ZWQgYnkgYWRtaW5pc3RyYXRvcnMgb2YgdGhlIHdhbGxldFxuICAgKiBJZiBhIHBlbmRpbmcgYXBwcm92YWwgaXMgb3duZWQgYnkgYW4gZW50ZXJwcmlzZSwgdGhlbiBpdCBjYW4gYmUgYXBwcm92ZWQgYnkgYWRtaW5pc3RyYXRvcnMgb2YgdGhlIGVudGVycHJpc2VcbiAgICovXG4gIG93bmVyVHlwZSgpOiBPd25lclR5cGUge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nQXBwcm92YWwud2FsbGV0KSB7XG4gICAgICByZXR1cm4gT3duZXJUeXBlLldBTExFVDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5lbnRlcnByaXNlKSB7XG4gICAgICByZXR1cm4gT3duZXJUeXBlLkVOVEVSUFJJU0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwZW5kaW5nIGFwcHJvdmFsIG93bmVyOiBuZWl0aGVyIHdhbGxldCBub3IgZW50ZXJwcmlzZSB3YXMgcHJlc2VudCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlkIG9mIHRoZSB3YWxsZXQgd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICB3YWxsZXRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwud2FsbGV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW50ZXJwcmlzZSBJRCB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgZW50ZXJwcmlzZUlkKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5lbnRlcnByaXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdGUgb2YgdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIHN0YXRlKCk6IFN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLnN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQgb2YgdGhlIHVzZXIgdGhhdCBwZXJmb3JtZWQgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW4gdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIGNyZWF0b3IoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmNyZWF0b3I7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0eXBlIG9mIHRoZSBwZW5kaW5nIGFwcHJvdmFsICh3aGF0IGl0IGFwcHJvdmVzKVxuICAgKi9cbiAgdHlwZSgpOiBUeXBlIHtcbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BlbmRpbmcgYXBwcm92YWwgaW5mbyBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pbmZvLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBpbmZvKCk6IFBlbmRpbmdBcHByb3ZhbEluZm8ge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuaW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBhcHByb3ZhbHMgdGhhdCBhcmUgcmVxdWlyZWQgZm9yIHRoaXMgUGVuZGluZ0FwcHJvdmFsIHRvIGJlIGFwcHJvdmVkLlxuICAgKiBEZWZhdWx0cyB0byAxIGlmIGFwcHJvdmFsc1JlcXVpcmVkIGRvZXNuJ3QgZXhpc3Qgb24gdGhlIG9iamVjdFxuICAgKi9cbiAgYXBwcm92YWxzUmVxdWlyZWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmFwcHJvdmFsc1JlcXVpcmVkIHx8IDE7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB1cmwgZm9yIHRoaXMgUGVuZGluZ0FwcHJvdmFsIGZvciBtYWtpbmcgcmVxdWVzdHMgdG8gdGhlIHNlcnZlci5cbiAgICogQHBhcmFtIGV4dHJhXG4gICAqL1xuICB1cmwoZXh0cmE6IHN0cmluZyA9ICcnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi51cmwoJy9wZW5kaW5nYXBwcm92YWxzLycgKyB0aGlzLmlkKCkgKyBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmZXRjaGVzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIGZyb20gdGhlIHNlcnZlciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbXV0YXRlcyB0aGUgUGVuZGluZ0FwcHJvdmFsIG9iamVjdCBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldChwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFBlbmRpbmdBcHByb3ZhbD4pOiBCbHVlYmlyZDxQZW5kaW5nQXBwcm92YWw+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UGVuZGluZ0FwcHJvdmFsPihmdW5jdGlvbiooKSB7XG4gICAgICBzZWxmLl9wZW5kaW5nQXBwcm92YWwgPSB5aWVsZCBzZWxmLmJpdGdvLmdldChzZWxmLnVybCgpKS5yZXN1bHQoKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCBzZWxmLndhbGxldCBpcyBzZXRcbiAgICovXG4gIHByaXZhdGUgcG9wdWxhdGVXYWxsZXQoKTogQmx1ZWJpcmQ8dW5kZWZpbmVkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHVuZGVmaW5lZD4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25SZXF1ZXN0ID0gc2VsZi5pbmZvKCkudHJhbnNhY3Rpb25SZXF1ZXN0O1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodHJhbnNhY3Rpb25SZXF1ZXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgb2JqZWN0IHByb3BlcnR5IHRyYW5zYWN0aW9uUmVxdWVzdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzZWxmLndhbGxldCkpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFdhbGxldDogV2FsbGV0ID0geWllbGQgc2VsZi5iYXNlQ29pbi53YWxsZXRzKCkuZ2V0KHsgaWQ6IHRyYW5zYWN0aW9uUmVxdWVzdC5zb3VyY2VXYWxsZXQgfSk7XG5cbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodXBkYXRlZFdhbGxldCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgLSB1bmFibGUgdG8gZ2V0IHdhbGxldCB1c2luZyBzb3VyY2V3YWxsZXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYud2FsbGV0ID0gdXBkYXRlZFdhbGxldDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYud2FsbGV0LmlkKCkgIT09IHRyYW5zYWN0aW9uUmVxdWVzdC5zb3VyY2VXYWxsZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHNvdXJjZSB3YWxsZXQgZm9yIHBlbmRpbmcgYXBwcm92YWwnKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkXG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIHRvIGFuIGFwcHJvdmVkIHN0YXRlXG4gICAqL1xuICBhcHByb3ZlKHBhcmFtczogQXBwcm92ZU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAnb3RwJ10sIGNhbGxiYWNrKTtcblxuICAgICAgbGV0IGNhblJlY3JlYXRlVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgLypcbiAgICAgICAqIENvbGQgd2FsbGV0cyBjYW5ub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb25zIGlmIHRoZSBvbmx5IHRoaW5nIHByb3ZpZGVkIGlzIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgICAgICpcbiAgICAgICAqIFRoZSB0cmFuc2FjdGlvbiBjYW4gYmUgcmVjcmVhdGVkIGlmIGVpdGhlclxuICAgICAgICog4oCTIHRoZXJlIGlzIGFuIHhwcnZcbiAgICAgICAqIOKAkyB0aGVyZSBpcyBhIHdhbGxldFBhc3NwaHJhc2UgYW5kIHRoZSB3YWxsZXQgaXMgbm90IGNvbGQgKGJlY2F1c2UgaWYgaXQncyBjb2xkLCB0aGUgcGFzc3BocmFzZSBpcyBvZiBsaXR0bGUgdXNlKVxuICAgICAgICpcbiAgICAgICAqIFRoZXJlZm9yZSwgaWYgbmVpdGhlciBvZiB0aGVzZSBpcyB0cnVlLCB0aGUgdHJhbnNhY3Rpb24gY2Fubm90IGJlIHJlY3JlYXRlZCwgd2hpY2ggaXMgcmVmbGVjdGVkIGluIHRoZSBpZlxuICAgICAgICogc3RhdGVtZW50IGJlbG93LlxuICAgICAgICovXG4gICAgICBjb25zdCBpc0NvbGRXYWxsZXQgPSAhIV8uZ2V0KHNlbGYud2FsbGV0LCAnX3dhbGxldC5pc0NvbGQnKTtcbiAgICAgIGNvbnN0IGlzT0ZDV2FsbGV0ID0gc2VsZi5iYXNlQ29pbi5nZXRGYW1pbHkoKSA9PT0gJ29mYyc7IC8vIE9mZi1jaGFpbiB0cmFuc2FjdGlvbnMgZG9uJ3QgbmVlZCB0byBiZSByZWJ1aWx0XG4gICAgICBpZiAoIXBhcmFtcy54cHJ2ICYmICEocGFyYW1zLndhbGxldFBhc3NwaHJhc2UgJiYgIWlzQ29sZFdhbGxldCAmJiAhaXNPRkNXYWxsZXQpKSB7XG4gICAgICAgIGNhblJlY3JlYXRlVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gd2hpY2ggaXMgYmVpbmcgYXBwcm92ZWRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2V0QXBwcm92YWxUcmFuc2FjdGlvbigpOiBCbHVlYmlyZDx7IHR4SGV4OiBzdHJpbmcgfT4ge1xuICAgICAgICByZXR1cm4gY288eyB0eEhleDogc3RyaW5nIH0+KGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICBpZiAoc2VsZi50eXBlKCkgPT09ICd0cmFuc2FjdGlvblJlcXVlc3QnKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIHJlcXVlc3QgZm9yIGFwcHJvdmluZyBhIHRyYW5zYWN0aW9uLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGlzIHVzZXIgaGFzIGEgcHJpdmF0ZSBrZXkgdG8gdGhlIHdhbGxldFxuICAgICAgICAgICAgICogKHNvbWUgYWRtaW5zIG1heSBub3QgaGF2ZSB0aGUgc3BlbmQgcGVybWlzc2lvbiksIHRoZSB0cmFuc2FjdGlvbiBjb3VsZCBlaXRoZXIgYmUgcmVicm9hZGNhc3QgYXMgaXMsIG9yIGl0IGNvdWxkXG4gICAgICAgICAgICAgKiBiZSByZWNvbnN0cnVjdGVkLiBJdCBpcyBwcmVmZXJhYmxlIHRvIHJlY29uc3RydWN0IGEgdHggaW4gb3JkZXIgdG8gYWRoZXJlIHRvIHRoZSBsYXRlc3QgbmV0d29yayBjb25kaXRpb25zXG4gICAgICAgICAgICAgKiBzdWNoIGFzIG5ld2VyIHVuc3BlbnRzLCBkaWZmZXJlbnQgZmVlcywgb3IgYSBoaWdoZXIgc2VxdWVuY2UgaWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50eCkge1xuICAgICAgICAgICAgICAvLyB0aGUgYXBwcm92YWwgdHggd2FzIHJlY29uc3RydWN0ZWQgYW5kIGV4cGxpY2l0bHkgc3BlY2lmaWVkIC0gcGFzcyBpdCB0aHJvdWdoXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHhIZXg6IHBhcmFtcy50eCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBfLmdldChzZWxmLmluZm8oKSwgYHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWMuJHtzZWxmLmJhc2VDb2luLnR5cGV9YCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgdXNlciBtYXkgbm90IGhhdmUgc3BlbmRpbmcgcHJpdmlsZWdlcyBvciBhIHBhc3NwaHJhc2UgbWF5IG5vdCBoYXZlIGJlZW4gcGFzc2VkIGluXG4gICAgICAgICAgICBpZiAoIWNhblJlY3JlYXRlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFfLmlzT2JqZWN0KHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlcmUgaXMgbmVpdGhlciBhbiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBvYmplY3Qgbm9yIGNhbiBhIG5ldyBvbmUgYmUgcmVjcmVhdGVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5aWVsZCBzZWxmLnBvcHVsYXRlV2FsbGV0KCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgc2VsZi5yZWNyZWF0ZUFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBwcmVwYXJlIHRoZSBhcHByb3ZhbCBwYXlsb2FkIGFuZCBzZW5kIGl0IHRvIGJpdGdvXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHNlbmRBcHByb3ZhbCh0cmFuc2FjdGlvbjogeyB0eEhleDogc3RyaW5nOyBoYWxmU2lnbmVkPzogc3RyaW5nIH0pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICAgICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICBjb25zdCBhcHByb3ZhbFBhcmFtczogYW55ID0geyBzdGF0ZTogJ2FwcHJvdmVkJywgb3RwOiBwYXJhbXMub3RwIH07XG4gICAgICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgdHJhbnNhY3Rpb24gYWxyZWFkeSBoYXMgYSBoYWxmIHNpZ25lZCBwcm9wZXJ0eSwgd2UgdGFrZSB0aGF0IGRpcmVjdGx5XG4gICAgICAgICAgICBhcHByb3ZhbFBhcmFtcy5oYWxmU2lnbmVkID0gdHJhbnNhY3Rpb24uaGFsZlNpZ25lZCB8fCB0cmFuc2FjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGYuYml0Z29cbiAgICAgICAgICAgIC5wdXQoc2VsZi51cmwoKSlcbiAgICAgICAgICAgIC5zZW5kKGFwcHJvdmFsUGFyYW1zKVxuICAgICAgICAgICAgLnJlc3VsdCgpXG4gICAgICAgICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmFsVHJhbnNhY3Rpb24gPSB5aWVsZCBnZXRBcHByb3ZhbFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIHJldHVybiB5aWVsZCBzZW5kQXBwcm92YWwoYXBwcm92YWxUcmFuc2FjdGlvbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhY2FuUmVjcmVhdGVUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgIChlLm1lc3NhZ2UuaW5kZXhPZignY291bGQgbm90IGZpbmQgdW5zcGVudCBvdXRwdXQgZm9yIGlucHV0JykgIT09IC0xIHx8XG4gICAgICAgICAgICBlLm1lc3NhZ2UuaW5kZXhPZigndHJhbnNhY3Rpb24gY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24gaW4gdGhlIHNlbmQgcXVldWUnKSAhPT0gLTEpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zcGVudHMgZXhwaXJlZCwgd2FsbGV0IHBhc3NwaHJhc2Ugb3IgeHBydiByZXF1aXJlZCB0byByZWNyZWF0ZSB0cmFuc2FjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIFBlbmRpbmdBcHByb3ZhbCB0byBhIHJlamVjdGVkIHN0YXRlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWplY3QocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5wdXQodGhpcy51cmwoKSlcbiAgICAgIC5zZW5kKHsgc3RhdGU6ICdyZWplY3RlZCcgfSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBQZW5kaW5nQXBwcm92YWwucmVqZWN0KClcbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNhbmNlbChwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QocGFyYW1zLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVjcmVhdGUgYSB0cmFuc2FjdGlvbiBmb3IgYSBwZW5kaW5nIGFwcHJvdmFsIHRvIHJlc3BvbmQgdG8gdXBkYXRlZCBuZXR3b3JrIGNvbmRpdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtczogYW55ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgLy8gdGhpcyBtZXRob2Qgb25seSBtYWtlcyBzZW5zZSB3aXRoIGV4aXN0aW5nIHRyYW5zYWN0aW9uIHJlcXVlc3RzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSBzZWxmLmluZm8oKS50cmFuc2FjdGlvblJlcXVlc3Q7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0cmFuc2FjdGlvblJlcXVlc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlY3JlYXRlIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gcmVxdWVzdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzZWxmLndhbGxldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb24gd2l0aG91dCB3YWxsZXQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3JpZ2luYWxQcmVidWlsZCA9IHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWNbc2VsZi5iYXNlQ29pbi50eXBlXTtcblxuICAgICAgY29uc3QgcmVjaXBpZW50cyA9IHRyYW5zYWN0aW9uUmVxdWVzdC5yZWNpcGllbnRzO1xuICAgICAgY29uc3QgcHJlYnVpbGRQYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zLCB7IHJlY2lwaWVudHM6IHJlY2lwaWVudHMgfSwgdHJhbnNhY3Rpb25SZXF1ZXN0LmJ1aWxkUGFyYW1zKTtcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9yaWdpbmFsUHJlYnVpbGQuaG9wVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgIHByZWJ1aWxkUGFyYW1zLmhvcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0geWllbGQgc2VsZi53YWxsZXQucHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb24ocHJlYnVpbGRQYXJhbXMpO1xuICAgICAgLy8gY29tcGFyZSBQQVlHbyBmZWVzXG4gICAgICBjb25zdCBvcmlnaW5hbFBhcnNlZFRyYW5zYWN0aW9uID0geWllbGQgc2VsZi5iYXNlQ29pbi5wYXJzZVRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHhQYXJhbXM6IHByZWJ1aWxkUGFyYW1zLFxuICAgICAgICB3YWxsZXQ6IHNlbGYud2FsbGV0LFxuICAgICAgICB0eFByZWJ1aWxkOiBvcmlnaW5hbFByZWJ1aWxkLFxuICAgICAgfSk7XG4gICAgICBjb25zdCByZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbiA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ucGFyc2VUcmFuc2FjdGlvbih7XG4gICAgICAgIHR4UGFyYW1zOiBwcmVidWlsZFBhcmFtcyxcbiAgICAgICAgd2FsbGV0OiBzZWxmLndhbGxldCxcbiAgICAgICAgdHhQcmVidWlsZDogc2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgICB9KTtcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50KSkge1xuICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc0Zpbml0ZShyZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmQgYW1vdW50IGNvdWxkIG5vdCBiZSBkZXRlcm1pbmVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKG9yaWdpbmFsUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50KSAmJlxuICAgICAgICByZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQgPiBvcmlnaW5hbFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjcmVhdGVkIHRyYW5zYWN0aW9uIGlzIHVzaW5nIGEgaGlnaGVyIHBheS1hcy15b3UtZ28tZmVlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cbn1cbiJdfQ==