"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var unspents_1 = require("@bitgo/unspents");
var request = require("superagent");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var _ = require("lodash");
var bitcoin = require("bitgo-utxo-lib");
/**
 * An instance of the recovery tool, which encapsulates the recovery functions
 * Instantiated with parameters:
 *   - bitgo: an instance of the bitgo SDK
 *   - sourceCoin: the coin that needs to be recovered
 *   - recoveryCoin: the type of address the faulty transaction was sent to
 */
var CrossChainRecoveryTool = /** @class */ (function () {
    function CrossChainRecoveryTool(opts) {
        this.bitgo = opts.bitgo;
        this.logging = opts.logging;
        if (_.isUndefined(this.bitgo)) {
            throw new Error('Please instantiate the recovery tool with a bitgo instance.');
        }
        // List of coins we support. Add modifiers (e.g. segwit) after the dash
        this.supportedCoins = ['btc', 'bch', 'ltc', 'btc-segwit', 'bsv'];
        if (_.isUndefined(opts.sourceCoin) || !this.supportedCoins.includes(opts.sourceCoin.getFamily())) {
            throw new Error('Please set a valid source coin');
        }
        this.sourceCoin = opts.sourceCoin;
        if (_.isUndefined(opts.recoveryCoin) || !this.supportedCoins.includes(opts.recoveryCoin.getFamily())) {
            throw new Error('Please set a valid recovery type');
        }
        this.recoveryCoin = opts.recoveryCoin;
        this.wallet = null;
        this.feeRates = {
            bch: 20,
            tbch: 20,
            bsv: 20,
            tbsv: 20,
            btc: 80,
            tbtc: 80,
            ltc: 100,
            tltc: 100,
        };
        this.recoveryTx = new bitcoin.TransactionBuilder(this.sourceCoin.network);
    }
    /**
     * Internal logging function (either uses provided logger or console.log, can be turned off)
     * @param args - the arguments to pass to the logger
     * @private
     */
    CrossChainRecoveryTool.prototype._log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this.logging) {
            return;
        }
        this.logger ? this.logger.apply(this, args) : console.log.apply(console, args);
    };
    /**
     * Sets the wallet ID of the recoveryCoin wallet. This is needed to find the private keys to sign the transaction.
     * @param walletId {String} wallet ID
     * @param callback
     */
    CrossChainRecoveryTool.prototype.setWallet = function (walletId, callback) {
        var self = this;
        return co(function setWallet() {
            var coinType, wallet, e_1, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        coinType = self.recoveryCoin.getChain();
                        if (_.isUndefined(walletId)) {
                            throw new Error('Please provide wallet id');
                        }
                        self._log("Fetching " + coinType + " wallet...");
                        if (self.sourceCoin.type !== coinType && self.recoveryCoin.type !== coinType) {
                            throw new Error('Cannot set a wallet for this coin type - this is not a coin involved in the recovery tx.');
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, self.bitgo
                                .coin(coinType)
                                .wallets()
                                .get({ id: walletId })];
                    case 2:
                        wallet = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        if (e_1.status !== 404 && e_1.status !== 400) {
                            throw e_1;
                        }
                        wallet = undefined;
                        return [3 /*break*/, 4];
                    case 4:
                        if (!(_.isUndefined(wallet) && coinType.endsWith('btc'))) return [3 /*break*/, 8];
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        self._log('Could not find v2 wallet. Falling back to v1...');
                        return [4 /*yield*/, self.bitgo.wallets().get({ id: walletId })];
                    case 6:
                        wallet = _a.sent();
                        wallet.isV1 = true;
                        return [3 /*break*/, 8];
                    case 7:
                        e_2 = _a.sent();
                        if (e_2.status !== 404) {
                            throw e_2;
                        }
                        return [3 /*break*/, 8];
                    case 8:
                        if (_.isUndefined(wallet)) {
                            throw new Error("Cannot find " + coinType + " wallet.");
                        }
                        self.wallet = wallet;
                        return [2 /*return*/];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Retrieves and stores the unspents from the faulty transaction
     * @param faultyTxId {String} the txid of the faulty transaction
     * @param callback
     */
    CrossChainRecoveryTool.prototype.findUnspents = function (faultyTxId, callback) {
        var self = this;
        return co(function findUnspents() {
            var TX_INFO_URL, res, faultyTxInfo, txOutputAddresses, outputAddresses, _i, txOutputAddresses_1, address, methodName, walletAddress, e_3, ADDRESS_UNSPENTS_URL, addressRes, unspents;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isUndefined(faultyTxId)) {
                            throw new Error('Please provide a faultyTxId');
                        }
                        self._log('Grabbing info for faulty tx...');
                        TX_INFO_URL = self.sourceCoin.url("/public/tx/" + faultyTxId);
                        return [4 /*yield*/, request.get(TX_INFO_URL)];
                    case 1:
                        res = _a.sent();
                        faultyTxInfo = res.body;
                        self._log('Getting unspents on output addresses..');
                        txOutputAddresses = faultyTxInfo.outputs.map(function (input) { return input.address; });
                        outputAddresses = [];
                        _i = 0, txOutputAddresses_1 = txOutputAddresses;
                        _a.label = 2;
                    case 2:
                        if (!(_i < txOutputAddresses_1.length)) return [3 /*break*/, 7];
                        address = txOutputAddresses_1[_i];
                        if (self.sourceCoin.getFamily() === 'ltc') {
                            try {
                                address = self.sourceCoin.canonicalAddress(address, 1);
                            }
                            catch (e) {
                                return [3 /*break*/, 6];
                            }
                        }
                        if (self.recoveryCoin.getFamily() === 'ltc') {
                            try {
                                address = self.recoveryCoin.canonicalAddress(address, 2);
                            }
                            catch (e) {
                                return [3 /*break*/, 6];
                            }
                        }
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        methodName = self.wallet.isV1 ? 'address' : 'getAddress';
                        return [4 /*yield*/, self.wallet[methodName]({ address: address })];
                    case 4:
                        walletAddress = _a.sent();
                        outputAddresses.push(walletAddress.address);
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _a.sent();
                        self._log("Address " + address + " not found on wallet");
                        return [3 /*break*/, 6];
                    case 6:
                        _i++;
                        return [3 /*break*/, 2];
                    case 7:
                        if (outputAddresses.length === 0) {
                            throw new Error('Could not find tx outputs belonging to the specified wallet. Please check the given parameters.');
                        }
                        if (self.recoveryCoin.getFamily() === 'ltc') {
                            outputAddresses = outputAddresses.map(function (address) { return self.recoveryCoin.canonicalAddress(address, 1); });
                        }
                        if (self.sourceCoin.getFamily() === 'ltc') {
                            outputAddresses = outputAddresses.map(function (address) { return self.sourceCoin.canonicalAddress(address, 2); });
                        }
                        self._log("Finding unspents for these output addresses: " + outputAddresses.join(', '));
                        ADDRESS_UNSPENTS_URL = self.sourceCoin.url("/public/addressUnspents/" + _.uniq(outputAddresses).join(','));
                        return [4 /*yield*/, request.get(ADDRESS_UNSPENTS_URL)];
                    case 8:
                        addressRes = _a.sent();
                        unspents = addressRes.body;
                        self.unspents = unspents;
                        return [2 /*return*/, unspents];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Constructs transaction inputs from a set of unspents.
     * @param unspents {Object[]} array of unspents from the faulty transaction
     * @param callback
     * @returns {Object} partial txInfo object with transaction inputs
     */
    CrossChainRecoveryTool.prototype.buildInputs = function (unspents, callback) {
        var self = this;
        return co(function buildInputs() {
            var txInfo, totalFound, noSegwit, _i, unspents_2, unspent, searchAddress, unspentAddress, methodName, e_4, _a, txHash, index, inputIndex, hash, inputData, addressInfo, _b, txid, nOut;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        self._log('Building inputs for recovery transaction...');
                        unspents = unspents || self.unspents;
                        if (_.isUndefined(unspents) || unspents.length === 0) {
                            throw new Error('Could not find unspents. Either supply an argument or call findUnspents');
                        }
                        txInfo = {
                            inputAmount: 0,
                            outputAmount: 0,
                            spendAmount: 0,
                            inputs: [],
                            outputs: [],
                            unspents: [],
                            externalOutputs: [],
                            changeOutputs: [],
                            minerFee: 0,
                            payGoFee: 0,
                        };
                        totalFound = 0;
                        noSegwit = self.recoveryCoin.getFamily() === 'btc' && self.sourceCoin.getFamily() === 'bch';
                        _i = 0, unspents_2 = unspents;
                        _c.label = 1;
                    case 1:
                        if (!(_i < unspents_2.length)) return [3 /*break*/, 10];
                        unspent = unspents_2[_i];
                        if (unspent.witnessScript && noSegwit) {
                            throw new Error('Warning! It appears one of the unspents is on a Segwit address. The tool only recovers BCH from non-Segwit BTC addresses. Aborting.');
                        }
                        searchAddress = unspent.address;
                        if (self.sourceCoin.type.endsWith('ltc')) {
                            searchAddress = self.sourceCoin.canonicalAddress(searchAddress, 1);
                        }
                        if (self.recoveryCoin.type.endsWith('ltc')) {
                            searchAddress = self.recoveryCoin.canonicalAddress(searchAddress, 2);
                        }
                        unspentAddress = void 0;
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 4, , 5]);
                        methodName = self.wallet.isV1 ? 'address' : 'getAddress';
                        return [4 /*yield*/, self.wallet[methodName]({ address: searchAddress })];
                    case 3:
                        unspentAddress = _c.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_4 = _c.sent();
                        self._log("Could not find address on wallet for " + searchAddress);
                        return [3 /*break*/, 9];
                    case 5:
                        self._log("Found " + unspent.value * 1e-8 + " " + self.sourceCoin.type + " at address " + unspent.address);
                        _a = unspent.id.split(':'), txHash = _a[0], index = _a[1];
                        inputIndex = parseInt(index, 10);
                        hash = new Buffer(txHash, 'hex');
                        hash = new Buffer(Array.prototype.reverse.call(hash));
                        try {
                            self.recoveryTx.addInput(hash, inputIndex);
                        }
                        catch (e) {
                            throw new Error("Error adding unspent " + unspent.id);
                        }
                        inputData = {};
                        if (!self.wallet.isV1) return [3 /*break*/, 7];
                        return [4 /*yield*/, self.wallet.address({ address: unspentAddress.address })];
                    case 6:
                        addressInfo = _c.sent();
                        unspentAddress.path = unspentAddress.path || "/" + unspentAddress.chain + "/" + unspentAddress.index;
                        _b = unspent.id.split(':'), txid = _b[0], nOut = _b[1];
                        inputData = {
                            redeemScript: addressInfo.redeemScript,
                            witnessScript: addressInfo.witnessScript,
                            path: '/0/0' + unspentAddress.path,
                            chainPath: unspentAddress.path,
                            index: unspentAddress.index,
                            chain: unspentAddress.chain,
                            txHash: txid,
                            txOutputN: parseInt(nOut, 10),
                            txValue: unspent.value,
                            value: parseInt(unspent.value, 10),
                        };
                        return [3 /*break*/, 8];
                    case 7:
                        inputData = {
                            redeemScript: unspentAddress.coinSpecific.redeemScript,
                            witnessScript: unspentAddress.coinSpecific.witnessScript,
                            index: unspentAddress.index,
                            chain: unspentAddress.chain,
                            wallet: self.wallet.id(),
                            fromWallet: self.wallet.id(),
                        };
                        _c.label = 8;
                    case 8:
                        txInfo.inputs.push(Object.assign({}, unspent, inputData));
                        txInfo.inputAmount += parseInt(unspent.value, 10);
                        totalFound += parseInt(unspent.value, 10);
                        _c.label = 9;
                    case 9:
                        _i++;
                        return [3 /*break*/, 1];
                    case 10:
                        txInfo.unspents = _.clone(txInfo.inputs);
                        // Normalize total found to base unit before we print it out
                        self._log("Found lost " + totalFound * 1e-8 + " " + self.sourceCoin.type + ".");
                        self.txInfo = txInfo;
                        return [2 /*return*/, txInfo];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Sets the txInfo.minerFee field by calculating the size of the transaction and multiplying it by the fee rate for
     * the source coin.
     * @param recoveryTx {Object} recovery transaction containing inputs
     * @returns {Number} recovery fee for the transaction
     */
    CrossChainRecoveryTool.prototype.setFees = function (recoveryTx) {
        recoveryTx = recoveryTx || this.recoveryTx;
        // Determine fee with default fee rate
        var feeRate = this.feeRates[this.sourceCoin.type];
        // Note that we assume one output here (all funds should be recovered to a single address)
        var txSize = unspents_1.VirtualSizes.txP2shInputSize * recoveryTx.tx.ins.length +
            unspents_1.VirtualSizes.txP2pkhOutputSize +
            unspents_1.VirtualSizes.txOverheadSize;
        var recoveryFee = feeRate * txSize;
        if (this.txInfo) {
            this.txInfo.minerFee = recoveryFee;
        }
        return recoveryFee;
    };
    /**
     * Constructs a single output to the recovery address.
     * @param recoveryAddress {String} address to recover funds to
     * @param outputAmount {Number} amount to send to the recovery address
     * @param recoveryFee {Number} miner fee for the transaction
     */
    CrossChainRecoveryTool.prototype.buildOutputs = function (recoveryAddress, outputAmount, recoveryFee) {
        if (_.isUndefined(outputAmount) && _.isUndefined(this.txInfo)) {
            throw new Error('Could not find transaction info. Please provide an output amount, or call buildInputs.');
        }
        this._log("Building outputs for recovery transaction. Funds will be sent to " + recoveryAddress + "...");
        var txInputAmount = outputAmount || (this.txInfo && this.txInfo.inputAmount);
        var txFeeAmount = recoveryFee || (this.txInfo && this.txInfo.minerFee);
        if (!txInputAmount) {
            throw new Error('could not determine transaction input amount');
        }
        if (!txFeeAmount) {
            throw new Error('could not determine transaction fee amount');
        }
        var txOutputAmount = txInputAmount - txFeeAmount;
        if (txOutputAmount <= 0) {
            throw new Error('This recovery transaction cannot pay its own fees. Aborting.');
        }
        if (!_.isUndefined(this.txInfo)) {
            this.txInfo.outputAmount = txOutputAmount;
            this.txInfo.spendAmount = txOutputAmount;
        }
        this.recoveryAddress = recoveryAddress;
        this.recoveryAmount = txOutputAmount;
        this.recoveryTx.addOutput(recoveryAddress, txOutputAmount);
        var outputData = {
            address: recoveryAddress,
            value: outputAmount,
            valueString: txOutputAmount.toString(),
            wallet: this.wallet.id(),
            change: false,
        };
        if (this.txInfo) {
            this.txInfo.outputs.push(outputData);
            this.txInfo.externalOutputs.push(outputData);
        }
    };
    /**
     * Half-signs the built transaction with the user's private key or keychain
     * @param params
     * @param params.prv {String} private key
     * @param params.passphrase {String} wallet passphrase
     * @param callback
     * @returns {Object} half-signed transaction
     */
    CrossChainRecoveryTool.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function signTransaction() {
            var transactionHex, prv, _a, txPrebuild;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (_.isUndefined(self.txInfo)) {
                            throw new Error('Could not find txInfo. Please build a transaction');
                        }
                        self._log('Signing the transaction...');
                        transactionHex = self.recoveryTx.buildIncomplete().toHex();
                        if (!_.isString(params.prv)) return [3 /*break*/, 1];
                        _a = params.prv;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, self.getKeys(params.passphrase)];
                    case 2:
                        _a = _b.sent();
                        _b.label = 3;
                    case 3:
                        prv = _a;
                        txPrebuild = { txHex: transactionHex, txInfo: self.txInfo };
                        self.halfSignedRecoveryTx = self.sourceCoin.signTransaction({ txPrebuild: txPrebuild, prv: prv });
                        return [2 /*return*/, self.halfSignedRecoveryTx];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Gets the wallet's encrypted keychain, then decrypts it with the wallet passphrase
     * @param passphrase {String} wallet passphrase
     * @param callback
     * @returns {String} decrypted wallet private key
     */
    CrossChainRecoveryTool.prototype.getKeys = function (passphrase, callback) {
        var self = this;
        return co(function getKeys() {
            var prv, keychain, e_5, encryptedPrv;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, self.wallet.getEncryptedUserKeychain()];
                    case 1:
                        keychain = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_5 = _a.sent();
                        if (e_5.status !== 404) {
                            throw e_5;
                        }
                        return [3 /*break*/, 3];
                    case 3:
                        if (_.isUndefined(passphrase)) {
                            throw new Error('You have an encrypted user keychain - please provide the passphrase to decrypt it');
                        }
                        if (self.wallet.isV1) {
                            if (_.isUndefined(keychain)) {
                                throw new Error('V1 wallets need a user keychain - could not find the proper keychain. Aborting');
                            }
                        }
                        if (keychain) {
                            try {
                                encryptedPrv = self.wallet.isV1 ? keychain.encryptedXprv : keychain.encryptedPrv;
                                prv = self.bitgo.decrypt({ input: encryptedPrv, password: passphrase });
                            }
                            catch (e) {
                                throw new Error('Error reading private key. Please check that you have the correct wallet passphrase');
                            }
                        }
                        return [2 /*return*/, prv];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.buildTransaction = function (params, callback) {
        var self = this;
        return co(function buildTransaction() {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.setWallet(params.wallet)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, self.findUnspents(params.faultyTxId)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, self.buildInputs()];
                    case 3:
                        _a.sent();
                        self.setFees();
                        self.buildOutputs(params.recoveryAddress);
                        return [2 /*return*/, self.recoveryTx];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.buildUnsigned = function (callback) {
        var self = this;
        return co(function () {
            var incomplete, txInfo, _i, _a, input, feeInfo;
            return __generator(this, function (_b) {
                if (_.isUndefined(self.txInfo)) {
                    throw new Error('Could not find txInfo. Please build a transaction');
                }
                incomplete = self.recoveryTx.buildIncomplete();
                txInfo = {
                    nP2SHInputs: 0,
                    nSegwitInputs: 0,
                };
                for (_i = 0, _a = self.txInfo.inputs; _i < _a.length; _i++) {
                    input = _a[_i];
                    if (input.chain === 10 || input.chain === 11) {
                        txInfo.nSegwitInputs++;
                    }
                    else {
                        txInfo.nP2SHInputs++;
                    }
                }
                txInfo.nOutputs = 1;
                txInfo.unspents = _.map(self.txInfo.inputs, _.partialRight(_.pick, ['chain', 'index', 'redeemScript', 'id', 'address', 'value']));
                txInfo.changeAddresses = [];
                txInfo.walletAddressDetails = {};
                feeInfo = {};
                feeInfo.size =
                    unspents_1.VirtualSizes.txOverheadSize +
                        unspents_1.VirtualSizes.txP2shInputSize * self.txInfo.inputs.length +
                        unspents_1.VirtualSizes.txP2pkhOutputSize;
                feeInfo.feeRate = self.feeRates[self.sourceCoin.type];
                feeInfo.fee = Math.round((feeInfo.size / 1000) * feeInfo.feeRate);
                feeInfo.payGoFee = 0;
                feeInfo.payGoFeeString = '0';
                return [2 /*return*/, {
                        txHex: incomplete.toHex(),
                        txInfo: txInfo,
                        feeInfo: feeInfo,
                        walletId: self.wallet.id(),
                        amount: self.recoveryAmount,
                        address: self.recoveryAddress,
                        coin: self.sourceCoin.type,
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.export = function () {
        return {
            version: this.wallet.isV1 ? 1 : 2,
            sourceCoin: this.sourceCoin.type,
            recoveryCoin: this.recoveryCoin.type,
            walletId: this.wallet.id(),
            recoveryAddress: this.recoveryAddress,
            recoveryAmount: this.recoveryAmount,
            txHex: this.halfSignedRecoveryTx && (this.halfSignedRecoveryTx.txHex || this.halfSignedRecoveryTx.tx),
            txInfo: this.txInfo,
        };
    };
    return CrossChainRecoveryTool;
}());
exports.CrossChainRecoveryTool = CrossChainRecoveryTool;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjb3ZlcnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdjIvcmVjb3ZlcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDRDQUErQztBQUMvQyxvQ0FBc0M7QUFFdEMsbUNBQXFDO0FBQ3JDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFDOUIsMEJBQTRCO0FBRTVCLHdDQUEwQztBQXdDMUM7Ozs7OztHQU1HO0FBQ0g7SUFnQkUsZ0NBQVksSUFBbUM7UUFDN0MsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUU1QixJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkRBQTZELENBQUMsQ0FBQztTQUNoRjtRQUVELHVFQUF1RTtRQUN2RSxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRWpFLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUU7WUFDaEcsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1NBQ25EO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBRWxDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFD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QixNQUFNLEVBQUUsTUFBTTt3QkFDZCxPQUFPLEVBQUUsT0FBTzt3QkFDaEIsUUFBUSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFO3dCQUMxQixNQUFNLEVBQUUsSUFBSSxDQUFDLGNBQWM7d0JBQzNCLE9BQU8sRUFBRSxJQUFJLENBQUMsZUFBZTt3QkFDN0IsSUFBSSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSTtxQkFDM0IsRUFBQzs7U0FDSCxDQUFDO2FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQzthQUNWLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQsdUNBQU0sR0FBTjtRQUNFLE9BQU87WUFDTCxPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJO1lBQ2hDLFlBQVksRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUk7WUFDcEMsUUFBUSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFO1lBQzFCLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZTtZQUNyQyxjQUFjLEVBQUUsSUFBSSxDQUFDLGNBQWM7WUFDbkMsS0FBSyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsQ0FBQztZQUNyRyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07U0FDcEIsQ0FBQztJQUNKLENBQUM7SUFDSCw2QkFBQztBQUFELENBQUMsQUE3aUJELElBNmlCQztBQTdpQlksd0RBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IHsgVmlydHVhbFNpemVzIH0gZnJvbSAnQGJpdGdvL3Vuc3BlbnRzJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi9iaXRnbyc7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ2JpdGdvLXV0eG8tbGliJztcbmltcG9ydCB7IEFic3RyYWN0VXR4b0NvaW4gfSBmcm9tICcuL2NvaW5zL2Fic3RyYWN0VXR4b0NvaW4nO1xuaW1wb3J0IHsgTHRjIH0gZnJvbSAnLi9jb2lucy9sdGMnO1xuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnLi93YWxsZXQnO1xuXG5pbnRlcmZhY2UgQ3Jvc3NDaGFpblJlY292ZXJ5VG9vbE9wdGlvbnMge1xuICBiaXRnbzogQml0R287XG4gIHNvdXJjZUNvaW4/OiBBYnN0cmFjdFV0eG9Db2luO1xuICByZWNvdmVyeUNvaW4/OiBBYnN0cmFjdFV0eG9Db2luO1xuICBsb2dnaW5nOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25SZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHBydj86IHN0cmluZztcbiAgcGFzc3BocmFzZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkUmVjb3ZlcnlUcmFuc2FjdGlvbk9wdGlvbnMge1xuICB3YWxsZXQ6IHN0cmluZztcbiAgZmF1bHR5VHhJZDogc3RyaW5nO1xuICByZWNvdmVyeUFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeVR4SW5mbyB7XG4gIGlucHV0QW1vdW50OiBudW1iZXI7XG4gIG91dHB1dEFtb3VudDogbnVtYmVyO1xuICBzcGVuZEFtb3VudDogbnVtYmVyO1xuICBpbnB1dHM6IGFueVtdO1xuICBvdXRwdXRzOiBhbnlbXTtcbiAgZXh0ZXJuYWxPdXRwdXRzOiBhbnlbXTtcbiAgY2hhbmdlT3V0cHV0czogYW55W107XG4gIG1pbmVyRmVlOiBudW1iZXI7XG4gIHBheUdvRmVlOiBudW1iZXI7XG4gIHVuc3BlbnRzOiBhbnlbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkUmVjb3ZlcnlUeCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIHR4Pzogc3RyaW5nO1xufVxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgcmVjb3ZlcnkgdG9vbCwgd2hpY2ggZW5jYXBzdWxhdGVzIHRoZSByZWNvdmVyeSBmdW5jdGlvbnNcbiAqIEluc3RhbnRpYXRlZCB3aXRoIHBhcmFtZXRlcnM6XG4gKiAgIC0gYml0Z286IGFuIGluc3RhbmNlIG9mIHRoZSBiaXRnbyBTREtcbiAqICAgLSBzb3VyY2VDb2luOiB0aGUgY29pbiB0aGF0IG5lZWRzIHRvIGJlIHJlY292ZXJlZFxuICogICAtIHJlY292ZXJ5Q29pbjogdGhlIHR5cGUgb2YgYWRkcmVzcyB0aGUgZmF1bHR5IHRyYW5zYWN0aW9uIHdhcyBzZW50IHRvXG4gKi9cbmV4cG9ydCBjbGFzcyBDcm9zc0NoYWluUmVjb3ZlcnlUb29sIHtcbiAgYml0Z286IEJpdEdvO1xuICBzb3VyY2VDb2luOiBBYnN0cmFjdFV0eG9Db2luO1xuICByZWNvdmVyeUNvaW46IEFic3RyYWN0VXR4b0NvaW47XG4gIGxvZ2dpbmc6IGJvb2xlYW47XG4gIHN1cHBvcnRlZENvaW5zOiBzdHJpbmdbXTtcbiAgd2FsbGV0OiBhbnk7IC8vIFRoaXMgY2FuIGJlIGVpdGhlciBhIHYxIG9yIHYyIHdhbGxldFxuICBmZWVSYXRlczogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfTtcbiAgcmVjb3ZlcnlUeDogYW55O1xuICBsb2dnZXI6IGFueTtcbiAgcHJpdmF0ZSB1bnNwZW50cz86IGFueTtcbiAgdHhJbmZvPzogUmVjb3ZlcnlUeEluZm87XG4gIHJlY292ZXJ5QWRkcmVzcz86IHN0cmluZztcbiAgcmVjb3ZlcnlBbW91bnQ/OiBudW1iZXI7XG4gIGhhbGZTaWduZWRSZWNvdmVyeVR4PzogSGFsZlNpZ25lZFJlY292ZXJ5VHg7XG5cbiAgY29uc3RydWN0b3Iob3B0czogQ3Jvc3NDaGFpblJlY292ZXJ5VG9vbE9wdGlvbnMpIHtcbiAgICB0aGlzLmJpdGdvID0gb3B0cy5iaXRnbztcbiAgICB0aGlzLmxvZ2dpbmcgPSBvcHRzLmxvZ2dpbmc7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLmJpdGdvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgaW5zdGFudGlhdGUgdGhlIHJlY292ZXJ5IHRvb2wgd2l0aCBhIGJpdGdvIGluc3RhbmNlLicpO1xuICAgIH1cblxuICAgIC8vIExpc3Qgb2YgY29pbnMgd2Ugc3VwcG9ydC4gQWRkIG1vZGlmaWVycyAoZS5nLiBzZWd3aXQpIGFmdGVyIHRoZSBkYXNoXG4gICAgdGhpcy5zdXBwb3J0ZWRDb2lucyA9IFsnYnRjJywgJ2JjaCcsICdsdGMnLCAnYnRjLXNlZ3dpdCcsICdic3YnXTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKG9wdHMuc291cmNlQ29pbikgfHwgIXRoaXMuc3VwcG9ydGVkQ29pbnMuaW5jbHVkZXMob3B0cy5zb3VyY2VDb2luLmdldEZhbWlseSgpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2V0IGEgdmFsaWQgc291cmNlIGNvaW4nKTtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VDb2luID0gb3B0cy5zb3VyY2VDb2luO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQob3B0cy5yZWNvdmVyeUNvaW4pIHx8ICF0aGlzLnN1cHBvcnRlZENvaW5zLmluY2x1ZGVzKG9wdHMucmVjb3ZlcnlDb2luLmdldEZhbWlseSgpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2V0IGEgdmFsaWQgcmVjb3ZlcnkgdHlwZScpO1xuICAgIH1cbiAgICB0aGlzLnJlY292ZXJ5Q29pbiA9IG9wdHMucmVjb3ZlcnlDb2luO1xuXG4gICAgdGhpcy53YWxsZXQgPSBudWxsO1xuXG4gICAgdGhpcy5mZWVSYXRlcyA9IHtcbiAgICAgIGJjaDogMjAsXG4gICAgICB0YmNoOiAyMCxcbiAgICAgIGJzdjogMjAsXG4gICAgICB0YnN2OiAyMCxcbiAgICAgIGJ0YzogODAsXG4gICAgICB0YnRjOiA4MCxcbiAgICAgIGx0YzogMTAwLFxuICAgICAgdGx0YzogMTAwLFxuICAgIH07XG5cbiAgICB0aGlzLnJlY292ZXJ5VHggPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbkJ1aWxkZXIodGhpcy5zb3VyY2VDb2luLm5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGxvZ2dpbmcgZnVuY3Rpb24gKGVpdGhlciB1c2VzIHByb3ZpZGVkIGxvZ2dlciBvciBjb25zb2xlLmxvZywgY2FuIGJlIHR1cm5lZCBvZmYpXG4gICAqIEBwYXJhbSBhcmdzIC0gdGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBsb2dnZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2coLi4uYXJncykge1xuICAgIGlmICghdGhpcy5sb2dnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIgPyB0aGlzLmxvZ2dlciguLi5hcmdzKSA6IGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdhbGxldCBJRCBvZiB0aGUgcmVjb3ZlcnlDb2luIHdhbGxldC4gVGhpcyBpcyBuZWVkZWQgdG8gZmluZCB0aGUgcHJpdmF0ZSBrZXlzIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gd2FsbGV0SWQge1N0cmluZ30gd2FsbGV0IElEXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHJvdGVjdGVkIHNldFdhbGxldCh3YWxsZXRJZD86IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPHZvaWQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288dm9pZD4oZnVuY3Rpb24qIHNldFdhbGxldCgpIHtcbiAgICAgIGNvbnN0IGNvaW5UeXBlID0gc2VsZi5yZWNvdmVyeUNvaW4uZ2V0Q2hhaW4oKTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHdhbGxldElkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIHdhbGxldCBpZCcpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9sb2coYEZldGNoaW5nICR7Y29pblR5cGV9IHdhbGxldC4uLmApO1xuXG4gICAgICBpZiAoc2VsZi5zb3VyY2VDb2luLnR5cGUgIT09IGNvaW5UeXBlICYmIHNlbGYucmVjb3ZlcnlDb2luLnR5cGUgIT09IGNvaW5UeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBhIHdhbGxldCBmb3IgdGhpcyBjb2luIHR5cGUgLSB0aGlzIGlzIG5vdCBhIGNvaW4gaW52b2x2ZWQgaW4gdGhlIHJlY292ZXJ5IHR4LicpO1xuICAgICAgfVxuXG4gICAgICBsZXQgd2FsbGV0OiBXYWxsZXQgfCB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB3YWxsZXQgPSB5aWVsZCBzZWxmLmJpdGdvXG4gICAgICAgICAgLmNvaW4oY29pblR5cGUpXG4gICAgICAgICAgLndhbGxldHMoKVxuICAgICAgICAgIC5nZXQoeyBpZDogd2FsbGV0SWQgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnN0YXR1cyAhPT0gNDA0ICYmIGUuc3RhdHVzICE9PSA0MDApIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FsbGV0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh3YWxsZXQpICYmIGNvaW5UeXBlLmVuZHNXaXRoKCdidGMnKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlbGYuX2xvZygnQ291bGQgbm90IGZpbmQgdjIgd2FsbGV0LiBGYWxsaW5nIGJhY2sgdG8gdjEuLi4nKTtcbiAgICAgICAgICB3YWxsZXQgPSB5aWVsZCBzZWxmLmJpdGdvLndhbGxldHMoKS5nZXQoeyBpZDogd2FsbGV0SWQgfSk7XG4gICAgICAgICAgKHdhbGxldCBhcyBhbnkpLmlzVjEgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUuc3RhdHVzICE9PSA0MDQpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHdhbGxldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCAke2NvaW5UeXBlfSB3YWxsZXQuYCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYud2FsbGV0ID0gd2FsbGV0O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbmQgc3RvcmVzIHRoZSB1bnNwZW50cyBmcm9tIHRoZSBmYXVsdHkgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGZhdWx0eVR4SWQge1N0cmluZ30gdGhlIHR4aWQgb2YgdGhlIGZhdWx0eSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHByb3RlY3RlZCBmaW5kVW5zcGVudHMoZmF1bHR5VHhJZD86IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiogZmluZFVuc3BlbnRzKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZmF1bHR5VHhJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIGZhdWx0eVR4SWQnKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fbG9nKCdHcmFiYmluZyBpbmZvIGZvciBmYXVsdHkgdHguLi4nKTtcblxuICAgICAgY29uc3QgVFhfSU5GT19VUkwgPSBzZWxmLnNvdXJjZUNvaW4udXJsKGAvcHVibGljL3R4LyR7ZmF1bHR5VHhJZH1gKTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHJlcXVlc3QuZ2V0KFRYX0lORk9fVVJMKTtcbiAgICAgIGNvbnN0IGZhdWx0eVR4SW5mbyA9IHJlcy5ib2R5O1xuXG4gICAgICBzZWxmLl9sb2coJ0dldHRpbmcgdW5zcGVudHMgb24gb3V0cHV0IGFkZHJlc3Nlcy4uJyk7XG5cbiAgICAgIC8vIEdldCBvdXRwdXQgYWRkcmVzc2VzIHRoYXQgZG8gbm90IGJlbG9uZyB0byB3YWxsZXRcbiAgICAgIC8vIFRoZXNlIGFyZSB3aGVyZSB0aGUgJ2xvc3QgY29pbnMnIGxpdmVcbiAgICAgIGNvbnN0IHR4T3V0cHV0QWRkcmVzc2VzID0gZmF1bHR5VHhJbmZvLm91dHB1dHMubWFwKGlucHV0ID0+IGlucHV0LmFkZHJlc3MpO1xuXG4gICAgICBsZXQgb3V0cHV0QWRkcmVzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgYWRkcmVzcyBvZiB0eE91dHB1dEFkZHJlc3Nlcykge1xuICAgICAgICBpZiAoc2VsZi5zb3VyY2VDb2luLmdldEZhbWlseSgpID09PSAnbHRjJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gKHNlbGYuc291cmNlQ29pbiBhcyBMdGMpLmNhbm9uaWNhbEFkZHJlc3MoYWRkcmVzcywgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYucmVjb3ZlcnlDb2luLmdldEZhbWlseSgpID09PSAnbHRjJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gKHNlbGYucmVjb3ZlcnlDb2luIGFzIEx0YykuY2Fub25pY2FsQWRkcmVzcyhhZGRyZXNzLCAyKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBzZWxmLndhbGxldC5pc1YxID8gJ2FkZHJlc3MnIDogJ2dldEFkZHJlc3MnO1xuICAgICAgICAgIGNvbnN0IHdhbGxldEFkZHJlc3MgPSB5aWVsZCBzZWxmLndhbGxldFttZXRob2ROYW1lXSh7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG4gICAgICAgICAgb3V0cHV0QWRkcmVzc2VzLnB1c2god2FsbGV0QWRkcmVzcy5hZGRyZXNzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNlbGYuX2xvZyhgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBvbiB3YWxsZXRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0QWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIHR4IG91dHB1dHMgYmVsb25naW5nIHRvIHRoZSBzcGVjaWZpZWQgd2FsbGV0LiBQbGVhc2UgY2hlY2sgdGhlIGdpdmVuIHBhcmFtZXRlcnMuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZWNvdmVyeUNvaW4uZ2V0RmFtaWx5KCkgPT09ICdsdGMnKSB7XG4gICAgICAgIG91dHB1dEFkZHJlc3NlcyA9IG91dHB1dEFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiAoc2VsZi5yZWNvdmVyeUNvaW4gYXMgTHRjKS5jYW5vbmljYWxBZGRyZXNzKGFkZHJlc3MsIDEpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc291cmNlQ29pbi5nZXRGYW1pbHkoKSA9PT0gJ2x0YycpIHtcbiAgICAgICAgb3V0cHV0QWRkcmVzc2VzID0gb3V0cHV0QWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IChzZWxmLnNvdXJjZUNvaW4gYXMgTHRjKS5jYW5vbmljYWxBZGRyZXNzKGFkZHJlc3MsIDIpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fbG9nKGBGaW5kaW5nIHVuc3BlbnRzIGZvciB0aGVzZSBvdXRwdXQgYWRkcmVzc2VzOiAke291dHB1dEFkZHJlc3Nlcy5qb2luKCcsICcpfWApO1xuXG4gICAgICAvLyBHZXQgdW5zcGVudHMgZm9yIGFkZHJlc3Nlc1xuICAgICAgY29uc3QgQUREUkVTU19VTlNQRU5UU19VUkwgPSBzZWxmLnNvdXJjZUNvaW4udXJsKGAvcHVibGljL2FkZHJlc3NVbnNwZW50cy8ke18udW5pcShvdXRwdXRBZGRyZXNzZXMpLmpvaW4oJywnKX1gKTtcbiAgICAgIGNvbnN0IGFkZHJlc3NSZXMgPSB5aWVsZCByZXF1ZXN0LmdldChBRERSRVNTX1VOU1BFTlRTX1VSTCk7XG4gICAgICBjb25zdCB1bnNwZW50cyA9IGFkZHJlc3NSZXMuYm9keTtcblxuICAgICAgc2VsZi51bnNwZW50cyA9IHVuc3BlbnRzO1xuICAgICAgcmV0dXJuIHVuc3BlbnRzO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdHJhbnNhY3Rpb24gaW5wdXRzIGZyb20gYSBzZXQgb2YgdW5zcGVudHMuXG4gICAqIEBwYXJhbSB1bnNwZW50cyB7T2JqZWN0W119IGFycmF5IG9mIHVuc3BlbnRzIGZyb20gdGhlIGZhdWx0eSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gcGFydGlhbCB0eEluZm8gb2JqZWN0IHdpdGggdHJhbnNhY3Rpb24gaW5wdXRzXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRJbnB1dHModW5zcGVudHM/OiBhbnksIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qIGJ1aWxkSW5wdXRzKCkge1xuICAgICAgc2VsZi5fbG9nKCdCdWlsZGluZyBpbnB1dHMgZm9yIHJlY292ZXJ5IHRyYW5zYWN0aW9uLi4uJyk7XG5cbiAgICAgIHVuc3BlbnRzID0gdW5zcGVudHMgfHwgc2VsZi51bnNwZW50cztcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodW5zcGVudHMpIHx8IHVuc3BlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHVuc3BlbnRzLiBFaXRoZXIgc3VwcGx5IGFuIGFyZ3VtZW50IG9yIGNhbGwgZmluZFVuc3BlbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4SW5mbzogYW55ID0ge1xuICAgICAgICBpbnB1dEFtb3VudDogMCxcbiAgICAgICAgb3V0cHV0QW1vdW50OiAwLFxuICAgICAgICBzcGVuZEFtb3VudDogMCxcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHVuc3BlbnRzOiBbXSxcbiAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICAgIG1pbmVyRmVlOiAwLFxuICAgICAgICBwYXlHb0ZlZTogMCxcbiAgICAgIH07XG5cbiAgICAgIGxldCB0b3RhbEZvdW5kID0gMDtcbiAgICAgIGNvbnN0IG5vU2Vnd2l0ID0gc2VsZi5yZWNvdmVyeUNvaW4uZ2V0RmFtaWx5KCkgPT09ICdidGMnICYmIHNlbGYuc291cmNlQ29pbi5nZXRGYW1pbHkoKSA9PT0gJ2JjaCc7XG4gICAgICBmb3IgKGNvbnN0IHVuc3BlbnQgb2YgdW5zcGVudHMpIHtcbiAgICAgICAgaWYgKHVuc3BlbnQud2l0bmVzc1NjcmlwdCAmJiBub1NlZ3dpdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdXYXJuaW5nISBJdCBhcHBlYXJzIG9uZSBvZiB0aGUgdW5zcGVudHMgaXMgb24gYSBTZWd3aXQgYWRkcmVzcy4gVGhlIHRvb2wgb25seSByZWNvdmVycyBCQ0ggZnJvbSBub24tU2Vnd2l0IEJUQyBhZGRyZXNzZXMuIEFib3J0aW5nLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlYXJjaEFkZHJlc3MgPSB1bnNwZW50LmFkZHJlc3M7XG5cbiAgICAgICAgaWYgKHNlbGYuc291cmNlQ29pbi50eXBlLmVuZHNXaXRoKCdsdGMnKSkge1xuICAgICAgICAgIHNlYXJjaEFkZHJlc3MgPSAoc2VsZi5zb3VyY2VDb2luIGFzIEx0YykuY2Fub25pY2FsQWRkcmVzcyhzZWFyY2hBZGRyZXNzLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnJlY292ZXJ5Q29pbi50eXBlLmVuZHNXaXRoKCdsdGMnKSkge1xuICAgICAgICAgIHNlYXJjaEFkZHJlc3MgPSAoc2VsZi5yZWNvdmVyeUNvaW4gYXMgTHRjKS5jYW5vbmljYWxBZGRyZXNzKHNlYXJjaEFkZHJlc3MsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHVuc3BlbnRBZGRyZXNzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBzZWxmLndhbGxldC5pc1YxID8gJ2FkZHJlc3MnIDogJ2dldEFkZHJlc3MnO1xuICAgICAgICAgIHVuc3BlbnRBZGRyZXNzID0geWllbGQgc2VsZi53YWxsZXRbbWV0aG9kTmFtZV0oeyBhZGRyZXNzOiBzZWFyY2hBZGRyZXNzIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2VsZi5fbG9nKGBDb3VsZCBub3QgZmluZCBhZGRyZXNzIG9uIHdhbGxldCBmb3IgJHtzZWFyY2hBZGRyZXNzfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fbG9nKGBGb3VuZCAke3Vuc3BlbnQudmFsdWUgKiAxZS04fSAke3NlbGYuc291cmNlQ29pbi50eXBlfSBhdCBhZGRyZXNzICR7dW5zcGVudC5hZGRyZXNzfWApO1xuXG4gICAgICAgIGNvbnN0IFt0eEhhc2gsIGluZGV4XSA9IHVuc3BlbnQuaWQuc3BsaXQoJzonKTtcbiAgICAgICAgY29uc3QgaW5wdXRJbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgICAgIGxldCBoYXNoID0gbmV3IEJ1ZmZlcih0eEhhc2gsICdoZXgnKTtcbiAgICAgICAgaGFzaCA9IG5ldyBCdWZmZXIoQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChoYXNoKSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZWxmLnJlY292ZXJ5VHguYWRkSW5wdXQoaGFzaCwgaW5wdXRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGFkZGluZyB1bnNwZW50ICR7dW5zcGVudC5pZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnB1dERhdGEgPSB7fTtcblxuICAgICAgICAvLyBBZGQgdjEgc3BlY2lmaWMgaW5wdXQgZmllbGRzXG4gICAgICAgIGlmIChzZWxmLndhbGxldC5pc1YxKSB7XG4gICAgICAgICAgY29uc3QgYWRkcmVzc0luZm8gPSB5aWVsZCBzZWxmLndhbGxldC5hZGRyZXNzKHsgYWRkcmVzczogdW5zcGVudEFkZHJlc3MuYWRkcmVzcyB9KTtcblxuICAgICAgICAgIHVuc3BlbnRBZGRyZXNzLnBhdGggPSB1bnNwZW50QWRkcmVzcy5wYXRoIHx8IGAvJHt1bnNwZW50QWRkcmVzcy5jaGFpbn0vJHt1bnNwZW50QWRkcmVzcy5pbmRleH1gO1xuICAgICAgICAgIGNvbnN0IFt0eGlkLCBuT3V0XSA9IHVuc3BlbnQuaWQuc3BsaXQoJzonKTtcblxuICAgICAgICAgIGlucHV0RGF0YSA9IHtcbiAgICAgICAgICAgIHJlZGVlbVNjcmlwdDogYWRkcmVzc0luZm8ucmVkZWVtU2NyaXB0LFxuICAgICAgICAgICAgd2l0bmVzc1NjcmlwdDogYWRkcmVzc0luZm8ud2l0bmVzc1NjcmlwdCxcbiAgICAgICAgICAgIHBhdGg6ICcvMC8wJyArIHVuc3BlbnRBZGRyZXNzLnBhdGgsXG4gICAgICAgICAgICBjaGFpblBhdGg6IHVuc3BlbnRBZGRyZXNzLnBhdGgsXG4gICAgICAgICAgICBpbmRleDogdW5zcGVudEFkZHJlc3MuaW5kZXgsXG4gICAgICAgICAgICBjaGFpbjogdW5zcGVudEFkZHJlc3MuY2hhaW4sXG4gICAgICAgICAgICB0eEhhc2g6IHR4aWQsXG4gICAgICAgICAgICB0eE91dHB1dE46IHBhcnNlSW50KG5PdXQsIDEwKSxcbiAgICAgICAgICAgIHR4VmFsdWU6IHVuc3BlbnQudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQodW5zcGVudC52YWx1ZSwgMTApLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXREYXRhID0ge1xuICAgICAgICAgICAgcmVkZWVtU2NyaXB0OiB1bnNwZW50QWRkcmVzcy5jb2luU3BlY2lmaWMucmVkZWVtU2NyaXB0LFxuICAgICAgICAgICAgd2l0bmVzc1NjcmlwdDogdW5zcGVudEFkZHJlc3MuY29pblNwZWNpZmljLndpdG5lc3NTY3JpcHQsXG4gICAgICAgICAgICBpbmRleDogdW5zcGVudEFkZHJlc3MuaW5kZXgsXG4gICAgICAgICAgICBjaGFpbjogdW5zcGVudEFkZHJlc3MuY2hhaW4sXG4gICAgICAgICAgICB3YWxsZXQ6IHNlbGYud2FsbGV0LmlkKCksXG4gICAgICAgICAgICBmcm9tV2FsbGV0OiBzZWxmLndhbGxldC5pZCgpLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0eEluZm8uaW5wdXRzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgdW5zcGVudCwgaW5wdXREYXRhKSk7XG5cbiAgICAgICAgdHhJbmZvLmlucHV0QW1vdW50ICs9IHBhcnNlSW50KHVuc3BlbnQudmFsdWUsIDEwKTtcbiAgICAgICAgdG90YWxGb3VuZCArPSBwYXJzZUludCh1bnNwZW50LnZhbHVlLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHR4SW5mby51bnNwZW50cyA9IF8uY2xvbmUodHhJbmZvLmlucHV0cyk7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSB0b3RhbCBmb3VuZCB0byBiYXNlIHVuaXQgYmVmb3JlIHdlIHByaW50IGl0IG91dFxuICAgICAgc2VsZi5fbG9nKGBGb3VuZCBsb3N0ICR7dG90YWxGb3VuZCAqIDFlLTh9ICR7c2VsZi5zb3VyY2VDb2luLnR5cGV9LmApO1xuXG4gICAgICBzZWxmLnR4SW5mbyA9IHR4SW5mbztcbiAgICAgIHJldHVybiB0eEluZm87XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHhJbmZvLm1pbmVyRmVlIGZpZWxkIGJ5IGNhbGN1bGF0aW5nIHRoZSBzaXplIG9mIHRoZSB0cmFuc2FjdGlvbiBhbmQgbXVsdGlwbHlpbmcgaXQgYnkgdGhlIGZlZSByYXRlIGZvclxuICAgKiB0aGUgc291cmNlIGNvaW4uXG4gICAqIEBwYXJhbSByZWNvdmVyeVR4IHtPYmplY3R9IHJlY292ZXJ5IHRyYW5zYWN0aW9uIGNvbnRhaW5pbmcgaW5wdXRzXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJlY292ZXJ5IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcm90ZWN0ZWQgc2V0RmVlcyhyZWNvdmVyeVR4PzogYW55KTogbnVtYmVyIHtcbiAgICByZWNvdmVyeVR4ID0gcmVjb3ZlcnlUeCB8fCB0aGlzLnJlY292ZXJ5VHg7XG5cbiAgICAvLyBEZXRlcm1pbmUgZmVlIHdpdGggZGVmYXVsdCBmZWUgcmF0ZVxuICAgIGNvbnN0IGZlZVJhdGUgPSB0aGlzLmZlZVJhdGVzW3RoaXMuc291cmNlQ29pbi50eXBlXTtcblxuICAgIC8vIE5vdGUgdGhhdCB3ZSBhc3N1bWUgb25lIG91dHB1dCBoZXJlIChhbGwgZnVuZHMgc2hvdWxkIGJlIHJlY292ZXJlZCB0byBhIHNpbmdsZSBhZGRyZXNzKVxuICAgIGNvbnN0IHR4U2l6ZSA9XG4gICAgICBWaXJ0dWFsU2l6ZXMudHhQMnNoSW5wdXRTaXplICogcmVjb3ZlcnlUeC50eC5pbnMubGVuZ3RoICtcbiAgICAgIFZpcnR1YWxTaXplcy50eFAycGtoT3V0cHV0U2l6ZSArXG4gICAgICBWaXJ0dWFsU2l6ZXMudHhPdmVyaGVhZFNpemU7XG4gICAgY29uc3QgcmVjb3ZlcnlGZWUgPSBmZWVSYXRlICogdHhTaXplO1xuXG4gICAgaWYgKHRoaXMudHhJbmZvKSB7XG4gICAgICB0aGlzLnR4SW5mby5taW5lckZlZSA9IHJlY292ZXJ5RmVlO1xuICAgIH1cblxuICAgIHJldHVybiByZWNvdmVyeUZlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgc2luZ2xlIG91dHB1dCB0byB0aGUgcmVjb3ZlcnkgYWRkcmVzcy5cbiAgICogQHBhcmFtIHJlY292ZXJ5QWRkcmVzcyB7U3RyaW5nfSBhZGRyZXNzIHRvIHJlY292ZXIgZnVuZHMgdG9cbiAgICogQHBhcmFtIG91dHB1dEFtb3VudCB7TnVtYmVyfSBhbW91bnQgdG8gc2VuZCB0byB0aGUgcmVjb3ZlcnkgYWRkcmVzc1xuICAgKiBAcGFyYW0gcmVjb3ZlcnlGZWUge051bWJlcn0gbWluZXIgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHByb3RlY3RlZCBidWlsZE91dHB1dHMocmVjb3ZlcnlBZGRyZXNzOiBzdHJpbmcsIG91dHB1dEFtb3VudD86IG51bWJlciwgcmVjb3ZlcnlGZWU/OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChvdXRwdXRBbW91bnQpICYmIF8uaXNVbmRlZmluZWQodGhpcy50eEluZm8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRyYW5zYWN0aW9uIGluZm8uIFBsZWFzZSBwcm92aWRlIGFuIG91dHB1dCBhbW91bnQsIG9yIGNhbGwgYnVpbGRJbnB1dHMuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9nKGBCdWlsZGluZyBvdXRwdXRzIGZvciByZWNvdmVyeSB0cmFuc2FjdGlvbi4gRnVuZHMgd2lsbCBiZSBzZW50IHRvICR7cmVjb3ZlcnlBZGRyZXNzfS4uLmApO1xuXG4gICAgY29uc3QgdHhJbnB1dEFtb3VudCA9IG91dHB1dEFtb3VudCB8fCAodGhpcy50eEluZm8gJiYgdGhpcy50eEluZm8uaW5wdXRBbW91bnQpO1xuICAgIGNvbnN0IHR4RmVlQW1vdW50ID0gcmVjb3ZlcnlGZWUgfHwgKHRoaXMudHhJbmZvICYmIHRoaXMudHhJbmZvLm1pbmVyRmVlKTtcblxuICAgIGlmICghdHhJbnB1dEFtb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZGV0ZXJtaW5lIHRyYW5zYWN0aW9uIGlucHV0IGFtb3VudCcpO1xuICAgIH1cbiAgICBpZiAoIXR4RmVlQW1vdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBkZXRlcm1pbmUgdHJhbnNhY3Rpb24gZmVlIGFtb3VudCcpO1xuICAgIH1cbiAgICBjb25zdCB0eE91dHB1dEFtb3VudCA9IHR4SW5wdXRBbW91bnQgLSB0eEZlZUFtb3VudDtcblxuICAgIGlmICh0eE91dHB1dEFtb3VudCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gY2Fubm90IHBheSBpdHMgb3duIGZlZXMuIEFib3J0aW5nLicpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0aGlzLnR4SW5mbykpIHtcbiAgICAgIHRoaXMudHhJbmZvLm91dHB1dEFtb3VudCA9IHR4T3V0cHV0QW1vdW50O1xuICAgICAgdGhpcy50eEluZm8uc3BlbmRBbW91bnQgPSB0eE91dHB1dEFtb3VudDtcbiAgICB9XG5cbiAgICB0aGlzLnJlY292ZXJ5QWRkcmVzcyA9IHJlY292ZXJ5QWRkcmVzcztcbiAgICB0aGlzLnJlY292ZXJ5QW1vdW50ID0gdHhPdXRwdXRBbW91bnQ7XG5cbiAgICB0aGlzLnJlY292ZXJ5VHguYWRkT3V0cHV0KHJlY292ZXJ5QWRkcmVzcywgdHhPdXRwdXRBbW91bnQpO1xuXG4gICAgY29uc3Qgb3V0cHV0RGF0YSA9IHtcbiAgICAgIGFkZHJlc3M6IHJlY292ZXJ5QWRkcmVzcyxcbiAgICAgIHZhbHVlOiBvdXRwdXRBbW91bnQsXG4gICAgICB2YWx1ZVN0cmluZzogdHhPdXRwdXRBbW91bnQudG9TdHJpbmcoKSxcbiAgICAgIHdhbGxldDogdGhpcy53YWxsZXQuaWQoKSxcbiAgICAgIGNoYW5nZTogZmFsc2UsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnR4SW5mbykge1xuICAgICAgdGhpcy50eEluZm8ub3V0cHV0cy5wdXNoKG91dHB1dERhdGEpO1xuICAgICAgdGhpcy50eEluZm8uZXh0ZXJuYWxPdXRwdXRzLnB1c2gob3V0cHV0RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbGYtc2lnbnMgdGhlIGJ1aWx0IHRyYW5zYWN0aW9uIHdpdGggdGhlIHVzZXIncyBwcml2YXRlIGtleSBvciBrZXljaGFpblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMucGFzc3BocmFzZSB7U3RyaW5nfSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gaGFsZi1zaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25SZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiogc2lnblRyYW5zYWN0aW9uKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoc2VsZi50eEluZm8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdHhJbmZvLiBQbGVhc2UgYnVpbGQgYSB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9sb2coJ1NpZ25pbmcgdGhlIHRyYW5zYWN0aW9uLi4uJyk7XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGV4ID0gc2VsZi5yZWNvdmVyeVR4LmJ1aWxkSW5jb21wbGV0ZSgpLnRvSGV4KCk7XG5cbiAgICAgIGNvbnN0IHBydjogc3RyaW5nID0gXy5pc1N0cmluZyhwYXJhbXMucHJ2KSA/IHBhcmFtcy5wcnYgOiB5aWVsZCBzZWxmLmdldEtleXMocGFyYW1zLnBhc3NwaHJhc2UpO1xuXG4gICAgICBjb25zdCB0eFByZWJ1aWxkID0geyB0eEhleDogdHJhbnNhY3Rpb25IZXgsIHR4SW5mbzogc2VsZi50eEluZm8gfTtcbiAgICAgIHNlbGYuaGFsZlNpZ25lZFJlY292ZXJ5VHggPSBzZWxmLnNvdXJjZUNvaW4uc2lnblRyYW5zYWN0aW9uKHsgdHhQcmVidWlsZCwgcHJ2IH0pO1xuXG4gICAgICByZXR1cm4gc2VsZi5oYWxmU2lnbmVkUmVjb3ZlcnlUeDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB3YWxsZXQncyBlbmNyeXB0ZWQga2V5Y2hhaW4sIHRoZW4gZGVjcnlwdHMgaXQgd2l0aCB0aGUgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHBhc3NwaHJhc2Uge1N0cmluZ30gd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IGRlY3J5cHRlZCB3YWxsZXQgcHJpdmF0ZSBrZXlcbiAgICovXG4gIGdldEtleXMocGFzc3BocmFzZTogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxzdHJpbmc+KTogQmx1ZWJpcmQ8c3RyaW5nPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHN0cmluZz4oZnVuY3Rpb24qIGdldEtleXMoKSB7XG4gICAgICBsZXQgcHJ2O1xuXG4gICAgICBsZXQga2V5Y2hhaW47XG4gICAgICB0cnkge1xuICAgICAgICBrZXljaGFpbiA9IHlpZWxkIHNlbGYud2FsbGV0LmdldEVuY3J5cHRlZFVzZXJLZXljaGFpbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5zdGF0dXMgIT09IDQwNCkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFzc3BocmFzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSBhbiBlbmNyeXB0ZWQgdXNlciBrZXljaGFpbiAtIHBsZWFzZSBwcm92aWRlIHRoZSBwYXNzcGhyYXNlIHRvIGRlY3J5cHQgaXQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYud2FsbGV0LmlzVjEpIHtcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoa2V5Y2hhaW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWMSB3YWxsZXRzIG5lZWQgYSB1c2VyIGtleWNoYWluIC0gY291bGQgbm90IGZpbmQgdGhlIHByb3BlciBrZXljaGFpbi4gQWJvcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Y2hhaW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRQcnYgPSBzZWxmLndhbGxldC5pc1YxID8ga2V5Y2hhaW4uZW5jcnlwdGVkWHBydiA6IGtleWNoYWluLmVuY3J5cHRlZFBydjtcbiAgICAgICAgICBwcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogZW5jcnlwdGVkUHJ2LCBwYXNzd29yZDogcGFzc3BocmFzZSB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgcmVhZGluZyBwcml2YXRlIGtleS4gUGxlYXNlIGNoZWNrIHRoYXQgeW91IGhhdmUgdGhlIGNvcnJlY3Qgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJ2O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgYnVpbGRUcmFuc2FjdGlvbihwYXJhbXM6IEJ1aWxkUmVjb3ZlcnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qIGJ1aWxkVHJhbnNhY3Rpb24oKSB7XG4gICAgICB5aWVsZCBzZWxmLnNldFdhbGxldChwYXJhbXMud2FsbGV0KTtcblxuICAgICAgeWllbGQgc2VsZi5maW5kVW5zcGVudHMocGFyYW1zLmZhdWx0eVR4SWQpO1xuICAgICAgeWllbGQgc2VsZi5idWlsZElucHV0cygpO1xuICAgICAgc2VsZi5zZXRGZWVzKCk7XG4gICAgICBzZWxmLmJ1aWxkT3V0cHV0cyhwYXJhbXMucmVjb3ZlcnlBZGRyZXNzKTtcblxuICAgICAgcmV0dXJuIHNlbGYucmVjb3ZlcnlUeDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGJ1aWxkVW5zaWduZWQoY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzZWxmLnR4SW5mbykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0eEluZm8uIFBsZWFzZSBidWlsZCBhIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNvbXBsZXRlID0gc2VsZi5yZWNvdmVyeVR4LmJ1aWxkSW5jb21wbGV0ZSgpO1xuXG4gICAgICBjb25zdCB0eEluZm86IGFueSA9IHtcbiAgICAgICAgblAyU0hJbnB1dHM6IDAsXG4gICAgICAgIG5TZWd3aXRJbnB1dHM6IDAsXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHNlbGYudHhJbmZvLmlucHV0cykge1xuICAgICAgICBpZiAoaW5wdXQuY2hhaW4gPT09IDEwIHx8IGlucHV0LmNoYWluID09PSAxMSkge1xuICAgICAgICAgIHR4SW5mby5uU2Vnd2l0SW5wdXRzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHhJbmZvLm5QMlNISW5wdXRzKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHhJbmZvLm5PdXRwdXRzID0gMTtcbiAgICAgIHR4SW5mby51bnNwZW50cyA9IF8ubWFwKFxuICAgICAgICBzZWxmLnR4SW5mby5pbnB1dHMsXG4gICAgICAgIF8ucGFydGlhbFJpZ2h0KF8ucGljaywgWydjaGFpbicsICdpbmRleCcsICdyZWRlZW1TY3JpcHQnLCAnaWQnLCAnYWRkcmVzcycsICd2YWx1ZSddKVxuICAgICAgKTtcbiAgICAgIHR4SW5mby5jaGFuZ2VBZGRyZXNzZXMgPSBbXTtcbiAgICAgIHR4SW5mby53YWxsZXRBZGRyZXNzRGV0YWlscyA9IHt9O1xuXG4gICAgICBjb25zdCBmZWVJbmZvOiBhbnkgPSB7fTtcblxuICAgICAgZmVlSW5mby5zaXplID1cbiAgICAgICAgVmlydHVhbFNpemVzLnR4T3ZlcmhlYWRTaXplICtcbiAgICAgICAgVmlydHVhbFNpemVzLnR4UDJzaElucHV0U2l6ZSAqIHNlbGYudHhJbmZvLmlucHV0cy5sZW5ndGggK1xuICAgICAgICBWaXJ0dWFsU2l6ZXMudHhQMnBraE91dHB1dFNpemU7XG5cbiAgICAgIGZlZUluZm8uZmVlUmF0ZSA9IHNlbGYuZmVlUmF0ZXNbc2VsZi5zb3VyY2VDb2luLnR5cGVdO1xuICAgICAgZmVlSW5mby5mZWUgPSBNYXRoLnJvdW5kKChmZWVJbmZvLnNpemUgLyAxMDAwKSAqIGZlZUluZm8uZmVlUmF0ZSk7XG4gICAgICBmZWVJbmZvLnBheUdvRmVlID0gMDtcbiAgICAgIGZlZUluZm8ucGF5R29GZWVTdHJpbmcgPSAnMCc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGV4OiBpbmNvbXBsZXRlLnRvSGV4KCksXG4gICAgICAgIHR4SW5mbzogdHhJbmZvLFxuICAgICAgICBmZWVJbmZvOiBmZWVJbmZvLFxuICAgICAgICB3YWxsZXRJZDogc2VsZi53YWxsZXQuaWQoKSxcbiAgICAgICAgYW1vdW50OiBzZWxmLnJlY292ZXJ5QW1vdW50LFxuICAgICAgICBhZGRyZXNzOiBzZWxmLnJlY292ZXJ5QWRkcmVzcyxcbiAgICAgICAgY29pbjogc2VsZi5zb3VyY2VDb2luLnR5cGUsXG4gICAgICB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgZXhwb3J0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLndhbGxldC5pc1YxID8gMSA6IDIsXG4gICAgICBzb3VyY2VDb2luOiB0aGlzLnNvdXJjZUNvaW4udHlwZSxcbiAgICAgIHJlY292ZXJ5Q29pbjogdGhpcy5yZWNvdmVyeUNvaW4udHlwZSxcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldC5pZCgpLFxuICAgICAgcmVjb3ZlcnlBZGRyZXNzOiB0aGlzLnJlY292ZXJ5QWRkcmVzcyxcbiAgICAgIHJlY292ZXJ5QW1vdW50OiB0aGlzLnJlY292ZXJ5QW1vdW50LFxuICAgICAgdHhIZXg6IHRoaXMuaGFsZlNpZ25lZFJlY292ZXJ5VHggJiYgKHRoaXMuaGFsZlNpZ25lZFJlY292ZXJ5VHgudHhIZXggfHwgdGhpcy5oYWxmU2lnbmVkUmVjb3ZlcnlUeC50eCksXG4gICAgICB0eEluZm86IHRoaXMudHhJbmZvLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==