"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var _ = require("lodash");
var Bluebird = require("bluebird");
var debugLib = require("debug");
var common_1 = require("../common");
var pendingApproval_1 = require("./pendingApproval");
var co = Bluebird.coroutine;
var debug = debugLib('bitgo:v2:pendingApprovals');
var PendingApprovals = /** @class */ (function () {
    function PendingApprovals(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * List the pending approvals available to the user
     * @param params
     * @param callback
     */
    PendingApprovals.prototype.list = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var queryParams, body;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common_1.validateParams(params, [], ['walletId', 'enterpriseId'], callback);
                        queryParams = {};
                        if (_.isString(params.walletId)) {
                            queryParams.walletId = params.walletId;
                        }
                        if (_.isString(params.enterpriseId)) {
                            queryParams.enterprise = params.enterpriseId;
                        }
                        if (Object.keys(queryParams).length !== 1) {
                            throw new Error('must provide exactly 1 of walletId or enterpriseId to get pending approvals on');
                        }
                        return [4 /*yield*/, self.bitgo
                                .get(self.baseCoin.url('/pendingapprovals'))
                                .query(queryParams)
                                .result()];
                    case 1:
                        body = _a.sent();
                        body.pendingApprovals = body.pendingApprovals.map(function (currentApproval) { return new pendingApproval_1.PendingApproval(self.bitgo, self.baseCoin, currentApproval); });
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Fetch an existing pending approval
     * @param params
     * @param callback
     */
    PendingApprovals.prototype.get = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var approvalData, approvalWallet, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common_1.validateParams(params, ['id'], [], callback);
                        return [4 /*yield*/, self.bitgo.get(self.baseCoin.url('/pendingapprovals/' + params.id)).result()];
                    case 1:
                        approvalData = _a.sent();
                        if (!approvalData.wallet) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, self.baseCoin.wallets().get({ id: approvalData.wallet })];
                    case 3:
                        approvalWallet = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        // nothing to be done here, although it's probably noteworthy that a non-existent wallet is referenced
                        debug('failed to get wallet %s, referenced by pending approval %s', approvalData.wallet, params.id);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/, new pendingApproval_1.PendingApproval(self.bitgo, self.baseCoin, approvalData, approvalWallet)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return PendingApprovals;
}());
exports.PendingApprovals = PendingApprovals;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ0FwcHJvdmFscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92Mi9wZW5kaW5nQXBwcm92YWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCwwQkFBNEI7QUFDNUIsbUNBQXFDO0FBQ3JDLGdDQUFrQztBQUdsQyxvQ0FBMkM7QUFDM0MscURBQW9EO0FBSXBELElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFDOUIsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLDJCQUEyQixDQUFDLENBQUM7QUFlcEQ7SUFJRSwwQkFBWSxLQUFZLEVBQUUsUUFBa0I7UUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCwrQkFBSSxHQUFKLFVBQ0UsTUFBd0MsRUFDeEMsUUFBbUQ7UUFEbkQsdUJBQUEsRUFBQSxXQUF3QztRQUd4QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQTZCOzs7Ozt3QkFDcEMsdUJBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUU3RCxXQUFXLEdBQVEsRUFBRSxDQUFDO3dCQUM1QixJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFOzRCQUMvQixXQUFXLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7eUJBQ3hDO3dCQUNELElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUU7NEJBQ25DLFdBQVcsQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQzt5QkFDOUM7d0JBRUQsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7NEJBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0ZBQWdGLENBQUMsQ0FBQzt5QkFDbkc7d0JBRVkscUJBQU0sSUFBSSxDQUFDLEtBQUs7aUNBQzFCLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2lDQUMzQyxLQUFLLENBQUMsV0FBVyxDQUFDO2lDQUNsQixNQUFNLEVBQUUsRUFBQTs7d0JBSEwsSUFBSSxHQUFHLFNBR0Y7d0JBQ1gsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQy9DLFVBQUEsZUFBZSxJQUFJLE9BQUEsSUFBSSxpQ0FBZSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxlQUFlLENBQUMsRUFBL0QsQ0FBK0QsQ0FDbkYsQ0FBQzt3QkFDRixzQkFBTyxJQUFJLEVBQUM7OztTQUNiLENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsOEJBQUcsR0FBSCxVQUFJLE1BQXNDLEVBQUUsUUFBd0M7UUFBaEYsdUJBQUEsRUFBQSxXQUFzQztRQUN4QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQWtCOzs7Ozt3QkFDekIsdUJBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBRXhCLHFCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFBOzt3QkFBakcsWUFBWSxHQUFHLFNBQWtGOzZCQUVuRyxZQUFZLENBQUMsTUFBTSxFQUFuQix3QkFBbUI7Ozs7d0JBRUYscUJBQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUE7O3dCQUEvRSxjQUFjLEdBQUcsU0FBOEQsQ0FBQzs7Ozt3QkFFaEYsc0dBQXNHO3dCQUN0RyxLQUFLLENBQUMsNERBQTRELEVBQUUsWUFBWSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7OzRCQUd4RyxzQkFBTyxJQUFJLGlDQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLFlBQVksRUFBRSxjQUFjLENBQUMsRUFBQzs7O1NBQ3JGLENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFDSCx1QkFBQztBQUFELENBQUMsQUF4RUQsSUF3RUM7QUF4RVksNENBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi9iaXRnbyc7XG5cbmltcG9ydCB7IHZhbGlkYXRlUGFyYW1zIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IFBlbmRpbmdBcHByb3ZhbCB9IGZyb20gJy4vcGVuZGluZ0FwcHJvdmFsJztcbmltcG9ydCB7IEJhc2VDb2luIH0gZnJvbSAnLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2MjpwZW5kaW5nQXBwcm92YWxzJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFBlbmRpbmdBcHByb3ZhbHNPcHRpb25zIHtcbiAgd2FsbGV0SWQ/OiBzdHJpbmc7XG4gIGVudGVycHJpc2VJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRQZW5kaW5nQXBwcm92YWxPcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFBlbmRpbmdBcHByb3ZhbHNSZXN1bHQge1xuICBwZW5kaW5nQXBwcm92YWxzOiBQZW5kaW5nQXBwcm92YWxbXTtcbn1cblxuZXhwb3J0IGNsYXNzIFBlbmRpbmdBcHByb3ZhbHMge1xuICBwcml2YXRlIHJlYWRvbmx5IGJpdGdvOiBCaXRHbztcbiAgcHJpdmF0ZSByZWFkb25seSBiYXNlQ29pbjogQmFzZUNvaW47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBiYXNlQ29pbjogQmFzZUNvaW4pIHtcbiAgICB0aGlzLmJpdGdvID0gYml0Z287XG4gICAgdGhpcy5iYXNlQ29pbiA9IGJhc2VDb2luO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHBlbmRpbmcgYXBwcm92YWxzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbGlzdChcbiAgICBwYXJhbXM6IExpc3RQZW5kaW5nQXBwcm92YWxzT3B0aW9ucyA9IHt9LFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPExpc3RQZW5kaW5nQXBwcm92YWxzUmVzdWx0PlxuICApOiBCbHVlYmlyZDxMaXN0UGVuZGluZ0FwcHJvdmFsc1Jlc3VsdD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxMaXN0UGVuZGluZ0FwcHJvdmFsc1Jlc3VsdD4oZnVuY3Rpb24qKCkge1xuICAgICAgdmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRJZCcsICdlbnRlcnByaXNlSWQnXSwgY2FsbGJhY2spO1xuXG4gICAgICBjb25zdCBxdWVyeVBhcmFtczogYW55ID0ge307XG4gICAgICBpZiAoXy5pc1N0cmluZyhwYXJhbXMud2FsbGV0SWQpKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLndhbGxldElkID0gcGFyYW1zLndhbGxldElkO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNTdHJpbmcocGFyYW1zLmVudGVycHJpc2VJZCkpIHtcbiAgICAgICAgcXVlcnlQYXJhbXMuZW50ZXJwcmlzZSA9IHBhcmFtcy5lbnRlcnByaXNlSWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhxdWVyeVBhcmFtcykubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGV4YWN0bHkgMSBvZiB3YWxsZXRJZCBvciBlbnRlcnByaXNlSWQgdG8gZ2V0IHBlbmRpbmcgYXBwcm92YWxzIG9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCBzZWxmLmJpdGdvXG4gICAgICAgIC5nZXQoc2VsZi5iYXNlQ29pbi51cmwoJy9wZW5kaW5nYXBwcm92YWxzJykpXG4gICAgICAgIC5xdWVyeShxdWVyeVBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgYm9keS5wZW5kaW5nQXBwcm92YWxzID0gYm9keS5wZW5kaW5nQXBwcm92YWxzLm1hcChcbiAgICAgICAgY3VycmVudEFwcHJvdmFsID0+IG5ldyBQZW5kaW5nQXBwcm92YWwoc2VsZi5iaXRnbywgc2VsZi5iYXNlQ29pbiwgY3VycmVudEFwcHJvdmFsKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFuIGV4aXN0aW5nIHBlbmRpbmcgYXBwcm92YWxcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldChwYXJhbXM6IEdldFBlbmRpbmdBcHByb3ZhbE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UGVuZGluZ0FwcHJvdmFsPik6IEJsdWViaXJkPFBlbmRpbmdBcHByb3ZhbD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxQZW5kaW5nQXBwcm92YWw+KGZ1bmN0aW9uKigpIHtcbiAgICAgIHZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgICBjb25zdCBhcHByb3ZhbERhdGEgPSB5aWVsZCBzZWxmLmJpdGdvLmdldChzZWxmLmJhc2VDb2luLnVybCgnL3BlbmRpbmdhcHByb3ZhbHMvJyArIHBhcmFtcy5pZCkpLnJlc3VsdCgpO1xuICAgICAgbGV0IGFwcHJvdmFsV2FsbGV0O1xuICAgICAgaWYgKGFwcHJvdmFsRGF0YS53YWxsZXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhcHByb3ZhbFdhbGxldCA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ud2FsbGV0cygpLmdldCh7IGlkOiBhcHByb3ZhbERhdGEud2FsbGV0IH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm90aGluZyB0byBiZSBkb25lIGhlcmUsIGFsdGhvdWdoIGl0J3MgcHJvYmFibHkgbm90ZXdvcnRoeSB0aGF0IGEgbm9uLWV4aXN0ZW50IHdhbGxldCBpcyByZWZlcmVuY2VkXG4gICAgICAgICAgZGVidWcoJ2ZhaWxlZCB0byBnZXQgd2FsbGV0ICVzLCByZWZlcmVuY2VkIGJ5IHBlbmRpbmcgYXBwcm92YWwgJXMnLCBhcHByb3ZhbERhdGEud2FsbGV0LCBwYXJhbXMuaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFBlbmRpbmdBcHByb3ZhbChzZWxmLmJpdGdvLCBzZWxmLmJhc2VDb2luLCBhcHByb3ZhbERhdGEsIGFwcHJvdmFsV2FsbGV0KTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19