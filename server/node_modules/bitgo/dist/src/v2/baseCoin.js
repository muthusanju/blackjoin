"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var bignumber_js_1 = require("bignumber.js");
var bitcoin = require("bitgo-utxo-lib");
var bitcoin_1 = require("../bitcoin");
var bitcoinMessage = require('bitcoinjs-message');
var Bluebird = require("bluebird");
var errors = require("../errors");
var co = Bluebird.coroutine;
var wallet_1 = require("./wallet");
var wallets_1 = require("./wallets");
var markets_1 = require("./markets");
var webhooks_1 = require("./webhooks");
var pendingApprovals_1 = require("./pendingApprovals");
var keychains_1 = require("./keychains");
var enterprises_1 = require("./enterprises");
var BaseCoin = /** @class */ (function () {
    function BaseCoin(bitgo) {
        this.bitgo = bitgo;
        this._url = this.bitgo.url('/', 2);
        this._wallets = new wallets_1.Wallets(this.bitgo, this);
        this._keychains = new keychains_1.Keychains(this.bitgo, this);
        this._webhooks = new webhooks_1.Webhooks(this.bitgo, this);
        this._pendingApprovals = new pendingApprovals_1.PendingApprovals(this.bitgo, this);
        this._enterprises = new enterprises_1.Enterprises(this.bitgo, this);
        this._markets = new markets_1.Markets(this.bitgo, this);
    }
    BaseCoin.prototype.url = function (suffix) {
        return this._url + this.getChain() + suffix;
    };
    BaseCoin.prototype.wallets = function () {
        return this._wallets;
    };
    BaseCoin.prototype.enterprises = function () {
        return this._enterprises;
    };
    BaseCoin.prototype.keychains = function () {
        return this._keychains;
    };
    BaseCoin.prototype.webhooks = function () {
        return this._webhooks;
    };
    BaseCoin.prototype.pendingApprovals = function () {
        return this._pendingApprovals;
    };
    BaseCoin.prototype.markets = function () {
        return this._markets;
    };
    Object.defineProperty(BaseCoin, "coinTokenPatternSeparator", {
        get: function () {
            return this._coinTokenPatternSeparator;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCoin.prototype, "type", {
        get: function () {
            return this.getChain();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Flag for sending value of 0.
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    BaseCoin.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    BaseCoin.prototype.transactionDataAllowed = function () {
        return false;
    };
    /**
     * Flag for determining whether this coin supports account consolidations
     * from its receive addresses to the root address.
     * @returns {boolean} True if okay to consolidate over this coin; false, otherwise
     */
    BaseCoin.prototype.allowsAccountConsolidations = function () {
        return false;
    };
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, rmg, xrp, xlm)
     */
    BaseCoin.prototype.baseUnitsToBigUnits = function (baseUnits) {
        var dividend = this.getBaseFactor();
        var bigNumber = new bignumber_js_1.BigNumber(baseUnits).dividedBy(dividend);
        // set the format so commas aren't added to large coin amounts
        // @ts-ignore
        return bigNumber.toFormat(null, null, { groupSeparator: '', decimalSeparator: '.' });
    };
    /**
     * Convert a currency amount represented in big units (btc, eth, rmg, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    BaseCoin.prototype.bigUnitsToBaseUnits = function (bigUnits) {
        var multiplier = this.getBaseFactor();
        var bigNumber = new bignumber_js_1.BigNumber(bigUnits).times(multiplier);
        if (!bigNumber.isInteger()) {
            throw new Error("non-integer output resulted from multiplying " + bigUnits + " by " + multiplier);
        }
        return bigNumber.toFixed(0);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    BaseCoin.prototype.signMessage = function (key, message) {
        var privateKey = bitcoin.HDNode.fromBase58(key.prv).getKey();
        var privateKeyBuffer = privateKey.d.toBuffer(32);
        var isCompressed = privateKey.compressed;
        var prefix = bitcoin.networks.bitcoin.messagePrefix;
        return bitcoinMessage.sign(message, privateKeyBuffer, isCompressed, prefix);
    };
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    BaseCoin.prototype.supportsBlockTarget = function () {
        return false;
    };
    /**
     * Hook to add additional parameters to the wallet generation
     * @param walletParams
     * @param keychains
     * @return {*}
     */
    BaseCoin.prototype.supplementGenerateWallet = function (walletParams, keychains) {
        return Bluebird.resolve(walletParams);
    };
    /**
     * Get extra parameters for prebuilding a tx. Add things like hop transaction params
     */
    BaseCoin.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    BaseCoin.prototype.postProcessPrebuild = function (prebuildResponse, callback) {
        return Bluebird.resolve(prebuildResponse).asCallback(callback);
    };
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     */
    BaseCoin.prototype.presignTransaction = function (params, callback) {
        return Bluebird.resolve(params).asCallback(callback);
    };
    /**
     * Create a new wallet object from a wallet data object
     * @param walletParams
     */
    BaseCoin.prototype.newWalletObject = function (walletParams) {
        return new wallet_1.Wallet(this.bitgo, this, walletParams);
    };
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @param callback
     * @returns {Object} The info returned from the merchant server
     */
    BaseCoin.prototype.feeEstimate = function (params, callback) {
        var self = this;
        return co(function coFeeEstimate() {
            var query;
            return __generator(this, function (_a) {
                query = {};
                if (params && params.numBlocks) {
                    query.numBlocks = params.numBlocks;
                }
                return [2 /*return*/, self.bitgo
                        .get(self.url('/tx/fee'))
                        .query(query)
                        .result()];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: string, derivationPath: string}}
     */
    BaseCoin.prototype.deriveKeyWithSeed = function (_a) {
        var key = _a.key, seed = _a.seed;
        var derivationPathInput = bitcoin.crypto.hash256("" + seed).toString('hex');
        var derivationPathParts = [
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        var derivationPath = 'm/999999/' + derivationPathParts.join('/');
        var keyNode = bitcoin.HDNode.fromBase58(key);
        var derivedKeyNode = bitcoin_1.hdPath(keyNode).derive(derivationPath);
        return {
            key: derivedKeyNode.toBase58(),
            derivationPath: derivationPath,
        };
    };
    /**
     * Specifies what key we will need for signing - right now we just need the
     * user key.
     */
    BaseCoin.prototype.keyIdsForSigning = function () {
        return [keychains_1.KeyIndices.USER];
    };
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    BaseCoin.prototype.preCreateBitGo = function (params) { };
    BaseCoin.prototype.initiateRecovery = function (params) {
        var self = this;
        return co(function initiateRecovery() {
            function validatePassphraseKey(userKey, passphrase) {
                try {
                    if (!userKey.startsWith('xprv') && !userKey.startsWith('xpub')) {
                        userKey = self.bitgo.decrypt({
                            input: userKey,
                            password: passphrase,
                        });
                    }
                    return bitcoin.HDNode.fromBase58(userKey);
                }
                catch (e) {
                    throw new Error('Failed to decrypt user key with passcode - try again!');
                }
            }
            var keys, userKey, backupKey, bitgoXpub, destinationAddress, passphrase, isKrsRecovery, key, backupHDNode, bitgoHDNode;
            return __generator(this, function (_a) {
                keys = [];
                userKey = params.userKey;
                backupKey = params.backupKey;
                bitgoXpub = params.bitgoKey;
                destinationAddress = params.recoveryDestination;
                passphrase = params.walletPassphrase;
                isKrsRecovery = backupKey.startsWith('xpub') && !userKey.startsWith('xpub');
                key = validatePassphraseKey(userKey, passphrase);
                keys.push(key);
                // Validate the backup key
                try {
                    if (!backupKey.startsWith('xprv') && !isKrsRecovery && !backupKey.startsWith('xpub')) {
                        backupKey = self.bitgo.decrypt({
                            input: backupKey,
                            password: passphrase,
                        });
                    }
                    backupHDNode = bitcoin.HDNode.fromBase58(backupKey);
                    keys.push(backupHDNode);
                }
                catch (e) {
                    throw new Error('Failed to decrypt backup key with passcode - try again!');
                }
                try {
                    bitgoHDNode = bitcoin.HDNode.fromBase58(bitgoXpub);
                    keys.push(bitgoHDNode);
                }
                catch (e) {
                    if (self.getFamily() !== 'xrp') {
                        // in XRP recoveries, the BitGo xpub is optional
                        throw new Error('Failed to parse bitgo xpub!');
                    }
                }
                // Validate the destination address
                try {
                    if (!self.isValidAddress(destinationAddress)) {
                        throw new Error('Invalid destination address!');
                    }
                }
                catch (e) {
                    // if isValidAddress is not implemented, assume the destination
                    // address is valid and let the tx go through. If the destination
                    // is actually invalid (`isValidAddress` returns false and does
                    // not throw), this method will still throw
                    if (!(e instanceof errors.MethodNotImplementedError)) {
                        throw e;
                    }
                }
                return [2 /*return*/, keys];
            });
        }).call(this);
    };
    // Some coins can have their tx info verified, if a public tx decoder is available
    BaseCoin.prototype.verifyRecoveryTransaction = function (txInfo) {
        return Bluebird.reject(new errors.MethodNotImplementedError());
    };
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    BaseCoin.prototype.isValidMofNSetup = function (_a) {
        var m = _a.m, n = _a.n;
        return m === 2 && n === 3;
    };
    BaseCoin._coinTokenPatternSeparator = ':';
    return BaseCoin;
}());
exports.BaseCoin = BaseCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZUNvaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdjIvYmFzZUNvaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDZDQUF5QztBQUN6Qyx3Q0FBMEM7QUFDMUMsc0NBQW9DO0FBQ3BDLElBQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3BELG1DQUFxQztBQUVyQyxrQ0FBb0M7QUFHcEMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUU5QixtQ0FBa0M7QUFDbEMscUNBQW9DO0FBQ3BDLHFDQUFvQztBQUNwQyx1Q0FBc0M7QUFDdEMsdURBQXNEO0FBQ3RELHlDQUE4RDtBQUM5RCw2Q0FBNEM7QUE2SjVDO0lBV0Usa0JBQXNCLEtBQVk7UUFDaEMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGlCQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUkscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxtQkFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksbUNBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUkseUJBQVcsQ0FBQyxJQUFJLENB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QUFDLDZCQUE2QixDQUFDLENBQUM7cUJBQ2hEO2lCQUNGO2dCQUNELG1DQUFtQztnQkFDbkMsSUFBSTtvQkFDRixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO3dCQUM1QyxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7cUJBQ2pEO2lCQUNGO2dCQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUNWLCtEQUErRDtvQkFDL0QsaUVBQWlFO29CQUNqRSwrREFBK0Q7b0JBQy9ELDJDQUEyQztvQkFDM0MsSUFBSSxDQUFDLENBQUMsQ0FBQyxZQUFZLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxFQUFFO3dCQUNwRCxNQUFNLENBQUMsQ0FBQztxQkFDVDtpQkFDRjtnQkFFRCxzQkFBTyxJQUFJLEVBQUM7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoQixDQUFDO0lBRUQsa0ZBQWtGO0lBQ2xGLDRDQUF5QixHQUF6QixVQUEwQixNQUF3QztRQUNoRSxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFzQkQ7O09BRUc7SUFDSCxtQ0FBZ0IsR0FBaEIsVUFBaUIsRUFBb0M7WUFBbEMsUUFBQyxFQUFFLFFBQUM7UUFDckIsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQXhXeUIsbUNBQTBCLEdBQUcsR0FBRyxDQUFDO0lBdVg3RCxlQUFDO0NBQUEsQUFoWUQsSUFnWUM7QUFoWXFCLDRCQUFRIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIGJpdGNvaW4gZnJvbSAnYml0Z28tdXR4by1saWInO1xuaW1wb3J0IHsgaGRQYXRoIH0gZnJvbSAnLi4vYml0Y29pbic7XG5jb25zdCBiaXRjb2luTWVzc2FnZSA9IHJlcXVpcmUoJ2JpdGNvaW5qcy1tZXNzYWdlJyk7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uL2JpdGdvJztcbmltcG9ydCAqIGFzIGVycm9ycyBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi9pbnRlcm5hbC91dGlsJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuL3dhbGxldCc7XG5pbXBvcnQgeyBXYWxsZXRzIH0gZnJvbSAnLi93YWxsZXRzJztcbmltcG9ydCB7IE1hcmtldHMgfSBmcm9tICcuL21hcmtldHMnO1xuaW1wb3J0IHsgV2ViaG9va3MgfSBmcm9tICcuL3dlYmhvb2tzJztcbmltcG9ydCB7IFBlbmRpbmdBcHByb3ZhbHMgfSBmcm9tICcuL3BlbmRpbmdBcHByb3ZhbHMnO1xuaW1wb3J0IHsgS2V5Y2hhaW4sIEtleWNoYWlucywgS2V5SW5kaWNlcyB9IGZyb20gJy4va2V5Y2hhaW5zJztcbmltcG9ydCB7IEVudGVycHJpc2VzIH0gZnJvbSAnLi9lbnRlcnByaXNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25SZWNpcGllbnQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uRmVlIHtcbiAgZmVlOiBzdHJpbmc7XG4gIGZlZVJhdGU/OiBudW1iZXI7XG4gIHNpemU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIGRpc3BsYXlPcmRlcjogc3RyaW5nW107XG4gIGlkOiBzdHJpbmc7XG4gIG91dHB1dHM6IFRyYW5zYWN0aW9uUmVjaXBpZW50W107XG4gIG91dHB1dEFtb3VudDogc3RyaW5nO1xuICBjaGFuZ2VPdXRwdXRzOiBUcmFuc2FjdGlvblJlY2lwaWVudFtdO1xuICBjaGFuZ2VBbW91bnQ6IHN0cmluZztcbiAgZmVlOiBUcmFuc2FjdGlvbkZlZTtcbiAgcHJveHk/OiBzdHJpbmc7XG4gIHByb2R1Y2Vycz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEtleVBhaXIge1xuICBwdWI/OiBzdHJpbmc7XG4gIHBydjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBhZGRyZXNzVHlwZT86IHN0cmluZztcbiAga2V5Y2hhaW5zPzoge1xuICAgIHB1Yjogc3RyaW5nO1xuICB9W107XG4gIGNvaW5TcGVjaWZpYz86IEFkZHJlc3NDb2luU3BlY2lmaWM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QYXJhbXMge1xuICByZWNpcGllbnRzPzogVHJhbnNhY3Rpb25SZWNpcGllbnRbXTtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZmljYXRpb25PcHRpb25zIHtcbiAgZGlzYWJsZU5ldHdvcmtpbmc/OiBib29sZWFuO1xuICBrZXljaGFpbnM/OiB7XG4gICAgdXNlcj86IEtleWNoYWluO1xuICAgIGJhY2t1cD86IEtleWNoYWluO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcztcbiAgd2FsbGV0OiBXYWxsZXQ7XG4gIHZlcmlmaWNhdGlvbj86IFZlcmlmaWNhdGlvbk9wdGlvbnM7XG4gIHJlcUlkPzogUmVxdWVzdFRyYWNlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgbTogbnVtYmVyO1xuICBuOiBudW1iZXI7XG4gIGVudGVycHJpc2U/OiBzdHJpbmc7XG4gIGRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM/OiBib29sZWFuO1xuICBnYXNQcmljZT86IG51bWJlcjtcbiAga2V5czogc3RyaW5nW107XG4gIGlzQ29sZDogYm9vbGVhbjtcbiAga2V5U2lnbmF0dXJlcz86IHtcbiAgICBiYWNrdXA6IHN0cmluZztcbiAgICBiaXRnbzogc3RyaW5nO1xuICB9O1xuICByb290UHJpdmF0ZUtleT86IHN0cmluZztcbiAgZGlzYWJsZUtSU0VtYWlsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGZWVFc3RpbWF0ZU9wdGlvbnMge1xuICBudW1CbG9ja3M/OiBudW1iZXI7XG4gIGhvcD86IGJvb2xlYW47XG4gIHJlY2lwaWVudD86IHN0cmluZztcbiAgZGF0YT86IHN0cmluZztcbiAgYW1vdW50Pzogc3RyaW5nO1xufVxuXG4vLyBUT0RPIChTREtULTkpOiByZXZlcnNlIGVuZ2luZWVyIGFuZCBhZGQgb3B0aW9uc1xuLy8gZXhwb3J0IGludGVyZmFjZSBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucyB7fVxuZXhwb3J0IHR5cGUgRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMgPSBhbnk7XG5cbi8vIFRPRE8gKFNES1QtOSk6IHJldmVyc2UgZW5naW5lZXIgYW5kIGFkZCBvcHRpb25zXG4vLyBleHBvcnQgaW50ZXJmYWNlIFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge31cbmV4cG9ydCB0eXBlIFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSBhbnk7XG5cbi8vIFRPRE8gKFNES1QtOSk6IHJldmVyc2UgZW5naW5lZXIgYW5kIGFkZCBvcHRpb25zXG4vLyBleHBvcnQgaW50ZXJmYWNlIFByZWNyZWF0ZUJpdEdvT3B0aW9ucyB7fVxuZXhwb3J0IHR5cGUgUHJlY3JlYXRlQml0R29PcHRpb25zID0gYW55O1xuXG4vLyBUT0RPIChTREtULTkpOiByZXZlcnNlIGVuZ2luZWVyIGFuZCBhZGQgb3B0aW9uc1xuLy8gZXhwb3J0IGludGVyZmFjZSBWZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucyB7fVxuZXhwb3J0IHR5cGUgVmVyaWZ5UmVjb3ZlcnlUcmFuc2FjdGlvbk9wdGlvbnMgPSBhbnk7XG5cbi8vIFRPRE8gKFNES1QtOSk6IHJldmVyc2UgZW5naW5lZXIgYW5kIGFkZCBvcHRpb25zXG4vLyBleHBvcnQgaW50ZXJmYWNlIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zIHt9XG5leHBvcnQgdHlwZSBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyA9IGFueTtcblxuLy8gVE9ETyAoU0RLVC05KTogcmV2ZXJzZSBlbmdpbmVlciBhbmQgYWRkIG9wdGlvbnNcbi8vIGV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkVHJhbnNhY3Rpb24ge31cbmV4cG9ydCB0eXBlIFBhcnNlZFRyYW5zYWN0aW9uID0gYW55O1xuXG4vLyBUT0RPIChTREtULTkpOiByZXZlcnNlIGVuZ2luZWVyIGFuZCBhZGQgb3B0aW9uc1xuLy8gZXhwb3J0IGludGVyZmFjZSBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyB7fVxuZXhwb3J0IHR5cGUgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IGFueTtcblxuZXhwb3J0IGludGVyZmFjZSBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIGJpdGdvS2V5Pzogc3RyaW5nOyAvLyBvcHRpb25hbCBmb3IgeHJwIHJlY292ZXJpZXNcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEtleWNoYWluc1RyaXBsZXQge1xuICB1c2VyS2V5Y2hhaW46IEtleWNoYWluO1xuICBiYWNrdXBLZXljaGFpbjogS2V5Y2hhaW47XG4gIGJpdGdvS2V5Y2hhaW46IEtleWNoYWluO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQge1xuICB0eEJhc2U2ND86IHN0cmluZztcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIHdhbGxldD86IFdhbGxldDtcbiAgYnVpbGRQYXJhbXM/OiBhbnk7XG4gIGNvbnNvbGlkYXRlSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRkcmVzc0NvaW5TcGVjaWZpYyB7XG4gIG91dHB1dFNjcmlwdD86IHN0cmluZztcbiAgcmVkZWVtU2NyaXB0Pzogc3RyaW5nO1xuICB3aXRuZXNzU2NyaXB0Pzogc3RyaW5nO1xuICBiYXNlQWRkcmVzcz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgdHhIZXg6IHN0cmluZzsgLy8gVHJhbnNhY3Rpb24gaW4gYW55IGZvcm1hdCByZXF1aXJlZCBieSBlYWNoIGNvaW4sIGkuZS4gaW4gVHJvbiBpdCBpcyBhIHN0cmluZ2lmeWVkIEpTT05cbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4Pzogc3RyaW5nOyAvLyBUcmFuc2FjdGlvbiBpbiBhbnkgZm9ybWF0IHJlcXVpcmVkIGJ5IGVhY2ggY29pbiwgaS5lLiBpbiBUcm9uIGl0IGlzIGEgc3RyaW5naWZ5ZWQgSlNPTlxuICAgIHBheWxvYWQ/OiBzdHJpbmc7XG4gICAgdHhCYXNlNjQ/OiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCB0eXBlIFNpZ25lZFRyYW5zYWN0aW9uID0gSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHwgRnVsbHlTaWduZWRUcmFuc2FjdGlvbjtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGJpdGdvOiBCaXRHbztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF91cmw6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9lbnRlcnByaXNlczogRW50ZXJwcmlzZXM7XG4gIHByb3RlY3RlZCByZWFkb25seSBfd2FsbGV0czogV2FsbGV0cztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9rZXljaGFpbnM6IEtleWNoYWlucztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF93ZWJob29rczogV2ViaG9va3M7XG4gIHByb3RlY3RlZCByZWFkb25seSBfcGVuZGluZ0FwcHJvdmFsczogUGVuZGluZ0FwcHJvdmFscztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9tYXJrZXRzOiBNYXJrZXRzO1xuICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IF9jb2luVG9rZW5QYXR0ZXJuU2VwYXJhdG9yID0gJzonO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28pIHtcbiAgICB0aGlzLmJpdGdvID0gYml0Z287XG4gICAgdGhpcy5fdXJsID0gdGhpcy5iaXRnby51cmwoJy8nLCAyKTtcbiAgICB0aGlzLl93YWxsZXRzID0gbmV3IFdhbGxldHModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fa2V5Y2hhaW5zID0gbmV3IEtleWNoYWlucyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgICB0aGlzLl93ZWJob29rcyA9IG5ldyBXZWJob29rcyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgICB0aGlzLl9wZW5kaW5nQXBwcm92YWxzID0gbmV3IFBlbmRpbmdBcHByb3ZhbHModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fZW50ZXJwcmlzZXMgPSBuZXcgRW50ZXJwcmlzZXModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fbWFya2V0cyA9IG5ldyBNYXJrZXRzKHRoaXMuYml0Z28sIHRoaXMpO1xuICB9XG5cbiAgcHVibGljIHVybChzdWZmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3VybCArIHRoaXMuZ2V0Q2hhaW4oKSArIHN1ZmZpeDtcbiAgfVxuXG4gIHB1YmxpYyB3YWxsZXRzKCk6IFdhbGxldHMge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXRzO1xuICB9XG5cbiAgcHVibGljIGVudGVycHJpc2VzKCk6IEVudGVycHJpc2VzIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJwcmlzZXM7XG4gIH1cblxuICBwdWJsaWMga2V5Y2hhaW5zKCk6IEtleWNoYWlucyB7XG4gICAgcmV0dXJuIHRoaXMuX2tleWNoYWlucztcbiAgfVxuXG4gIHB1YmxpYyB3ZWJob29rcygpOiBXZWJob29rcyB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYmhvb2tzO1xuICB9XG5cbiAgcHVibGljIHBlbmRpbmdBcHByb3ZhbHMoKTogUGVuZGluZ0FwcHJvdmFscyB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbHM7XG4gIH1cblxuICBwdWJsaWMgbWFya2V0cygpOiBNYXJrZXRzIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya2V0cztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IGNvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3IoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fY29pblRva2VuUGF0dGVyblNlcGFyYXRvcjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldENoYWluKCk7XG4gIH1cblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY2hhaW4gd2hpY2ggc3VwcG9ydHMgdGhpcyBjb2luIChlZywgJ2J0YycsICdldGgnKVxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0Q2hhaW4oKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjb2luIGZhbWlseSAoZWcuIGZvciB0YnRjLCB0aGlzIHdvdWxkIGJlIGJ0YylcbiAgICovXG4gIGFic3RyYWN0IGdldEZhbWlseSgpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEh1bWFuIHJlYWRhYmxlIGZ1bGwgbmFtZSBmb3IgdGhlIGNvaW5cbiAgICovXG4gIGFic3RyYWN0IGdldEZ1bGxOYW1lKCk6IHN0cmluZztcblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgZGF0YSBhbG9uZyB3aXRoIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgdHggZGF0YSAoRVRIKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB0cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgY29pbiBzdXBwb3J0cyBhY2NvdW50IGNvbnNvbGlkYXRpb25zXG4gICAqIGZyb20gaXRzIHJlY2VpdmUgYWRkcmVzc2VzIHRvIHRoZSByb290IGFkZHJlc3MuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gY29uc29saWRhdGUgb3ZlciB0aGlzIGNvaW47IGZhbHNlLCBvdGhlcndpc2VcbiAgICovXG4gIGFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmFjdG9yIGJldHdlZW4gdGhlIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBjdXJyZW5jeSBhbW91bnQgcmVwcmVzZW50ZWQgaW4gYmFzZSB1bml0cyAoc2F0b3NoaSwgd2VpLCBhdG9tcywgZHJvcHMsIHN0cm9vcHMpXG4gICAqIHRvIGJpZyB1bml0cyAoYnRjLCBldGgsIHJtZywgeHJwLCB4bG0pXG4gICAqL1xuICBiYXNlVW5pdHNUb0JpZ1VuaXRzKGJhc2VVbml0czogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBkaXZpZGVuZCA9IHRoaXMuZ2V0QmFzZUZhY3RvcigpO1xuICAgIGNvbnN0IGJpZ051bWJlciA9IG5ldyBCaWdOdW1iZXIoYmFzZVVuaXRzKS5kaXZpZGVkQnkoZGl2aWRlbmQpO1xuICAgIC8vIHNldCB0aGUgZm9ybWF0IHNvIGNvbW1hcyBhcmVuJ3QgYWRkZWQgdG8gbGFyZ2UgY29pbiBhbW91bnRzXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBiaWdOdW1iZXIudG9Gb3JtYXQobnVsbCwgbnVsbCwgeyBncm91cFNlcGFyYXRvcjogJycsIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgY3VycmVuY3kgYW1vdW50IHJlcHJlc2VudGVkIGluIGJpZyB1bml0cyAoYnRjLCBldGgsIHJtZywgeHJwLCB4bG0pXG4gICAqIHRvIGJhc2UgdW5pdHMgKHNhdG9zaGksIHdlaSwgYXRvbXMsIGRyb3BzLCBzdHJvb3BzKVxuICAgKiBAcGFyYW0gYmlnVW5pdHNcbiAgICovXG4gIGJpZ1VuaXRzVG9CYXNlVW5pdHMoYmlnVW5pdHM6IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgbXVsdGlwbGllciA9IHRoaXMuZ2V0QmFzZUZhY3RvcigpO1xuICAgIGNvbnN0IGJpZ051bWJlciA9IG5ldyBCaWdOdW1iZXIoYmlnVW5pdHMpLnRpbWVzKG11bHRpcGxpZXIpO1xuICAgIGlmICghYmlnTnVtYmVyLmlzSW50ZWdlcigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vbi1pbnRlZ2VyIG91dHB1dCByZXN1bHRlZCBmcm9tIG11bHRpcGx5aW5nICR7YmlnVW5pdHN9IGJ5ICR7bXVsdGlwbGllcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpZ051bWJlci50b0ZpeGVkKDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIHNpZ25NZXNzYWdlKGtleTogeyBwcnY6IHN0cmluZyB9LCBtZXNzYWdlOiBzdHJpbmcpOiBCdWZmZXIge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KGtleS5wcnYpLmdldEtleSgpO1xuICAgIGNvbnN0IHByaXZhdGVLZXlCdWZmZXIgPSBwcml2YXRlS2V5LmQudG9CdWZmZXIoMzIpO1xuICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IHByaXZhdGVLZXkuY29tcHJlc3NlZDtcbiAgICBjb25zdCBwcmVmaXggPSBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW4ubWVzc2FnZVByZWZpeDtcbiAgICByZXR1cm4gYml0Y29pbk1lc3NhZ2Uuc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5QnVmZmVyLCBpc0NvbXByZXNzZWQsIHByZWZpeCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBjb21wbGllcyB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICovXG4gIGFic3RyYWN0IHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxib29sZWFuPik6IEJsdWViaXJkPGJvb2xlYW4+O1xuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhbiBhZGRyZXNzIGJlbG9uZ3MgdG8gYSB3YWxsZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBhYnN0cmFjdCB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyBibG9ja1RhcmdldCBmb3IgdHJhbnNhY3Rpb25zIHRvIGJlIGluY2x1ZGVkIGluXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNCbG9ja1RhcmdldCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSG9vayB0byBhZGQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHRoZSB3YWxsZXQgZ2VuZXJhdGlvblxuICAgKiBAcGFyYW0gd2FsbGV0UGFyYW1zXG4gICAqIEBwYXJhbSBrZXljaGFpbnNcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMsIGtleWNoYWluczogS2V5Y2hhaW5zVHJpcGxldCk6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHdhbGxldFBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGV4dHJhIHBhcmFtZXRlcnMgZm9yIHByZWJ1aWxkaW5nIGEgdHguIEFkZCB0aGluZ3MgbGlrZSBob3AgdHJhbnNhY3Rpb24gcGFyYW1zXG4gICAqL1xuICBnZXRFeHRyYVByZWJ1aWxkUGFyYW1zKGJ1aWxkUGFyYW1zOiBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8b2JqZWN0Pik6IEJsdWViaXJkPG9iamVjdD4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgcHJlYnVpbGQgYWZ0ZXIgcmVjZWl2aW5nIGl0IGZyb20gdGhlIHNlcnZlci4gQWRkIHRoaW5ncyBsaWtlIG5sb2NrdGltZVxuICAgKi9cbiAgcG9zdFByb2Nlc3NQcmVidWlsZChcbiAgICBwcmVidWlsZFJlc3BvbnNlOiBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uUHJlYnVpbGQ+XG4gICk6IEJsdWViaXJkPFRyYW5zYWN0aW9uUHJlYnVpbGQ+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShwcmVidWlsZFJlc3BvbnNlKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2luLXNwZWNpZmljIHRoaW5ncyBkb25lIGJlZm9yZSBzaWduaW5nIGEgdHJhbnNhY3Rpb24sIGkuZS4gdmVyaWZpY2F0aW9uXG4gICAqL1xuICBwcmVzaWduVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBQcmVzaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uUHJlYnVpbGQ+XG4gICk6IEJsdWViaXJkPFRyYW5zYWN0aW9uUHJlYnVpbGQ+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShwYXJhbXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB3YWxsZXQgb2JqZWN0IGZyb20gYSB3YWxsZXQgZGF0YSBvYmplY3RcbiAgICogQHBhcmFtIHdhbGxldFBhcmFtc1xuICAgKi9cbiAgbmV3V2FsbGV0T2JqZWN0KHdhbGxldFBhcmFtczogYW55KTogV2FsbGV0IHtcbiAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLCB3YWxsZXRQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGZlZSBlc3RpbWF0ZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1zIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IHBhcmFtcy5udW1CbG9ja3MgVGhlIG51bWJlciBvZiBibG9ja3MgdG8gdGFyZ2V0IGZvciBjb25mb3JtYXRpb24gKE9ubHkgd29ya3MgZm9yIGJ0YylcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpbmZvIHJldHVybmVkIGZyb20gdGhlIG1lcmNoYW50IHNlcnZlclxuICAgKi9cbiAgZmVlRXN0aW1hdGUocGFyYW1zOiBGZWVFc3RpbWF0ZU9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qIGNvRmVlRXN0aW1hdGUoKSB7XG4gICAgICBjb25zdCBxdWVyeTogYW55ID0ge307XG4gICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5udW1CbG9ja3MpIHtcbiAgICAgICAgcXVlcnkubnVtQmxvY2tzID0gcGFyYW1zLm51bUJsb2NrcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z29cbiAgICAgICAgLmdldChzZWxmLnVybCgnL3R4L2ZlZScpKVxuICAgICAgICAucXVlcnkocXVlcnkpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29sZCB3YWxsZXQgdG9vbCB1c2VzIHRoaXMgZnVuY3Rpb24gdG8gZGVyaXZlIGFuIGV4dGVuZGVkIGtleSB0aGF0IGlzIGJhc2VkIG9uIHRoZSBwYXNzZWQga2V5IGFuZCBzZWVkXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge3trZXk6IHN0cmluZywgZGVyaXZhdGlvblBhdGg6IHN0cmluZ319XG4gICAqL1xuICBkZXJpdmVLZXlXaXRoU2VlZCh7IGtleSwgc2VlZCB9OiB7IGtleTogc3RyaW5nOyBzZWVkOiBzdHJpbmcgfSk6IHsga2V5OiBzdHJpbmc7IGRlcml2YXRpb25QYXRoOiBzdHJpbmcgfSB7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhJbnB1dCA9IGJpdGNvaW4uY3J5cHRvLmhhc2gyNTYoYCR7c2VlZH1gKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhQYXJ0cyA9IFtcbiAgICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoMCwgNyksIDE2KSxcbiAgICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoNywgMTQpLCAxNiksXG4gICAgXTtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9ICdtLzk5OTk5OS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0cy5qb2luKCcvJyk7XG4gICAgY29uc3Qga2V5Tm9kZSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgoa2V5KTtcbiAgICBjb25zdCBkZXJpdmVkS2V5Tm9kZSA9IGhkUGF0aChrZXlOb2RlKS5kZXJpdmUoZGVyaXZhdGlvblBhdGgpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGRlcml2ZWRLZXlOb2RlLnRvQmFzZTU4KCksXG4gICAgICBkZXJpdmF0aW9uUGF0aDogZGVyaXZhdGlvblBhdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgd2hhdCBrZXkgd2Ugd2lsbCBuZWVkIGZvciBzaWduaW5nIC0gcmlnaHQgbm93IHdlIGp1c3QgbmVlZCB0aGVcbiAgICogdXNlciBrZXkuXG4gICAqL1xuICBrZXlJZHNGb3JTaWduaW5nKCk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gW0tleUluZGljZXMuVVNFUl07XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhZGRpdGlvbmFsIGNoZWNrcyBiZWZvcmUgYWRkaW5nIGEgYml0Z28ga2V5LiBCYXNlIGNvbnRyb2xsZXJcbiAgICogaXMgYSBuby1vcCwgYnV0IGNvaW4tc3BlY2lmaWMgY29udHJvbGxlciBtYXkgZG8gc29tZXRoaW5nXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHByZUNyZWF0ZUJpdEdvKHBhcmFtczogUHJlY3JlYXRlQml0R29PcHRpb25zKTogdm9pZCB7fVxuXG4gIGluaXRpYXRlUmVjb3ZlcnkocGFyYW1zOiBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyk6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiogaW5pdGlhdGVSZWNvdmVyeSgpIHtcbiAgICAgIGNvbnN0IGtleXM6IGJpdGNvaW4uSEROb2RlW10gPSBbXTtcbiAgICAgIGNvbnN0IHVzZXJLZXkgPSBwYXJhbXMudXNlcktleTsgLy8gQm94IEFcbiAgICAgIGxldCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5OyAvLyBCb3ggQlxuICAgICAgY29uc3QgYml0Z29YcHViID0gcGFyYW1zLmJpdGdvS2V5OyAvLyBCb3ggQ1xuICAgICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb247XG4gICAgICBjb25zdCBwYXNzcGhyYXNlID0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG5cbiAgICAgIGNvbnN0IGlzS3JzUmVjb3ZlcnkgPSBiYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcblxuICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXNzcGhyYXNlS2V5KHVzZXJLZXk6IHN0cmluZywgcGFzc3BocmFzZT86IHN0cmluZyk6IGJpdGNvaW4uSEROb2RlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXVzZXJLZXkuc3RhcnRzV2l0aCgneHBydicpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSkge1xuICAgICAgICAgICAgdXNlcktleSA9IHNlbGYuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgICAgIGlucHV0OiB1c2VyS2V5LFxuICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3BocmFzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OCh1c2VyS2V5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgdXNlciBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXk6IGJpdGNvaW4uSEROb2RlID0gdmFsaWRhdGVQYXNzcGhyYXNlS2V5KHVzZXJLZXksIHBhc3NwaHJhc2UpO1xuXG4gICAgICBrZXlzLnB1c2goa2V5KTtcblxuICAgICAgLy8gVmFsaWRhdGUgdGhlIGJhY2t1cCBrZXlcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwcnYnKSAmJiAhaXNLcnNSZWNvdmVyeSAmJiAhYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSkge1xuICAgICAgICAgIGJhY2t1cEtleSA9IHNlbGYuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3NwaHJhc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFja3VwSEROb2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChiYWNrdXBLZXkpO1xuICAgICAgICBrZXlzLnB1c2goYmFja3VwSEROb2RlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBiYWNrdXAga2V5IHdpdGggcGFzc2NvZGUgLSB0cnkgYWdhaW4hJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBiaXRnb0hETm9kZSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgoYml0Z29YcHViKTtcbiAgICAgICAga2V5cy5wdXNoKGJpdGdvSEROb2RlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0RmFtaWx5KCkgIT09ICd4cnAnKSB7XG4gICAgICAgICAgLy8gaW4gWFJQIHJlY292ZXJpZXMsIHRoZSBCaXRHbyB4cHViIGlzIG9wdGlvbmFsXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgYml0Z28geHB1YiEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVmFsaWRhdGUgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghc2VsZi5pc1ZhbGlkQWRkcmVzcyhkZXN0aW5hdGlvbkFkZHJlc3MpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRlc3RpbmF0aW9uIGFkZHJlc3MhJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgaXNWYWxpZEFkZHJlc3MgaXMgbm90IGltcGxlbWVudGVkLCBhc3N1bWUgdGhlIGRlc3RpbmF0aW9uXG4gICAgICAgIC8vIGFkZHJlc3MgaXMgdmFsaWQgYW5kIGxldCB0aGUgdHggZ28gdGhyb3VnaC4gSWYgdGhlIGRlc3RpbmF0aW9uXG4gICAgICAgIC8vIGlzIGFjdHVhbGx5IGludmFsaWQgKGBpc1ZhbGlkQWRkcmVzc2AgcmV0dXJucyBmYWxzZSBhbmQgZG9lc1xuICAgICAgICAvLyBub3QgdGhyb3cpLCB0aGlzIG1ldGhvZCB3aWxsIHN0aWxsIHRocm93XG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBlcnJvcnMuTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBTb21lIGNvaW5zIGNhbiBoYXZlIHRoZWlyIHR4IGluZm8gdmVyaWZpZWQsIGlmIGEgcHVibGljIHR4IGRlY29kZXIgaXMgYXZhaWxhYmxlXG4gIHZlcmlmeVJlY292ZXJ5VHJhbnNhY3Rpb24odHhJbmZvOiBWZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucyk6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QobmV3IGVycm9ycy5NZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCkpO1xuICB9XG5cbiAgYWJzdHJhY3QgcGFyc2VUcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFBhcnNlZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj47XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEga2V5IHBhaXIgb24gdGhlIGN1cnZlIHVzZWQgYnkgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICovXG4gIGFic3RyYWN0IGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpcjtcblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBhYnN0cmFjdCBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmV0dXJuIHdldGhlciB0aGUgZ2l2ZW4gbSBvZiBuIHdhbGxldCBzaWduZXJzLyBrZXkgYW1vdW50cyBhcmUgdmFsaWQgZm9yIHRoZSBjb2luXG4gICAqL1xuICBpc1ZhbGlkTW9mTlNldHVwKHsgbSwgbiB9OiB7IG0/OiBudW1iZXI7IG4/OiBudW1iZXIgfSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBtID09PSAyICYmIG4gPT09IDM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYGFkZHJlc3NgIGlzIGEgcGxhdXNpYmx5IHZhbGlkIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiBjb2luLlxuICAgKlxuICAgKiBEb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvIGEgd2FsbGV0LiBGb3IgdGhhdCxcbiAgICogdXNlIFtbdmVyaWZ5QWRkcmVzc11dXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBhYnN0cmFjdCBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTaWduIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFic3RyYWN0IHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBTaWduZWRUcmFuc2FjdGlvbjtcbn1cbiJdfQ==