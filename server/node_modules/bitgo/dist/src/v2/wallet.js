"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var Bluebird = require("bluebird");
var _ = require("lodash");
var debugLib = require("debug");
var bitcoin_1 = require("../bitcoin");
var common = require("../common");
var errors_1 = require("../errors");
var internal = require("./internal/internal");
var keycard_1 = require("./internal/keycard");
var tradingAccount_1 = require("./trading/tradingAccount");
var pendingApproval_1 = require("./pendingApproval");
var util_1 = require("./internal/util");
var debug = debugLib('bitgo:v2:wallet');
var co = Bluebird.coroutine;
var Wallet = /** @class */ (function () {
    function Wallet(bitgo, baseCoin, walletData) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this._wallet = walletData;
        var userId = _.get(bitgo, '_user.id');
        if (_.isString(userId)) {
            var userDetails = _.find(walletData.users, { user: userId });
            this._permissions = _.get(userDetails, 'permissions');
        }
    }
    /**
     * Build a URL using this wallet's id which can be used for BitGo API operations
     * @param extra API specific string to append to the wallet id
     */
    Wallet.prototype.url = function (extra) {
        if (extra === void 0) { extra = ''; }
        return this.baseCoin.url('/wallet/' + this.id() + extra);
    };
    /**
     * Get this wallet's id
     */
    Wallet.prototype.id = function () {
        return this._wallet.id;
    };
    /**
     * Get the number of approvals required for spending funds from this wallet
     */
    Wallet.prototype.approvalsRequired = function () {
        return this._wallet.approvalsRequired;
    };
    /**
     * Get the current balance of this wallet
     */
    Wallet.prototype.balance = function () {
        return this._wallet.balance;
    };
    Wallet.prototype.prebuildWhitelistedParams = function () {
        return [
            'recipients', 'numBlocks', 'feeRate', 'maxFeeRate', 'minConfirms', 'enforceMinConfirmsForChange',
            'targetWalletUnspents', 'message', 'minValue', 'maxValue', 'sequenceId', 'lastLedgerSequence',
            'ledgerSequenceDelta', 'gasPrice', 'gasLimit', 'noSplitChange', 'unspents', 'changeAddress', 'instant', 'memo', 'addressType',
            'cpfpTxIds', 'cpfpFeeRate', 'maxFee', 'idfVersion', 'idfSignedTimestamp', 'idfUserId', 'strategy',
            'validFromBlock', 'validToBlock', 'type', 'trustlines', 'reservation',
        ];
    };
    /**
     * This is a strict sub-set of prebuildWhitelistedParams.
     */
    Wallet.prototype.prebuildConsolidateTransactionParams = function () {
        return [
            'feeRate', 'maxFeeRate', 'memo', 'validFromBlock', 'validToBlock',
        ];
    };
    /**
     * Get the confirmed balance of this wallet
     */
    Wallet.prototype.confirmedBalance = function () {
        return this._wallet.confirmedBalance;
    };
    /**
     * Get the spendable balance of this wallet
     */
    Wallet.prototype.spendableBalance = function () {
        return this._wallet.spendableBalance;
    };
    /**
     * Get a string representation of the balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.balanceString = function () {
        return this._wallet.balanceString;
    };
    /**
     * Get a string representation of the confirmed balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.confirmedBalanceString = function () {
        return this._wallet.confirmedBalanceString;
    };
    /**
     * Get a string representation of the spendable balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.spendableBalanceString = function () {
        return this._wallet.spendableBalanceString;
    };
    /**
     * Get the coin identifier for the type of coin this wallet holds
     */
    Wallet.prototype.coin = function () {
        return this._wallet.coin;
    };
    /**
     * Get the label (name) for this wallet
     */
    Wallet.prototype.label = function () {
        return this._wallet.label;
    };
    /**
     * Get the public object ids for the keychains on this wallet.
     */
    Wallet.prototype.keyIds = function () {
        return this._wallet.keys;
    };
    /**
     * Get a receive address for this wallet
     */
    Wallet.prototype.receiveAddress = function () {
        return this._wallet.receiveAddress.address;
    };
    /**
     * Get the wallet id of the wallet that this wallet was migrated from.
     *
     * For example, if this is a BCH wallet that was created from a BTC wallet,
     * the BCH wallet migrated from field would have the BTC wallet id.
     */
    Wallet.prototype.migratedFrom = function () {
        return this._wallet.migratedFrom;
    };
    /**
     * Return the token flush thresholds for this wallet
     * @return {*|Object} pairs of { [tokenName]: thresholds } base units
     */
    Wallet.prototype.tokenFlushThresholds = function () {
        if (this.baseCoin.getFamily() !== 'eth') {
            throw new Error('not supported for this wallet');
        }
        return this._wallet.coinSpecific.tokenFlushThresholds;
    };
    /**
     * Get wallet properties which are specific to certain coin implementations
     */
    Wallet.prototype.coinSpecific = function () {
        return this._wallet.coinSpecific;
    };
    /**
     * Get all pending approvals on this wallet
     */
    Wallet.prototype.pendingApprovals = function () {
        var _this = this;
        return this._wallet.pendingApprovals.map(function (currentApproval) {
            return new pendingApproval_1.PendingApproval(_this.bitgo, _this.baseCoin, currentApproval, _this);
        });
    };
    /**
     * Refresh the wallet object by syncing with the back-end
     * @param params
     * @param callback
     * @returns {Wallet}
     */
    Wallet.prototype.refresh = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = self;
                        return [4 /*yield*/, self.bitgo.get(self.url()).result()];
                    case 1:
                        _a._wallet = _b.sent();
                        return [2 /*return*/, this];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List the transactions for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transactions = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * List the transactions for a given wallet
     * @param params
     *  - txHash the transaction hash to search for
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.getTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['txHash'], [], callback);
        var query = {};
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (!_.isUndefined(params.limit)) {
            if (!_.isInteger(params.limit) || params.limit < 1) {
                throw new Error('invalid limit argument, expecting positive integer');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.url('/tx/' + params.txHash))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * List the transfers for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transfers = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            query.allTokens = params.allTokens;
        }
        if (params.searchLabel) {
            if (!_.isString(params.searchLabel)) {
                throw new Error('invalid searchLabel argument, expecting string');
            }
            query.searchLabel = params.searchLabel;
        }
        if (params.address) {
            if (!_.isArray(params.address) && !_.isString(params.address)) {
                throw new Error('invalid address argument, expecting string or array');
            }
            if (_.isArray(params.address)) {
                params.address.forEach(function (address) {
                    if (!_.isString(address)) {
                        throw new Error('invalid address argument, expecting array of address strings');
                    }
                });
            }
            query.address = params.address;
        }
        if (params.dateGte) {
            if (!_.isString(params.dateGte)) {
                throw new Error('invalid dateGte argument, expecting string');
            }
            query.dateGte = params.dateGte;
        }
        if (params.dateLt) {
            if (!_.isString(params.dateLt)) {
                throw new Error('invalid dateLt argument, expecting string');
            }
            query.dateLt = params.dateLt;
        }
        if (!_.isNil(params.valueGte)) {
            if (!_.isNumber(params.valueGte)) {
                throw new Error('invalid valueGte argument, expecting number');
            }
            query.valueGte = params.valueGte;
        }
        if (!_.isNil(params.valueLt)) {
            if (!_.isNumber(params.valueLt)) {
                throw new Error('invalid valueLt argument, expecting number');
            }
            query.valueLt = params.valueLt;
        }
        if (!_.isNil(params.includeHex)) {
            if (!_.isBoolean(params.includeHex)) {
                throw new Error('invalid includeHex argument, expecting boolean');
            }
            query.includeHex = params.includeHex;
        }
        if (!_.isNil(params.state)) {
            if (!Array.isArray(params.state) && !_.isString(params.state)) {
                throw new Error('invalid state argument, expecting string or array');
            }
            if (Array.isArray(params.state)) {
                params.state.forEach(function (state) {
                    if (!_.isString(state)) {
                        throw new Error('invalid state argument, expecting array of state strings');
                    }
                });
            }
            query.state = params.state;
        }
        if (!_.isNil(params.type)) {
            if (!_.isString(params.type)) {
                throw new Error('invalid type argument, expecting string');
            }
            query.type = params.type;
        }
        return this.bitgo.get(this.url('/transfer'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Get transfers on this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.getTransfer = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['id'], [], callback);
        return this.bitgo.get(this.url('/transfer/' + params.id))
            .result()
            .nodeify(callback);
    };
    /**
     * Get a transaction by sequence id for a given wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.transferBySequenceId = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['sequenceId'], [], callback);
        return this.bitgo.get(this.url('/transfer/sequenceId/' + params.sequenceId))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the maximum amount you can spend in a single transaction
     *
     * @param {Object} params - parameters object
     * @param {Number} params.limit - maximum number of selectable unspents
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
     * @param callback
     * @returns {{maximumSpendable: Number, coin: String}}
     * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
     */
    Wallet.prototype.maximumSpendable = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var filteredParams;
            return __generator(this, function (_a) {
                filteredParams = _.pick(params, [
                    'minValue', 'maxValue', 'minHeight', 'target', 'plainTarget', 'limit', 'minConfirms',
                    'enforceMinConfirmsForChange', 'feeRate', 'maxFeeRate', 'recipientAddress'
                ]);
                return [2 /*return*/, self.bitgo.get(self.url('/maximumSpendable'))
                        .query(filteredParams)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List the unspents for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.unspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = _.pick(params, ['prevId', 'limit', 'minValue', 'maxValue', 'minHeight', 'minConfirms', 'target', 'segwit', 'chains']);
        return this.bitgo.get(this.url('/unspents'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Consolidate or fanout unspents on a wallet
     *
     * @param {String} routeName - either `consolidate` or `fanout`
     *
     * @param {Object} params - parameters object
     *
     * Wallet parameters:
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     *
     * Fee parameters:
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     *
     * Input parameters:
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumUnspentsToUse  for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * Output parameters:
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     *
     * @param callback
     */
    Wallet.prototype.manageUnspents = function (routeName, params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var reqId, filteredParams, response, keychain, transactionParams, signedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
                        reqId = new util_1.RequestTracer();
                        filteredParams = _.pick(params, [
                            'feeRate',
                            'maxFeeRate',
                            'maxFeePercentage',
                            'feeTxConfirmTarget',
                            'minValue',
                            'maxValue',
                            'minHeight',
                            'minConfirms',
                            'enforceMinConfirmsForChange',
                            routeName === 'consolidate' ? 'limit' : 'maxNumUnspentsToUse',
                            'numUnspentsToMake',
                        ]);
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, self.bitgo.post(self.url("/" + routeName + "Unspents"))
                                .send(filteredParams)
                                .result()];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, self.baseCoin.keychains().get({ id: self._wallet.keys[0], reqId: reqId })];
                    case 2:
                        keychain = _a.sent();
                        transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain });
                        return [4 /*yield*/, self.signTransaction(transactionParams)];
                    case 3:
                        signedTransaction = _a.sent();
                        selectParams = _.pick(params, ['comment', 'otp']);
                        finalTxParams = _.extend({}, signedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Consolidate unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumUnspentsToUse  for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param callback
     */
    Wallet.prototype.consolidateUnspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.manageUnspents('consolidate', params, callback);
    };
    /**
     * Fanout unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.minValue - the minimum value of unspents to use
     * @param {Number} params.maxValue - the maximum value of unspents to use
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
     * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param callback
     */
    Wallet.prototype.fanoutUnspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.manageUnspents('fanout', params, callback);
    };
    /**
     * Set the token flush thresholds for the wallet. Updates the wallet.
     * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
     * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
     * @param [callback]
     */
    Wallet.prototype.updateTokenFlushThresholds = function (thresholds, callback) {
        if (thresholds === void 0) { thresholds = {}; }
        var self = this;
        return co(function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (self.baseCoin.getFamily() !== 'eth') {
                            throw new Error('not supported for this wallet');
                        }
                        _a = self;
                        return [4 /*yield*/, self.bitgo.put(self.url()).send({
                                tokenFlushThresholds: thresholds
                            }).result()];
                    case 1:
                        _a._wallet = _b.sent();
                        return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Sweep funds for a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.address - The address to send all the funds in the wallet to
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
     * @param {Boolean} [params.allowPartialSweep] - allows sweeping 200 unspents when the wallet has more than that
     * @param [callback]
     * @returns txHex {String} the txHex of the signed transaction
     */
    Wallet.prototype.sweep = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var value, reqId, filteredParams, response, keychain, transactionParams, signedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = params || {};
                        common.validateParams(params, ['address'], ['walletPassphrase', 'xprv', 'otp'], callback);
                        if (['eth', 'xrp'].includes(self.baseCoin.getFamily())) {
                            if (self.confirmedBalanceString() !== self.balanceString()) {
                                throw new Error('cannot sweep when unconfirmed funds exist on the wallet, please wait until all inbound transactions confirm');
                            }
                            value = self.spendableBalanceString();
                            if (_.isUndefined(value) || value === '0') {
                                throw new Error('no funds to sweep');
                            }
                            params.recipients = [{
                                    address: params.address,
                                    amount: value,
                                }];
                            return [2 /*return*/, self.sendMany(params)];
                        }
                        reqId = new util_1.RequestTracer();
                        filteredParams = _.pick(params, ['address', 'feeRate', 'maxFeeRate', 'feeTxConfirmTarget', 'allowPartialSweep']);
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, self.bitgo.post(self.url('/sweepWallet'))
                                .send(filteredParams)
                                .result()];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, self.baseCoin.keychains().get({ id: self._wallet.keys[0], reqId: reqId })];
                    case 2:
                        keychain = _a.sent();
                        transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain, prv: params.xprv });
                        return [4 /*yield*/, self.signTransaction(transactionParams)];
                    case 3:
                        signedTransaction = _a.sent();
                        selectParams = _.pick(params, ['otp']);
                        finalTxParams = _.extend({}, signedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Freeze a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.freeze = function (params, callback) {
        if (params === void 0) { params = {}; }
        params = params || {};
        common.validateParams(params, [], [], callback);
        if (params.duration) {
            if (!_.isNumber(params.duration)) {
                throw new Error('invalid duration: should be number of seconds');
            }
        }
        return this.bitgo.post(this.url('/freeze'))
            .result()
            .nodeify(callback);
    };
    /**
     * Update comment of a transfer
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transferComment = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['id'], ['comment'], callback);
        return this.bitgo.post(this.baseCoin.url('/wallet/' + this._wallet.id + '/transfer/' + params.id + '/comment'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * List the addresses for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.addresses = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], [], callback);
        var query = {};
        if (params.mine) {
            query.mine = !!params.mine;
        }
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.sort) {
            if (!_.isNumber(params.sort)) {
                throw new Error('invalid sort argument, expecting number');
            }
            query.sort = params.sort;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.labelContains) {
            if (!_.isString(params.labelContains)) {
                throw new Error('invalid labelContains argument, expecting string');
            }
            query.labelContains = params.labelContains;
        }
        if (!_.isUndefined(params.segwit)) {
            if (!_.isBoolean(params.segwit)) {
                throw new Error('invalid segwit argument, expecting boolean');
            }
            query.segwit = params.segwit;
        }
        if (!_.isUndefined(params.chains)) {
            if (!_.isArray(params.chains)) {
                throw new Error('invalid chains argument, expecting array of numbers');
            }
            query.chains = params.chains;
        }
        return this.bitgo.get(this.baseCoin.url('/wallet/' + this._wallet.id + '/addresses'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Get a single wallet address by its id
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.getAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], ['address', 'id'], callback);
        var query;
        if (_.isUndefined(params.address) && _.isUndefined(params.id)) {
            throw new Error('address or id of address required');
        }
        if (params.address) {
            query = params.address;
        }
        else {
            query = params.id;
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return this.bitgo.get(this.baseCoin.url("/wallet/" + this._wallet.id + "/address/" + encodeURIComponent(query)))
            .result()
            .nodeify(callback);
    };
    /**
     * Create one or more new address(es) for use with this wallet.
     *
     * If the `count` field is defined and greater than 1, an object with a single
     * array property named `addresses` containing `count` address objects
     * will be returned. Otherwise, a single address object is returned.
     *
     * @param params
     * @param {Number} params.chain on which the new address should be created
     * @param {(Number|String)} params.gasPrice gas price for new address creation, if applicable
     * @param {String} params.label label for the new address(es)
     * @param {Number} params.count=1 number of new addresses which should be created (maximum 250)
     * @param {Boolean} params.lowPriority Ethereum-specific param to create address using low priority fee address
     * @param callback
     */
    Wallet.prototype.createAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var addressParams, reqId, chain, gasPrice, label, lowPriority, _a, count, keychains, rootAddress, newAddresses, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        addressParams = {};
                        reqId = new util_1.RequestTracer();
                        chain = params.chain, gasPrice = params.gasPrice, label = params.label, lowPriority = params.lowPriority, _a = params.count, count = _a === void 0 ? 1 : _a;
                        if (!_.isUndefined(chain)) {
                            if (!_.isInteger(chain)) {
                                throw new Error('chain has to be an integer');
                            }
                            addressParams.chain = chain;
                        }
                        if (!_.isUndefined(gasPrice)) {
                            if (!_.isInteger(gasPrice) && (isNaN(Number(gasPrice)) || !_.isString(gasPrice))) {
                                throw new Error('gasPrice has to be an integer or numeric string');
                            }
                            addressParams.gasPrice = gasPrice;
                        }
                        if (!_.isUndefined(label)) {
                            if (!_.isString(label)) {
                                throw new Error('label has to be a string');
                            }
                            addressParams.label = label;
                        }
                        if (!_.isInteger(count) || count <= 0 || count > 250) {
                            throw new Error('count has to be a number between 1 and 250');
                        }
                        if (!_.isUndefined(lowPriority)) {
                            if (!_.isBoolean(lowPriority)) {
                                throw new Error('lowPriority has to be a boolean');
                            }
                            addressParams.lowPriority = lowPriority;
                        }
                        return [4 /*yield*/, Bluebird.map(self._wallet.keys, function (k) { return self.baseCoin.keychains().get({ id: k, reqId: reqId }); })];
                    case 1:
                        keychains = _c.sent();
                        rootAddress = _.get(self._wallet, 'receiveAddress.address');
                        newAddresses = _.times(count, co(function createAndVerifyAddress() {
                            var newAddress, AbstractUtxoCoin_1, verificationData;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        self.bitgo.setRequestTracer(reqId);
                                        return [4 /*yield*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/address'))
                                                .send(addressParams)
                                                .result()];
                                    case 1:
                                        newAddress = _a.sent();
                                        // infer its address type
                                        if (_.isObject(newAddress.coinSpecific)) {
                                            AbstractUtxoCoin_1 = require('./coins/abstractUtxoCoin').AbstractUtxoCoin;
                                            newAddress.addressType = AbstractUtxoCoin_1.inferAddressType(newAddress);
                                        }
                                        newAddress.keychains = keychains;
                                        verificationData = _.merge({}, newAddress, { rootAddress: rootAddress });
                                        if (verificationData.error) {
                                            throw new errors_1.AddressGenerationError(verificationData.error);
                                        }
                                        self.baseCoin.verifyAddress(verificationData);
                                        return [2 /*return*/, newAddress];
                                }
                            });
                        }).bind(this));
                        if (newAddresses.length === 1) {
                            return [2 /*return*/, newAddresses[0]];
                        }
                        _b = {};
                        return [4 /*yield*/, Promise.all(newAddresses)];
                    case 2: return [2 /*return*/, (_b.addresses = _c.sent(),
                            _b)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Update properties on an address
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.updateAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var address, putParams, url;
            return __generator(this, function (_a) {
                address = params.address;
                if (!_.isString(address)) {
                    throw new Error('missing required string parameter address');
                }
                putParams = _.pick(params, ['label']);
                url = self.url('/address/' + encodeURIComponent(address));
                return [2 /*return*/, self.bitgo.put(url).send(putParams).result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List webhooks on this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.listWebhooks = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.url('/webhooks'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
     * @param params
     * - webhookId (required) id of the webhook to be simulated
     * - transferId (optional but required for transfer webhooks) id of the simulated transfer
     * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.simulateWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['webhookId'], ['transferId', 'pendingApprovalId'], callback);
        var hasTransferId = !!params.transferId;
        var hasPendingApprovalId = !!params.pendingApprovalId;
        if (!hasTransferId && !hasPendingApprovalId) {
            throw new Error('must supply either transferId or pendingApprovalId');
        }
        if (hasTransferId && hasPendingApprovalId) {
            throw new Error('must supply either transferId or pendingApprovalId, but not both');
        }
        // depending on the coin type of the wallet, the txHash has to adhere to its respective format
        // but the server takes care of that
        // only take the transferId and pendingApprovalId properties
        var filteredParams = _.pick(params, ['transferId', 'pendingApprovalId']);
        var webhookId = params.webhookId;
        return this.bitgo.post(this.url('/webhooks/' + webhookId + '/simulate'))
            .send(filteredParams)
            .result()
            .nodeify(callback);
    };
    /**
     * Add a webhook to this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.addWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['url', 'type'], [], callback);
        return this.bitgo.post(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Remove a webhook from this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.removeWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['url', 'type'], [], callback);
        return this.bitgo.del(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Gets the user key chain for this wallet
     *
     * The user key chain is the first keychain of the wallet and usually has the encrypted prv stored on BitGo.
     * Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
     * @param params
     * @param callback
     */
    Wallet.prototype.getEncryptedUserKeychain = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        var tryKeyChain = co(function (index) {
            var params, keychain;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self._wallet.keys || index >= self._wallet.keys.length) {
                            throw new Error('No encrypted keychains on this wallet.');
                        }
                        params = { id: self._wallet.keys[index] };
                        return [4 /*yield*/, self.baseCoin.keychains().get(params)];
                    case 1:
                        keychain = _a.sent();
                        // If we find the prv, then this is probably the user keychain we're looking for
                        if (keychain.encryptedPrv) {
                            return [2 /*return*/, keychain];
                        }
                        return [2 /*return*/, tryKeyChain(index + 1)];
                }
            });
        }).bind(this);
        return tryKeyChain(0).nodeify(callback);
    };
    /**
     * Gets the unencrypted private key for this wallet (be careful!)
     * Requires wallet passphrase
     *
     * @param params
     * @param callback
     */
    Wallet.prototype.getPrv = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var userKeychain, userEncryptedPrv, userPrv;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['walletPassphrase', 'prv'], callback);
                        // Prepare signing key
                        if (_.isUndefined(params.prv) && _.isUndefined(params.walletPassphrase)) {
                            throw new Error('must either provide prv or wallet passphrase');
                        }
                        if (!_.isUndefined(params.prv) && !_.isString(params.prv)) {
                            throw new Error('prv must be a string');
                        }
                        if (!_.isUndefined(params.walletPassphrase) && !_.isString(params.walletPassphrase)) {
                            throw new Error('walletPassphrase must be a string');
                        }
                        if (params.prv) {
                            return [2 /*return*/, params.prv];
                        }
                        return [4 /*yield*/, self.getEncryptedUserKeychain()];
                    case 1:
                        userKeychain = _a.sent();
                        userEncryptedPrv = userKeychain.encryptedPrv;
                        try {
                            userPrv = self.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
                        }
                        catch (e) {
                            throw new Error('error decrypting wallet passphrase');
                        }
                        return [2 /*return*/, userPrv];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Send an encrypted wallet share to BitGo.
     * @param params
     * @param callback
     */
    Wallet.prototype.createShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['user', 'permissions'], [], callback);
        if (params.keychain && !_.isEmpty(params.keychain)) {
            if (!params.keychain.pub || !params.keychain.encryptedPrv || !params.keychain.fromPubKey || !params.keychain.toPubKey || !params.keychain.path) {
                throw new Error('requires keychain parameters - pub, encryptedPrv, fromPubKey, toPubKey, path');
            }
        }
        return this.bitgo.post(this.url('/share'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Share this wallet with another BitGo user.
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.shareWallet = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var needsKeychain, sharing, sharedKeychain, keychain, eckey, secret, newEncryptedPrv, e_1, options;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['email', 'permissions'], ['walletPassphrase', 'message'], callback);
                        if (params.reshare !== undefined && !_.isBoolean(params.reshare)) {
                            throw new Error('Expected reshare to be a boolean.');
                        }
                        if (params.skipKeychain !== undefined && !_.isBoolean(params.skipKeychain)) {
                            throw new Error('Expected skipKeychain to be a boolean. ');
                        }
                        needsKeychain = !params.skipKeychain && params.permissions && params.permissions.indexOf('spend') !== -1;
                        if (params.disableEmail !== undefined && !_.isBoolean(params.disableEmail)) {
                            throw new Error('Expected disableEmail to be a boolean.');
                        }
                        if (!_.isString(params.email)) {
                            throw new Error('missing required string parameter email');
                        }
                        return [4 /*yield*/, self.bitgo.getSharingKey({ email: params.email.toLowerCase() })];
                    case 1:
                        sharing = _a.sent();
                        if (!needsKeychain) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, self.getEncryptedUserKeychain({})];
                    case 3:
                        keychain = _a.sent();
                        // Decrypt the user key with a passphrase
                        if (keychain.encryptedPrv) {
                            if (!params.walletPassphrase) {
                                throw new Error('Missing walletPassphrase argument');
                            }
                            try {
                                keychain.prv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedPrv });
                            }
                            catch (e) {
                                throw new Error('Unable to decrypt user keychain');
                            }
                            eckey = bitcoin_1.makeRandomKey();
                            secret = self.bitgo.getECDHSecret({ eckey: eckey, otherPubKeyHex: sharing.pubkey });
                            newEncryptedPrv = self.bitgo.encrypt({ password: secret, input: keychain.prv });
                            sharedKeychain = {
                                pub: keychain.pub,
                                encryptedPrv: newEncryptedPrv,
                                fromPubKey: eckey.getPublicKeyBuffer().toString('hex'),
                                toPubKey: sharing.pubkey,
                                path: sharing.path,
                            };
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        if (e_1.message === 'No encrypted keychains on this wallet.') {
                            sharedKeychain = {};
                            // ignore this error because this looks like a cold wallet
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        options = {
                            user: sharing.userId,
                            permissions: params.permissions,
                            reshare: params.reshare,
                            message: params.message,
                            disableEmail: params.disableEmail,
                        };
                        if (sharedKeychain) {
                            options.keychain = sharedKeychain;
                        }
                        else if (params.skipKeychain) {
                            options.keychain = {};
                        }
                        return [2 /*return*/, self.createShare(options)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove user from wallet
     * @param params
     * - userId Id of the user to remove
     * @param callback
     * @return {*}
     */
    Wallet.prototype.removeUser = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['userId'], [], callback);
        var userId = params.userId;
        return this.bitgo.del(this.url('/user/' + userId))
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch a transaction prebuild (unsigned transaction) from BitGo
     *
     * @param {Object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
     * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the wallet’s current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of base units
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of base units
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Number} params.gasLimit - Custom gas limit to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Number} params.validFromBlock - (Algorand) The minimum round this will run on
     * @param {Number} params.validToBlock - (Algorand) The maximum round this will run on
     * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
     * @param {Boolean} params.hop - Build this as an Ethereum hop transaction
     * @param {Object} params.reservation - Object to reserve the unspents that this tx build uses. Format is reservation = { expireTime: ISODateString, pendingApprovalId: String }
     * @param {String} params.walletPassphrase The passphrase to the wallet user key, to sign commitment data for Ethereum hop transactions
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.prebuildTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var whitelistedParams, extraParams, buildQuery, utxoCoin, blockHeightQuery, queries, _a, buildResponse, blockHeight, prebuild;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        whitelistedParams = _.pick(params, self.prebuildWhitelistedParams());
                        debug('prebuilding transaction: %O', whitelistedParams);
                        if (params.reqId) {
                            self.bitgo.setRequestTracer(params.reqId);
                        }
                        return [4 /*yield*/, self.baseCoin.getExtraPrebuildParams(Object.assign(params, { wallet: self }))];
                    case 1:
                        extraParams = _b.sent();
                        Object.assign(whitelistedParams, extraParams);
                        buildQuery = self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/tx/build'))
                            .send(whitelistedParams)
                            .result();
                        utxoCoin = self.baseCoin;
                        blockHeightQuery = _.isFunction(utxoCoin.getLatestBlockHeight) ?
                            utxoCoin.getLatestBlockHeight(params.reqId) :
                            Promise.resolve(undefined);
                        queries = [buildQuery, blockHeightQuery];
                        return [4 /*yield*/, Promise.all(queries)];
                    case 2:
                        _a = _b.sent(), buildResponse = _a[0], blockHeight = _a[1];
                        debug('postprocessing transaction prebuild: %O', buildResponse);
                        if (!_.isUndefined(blockHeight)) {
                            buildResponse.blockHeight = blockHeight;
                        }
                        return [4 /*yield*/, self.baseCoin.postProcessPrebuild(Object.assign(buildResponse, { wallet: self, buildParams: whitelistedParams }))];
                    case 3:
                        prebuild = _b.sent();
                        delete prebuild.wallet;
                        delete prebuild.buildParams;
                        prebuild = _.extend({}, prebuild, { walletId: self.id() });
                        debug('final transaction prebuild: %O', prebuild);
                        return [2 /*return*/, prebuild];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Sign a transaction
     * @param params
     * - txPrebuild
     * - [keychain / key] (object) or prv (string)
     * - walletPassphrase
     * @param callback
     * @return {*}
     */
    Wallet.prototype.signTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var txPrebuild, presign, userPrv, signingParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txPrebuild = params.txPrebuild;
                        if (!txPrebuild || typeof txPrebuild !== 'object') {
                            throw new Error('txPrebuild must be an object');
                        }
                        return [4 /*yield*/, self.baseCoin.presignTransaction(params)];
                    case 1:
                        presign = _a.sent();
                        userPrv = self.getUserPrv(presign);
                        signingParams = _.extend({}, presign, { txPrebuild: txPrebuild, prv: userPrv });
                        return [2 /*return*/, self.baseCoin.signTransaction(signingParams)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get the user private key from either a derivation or an encrypted keychain
     * @param [params.keychain / params.key] (object) or params.prv (string)
     * @param params.walletPassphrase (string)
     */
    Wallet.prototype.getUserPrv = function (params) {
        if (params === void 0) { params = {}; }
        var userKeychain = params.keychain || params.key;
        var userPrv = params.prv;
        if (userPrv && typeof userPrv !== 'string') {
            throw new Error('prv must be a string');
        }
        if (userPrv && params.coldDerivationSeed) {
            // the derivation only makes sense when a key already exists
            var derivation = this.baseCoin.deriveKeyWithSeed({ key: userPrv, seed: params.coldDerivationSeed });
            userPrv = derivation.key;
        }
        else if (!userPrv) {
            if (!userKeychain || typeof userKeychain !== 'object') {
                throw new Error('keychain must be an object');
            }
            var userEncryptedPrv = userKeychain.encryptedPrv;
            if (!userEncryptedPrv) {
                throw new Error('keychain does not have property encryptedPrv');
            }
            if (!params.walletPassphrase) {
                throw new Error('walletPassphrase property missing');
            }
            userPrv = this.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
        }
        return userPrv;
    };
    /**
     * Get a transaction prebuild from BitGo, validate it, and then decrypt the user key and sign the transaction
     * @param params
     * @param callback
     */
    Wallet.prototype.prebuildAndSignTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var error, error, error, txPrebuildQuery, keychains, txPrebuild, verificationParams, e_2, signingParams, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (params.prebuildTx && params.recipients) {
                            error = new Error('Only one of prebuildTx and recipients may be specified');
                            error.code = 'both_prebuildtx_and_recipients_specified';
                            throw error;
                        }
                        if (params.recipients && !Array.isArray(params.recipients)) {
                            error = new Error('expecting recipients array');
                            error.code = 'recipients_not_array';
                            throw error;
                        }
                        if (_.isArray(self._permissions) && !self._permissions.includes('spend')) {
                            error = new Error('no spend permission on this wallet');
                            error.code = 'user_not_allowed_to_spend_from_wallet';
                            throw error;
                        }
                        txPrebuildQuery = params.prebuildTx ? Promise.resolve(params.prebuildTx) : self.prebuildTransaction(params);
                        return [4 /*yield*/, self.baseCoin.keychains().getKeysForSigning({ wallet: self, reqId: params.reqId })];
                    case 1:
                        keychains = _a.sent();
                        return [4 /*yield*/, txPrebuildQuery];
                    case 2:
                        txPrebuild = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        verificationParams = _.pick(params.verification || {}, ['disableNetworking', 'keychains', 'addresses']);
                        return [4 /*yield*/, self.baseCoin.verifyTransaction({
                                txParams: params,
                                txPrebuild: txPrebuild,
                                wallet: self,
                                verification: verificationParams,
                                reqId: params.reqId,
                            })];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_2 = _a.sent();
                        debug('Transaction prebuild failure:', e_2);
                        console.error('transaction prebuild failed local validation:');
                        throw e_2;
                    case 6:
                        signingParams = _.extend({}, params, {
                            txPrebuild: txPrebuild,
                            wallet: {
                                // this is the version of the multisig address at wallet creation time
                                addressVersion: self._wallet.coinSpecific.addressVersion
                            },
                            keychain: keychains[0],
                            backupKeychain: (keychains.length > 1) ? keychains[1] : null,
                            bitgoKeychain: (keychains.length > 2) ? keychains[2] : null,
                        });
                        _a.label = 7;
                    case 7:
                        _a.trys.push([7, 9, , 10]);
                        return [4 /*yield*/, self.signTransaction(signingParams)];
                    case 8: return [2 /*return*/, _a.sent()];
                    case 9:
                        error_1 = _a.sent();
                        if (error_1.message.includes('insufficient funds')) {
                            error_1.code = 'insufficient_funds';
                            error_1.walletBalances = {
                                balanceString: self.balanceString(),
                                confirmedBalanceString: self.confirmedBalanceString(),
                                spendableBalanceString: self.spendableBalanceString(),
                                balance: self.balance(),
                                confirmedBalance: self.confirmedBalance(),
                                spendableBalance: self.spendableBalance()
                            };
                            error_1.txParams = _.omit(params, ['keychain', 'prv', 'passphrase', 'walletPassphrase', 'key']);
                        }
                        throw error_1;
                    case 10: return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Accelerate a transaction's confirmation using Child-Pays-For-Parent (CPFP)
     * @param params
     * @param callback
     */
    Wallet.prototype.accelerateTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var error, error, error, error, error, submitParams, _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        // TODO(BG-9349): change the last check to > 0 and the error message once platform allows multiple transactions to
                        //                be bumped in the same CPFP transaction
                        if (_.isUndefined(params.cpfpTxIds) || !Array.isArray(params.cpfpTxIds) || params.cpfpTxIds.length !== 1) {
                            error = new Error('expecting cpfpTxIds to be an array of length 1');
                            error.code = 'cpfptxids_not_array';
                            throw error;
                        }
                        if (_.isUndefined(params.cpfpFeeRate)) {
                            if (params.noCpfpFeeRate !== true) {
                                error = new Error('cpfpFeeRate must be set unless noCpfpFeeRate is set');
                                error.code = 'cpfpfeerate_not_set';
                                throw error;
                            }
                        }
                        else {
                            if (!_.isInteger(params.cpfpFeeRate) || params.cpfpFeeRate < 0) {
                                error = new Error('cpfpFeeRate must be a non-negative integer');
                                error.code = 'cpfpfeerate_not_nonnegative_integer';
                                throw error;
                            }
                        }
                        if (_.isUndefined(params.maxFee)) {
                            if (params.noMaxFee !== true) {
                                error = new Error('maxFee must be set unless noMaxFee is set');
                                error.code = 'maxfee_not_set';
                                throw error;
                            }
                        }
                        else {
                            if (!_.isInteger(params.maxFee) || params.maxFee < 0) {
                                error = new Error('maxFee must be a non-negative integer');
                                error.code = 'maxfee_not_nonnegative_integer';
                                throw error;
                            }
                        }
                        if (params.recipients !== undefined) {
                            if (!Array.isArray(params.recipients) || params.recipients.length !== 0) {
                                throw new Error("invalid value for 'recipients': must be empty array when set");
                            }
                        }
                        params.recipients = [];
                        _b = (_a = Object).assign;
                        _c = [params];
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        submitParams = _b.apply(_a, _c.concat([_d.sent()]));
                        delete submitParams.wallet;
                        return [4 /*yield*/, self.submitTransaction(submitParams)];
                    case 2: return [2 /*return*/, _d.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Submit a half-signed transaction to BitGo
     * @param params
     * - txHex: transaction hex to submit
     * - halfSigned: object containing transaction (txHex or txBase64) to submit
     * @param callback
     */
    Wallet.prototype.submitTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], ['otp', 'txHex'], callback);
        var hasTxHex = !!params.txHex;
        var hasHalfSigned = !!params.halfSigned;
        if ((hasTxHex && hasHalfSigned) || (!hasTxHex && !hasHalfSigned)) {
            throw new Error('must supply either txHex or halfSigned, but not both');
        }
        return this.bitgo.post(this.baseCoin.url('/wallet/' + this.id() + '/tx/send'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Send coins to a recipient
     * @param params
     * @param params.address - the destination address
     * @param params.amount - the amount in satoshis/wei/base value to be sent
     * @param params.message - optional message to attach to transaction
     * @param params.data - [Ethereum Specific] optional data to pass to transaction
     * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
     * @param params.prv - the private key in string form, if walletPassphrase is not available
     * @param params.minConfirms - the minimum confirmation threshold for inputs
     * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.send = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['address'], ['message', 'data'], callback);
        if (_.isUndefined(params.amount)) {
            throw new Error('missing required parameter amount');
        }
        if (_.isUndefined(params.address)) {
            throw new Error('missing required parameter amount');
        }
        var coin = this.baseCoin;
        var amount = new bignumber_js_1.BigNumber(params.amount);
        if (amount.isNegative()) {
            throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
        }
        if (!coin.valuelessTransferAllowed() && amount.isZero()) {
            throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
        }
        var recipients = [{
                address: params.address,
                amount: params.amount,
            }];
        if (params.data && coin.transactionDataAllowed()) {
            recipients[0].data = params.data;
        }
        var sendManyOptions = Object.assign({}, params, { recipients: recipients });
        return this.sendMany(sendManyOptions).nodeify(callback);
    };
    /**
     * Send money to multiple recipients
     * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
     * 2. Decrypts user key
     * 3. Creates the transaction with default fee
     * 4. Signs transaction with decrypted user key
     * 5. Sends the transaction to BitGo
     * @param {object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
     * @param {String} params.message - optional message to attach to transaction
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of satoshis
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of satoshis
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.comment - Any additional comment to attach to the transaction
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.type - Type of the transaction (e.g. trustline)
     * @param {{token: params, action: String, limit: String}[]} options.trustlines - Array of trustlines to manage (supported by Stellar)
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.sendMany = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var reqId, coin, halfSignedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['comment', 'otp'], callback);
                        debug('sendMany called');
                        reqId = params.reqId || new util_1.RequestTracer();
                        params.reqId = reqId;
                        coin = self.baseCoin;
                        if (_.isObject(params.recipients)) {
                            params.recipients.map(function (recipient) {
                                var amount = new bignumber_js_1.BigNumber(recipient.amount);
                                if (amount.isNegative()) {
                                    throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                                }
                                if (!coin.valuelessTransferAllowed() && amount.isZero()) {
                                    throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                                }
                            });
                        }
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        halfSignedTransaction = _a.sent();
                        selectParams = _.pick(params, [
                            'recipients', 'numBlocks', 'feeRate', 'maxFeeRate', 'minConfirms',
                            'enforceMinConfirmsForChange', 'targetWalletUnspents',
                            'message', 'minValue', 'maxValue', 'sequenceId',
                            'lastLedgerSequence', 'ledgerSequenceDelta', 'gasPrice',
                            'noSplitChange', 'unspents', 'comment', 'otp', 'changeAddress',
                            'instant', 'memo', 'type', 'trustlines',
                        ]);
                        finalTxParams = _.extend({}, halfSignedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.url('/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * params are validated in Eth.prototype.recoverToken
     * @param params
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param callback
     */
    Wallet.prototype.recoverToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var tokenContractAddress, recipient, recoverTokenOptions;
            return __generator(this, function (_a) {
                if (self.baseCoin.getFamily() !== 'eth') {
                    throw new Error('token recovery only supported for eth wallets');
                }
                tokenContractAddress = params.tokenContractAddress, recipient = params.recipient;
                if (_.isUndefined(tokenContractAddress)) {
                    throw new Error('missing required string parameter tokenContractAddress');
                }
                if (_.isUndefined(recipient)) {
                    throw new Error('missing required string parameter recipient');
                }
                recoverTokenOptions = Object.assign({ tokenContractAddress: tokenContractAddress, recipient: recipient }, params, { wallet: self });
                return [2 /*return*/, self.baseCoin.recoverToken(recoverTokenOptions)];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get transaction metadata for the oldest transaction that is still pending or attempted
     * @param params
     * @param callback
     * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
     */
    Wallet.prototype.getFirstPendingTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        return internal.getFirstPendingTransaction({ walletId: this.id() }, this.baseCoin, this.bitgo).asCallback(callback);
    };
    /**
     * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
     * @param params
     * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
     * @param {String} params.fee The new fee to apply to the denoted transaction
     * @param callback
     * @returns {String} The transaction ID of the new transaction that contains the new fee rate
     */
    Wallet.prototype.changeFee = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['txid', 'fee'], [], callback);
                return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/tx/changeFee'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Fetch info from merchant server
     * @param {Object} params The params passed into the function
     * @param {String} params.url The Url to retrieve info from
     * @param callback
     * @returns {Object} The info returned from the merchant server
     * @deprecated
     */
    Wallet.prototype.getPaymentInfo = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function coGetPaymentInfo() {
            return __generator(this, function (_a) {
                params = params || {};
                common.validateParams(params, ['url'], [], callback);
                return [2 /*return*/, self.bitgo.get(self.url('/paymentInfo'))
                        .query(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Send json payment response
     * @param {Object} params The params passed into the function
     * @param {String} params.paymentUrl - The url to send the fully signed transaction to
     * @param {String} params.txHex - The transaction hex of the payment
     * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
     * @param {String} params.expires {String} - ISO Date format of when the payment request expires
     * @param callback
     * @returns {Object} The info returned from the merchant server Payment Ack
     * @deprecated
     */
    Wallet.prototype.sendPaymentResponse = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo.post(this.url('/sendPayment'))
            .send(params)
            .result()
            .asCallback(callback);
    };
    /**
     * Create a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.createPolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id', 'type'], ['message'], callback);
                if (!_.isObject(params.condition)) {
                    throw new Error('missing parameter: conditions object');
                }
                if (!_.isObject(params.action)) {
                    throw new Error('missing parameter: action object');
                }
                return [2 /*return*/, self.bitgo.post(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Update a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.setPolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id', 'type'], ['message'], callback);
                if (!_.isObject(params.condition)) {
                    throw new Error('missing parameter: conditions object');
                }
                if (!_.isObject(params.action)) {
                    throw new Error('missing parameter: action object');
                }
                return [2 /*return*/, self.bitgo.put(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove Policy Rule
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.removePolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id'], ['message'], callback);
                return [2 /*return*/, self.bitgo.del(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove this wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.remove = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo.del(this.url()).result().asCallback(callback);
    };
    /**
     * Create a trading account from this wallet
     */
    Wallet.prototype.toTradingAccount = function () {
        if (this.baseCoin.getFamily() !== 'ofc') {
            throw new Error('Can only convert an Offchain (OFC) wallet to a trading account');
        }
        return new tradingAccount_1.TradingAccount(this._wallet.enterprise, this, this.bitgo);
    };
    /**
     * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
     *
     * Note: this is example code and is not the version used on bitgo.com
     *
     * @param params
     *   * jsPDF - an instance of the jsPDF library
     *   * QRCode - an instance of the QRious library
     *   * userKeychain - a wallet's private user keychain
     *   * backupKeychain - a wallet's private backup keychain
     *   * bitgoKeychain - a wallet's private bitgo keychain
     *   * passphrase - the wallet passphrase
     *   * passcodeEncryptionCode - the encryption secret used for Box D
     *   * activationCode - a randomly generated six-digit activation code
     *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
     *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
     * @returns {*}
     */
    Wallet.prototype.downloadKeycard = function (params) {
        if (params === void 0) { params = {}; }
        if (!window || !window.location) {
            throw new Error('The downloadKeycard function is only callable within a browser.');
        }
        // Grab parameters with default for activationCode
        var jsPDF = params.jsPDF, QRCode = params.QRCode, userKeychain = params.userKeychain, backupKeychain = params.backupKeychain, bitgoKeychain = params.bitgoKeychain, passphrase = params.passphrase, passcodeEncryptionCode = params.passcodeEncryptionCode, walletKeyID = params.walletKeyID, backupKeyID = params.backupKeyID, _a = params.activationCode, activationCode = _a === void 0 ? Math.floor(Math.random() * 900000 + 100000).toString() : _a;
        if (!jsPDF || typeof jsPDF !== 'function') {
            throw new Error('Please pass in a valid jsPDF instance');
        }
        // Validate keychains
        if (!userKeychain || typeof userKeychain !== 'object') {
            throw new Error("Wallet keychain must have a 'user' property");
        }
        if (!backupKeychain || typeof backupKeychain !== 'object') {
            throw new Error('Backup keychain is required and must be an object');
        }
        if (!bitgoKeychain || typeof bitgoKeychain !== 'object') {
            throw new Error('Bitgo keychain is required and must be an object');
        }
        if (walletKeyID && typeof walletKeyID !== 'string') {
            throw new Error('walletKeyID must be a string');
        }
        if (backupKeyID && typeof backupKeyID !== 'string') {
            throw new Error('backupKeyID must be a string');
        }
        // Validate activation code if provided
        if (typeof activationCode !== 'string') {
            throw new Error('Activation Code must be a string');
        }
        if (activationCode.length !== 6) {
            throw new Error('Activation code must be six characters');
        }
        var coinShortName = this.baseCoin.type;
        var coinName = this.baseCoin.getFullName();
        var walletLabel = this._wallet.label;
        var doc = keycard_1.drawKeycard({
            jsPDF: jsPDF,
            QRCode: QRCode,
            encrypt: this.bitgo.encrypt,
            coinShortName: coinShortName,
            coinName: coinName,
            activationCode: activationCode,
            walletLabel: walletLabel,
            passphrase: passphrase,
            passcodeEncryptionCode: passcodeEncryptionCode,
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain,
            walletKeyID: walletKeyID,
            backupKeyID: backupKeyID,
        });
        // Save the PDF on the user's browser
        doc.save("BitGo Keycard for " + walletLabel + ".pdf");
    };
    /**
     * Builds a set of consolidation transactions for a wallet.
     * @param params
     *     fromAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     * @param callback
     */
    Wallet.prototype.buildAccountConsolidations = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var whitelistedParams, buildResponse, consolidations, _i, buildResponse_1, consolidateAccountBuild, prebuild;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        whitelistedParams = _.pick(params, self.prebuildConsolidateTransactionParams());
                        debug('prebuilding consolidation transaction: %O', whitelistedParams);
                        if (params.reqId) {
                            self.bitgo.setRequestTracer(params.reqId);
                        }
                        return [4 /*yield*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/consolidateAccount/build'))
                                .send(whitelistedParams)
                                .result()];
                    case 1:
                        buildResponse = _a.sent();
                        consolidations = [];
                        _i = 0, buildResponse_1 = buildResponse;
                        _a.label = 2;
                    case 2:
                        if (!(_i < buildResponse_1.length)) return [3 /*break*/, 5];
                        consolidateAccountBuild = buildResponse_1[_i];
                        return [4 /*yield*/, self.baseCoin.postProcessPrebuild(Object.assign(consolidateAccountBuild, { wallet: self, buildParams: whitelistedParams }))];
                    case 3:
                        prebuild = _a.sent();
                        delete prebuild.wallet;
                        delete prebuild.buildParams;
                        prebuild = _.extend({}, prebuild, { walletId: self.id() });
                        debug('final consolidation transaction prebuild: %O', prebuild);
                        consolidations.push(prebuild);
                        _a.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5: return [2 /*return*/, consolidations];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Builds and sends a set of consolidation transactions for a wallet.
     * @param params
     *     fromAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    Wallet.prototype.sendAccountConsolidation = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var signedPrebuild;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        // one of a set of consolidation transactions
                        if (typeof params.prebuildTx === 'string' || params.prebuildTx === undefined) {
                            throw new Error('Invalid build of account consolidation.');
                        }
                        if (!params.prebuildTx.consolidateId) {
                            throw new Error('Failed to find consolidation id on consolidation transaction.');
                        }
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        signedPrebuild = _a.sent();
                        // decorate with our consolidation id
                        signedPrebuild.consolidateId = params.prebuildTx.consolidateId;
                        delete signedPrebuild.wallet;
                        return [4 /*yield*/, self.submitTransaction(signedPrebuild)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Builds and sends a set of account consolidations. This is intended to flush many balances to the root wallet balance.
     * @param params
     * @param callback
     */
    Wallet.prototype.sendAccountConsolidations = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var unsignedBuilds, successfulTxs, failedTxs, _i, unsignedBuilds_1, unsignedBuild, unsignedBuildWithOptions, sendTx, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        return [4 /*yield*/, self.buildAccountConsolidations(params)];
                    case 1:
                        unsignedBuilds = _a.sent();
                        if (!(unsignedBuilds && unsignedBuilds.length > 0)) return [3 /*break*/, 8];
                        successfulTxs = [];
                        failedTxs = new Array();
                        _i = 0, unsignedBuilds_1 = unsignedBuilds;
                        _a.label = 2;
                    case 2:
                        if (!(_i < unsignedBuilds_1.length)) return [3 /*break*/, 7];
                        unsignedBuild = unsignedBuilds_1[_i];
                        unsignedBuildWithOptions = Object.assign({}, params);
                        unsignedBuildWithOptions.prebuildTx = unsignedBuild;
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, self.sendAccountConsolidation(unsignedBuildWithOptions)];
                    case 4:
                        sendTx = _a.sent();
                        successfulTxs.push(sendTx);
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _a.sent();
                        failedTxs.push(e_3);
                        return [3 /*break*/, 6];
                    case 6:
                        _i++;
                        return [3 /*break*/, 2];
                    case 7: return [2 /*return*/, {
                            success: successfulTxs,
                            failure: failedTxs,
                        }];
                    case 8: return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    return Wallet;
}());
exports.Wallet = Wallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUF5QztBQUN6QyxtQ0FBcUM7QUFDckMsMEJBQTRCO0FBQzVCLGdDQUFrQztBQUVsQyxzQ0FBMkM7QUFFM0Msa0NBQW9DO0FBQ3BDLG9DQUFtRDtBQVFuRCw4Q0FBZ0Q7QUFDaEQsOENBQWlEO0FBRWpELDJEQUEwRDtBQUUxRCxxREFBeUU7QUFDekUsd0NBQWdEO0FBRWhELElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzFDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFxWjlCO0lBTUUsZ0JBQVksS0FBWSxFQUFFLFFBQWtCLEVBQUUsVUFBZTtRQUMzRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQztRQUMxQixJQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdEIsSUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDL0QsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQztTQUN2RDtJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCxvQkFBRyxHQUFILFVBQUksS0FBa0I7UUFBbEIsc0JBQUEsRUFBQSxVQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOztPQUVHO0lBQ0gsbUJBQUUsR0FBRjtRQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsa0NBQWlCLEdBQWpCO1FBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDO0lBQ3hDLENBQUM7SUFFRDs7T0FFRztJQUNILHdCQUFPLEdBQVA7UUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQzlCLENBQUM7SUFFRCwwQ0FBeUIsR0FBekI7UUFDRSxPQUFPO1lBQ0wsWUFBWSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSw2QkFBNkI7WUFDaEcsc0JBQXNCLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLG9CQUFvQjtZQUM3RixxQkFBcUIsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsYUFBYTtZQUM3SCxXQUFXLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsb0JBQW9CLEVBQUUsV0FBVyxFQUFFLFVBQVU7WUFDakcsZ0JBQWdCLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsYUFBYTtTQUN0RSxDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0gscURBQW9DLEdBQXBDO1FBQ0UsT0FBTztZQUNMLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixFQUFFLGNBQWM7U0FDbEUsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILGlDQUFnQixHQUFoQjtRQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxpQ0FBZ0IsR0FBaEI7UUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw4QkFBYSxHQUFiO1FBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHVDQUFzQixHQUF0QjtRQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHVDQUFzQixHQUF0QjtRQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxxQkFBSSxHQUFKO1FBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUMzQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxzQkFBSyxHQUFaO1FBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUM1QixDQUFDO0lBRUQ7O09BRUc7SUFDSSx1QkFBTSxHQUFiO1FBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUMzQixDQUFDO0lBRUQ7O09BRUc7SUFDSSwrQkFBYyxHQUFyQjtRQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLDZCQUFZLEdBQW5CO1FBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQztJQUNuQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gscUNBQW9CLEdBQXBCO1FBQ0UsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxLQUFLLEtBQUssRUFBRTtZQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixDQUFDLENBQUM7U0FDbEQ7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLG9CQUFvQixDQUFDO0lBQ3hELENBQUM7SUFFRDs7T0FFRztJQUNILDZCQUFZLEdBQVo7UUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNILGlDQUFnQixHQUFoQjtRQUFBLGlCQUlDO1FBSEMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxVQUFDLGVBQWU7WUFDdkQsT0FBTyxJQUFJLGlDQUFlLENBQUMsS0FBSSxDQUFDLEtBQUssRUFBRSxLQUFJLENBQUMsUUFBUSxFQUFFLGVBQWUsRUFBRSxLQUFJLENBQUMsQ0FBQztRQUMvRSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHdCQUFPLEdBQVAsVUFBUSxNQUFlLEVBQUUsUUFBK0I7UUFBaEQsdUJBQUEsRUFBQSxXQUFlO1FBQ3JCLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBUzs7Ozs7d0JBQ2hCLEtBQUEsSUFBSSxDQUFBO3dCQUFXLHFCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFBOzt3QkFBeEQsR0FBSyxPQUFPLEdBQUcsU0FBeUMsQ0FBQzt3QkFDekQsc0JBQU8sSUFBSSxFQUFDOzs7U0FDYixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw2QkFBWSxHQUFaLFVBQWEsTUFBOEIsRUFBRSxRQUE0QjtRQUE1RCx1QkFBQSxFQUFBLFdBQThCO1FBQ3pDLElBQU0sS0FBSyxHQUFzQixFQUFFLENBQUM7UUFFcEMsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO2FBQzlEO1lBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO2FBQzdEO1lBQ0QsS0FBSyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO1NBQzVCO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUM7YUFDM0UsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsK0JBQWMsR0FBZCxVQUFlLE1BQWtDLEVBQUUsUUFBNEI7UUFBaEUsdUJBQUEsRUFBQSxXQUFrQztRQUMvQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV4RCxJQUFNLEtBQUssR0FBc0IsRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQzthQUM5RDtZQUNELEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUM5QjtRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNoQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUU7Z0JBQ2xELE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQzthQUN2RTtZQUNELEtBQUssQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztTQUM1QjtRQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3BELEtBQUssQ0FBQyxLQUFLLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMEJBQVMsR0FBVCxVQUFVLE1BQTZCLEVBQUUsUUFBNEI7UUFBM0QsdUJBQUEsRUFBQSxXQUE2QjtRQUNyQyxJQUFNLEtBQUssR0FBcUIsRUFBRSxDQUFDO1FBQ25DLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNqQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQzthQUM5RDtZQUNELEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUM5QjtRQUVELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtZQUNoQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQzthQUM3RDtZQUNELEtBQUssQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztTQUM1QjtRQUVELElBQUksTUFBTSxDQUFDLFNBQVMsRUFBRTtZQUNwQixJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQzthQUNsRTtZQUNELEtBQUssQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztTQUNwQztRQUVELElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRTtZQUN0QixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ25DLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQzthQUNuRTtZQUNELEtBQUssQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztTQUN4QztRQUVELElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRTtZQUNsQixJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDN0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO2FBQ3hFO1lBQ0QsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDN0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQSxPQUFPO29CQUM1QixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTt3QkFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO3FCQUNqRjtnQkFDSCxDQUFDLENBQUMsQ0FBQzthQUNKO1lBQ0QsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO2FBQzlEO1lBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzdCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO2FBQ2hFO1lBQ0QsS0FBSyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDO1NBQ2xDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FB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Q0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUNILGFBQUM7QUFBRCxDQUFDLEFBaDdERCxJQWc3REM7QUFoN0RZLHdCQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcblxuaW1wb3J0IHsgbWFrZVJhbmRvbUtleSB9IGZyb20gJy4uL2JpdGNvaW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi9iaXRnbyc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IEFkZHJlc3NHZW5lcmF0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIFNpZ25lZFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBWZXJpZmljYXRpb25PcHRpb25zLFxufSBmcm9tICcuL2Jhc2VDb2luJztcbmltcG9ydCB7IEFic3RyYWN0VXR4b0NvaW4gfSBmcm9tICcuL2NvaW5zL2Fic3RyYWN0VXR4b0NvaW4nO1xuaW1wb3J0IHsgRXRoIH0gZnJvbSAnLi9jb2lucyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2ludGVybmFsJztcbmltcG9ydCB7IGRyYXdLZXljYXJkIH0gZnJvbSAnLi9pbnRlcm5hbC9rZXljYXJkJztcbmltcG9ydCB7IEtleWNoYWluIH0gZnJvbSAnLi9rZXljaGFpbnMnO1xuaW1wb3J0IHsgVHJhZGluZ0FjY291bnQgfSBmcm9tICcuL3RyYWRpbmcvdHJhZGluZ0FjY291bnQnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBQZW5kaW5nQXBwcm92YWwsIFBlbmRpbmdBcHByb3ZhbERhdGEgfSBmcm9tICcuL3BlbmRpbmdBcHByb3ZhbCc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi9pbnRlcm5hbC91dGlsJztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286djI6d2FsbGV0Jyk7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxudHlwZSBNYW5hZ2VVbnNwZW50cyA9ICdjb25zb2xpZGF0ZScgfCAnZmFub3V0JztcblxuZXhwb3J0IGludGVyZmFjZSBNYXhpbXVtU3BlbmRhYmxlT3B0aW9ucyB7XG4gICAgbWluVmFsdWU/OiBudW1iZXI7XG4gICAgbWF4VmFsdWU/OiBudW1iZXI7XG4gICAgbWluSGVpZ2h0PzogbnVtYmVyO1xuICAgIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICAgIGVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZT86IGJvb2xlYW47XG4gICAgZmVlUmF0ZT86IG51bWJlcjtcbiAgICBtYXhGZWVSYXRlPzogbnVtYmVyO1xuICAgIHJlY2lwaWVudEFkZHJlc3M/OiBzdHJpbmc7XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gICAgdGFyZ2V0PzogbnVtYmVyO1xuICAgIHBsYWluVGFyZ2V0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1heGltdW1TcGVuZGFibGUge1xuICAgIG1heGltdW1TcGVuZGFibGU6IG51bWJlcjtcbiAgICBjb2luOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVtbyB7XG4gICAgdmFsdWU6IHN0cmluZztcbiAgICB0eXBlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcGFyYW1ldGVycyBzaG91bGQgYmUgdXNlZCBmb3IgYnVpbGRpbmcgYSBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uOlxuICogLSB3YWxsZXRQYXNzcGhyYXNlIC0gbmVjZXNzYXJ5IGZvciBzaWduaW5nXG4gKiAtIGZlZVJhdGVcbiAqIC0gbWF4RmVlUmF0ZVxuICogLSB2YWxpZEZyb21CbG9ja1xuICogLSB2YWxpZFRvQmxvY2tcbiAqXG4gKiBXaGF0IHNob3VsZG4ndCBiZSBwYXNzZWQgKHRoZXNlIHdpbGwgYmUgaWdub3JlZCk6XG4gKiAtIHJlY2lwaWVudHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCdWlsZENvbnNvbGlkYXRpb25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBQcmVidWlsZFRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIGZyb21BZGRyZXNzZXM/OiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVidWlsZFRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gICAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xuICAgIHJlY2lwaWVudHM/OiB7XG4gICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgYW1vdW50OiBzdHJpbmcgfCBudW1iZXI7XG4gICAgfVtdO1xuICAgIG51bUJsb2Nrcz86IG51bWJlcjtcbiAgICBmZWVSYXRlPzogbnVtYmVyO1xuICAgIG1heEZlZVJhdGU/OiBudW1iZXI7XG4gICAgbWluQ29uZmlybXM/OiBudW1iZXI7XG4gICAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgICB0YXJnZXRXYWxsZXRVbnNwZW50cz86IG51bWJlcjtcbiAgICBtaW5WYWx1ZT86IG51bWJlcjtcbiAgICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgICBzZXF1ZW5jZUlkPzogbnVtYmVyO1xuICAgIGxhc3RMZWRnZXJTZXF1ZW5jZT86IG51bWJlcjtcbiAgICBsZWRnZXJTZXF1ZW5jZURlbHRhPzogc3RyaW5nO1xuICAgIGdhc1ByaWNlPzogbnVtYmVyO1xuICAgIG5vU3BsaXRDaGFuZ2U/OiBib29sZWFuO1xuICAgIHVuc3BlbnRzPzogYW55W107XG4gICAgY2hhbmdlQWRkcmVzcz86IHN0cmluZztcbiAgICB2YWxpZEZyb21CbG9jaz86IG51bWJlcjtcbiAgICB2YWxpZFRvQmxvY2s/OiBudW1iZXI7XG4gICAgaW5zdGFudD86IGJvb2xlYW47XG4gICAgbWVtbz86IE1lbW87XG4gICAgYWRkcmVzc1R5cGU/OiBzdHJpbmc7XG4gICAgaG9wPzogYm9vbGVhbjtcbiAgICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICAgIHJlc2VydmF0aW9uPzoge1xuICAgICAgZXhwaXJlVGltZT86IHN0cmluZztcbiAgICAgIHBlbmRpbmdBcHByb3ZhbElkPzogc3RyaW5nO1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgUHJlYnVpbGRUcmFuc2FjdGlvbk9wdGlvbnMge1xuICAgIHByZWJ1aWxkVHg/OiBzdHJpbmcgfCBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0O1xuICAgIHZlcmlmaWNhdGlvbj86IFZlcmlmaWNhdGlvbk9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdCBleHRlbmRzIFRyYW5zYWN0aW9uUHJlYnVpbGQge1xuICAgIHdhbGxldElkOiBzdHJpbmc7XG4gICAgLy8gQ29uc29saWRhdGUgSUQgaXMgdXNlZCBmb3IgY29uc29saWRhdGUgYWNjb3VudCB0cmFuc2FjdGlvbnMgYW5kIGluZGljYXRlcyBpZiB0aGlzIGlzXG4gICAgLy8gYSBjb25zb2xpZGF0aW9uIGFuZCB3aGF0IGNvbnNvbGlkYXRlIGdyb3VwIGl0IHNob3VsZCBiZSByZWZlcmVuY2VkIGJ5LlxuICAgIGNvbnNvbGlkYXRlSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0U2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gICAgdHhQcmVidWlsZD86IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gICAgcHJ2Pzogc3RyaW5nO1xuICAgIGlzTGFzdFNpZ25hdHVyZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0VXNlclBydk9wdGlvbnMge1xuICAgIGtleWNoYWluPzogS2V5Y2hhaW47XG4gICAga2V5PzogS2V5Y2hhaW47XG4gICAgcHJ2Pzogc3RyaW5nO1xuICAgIGNvbGREZXJpdmF0aW9uU2VlZD86IHN0cmluZztcbiAgICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldENvaW5TcGVjaWZpYyB7XG4gIHRva2VuRmx1c2hUaHJlc2hvbGRzPzogYW55O1xuICBhZGRyZXNzVmVyc2lvbj86IG51bWJlcjtcbiAgYmFzZUFkZHJlc3M/OiBzdHJpbmc7XG4gIHJvb3RBZGRyZXNzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgcHJldklkPzogc3RyaW5nO1xuICBsaW1pdD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIHR4SGFzaD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2ZlcnNPcHRpb25zIGV4dGVuZHMgUGFnaW5hdGlvbk9wdGlvbnMge1xuICB0eEhhc2g/OiBzdHJpbmc7XG4gIGFsbFRva2Vucz86IHN0cmluZztcbiAgc2VhcmNoTGFiZWw/OiBzdHJpbmc7XG4gIGFkZHJlc3M/OiBzdHJpbmdbXSB8IHN0cmluZztcbiAgZGF0ZUd0ZT86IHN0cmluZztcbiAgZGF0ZUx0Pzogc3RyaW5nO1xuICB2YWx1ZUd0ZT86IHN0cmluZztcbiAgdmFsdWVMdD86IHN0cmluZztcbiAgaW5jbHVkZUhleD86IGJvb2xlYW47XG4gIHN0YXRlPzogc3RyaW5nW10gfCBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0VHJhbnNmZXJPcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJCeVNlcXVlbmNlSWRPcHRpb25zIHtcbiAgc2VxdWVuY2VJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbnNwZW50c09wdGlvbnMgZXh0ZW5kcyBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIG1pblZhbHVlPzogbnVtYmVyO1xuICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgbWluSGVpZ2h0PzogbnVtYmVyO1xuICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgdGFyZ2V0PzogbnVtYmVyO1xuICBzZWd3aXQ/OiBib29sZWFuO1xuICBjaGFpbnM/OiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25zb2xpZGF0ZVVuc3BlbnRzT3B0aW9ucyB7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHhwcnY/OiBzdHJpbmc7XG4gIG1pblZhbHVlPzogbnVtYmVyO1xuICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgbWluSGVpZ2h0PzogbnVtYmVyXG4gIG51bVVuc3BlbnRzVG9NYWtlPzogbnVtYmVyO1xuICBmZWVUeENvbmZpcm1UYXJnZXQ/OiBudW1iZXI7XG4gIGxpbWl0PzogbnVtYmVyO1xuICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgZmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUGVyY2VudGFnZT86IG51bWJlcjtcbiAgY29tbWVudD86IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZhbm91dFVuc3BlbnRzT3B0aW9ucyB7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHhwcnY/OiBzdHJpbmc7XG4gIG1pblZhbHVlPzogbnVtYmVyO1xuICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgbWluSGVpZ2h0PzogbnVtYmVyXG4gIG1heE51bUlucHV0c1RvVXNlPzogbnVtYmVyO1xuICBudW1VbnNwZW50c1RvTWFrZT86IG51bWJlcjtcbiAgbWluQ29uZmlybXM/OiBudW1iZXI7XG4gIGVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZT86IGJvb2xlYW47XG4gIGZlZVJhdGU/OiBudW1iZXI7XG4gIG1heEZlZVJhdGU/OiBudW1iZXI7XG4gIG1heEZlZVBlcmNlbnRhZ2U/OiBudW1iZXI7XG4gIGZlZVR4Q29uZmlybVRhcmdldD86IG51bWJlcjtcbiAgY29tbWVudD86IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN3ZWVwT3B0aW9ucyB7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHhwcnY/OiBzdHJpbmc7XG4gIG90cD86IHN0cmluZztcbiAgZmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUmF0ZT86IG51bWJlcjtcbiAgZmVlVHhDb25maXJtVGFyZ2V0PzogbnVtYmVyO1xuICBhbGxvd1BhcnRpYWxTd2VlcD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJlZXplT3B0aW9ucyB7XG4gIGR1cmF0aW9uPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZmVyQ29tbWVudE9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgY29tbWVudD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGRyZXNzZXNPcHRpb25zIGV4dGVuZHMgUGFnaW5hdGlvbk9wdGlvbnMge1xuICBtaW5lPzogYm9vbGVhbjtcbiAgc29ydD86IG51bWJlcjtcbiAgbGFiZWxDb250YWlucz86IHN0cmluZztcbiAgc2Vnd2l0PzogYm9vbGVhbjtcbiAgY2hhaW5zPzogbnVtYmVyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0QWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUFkZHJlc3NPcHRpb25zIHtcbiAgY2hhaW4/OiBudW1iZXI7XG4gIGdhc1ByaWNlPzogbnVtYmVyIHwgc3RyaW5nO1xuICBjb3VudD86IG51bWJlcjtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGxvd1ByaW9yaXR5PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVBZGRyZXNzT3B0aW9ucyB7XG4gIGxhYmVsPzogc3RyaW5nO1xuICBhZGRyZXNzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXVsYXRlV2ViaG9va09wdGlvbnMge1xuICB3ZWJob29rSWQ/OiBzdHJpbmc7XG4gIHRyYW5zZmVySWQ/OiBzdHJpbmc7XG4gIHBlbmRpbmdBcHByb3ZhbElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vZGlmeVdlYmhvb2tPcHRpb25zIHtcbiAgdXJsPzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFBydk9wdGlvbnMge1xuICBwcnY/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU2hhcmVPcHRpb25zIHtcbiAgdXNlcj86IHN0cmluZztcbiAgcGVybWlzc2lvbnM/OiBzdHJpbmc7XG4gIGtleWNoYWluPzoge1xuICAgIHB1Yj86IHN0cmluZztcbiAgICBlbmNyeXB0ZWRQcnY/OiBzdHJpbmc7XG4gICAgZnJvbVB1YktleT86IHN0cmluZztcbiAgICB0b1B1YktleT86IHN0cmluZztcbiAgICBwYXRoPzogc3RyaW5nO1xuICB9LFxuICByZXNoYXJlPzogYm9vbGVhbjtcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgZGlzYWJsZUVtYWlsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaGFyZVdhbGxldE9wdGlvbnMge1xuICBlbWFpbD86IHN0cmluZztcbiAgcGVybWlzc2lvbnM/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIHJlc2hhcmU/OiBib29sZWFuO1xuICBza2lwS2V5Y2hhaW4/OiBib29sZWFuO1xuICBkaXNhYmxlRW1haWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbW92ZVVzZXJPcHRpb25zIHtcbiAgdXNlcklkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjY2VsZXJhdGVUcmFuc2FjdGlvbk9wdGlvbnMge1xuICBjcGZwVHhJZHM/OiBzdHJpbmdbXTtcbiAgY3BmcEZlZVJhdGU/OiBudW1iZXI7XG4gIG5vQ3BmcEZlZVJhdGU/OiBib29sZWFuO1xuICBtYXhGZWU/OiBudW1iZXI7XG4gIG5vTWF4RmVlPzogYm9vbGVhbjtcbiAgcmVjaXBpZW50cz86IHtcbiAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgYW1vdW50OiBzdHJpbmc7XG4gIH1bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRUcmFuc2FjdGlvbk9wdGlvbnMge1xuICBvdHA/OiBzdHJpbmc7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbmRPcHRpb25zIHtcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgYW1vdW50PzogbnVtYmVyIHwgc3RyaW5nO1xuICBkYXRhPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBwcnY/OiBzdHJpbmc7XG4gIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICBlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2U/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZE1hbnlPcHRpb25zIHtcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xuICByZWNpcGllbnRzPzoge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgICBkYXRhPzogc3RyaW5nO1xuICB9W107XG4gIG51bUJsb2Nrcz86IG51bWJlcjtcbiAgZmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUmF0ZT86IG51bWJlcjtcbiAgbWluQ29uZmlybXM/OiBudW1iZXI7XG4gIGVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZT86IGJvb2xlYW47XG4gIHRhcmdldFdhbGxldFVuc3BlbnRzPzogbnVtYmVyO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBtaW5WYWx1ZT86IG51bWJlcjtcbiAgbWF4VmFsdWU/OiBudW1iZXI7XG4gIHNlcXVlbmNlSWQ/OiBudW1iZXI7XG4gIGxhc3RMZWRnZXJTZXF1ZW5jZT86IG51bWJlcjtcbiAgbGVkZ2VyU2VxdWVuY2VEZWx0YT86IHN0cmluZztcbiAgZ2FzUHJpY2U/OiBudW1iZXI7XG4gIG5vU3BsaXRDaGFuZ2U/OiBib29sZWFuO1xuICB1bnNwZW50cz86IHN0cmluZ1tdO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG4gIGNoYW5nZUFkZHJlc3M/OiBzdHJpbmc7XG4gIGluc3RhbnQ/OiBib29sZWFuO1xuICBtZW1vPzogTWVtbztcbn1cblxuaW50ZXJmYWNlIFdhbGxldERhdGEge1xuICBpZDogc3RyaW5nO1xuICBhcHByb3ZhbHNSZXF1aXJlZDogbnVtYmVyO1xuICBiYWxhbmNlOiBudW1iZXI7XG4gIGNvbmZpcm1lZEJhbGFuY2U6IG51bWJlcjtcbiAgc3BlbmRhYmxlQmFsYW5jZTogbnVtYmVyO1xuICBiYWxhbmNlU3RyaW5nOiBzdHJpbmc7XG4gIGNvbmZpcm1lZEJhbGFuY2VTdHJpbmc6IHN0cmluZztcbiAgc3BlbmRhYmxlQmFsYW5jZVN0cmluZzogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGtleXM6IHN0cmluZ1tdO1xuICByZWNlaXZlQWRkcmVzczoge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgfTtcbiAgbWlncmF0ZWRGcm9tPzogc3RyaW5nO1xuICBjb2luU3BlY2lmaWM6IFdhbGxldENvaW5TcGVjaWZpYztcbiAgcGVuZGluZ0FwcHJvdmFsczogUGVuZGluZ0FwcHJvdmFsRGF0YVtdO1xuICBlbnRlcnByaXNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlclRva2VuT3B0aW9ucyB7XG4gIHRva2VuQ29udHJhY3RBZGRyZXNzPzogc3RyaW5nO1xuICByZWNpcGllbnQ/OiBzdHJpbmc7XG4gIGJyb2FkY2FzdD86IGJvb2xlYW47XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHBydj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFuZ2VGZWVPcHRpb25zIHtcbiAgdHhpZD86IHN0cmluZztcbiAgZmVlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVBvbGljeVJ1bGVPcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIGNvbmRpdGlvbj86IHVua25vd247XG4gIGFjdGlvbj86IHVua25vd247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0UG9saWN5UnVsZU9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgY29uZGl0aW9uPzogdW5rbm93bjtcbiAgYWN0aW9uPzogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdmVQb2xpY3lSdWxlT3B0aW9ucyB7XG4gIGlkPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvd25sb2FkS2V5Y2FyZE9wdGlvbnMge1xuICBqc1BERj86IGFueTtcbiAgUVJDb2RlPzogYW55O1xuICB1c2VyS2V5Y2hhaW4/OiBLZXljaGFpbjtcbiAgYmFja3VwS2V5Y2hhaW4/OiBLZXljaGFpbjtcbiAgYml0Z29LZXljaGFpbj86IEtleWNoYWluO1xuICBwYXNzcGhyYXNlPzogc3RyaW5nO1xuICBwYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nO1xuICBhY3RpdmF0aW9uQ29kZT86IHN0cmluZztcbiAgd2FsbGV0S2V5SUQ/OiBzdHJpbmc7XG4gIGJhY2t1cEtleUlEPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgV2FsbGV0IHtcbiAgcHVibGljIHJlYWRvbmx5IGJpdGdvOiBCaXRHbztcbiAgcHVibGljIHJlYWRvbmx5IGJhc2VDb2luOiBCYXNlQ29pbjtcbiAgcHJpdmF0ZSBfd2FsbGV0OiBXYWxsZXREYXRhO1xuICBwcml2YXRlIHJlYWRvbmx5IF9wZXJtaXNzaW9ucz86IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgYmFzZUNvaW46IEJhc2VDb2luLCB3YWxsZXREYXRhOiBhbnkpIHtcbiAgICB0aGlzLmJpdGdvID0gYml0Z287XG4gICAgdGhpcy5iYXNlQ29pbiA9IGJhc2VDb2luO1xuICAgIHRoaXMuX3dhbGxldCA9IHdhbGxldERhdGE7XG4gICAgY29uc3QgdXNlcklkID0gXy5nZXQoYml0Z28sICdfdXNlci5pZCcpO1xuICAgIGlmIChfLmlzU3RyaW5nKHVzZXJJZCkpIHtcbiAgICAgIGNvbnN0IHVzZXJEZXRhaWxzID0gXy5maW5kKHdhbGxldERhdGEudXNlcnMsIHsgdXNlcjogdXNlcklkIH0pO1xuICAgICAgdGhpcy5fcGVybWlzc2lvbnMgPSBfLmdldCh1c2VyRGV0YWlscywgJ3Blcm1pc3Npb25zJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgVVJMIHVzaW5nIHRoaXMgd2FsbGV0J3MgaWQgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIEJpdEdvIEFQSSBvcGVyYXRpb25zXG4gICAqIEBwYXJhbSBleHRyYSBBUEkgc3BlY2lmaWMgc3RyaW5nIHRvIGFwcGVuZCB0byB0aGUgd2FsbGV0IGlkXG4gICAqL1xuICB1cmwoZXh0cmE6IHN0cmluZyA9ICcnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMuaWQoKSArIGV4dHJhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhpcyB3YWxsZXQncyBpZFxuICAgKi9cbiAgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIGFwcHJvdmFscyByZXF1aXJlZCBmb3Igc3BlbmRpbmcgZnVuZHMgZnJvbSB0aGlzIHdhbGxldFxuICAgKi9cbiAgYXBwcm92YWxzUmVxdWlyZWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmFwcHJvdmFsc1JlcXVpcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICBiYWxhbmNlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5iYWxhbmNlO1xuICB9XG5cbiAgcHJlYnVpbGRXaGl0ZWxpc3RlZFBhcmFtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdyZWNpcGllbnRzJywgJ251bUJsb2NrcycsICdmZWVSYXRlJywgJ21heEZlZVJhdGUnLCAnbWluQ29uZmlybXMnLCAnZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlJyxcbiAgICAgICd0YXJnZXRXYWxsZXRVbnNwZW50cycsICdtZXNzYWdlJywgJ21pblZhbHVlJywgJ21heFZhbHVlJywgJ3NlcXVlbmNlSWQnLCAnbGFzdExlZGdlclNlcXVlbmNlJyxcbiAgICAgICdsZWRnZXJTZXF1ZW5jZURlbHRhJywgJ2dhc1ByaWNlJywgJ2dhc0xpbWl0JywgJ25vU3BsaXRDaGFuZ2UnLCAndW5zcGVudHMnLCAnY2hhbmdlQWRkcmVzcycsICdpbnN0YW50JywgJ21lbW8nLCAnYWRkcmVzc1R5cGUnLFxuICAgICAgJ2NwZnBUeElkcycsICdjcGZwRmVlUmF0ZScsICdtYXhGZWUnLCAnaWRmVmVyc2lvbicsICdpZGZTaWduZWRUaW1lc3RhbXAnLCAnaWRmVXNlcklkJywgJ3N0cmF0ZWd5JyxcbiAgICAgICd2YWxpZEZyb21CbG9jaycsICd2YWxpZFRvQmxvY2snLCAndHlwZScsICd0cnVzdGxpbmVzJywgJ3Jlc2VydmF0aW9uJyxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBzdHJpY3Qgc3ViLXNldCBvZiBwcmVidWlsZFdoaXRlbGlzdGVkUGFyYW1zLlxuICAgKi9cbiAgcHJlYnVpbGRDb25zb2xpZGF0ZVRyYW5zYWN0aW9uUGFyYW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ2ZlZVJhdGUnLCAnbWF4RmVlUmF0ZScsICdtZW1vJywgJ3ZhbGlkRnJvbUJsb2NrJywgJ3ZhbGlkVG9CbG9jaycsXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbmZpcm1lZCBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICBjb25maXJtZWRCYWxhbmNlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5jb25maXJtZWRCYWxhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3BlbmRhYmxlIGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXRcbiAgICovXG4gIHNwZW5kYWJsZUJhbGFuY2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LnNwZW5kYWJsZUJhbGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYmFsYW5jZXMgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIG92ZXJmbG93IHN0YW5kYXJkIGphdmFzY3JpcHQgbnVtYmVyc1xuICAgKi9cbiAgYmFsYW5jZVN0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuYmFsYW5jZVN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbmZpcm1lZCBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYmFsYW5jZXMgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIG92ZXJmbG93IHN0YW5kYXJkIGphdmFzY3JpcHQgbnVtYmVyc1xuICAgKi9cbiAgY29uZmlybWVkQmFsYW5jZVN0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuY29uZmlybWVkQmFsYW5jZVN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZW5kYWJsZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYmFsYW5jZXMgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIG92ZXJmbG93IHN0YW5kYXJkIGphdmFzY3JpcHQgbnVtYmVyc1xuICAgKi9cbiAgc3BlbmRhYmxlQmFsYW5jZVN0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuc3BlbmRhYmxlQmFsYW5jZVN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvaW4gaWRlbnRpZmllciBmb3IgdGhlIHR5cGUgb2YgY29pbiB0aGlzIHdhbGxldCBob2xkc1xuICAgKi9cbiAgY29pbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuY29pbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhYmVsIChuYW1lKSBmb3IgdGhpcyB3YWxsZXRcbiAgICovXG4gIHB1YmxpYyBsYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQubGFiZWw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWMgb2JqZWN0IGlkcyBmb3IgdGhlIGtleWNoYWlucyBvbiB0aGlzIHdhbGxldC5cbiAgICovXG4gIHB1YmxpYyBrZXlJZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQua2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWNlaXZlIGFkZHJlc3MgZm9yIHRoaXMgd2FsbGV0XG4gICAqL1xuICBwdWJsaWMgcmVjZWl2ZUFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LnJlY2VpdmVBZGRyZXNzLmFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3YWxsZXQgaWQgb2YgdGhlIHdhbGxldCB0aGF0IHRoaXMgd2FsbGV0IHdhcyBtaWdyYXRlZCBmcm9tLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhpcyBpcyBhIEJDSCB3YWxsZXQgdGhhdCB3YXMgY3JlYXRlZCBmcm9tIGEgQlRDIHdhbGxldCxcbiAgICogdGhlIEJDSCB3YWxsZXQgbWlncmF0ZWQgZnJvbSBmaWVsZCB3b3VsZCBoYXZlIHRoZSBCVEMgd2FsbGV0IGlkLlxuICAgKi9cbiAgcHVibGljIG1pZ3JhdGVkRnJvbSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQubWlncmF0ZWRGcm9tO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdG9rZW4gZmx1c2ggdGhyZXNob2xkcyBmb3IgdGhpcyB3YWxsZXRcbiAgICogQHJldHVybiB7KnxPYmplY3R9IHBhaXJzIG9mIHsgW3Rva2VuTmFtZV06IHRocmVzaG9sZHMgfSBiYXNlIHVuaXRzXG4gICAqL1xuICB0b2tlbkZsdXNoVGhyZXNob2xkcygpOiBhbnkge1xuICAgIGlmICh0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpICE9PSAnZXRoJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHdhbGxldCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmNvaW5TcGVjaWZpYy50b2tlbkZsdXNoVGhyZXNob2xkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2FsbGV0IHByb3BlcnRpZXMgd2hpY2ggYXJlIHNwZWNpZmljIHRvIGNlcnRhaW4gY29pbiBpbXBsZW1lbnRhdGlvbnNcbiAgICovXG4gIGNvaW5TcGVjaWZpYygpOiBXYWxsZXRDb2luU3BlY2lmaWMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuY29pblNwZWNpZmljO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgcGVuZGluZyBhcHByb3ZhbHMgb24gdGhpcyB3YWxsZXRcbiAgICovXG4gIHBlbmRpbmdBcHByb3ZhbHMoKTogUGVuZGluZ0FwcHJvdmFsW10ge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQucGVuZGluZ0FwcHJvdmFscy5tYXAoKGN1cnJlbnRBcHByb3ZhbCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQZW5kaW5nQXBwcm92YWwodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgY3VycmVudEFwcHJvdmFsLCB0aGlzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSB3YWxsZXQgb2JqZWN0IGJ5IHN5bmNpbmcgd2l0aCB0aGUgYmFjay1lbmRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge1dhbGxldH1cbiAgICovXG4gIHJlZnJlc2gocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxXYWxsZXQ+KTogQmx1ZWJpcmQ8V2FsbGV0PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFdhbGxldD4oZnVuY3Rpb24gKigpIHtcbiAgICAgIHNlbGYuX3dhbGxldCA9IHlpZWxkIHNlbGYuYml0Z28uZ2V0KHNlbGYudXJsKCkpLnJlc3VsdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB0cmFuc2FjdGlvbnMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdHJhbnNhY3Rpb25zKHBhcmFtczogUGFnaW5hdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5OiBQYWdpbmF0aW9uT3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLl93YWxsZXQuaWQgKyAnL3R4JykpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB0cmFuc2FjdGlvbnMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogIC0gdHhIYXNoIHRoZSB0cmFuc2FjdGlvbiBoYXNoIHRvIHNlYXJjaCBmb3JcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb24ocGFyYW1zOiBHZXRUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndHhIYXNoJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICBjb25zdCBxdWVyeTogUGFnaW5hdGlvbk9wdGlvbnMgPSB7fTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMubGltaXQpKSB7XG4gICAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5saW1pdCkgfHwgcGFyYW1zLmxpbWl0IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy90eC8nICsgcGFyYW1zLnR4SGFzaCkpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB0cmFuc2ZlcnMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdHJhbnNmZXJzKHBhcmFtczogVHJhbnNmZXJzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3QgcXVlcnk6IFRyYW5zZmVyc09wdGlvbnMgPSB7fTtcbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFsbFRva2Vucykge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnNlYXJjaExhYmVsKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnNlYXJjaExhYmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2VhcmNoTGFiZWwgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnNlYXJjaExhYmVsID0gcGFyYW1zLnNlYXJjaExhYmVsO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYWRkcmVzcykge1xuICAgICAgaWYgKCFfLmlzQXJyYXkocGFyYW1zLmFkZHJlc3MpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRkcmVzcyBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZyBvciBhcnJheScpO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNBcnJheShwYXJhbXMuYWRkcmVzcykpIHtcbiAgICAgICAgcGFyYW1zLmFkZHJlc3MuZm9yRWFjaChhZGRyZXNzID0+IHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZGRyZXNzIGFyZ3VtZW50LCBleHBlY3RpbmcgYXJyYXkgb2YgYWRkcmVzcyBzdHJpbmdzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmFkZHJlc3MgPSBwYXJhbXMuYWRkcmVzcztcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmRhdGVHdGUpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuZGF0ZUd0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGVHdGUgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmRhdGVHdGUgPSBwYXJhbXMuZGF0ZUd0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmRhdGVMdCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5kYXRlTHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkYXRlTHQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmRhdGVMdCA9IHBhcmFtcy5kYXRlTHQ7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy52YWx1ZUd0ZSkpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMudmFsdWVHdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWx1ZUd0ZSBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkudmFsdWVHdGUgPSBwYXJhbXMudmFsdWVHdGU7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy52YWx1ZUx0KSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy52YWx1ZUx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsdWVMdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkudmFsdWVMdCA9IHBhcmFtcy52YWx1ZUx0O1xuICAgIH1cblxuICAgIGlmICghXy5pc05pbChwYXJhbXMuaW5jbHVkZUhleCkpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmluY2x1ZGVIZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNsdWRlSGV4IGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuaW5jbHVkZUhleCA9IHBhcmFtcy5pbmNsdWRlSGV4O1xuICAgIH1cblxuICAgIGlmICghXy5pc05pbChwYXJhbXMuc3RhdGUpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnN0YXRlKSAmJiAhXy5pc1N0cmluZyhwYXJhbXMuc3RhdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZSBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZyBvciBhcnJheScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMuc3RhdGUpKSB7XG4gICAgICAgIHBhcmFtcy5zdGF0ZS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoc3RhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUgYXJndW1lbnQsIGV4cGVjdGluZyBhcnJheSBvZiBzdGF0ZSBzdHJpbmdzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnN0YXRlID0gcGFyYW1zLnN0YXRlO1xuICAgIH1cblxuICAgIGlmICghXy5pc05pbChwYXJhbXMudHlwZSkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy90cmFuc2ZlcicpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRyYW5zZmVycyBvbiB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0VHJhbnNmZXIocGFyYW1zOiBHZXRUcmFuc2Zlck9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3RyYW5zZmVyLycgKyBwYXJhbXMuaWQpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdHJhbnNhY3Rpb24gYnkgc2VxdWVuY2UgaWQgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB0cmFuc2ZlckJ5U2VxdWVuY2VJZChwYXJhbXM6IFRyYW5zZmVyQnlTZXF1ZW5jZUlkT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydzZXF1ZW5jZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy90cmFuc2Zlci9zZXF1ZW5jZUlkLycgKyBwYXJhbXMuc2VxdWVuY2VJZCkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gYW1vdW50IHlvdSBjYW4gc3BlbmQgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGltaXQgLSBtYXhpbXVtIG51bWJlciBvZiBzZWxlY3RhYmxlIHVuc3BlbnRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluVmFsdWUgLSB0aGUgbWluaW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2UgaW4gc2F0b3NoaXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhWYWx1ZSAtIHRoZSBtYXhpbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkhlaWdodCAtIHRoZSBtaW5pbXVtIGhlaWdodCBvZiB1bnNwZW50cyBvbiB0aGUgYmxvY2sgY2hhaW4gdG8gdXNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluQ29uZmlybXMgLSBhbGwgc2VsZWN0ZWQgdW5zcGVudHMgd2lsbCBoYXZlIGF0IGxlYXN0IHRoaXMgbWFueSBjb25maXJtYXRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAtIEVuZm9yY2VzIG1pbkNvbmZpcm1zIG9uIGNoYW5nZSBpbnB1dHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVSYXRlIC0gZmVlIHJhdGUgdG8gdXNlIGluIGNhbGN1bGF0aW9uIG9mIG1heGltdW0gc3BlbmRhYmxlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUmF0ZSAtIHVwcGVyIGxpbWl0IGZvciBmZWVSYXRlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucmVjaXBpZW50QWRkcmVzcyAtIHJlY2lwaWVudCBhZGRyZXNzZXMgZm9yIGEgbW9yZSBhY2N1cmF0ZSBjYWxjdWxhdGlvbiBvZiB0aGUgbWF4aW11bSBhdmFpbGFibGUgdG8gc2VuZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ttYXhpbXVtU3BlbmRhYmxlOiBOdW1iZXIsIGNvaW46IFN0cmluZ319XG4gICAqIE5PVEUgOiBmZWVUeENvbmZpcm1UYXJnZXQgb21pdHRlZCBvbiBwdXJwb3NlIGJlY2F1c2UgZ2F1Z2luZyB0aGUgbWF4aW11bSBzcGVuZGFibGUgYW1vdW50IHdpdGggZHluYW1pYyBmZWVzIGRvZXMgbm90IG1ha2Ugc2Vuc2VcbiAgICovXG4gIG1heGltdW1TcGVuZGFibGUocGFyYW1zOiBNYXhpbXVtU3BlbmRhYmxlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxNYXhpbXVtU3BlbmRhYmxlPik6IEJsdWViaXJkPE1heGltdW1TcGVuZGFibGU+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288TWF4aW11bVNwZW5kYWJsZT4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgW1xuICAgICAgICAnbWluVmFsdWUnLCAnbWF4VmFsdWUnLCAnbWluSGVpZ2h0JywgJ3RhcmdldCcsICdwbGFpblRhcmdldCcsICdsaW1pdCcsICdtaW5Db25maXJtcycsXG4gICAgICAgICdlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UnLCAnZmVlUmF0ZScsICdtYXhGZWVSYXRlJywgJ3JlY2lwaWVudEFkZHJlc3MnXG4gICAgICBdKTtcblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z28uZ2V0KHNlbGYudXJsKCcvbWF4aW11bVNwZW5kYWJsZScpKVxuICAgICAgICAucXVlcnkoZmlsdGVyZWRQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHVuc3BlbnRzIGZvciBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHVuc3BlbnRzKHBhcmFtczogVW5zcGVudHNPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBxdWVyeSA9IF8ucGljayhwYXJhbXMsIFsncHJldklkJywgJ2xpbWl0JywgJ21pblZhbHVlJywgJ21heFZhbHVlJywgJ21pbkhlaWdodCcsICdtaW5Db25maXJtcycsICd0YXJnZXQnLCAnc2Vnd2l0JywgJ2NoYWlucyddKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3Vuc3BlbnRzJykpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZSBvciBmYW5vdXQgdW5zcGVudHMgb24gYSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJvdXRlTmFtZSAtIGVpdGhlciBgY29uc29saWRhdGVgIG9yIGBmYW5vdXRgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbWV0ZXJzIG9iamVjdFxuICAgKlxuICAgKiBXYWxsZXQgcGFyYW1ldGVyczpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHVzZXJzIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMueHBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSBpZiB0aGUgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqXG4gICAqIEZlZSBwYXJhbWV0ZXJzOlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBUaGUgZmVlIHJhdGUgdG8gdXNlIGZvciB0aGUgY29uc29saWRhdGlvbiBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVBlcmNlbnRhZ2UgLSB0aGUgbWF4aW11bSByZWxhdGl2ZSBwb3J0aW9uIHRoYXQgeW91J3JlIHdpbGxpbmcgdG8gc3BlbmQgdG93YXJkcyBmZWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IC0gZXN0aW1hdGUgdGhlIGZlZXMgdG8gYWltIGZvciBmaXJzdCBjb25maXJtYXRpb24gd2l0aCB0aGlzIG51bWJlciBvZiBibG9ja3NcbiAgICpcbiAgICogSW5wdXQgcGFyYW1ldGVyczpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gdGhlIG1heGltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluSGVpZ2h0IC0gdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHVuc3BlbnRzIG9uIHRoZSBibG9jayBjaGFpbiB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gaWYgdHJ1ZSwgbWluQ29uZmlybXMgYWxzbyBhcHBsaWVzIHRvIGNoYW5nZSBvdXRwdXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGltaXQgICAgICAgICAgICAgICAgZm9yIHJvdXRlTmFtZSA9PT0gJ2NvbnNvbGlkYXRlJ1xuICAgKiAgICAgICAgICAgICAgICAgcGFyYW1zLm1heE51bVVuc3BlbnRzVG9Vc2UgIGZvciByb3V0ZU5hbWUgPT09ICdmYW5vdXQnXG4gICAqICAgICAgICAgICAgICAgICAgLSBtYXhpbXVtIG51bWJlciBvZiB1bnNwZW50cyB5b3Ugd2FudCB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIE91dHB1dCBwYXJhbWV0ZXJzOlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm51bVVuc3BlbnRzVG9NYWtlIC0gdGhlIG51bWJlciBvZiBuZXcgdW5zcGVudHMgdG8gbWFrZVxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHByaXZhdGUgbWFuYWdlVW5zcGVudHMocm91dGVOYW1lOiBNYW5hZ2VVbnNwZW50cywgcGFyYW1zOiBDb25zb2xpZGF0ZVVuc3BlbnRzT3B0aW9ucyB8IEZhbm91dFVuc3BlbnRzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3hwcnYnXSwgY2FsbGJhY2spO1xuXG4gICAgICBjb25zdCByZXFJZCA9IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gICAgICBjb25zdCBmaWx0ZXJlZFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFtcbiAgICAgICAgJ2ZlZVJhdGUnLFxuICAgICAgICAnbWF4RmVlUmF0ZScsXG4gICAgICAgICdtYXhGZWVQZXJjZW50YWdlJyxcbiAgICAgICAgJ2ZlZVR4Q29uZmlybVRhcmdldCcsXG5cbiAgICAgICAgJ21pblZhbHVlJyxcbiAgICAgICAgJ21heFZhbHVlJyxcbiAgICAgICAgJ21pbkhlaWdodCcsXG4gICAgICAgICdtaW5Db25maXJtcycsXG4gICAgICAgICdlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UnLFxuXG4gICAgICAgIHJvdXRlTmFtZSA9PT0gJ2NvbnNvbGlkYXRlJyA/ICdsaW1pdCcgOiAnbWF4TnVtVW5zcGVudHNUb1VzZScsXG4gICAgICAgICdudW1VbnNwZW50c1RvTWFrZScsXG4gICAgICBdKTtcbiAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHNlbGYuYml0Z28ucG9zdChzZWxmLnVybChgLyR7cm91dGVOYW1lfVVuc3BlbnRzYCkpXG4gICAgICAgIC5zZW5kKGZpbHRlcmVkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG5cbiAgICAgIGNvbnN0IGtleWNoYWluID0geWllbGQgc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXQoeyBpZDogc2VsZi5fd2FsbGV0LmtleXNbMF0sIHJlcUlkIH0pO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25QYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zLCB7IHR4UHJlYnVpbGQ6IHJlc3BvbnNlLCBrZXljaGFpbiB9KTtcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0geWllbGQgc2VsZi5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25QYXJhbXMpO1xuICAgICAgY29uc3Qgc2VsZWN0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgWydjb21tZW50JywgJ290cCddKTtcbiAgICAgIGNvbnN0IGZpbmFsVHhQYXJhbXMgPSBfLmV4dGVuZCh7fSwgc2lnbmVkVHJhbnNhY3Rpb24sIHNlbGVjdFBhcmFtcyk7XG5cbiAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLl93YWxsZXQuaWQgKyAnL3R4L3NlbmQnKSlcbiAgICAgICAgLnNlbmQoZmluYWxUeFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc29saWRhdGUgdW5zcGVudHMgb24gYSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHRoZSB1c2VycyB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnhwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0gaWYgdGhlIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBUaGUgZmVlIHJhdGUgdG8gdXNlIGZvciB0aGUgY29uc29saWRhdGlvbiBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVBlcmNlbnRhZ2UgLSB0aGUgbWF4aW11bSByZWxhdGl2ZSBwb3J0aW9uIHRoYXQgeW91J3JlIHdpbGxpbmcgdG8gc3BlbmQgdG93YXJkcyBmZWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IC0gZXN0aW1hdGUgdGhlIGZlZXMgdG8gYWltIGZvciBmaXJzdCBjb25maXJtYXRpb24gd2l0aCB0aGlzIG51bWJlciBvZiBibG9ja3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gdGhlIG1heGltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluSGVpZ2h0IC0gdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHVuc3BlbnRzIG9uIHRoZSBibG9jayBjaGFpbiB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gaWYgdHJ1ZSwgbWluQ29uZmlybXMgYWxzbyBhcHBsaWVzIHRvIGNoYW5nZSBvdXRwdXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGltaXQgICAgICAgICAgICAgICAgZm9yIHJvdXRlTmFtZSA9PT0gJ2NvbnNvbGlkYXRlJ1xuICAgKiAgICAgICAgICAgICAgICAgcGFyYW1zLm1heE51bVVuc3BlbnRzVG9Vc2UgIGZvciByb3V0ZU5hbWUgPT09ICdmYW5vdXQnXG4gICAqICAgICAgICAgICAgICAgICAgLSBtYXhpbXVtIG51bWJlciBvZiB1bnNwZW50cyB5b3Ugd2FudCB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubnVtVW5zcGVudHNUb01ha2UgLSB0aGUgbnVtYmVyIG9mIG5ldyB1bnNwZW50cyB0byBtYWtlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgY29uc29saWRhdGVVbnNwZW50cyhwYXJhbXM6IENvbnNvbGlkYXRlVW5zcGVudHNPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5tYW5hZ2VVbnNwZW50cygnY29uc29saWRhdGUnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYW5vdXQgdW5zcGVudHMgb24gYSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHRoZSB1c2VycyB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnhwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0gaWYgdGhlIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pblZhbHVlIC0gdGhlIG1pbmltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4VmFsdWUgLSB0aGUgbWF4aW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5IZWlnaHQgLSB0aGUgbWluaW11bSBoZWlnaHQgb2YgdW5zcGVudHMgb24gdGhlIGJsb2NrIGNoYWluIHRvIHVzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gYWxsIHNlbGVjdGVkIHVuc3BlbnRzIHdpbGwgaGF2ZSBhdCBsZWFzdCB0aGlzIG1hbnkgY29uZmlybWF0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVBlcmNlbnRhZ2UgLSB0aGUgbWF4aW11bSBwcm9wb3J0aW9uIG9mIGFuIHVuc3BlbnQgeW91IGFyZSB3aWxsaW5nIHRvIGxvc2UgdG8gZmVlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCAtIGVzdGltYXRlIHRoZSBmZWVzIHRvIGFpbSBmb3IgZmlyc3QgY29uZmlybWF0aW9uIHdpdGggdGhpcyBudW1iZXIgb2YgYmxvY2tzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIFRoZSBkZXNpcmVkIGZlZSByYXRlIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVSYXRlIC0gVGhlIG1heCBsaW1pdCBmb3IgYSBmZWUgcmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heE51bUlucHV0c1RvVXNlIC0gdGhlIG51bWJlciBvZiB1bnNwZW50cyB5b3Ugd2FudCB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubnVtVW5zcGVudHNUb01ha2UgLSB0aGUgbnVtYmVyIG9mIG5ldyB1bnNwZW50cyB0byBtYWtlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZmFub3V0VW5zcGVudHMocGFyYW1zOiBGYW5vdXRVbnNwZW50c09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZVVuc3BlbnRzKCdmYW5vdXQnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRva2VuIGZsdXNoIHRocmVzaG9sZHMgZm9yIHRoZSB3YWxsZXQuIFVwZGF0ZXMgdGhlIHdhbGxldC5cbiAgICogVG9rZW5zIHdpbGwgb25seSBiZSBmbHVzaGVkIGZyb20gZm9yd2FyZGVyIGNvbnRyYWN0cyBpZiB0aGUgYmFsYW5jZSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZCBkZWZpbmVkIGhlcmUuXG4gICAqIEBwYXJhbSB0aHJlc2hvbGRzIHtPYmplY3R9IC0gcGFpcnMgb2YgeyBbdG9rZW5OYW1lXTogdGhyZXNob2xkIH0gKGJhc2UgdW5pdHMpXG4gICAqIEBwYXJhbSBbY2FsbGJhY2tdXG4gICAqL1xuICB1cGRhdGVUb2tlbkZsdXNoVGhyZXNob2xkcyh0aHJlc2hvbGRzOiBhbnkgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKHNlbGYuYmFzZUNvaW4uZ2V0RmFtaWx5KCkgIT09ICdldGgnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBmb3IgdGhpcyB3YWxsZXQnKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fd2FsbGV0ID0geWllbGQgc2VsZi5iaXRnby5wdXQoc2VsZi51cmwoKSkuc2VuZCh7XG4gICAgICAgIHRva2VuRmx1c2hUaHJlc2hvbGRzOiB0aHJlc2hvbGRzXG4gICAgICB9KS5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3ZWVwIGZ1bmRzIGZvciBhIHdhbGxldFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcGFyYW1ldGVycyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5hZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gc2VuZCBhbGwgdGhlIGZ1bmRzIGluIHRoZSB3YWxsZXQgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHVzZXJzIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMueHBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSBpZiB0aGUgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMub3RwIC0gVHdvIGZhY3RvciBhdXRoIGNvZGUgdG8gZW5hYmxlIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IC0gRXN0aW1hdGUgdGhlIGZlZXMgdG8gYWltIGZvciBmaXJzdCBjb25maXJtYXRpb24gd2l0aGluIHRoaXMgbnVtYmVyIG9mIGJsb2Nrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBUaGUgZGVzaXJlZCBmZWUgcmF0ZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heEZlZVJhdGVdIC0gdXBwZXIgbGltaXQgZm9yIGZlZVJhdGUgaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmFsbG93UGFydGlhbFN3ZWVwXSAtIGFsbG93cyBzd2VlcGluZyAyMDAgdW5zcGVudHMgd2hlbiB0aGUgd2FsbGV0IGhhcyBtb3JlIHRoYW4gdGhhdFxuICAgKiBAcGFyYW0gW2NhbGxiYWNrXVxuICAgKiBAcmV0dXJucyB0eEhleCB7U3RyaW5nfSB0aGUgdHhIZXggb2YgdGhlIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3dlZXAocGFyYW1zOiBTd2VlcE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFsnd2FsbGV0UGFzc3BocmFzZScsICd4cHJ2JywgJ290cCddLCBjYWxsYmFjayk7XG5cbiAgICAgIGlmIChbJ2V0aCcsICd4cnAnXS5pbmNsdWRlcyhzZWxmLmJhc2VDb2luLmdldEZhbWlseSgpKSkge1xuICAgICAgICBpZiAoc2VsZi5jb25maXJtZWRCYWxhbmNlU3RyaW5nKCkgIT09IHNlbGYuYmFsYW5jZVN0cmluZygpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3dlZXAgd2hlbiB1bmNvbmZpcm1lZCBmdW5kcyBleGlzdCBvbiB0aGUgd2FsbGV0LCBwbGVhc2Ugd2FpdCB1bnRpbCBhbGwgaW5ib3VuZCB0cmFuc2FjdGlvbnMgY29uZmlybScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzZWxmLnNwZW5kYWJsZUJhbGFuY2VTdHJpbmcoKTtcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnMCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGZ1bmRzIHRvIHN3ZWVwJyk7XG4gICAgICAgIH1cbiAgICAgICAgKHBhcmFtcyBhcyBhbnkpLnJlY2lwaWVudHMgPSBbe1xuICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgIGFtb3VudDogdmFsdWUsXG4gICAgICAgIH1dO1xuXG4gICAgICAgIHJldHVybiBzZWxmLnNlbmRNYW55KHBhcmFtcyk7XG4gICAgICB9XG4gICAgICAvLyB0aGUgZm9sbG93aW5nIGZsb3cgd29ya3MgZm9yIGFsbCBVVFhPIGNvaW5zXG5cbiAgICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgWydhZGRyZXNzJywgJ2ZlZVJhdGUnLCAnbWF4RmVlUmF0ZScsICdmZWVUeENvbmZpcm1UYXJnZXQnLCAnYWxsb3dQYXJ0aWFsU3dlZXAnXSk7XG4gICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBzZWxmLmJpdGdvLnBvc3Qoc2VsZi51cmwoJy9zd2VlcFdhbGxldCcpKVxuICAgICAgICAuc2VuZChmaWx0ZXJlZFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgLy8gVE9ETyhCRy0zNTg4KTogYWRkIHR4SGV4IHZhbGlkYXRpb24gdG8gcHJvdGVjdCBtYW4gaW4gdGhlIG1pZGRsZSBhdHRhY2tzIHJlcGxhY2luZyB0aGUgdHhIZXhcblxuICAgICAgY29uc3Qga2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiBzZWxmLl93YWxsZXQua2V5c1swXSwgcmVxSWQgfSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvblBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMsIHsgdHhQcmVidWlsZDogcmVzcG9uc2UsIGtleWNoYWluOiBrZXljaGFpbiwgcHJ2OiBwYXJhbXMueHBydiB9KTtcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0geWllbGQgc2VsZi5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25QYXJhbXMpO1xuXG4gICAgICBjb25zdCBzZWxlY3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ290cCddKTtcbiAgICAgIGNvbnN0IGZpbmFsVHhQYXJhbXMgPSBfLmV4dGVuZCh7fSwgc2lnbmVkVHJhbnNhY3Rpb24sIHNlbGVjdFBhcmFtcyk7XG4gICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgcmV0dXJuIHNlbGYuYml0Z28ucG9zdChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgc2VsZi5fd2FsbGV0LmlkICsgJy90eC9zZW5kJykpXG4gICAgICAgIC5zZW5kKGZpbmFsVHhQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyZWV6ZSBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGZyZWV6ZShwYXJhbXM6IEZyZWV6ZU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIGlmIChwYXJhbXMuZHVyYXRpb24pIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuZHVyYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkdXJhdGlvbjogc2hvdWxkIGJlIG51bWJlciBvZiBzZWNvbmRzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL2ZyZWV6ZScpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGNvbW1lbnQgb2YgYSB0cmFuc2ZlclxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHRyYW5zZmVyQ29tbWVudChwYXJhbXM6IFRyYW5zZmVyQ29tbWVudE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgWydjb21tZW50J10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMuX3dhbGxldC5pZCArICcvdHJhbnNmZXIvJyArIHBhcmFtcy5pZCArICcvY29tbWVudCcpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0aGUgYWRkcmVzc2VzIGZvciBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFkZHJlc3NlcyhwYXJhbXM6IEFkZHJlc3Nlc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgY29uc3QgcXVlcnk6IEFkZHJlc3Nlc09wdGlvbnMgPSB7fTtcblxuICAgIGlmIChwYXJhbXMubWluZSkge1xuICAgICAgcXVlcnkubWluZSA9ICEhcGFyYW1zLm1pbmU7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnNvcnQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuc29ydCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNvcnQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnNvcnQgPSBwYXJhbXMuc29ydDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGFiZWxDb250YWlucykge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5sYWJlbENvbnRhaW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGFiZWxDb250YWlucyBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGFiZWxDb250YWlucyA9IHBhcmFtcy5sYWJlbENvbnRhaW5zO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuc2Vnd2l0KSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuc2Vnd2l0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2Vnd2l0IGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuc2Vnd2l0ID0gcGFyYW1zLnNlZ3dpdDtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmNoYWlucykpIHtcbiAgICAgIGlmICghXy5pc0FycmF5KHBhcmFtcy5jaGFpbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaGFpbnMgYXJndW1lbnQsIGV4cGVjdGluZyBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5jaGFpbnMgPSBwYXJhbXMuY2hhaW5zO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5fd2FsbGV0LmlkICsgJy9hZGRyZXNzZXMnKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZSB3YWxsZXQgYWRkcmVzcyBieSBpdHMgaWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBnZXRBZGRyZXNzKHBhcmFtczogR2V0QWRkcmVzc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ2FkZHJlc3MnLCAnaWQnXSwgY2FsbGJhY2spO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuYWRkcmVzcykgJiYgXy5pc1VuZGVmaW5lZChwYXJhbXMuaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZHJlc3Mgb3IgaWQgb2YgYWRkcmVzcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmFkZHJlc3MpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLmFkZHJlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLmlkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMucmVxSWQpIHtcbiAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybChgL3dhbGxldC8ke3RoaXMuX3dhbGxldC5pZH0vYWRkcmVzcy8ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgb25lIG9yIG1vcmUgbmV3IGFkZHJlc3MoZXMpIGZvciB1c2Ugd2l0aCB0aGlzIHdhbGxldC5cbiAgICpcbiAgICogSWYgdGhlIGBjb3VudGAgZmllbGQgaXMgZGVmaW5lZCBhbmQgZ3JlYXRlciB0aGFuIDEsIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlXG4gICAqIGFycmF5IHByb3BlcnR5IG5hbWVkIGBhZGRyZXNzZXNgIGNvbnRhaW5pbmcgYGNvdW50YCBhZGRyZXNzIG9iamVjdHNcbiAgICogd2lsbCBiZSByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIHNpbmdsZSBhZGRyZXNzIG9iamVjdCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmNoYWluIG9uIHdoaWNoIHRoZSBuZXcgYWRkcmVzcyBzaG91bGQgYmUgY3JlYXRlZFxuICAgKiBAcGFyYW0geyhOdW1iZXJ8U3RyaW5nKX0gcGFyYW1zLmdhc1ByaWNlIGdhcyBwcmljZSBmb3IgbmV3IGFkZHJlc3MgY3JlYXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5sYWJlbCBsYWJlbCBmb3IgdGhlIG5ldyBhZGRyZXNzKGVzKVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmNvdW50PTEgbnVtYmVyIG9mIG5ldyBhZGRyZXNzZXMgd2hpY2ggc2hvdWxkIGJlIGNyZWF0ZWQgKG1heGltdW0gMjUwKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5sb3dQcmlvcml0eSBFdGhlcmV1bS1zcGVjaWZpYyBwYXJhbSB0byBjcmVhdGUgYWRkcmVzcyB1c2luZyBsb3cgcHJpb3JpdHkgZmVlIGFkZHJlc3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBjcmVhdGVBZGRyZXNzKHBhcmFtczogQ3JlYXRlQWRkcmVzc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgYWRkcmVzc1BhcmFtczogQ3JlYXRlQWRkcmVzc09wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBjaGFpbixcbiAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBsb3dQcmlvcml0eSxcbiAgICAgICAgY291bnQgPSAxLFxuICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNoYWluKSkge1xuICAgICAgICBpZiAoIV8uaXNJbnRlZ2VyKGNoYWluKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gaGFzIHRvIGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzUGFyYW1zLmNoYWluID0gY2hhaW47XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChnYXNQcmljZSkpIHtcbiAgICAgICAgaWYgKCFfLmlzSW50ZWdlcihnYXNQcmljZSkgJiYgKGlzTmFOKE51bWJlcihnYXNQcmljZSkpIHx8ICFfLmlzU3RyaW5nKGdhc1ByaWNlKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dhc1ByaWNlIGhhcyB0byBiZSBhbiBpbnRlZ2VyIG9yIG51bWVyaWMgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzc1BhcmFtcy5nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQobGFiZWwpKSB7XG4gICAgICAgIGlmICghXy5pc1N0cmluZyhsYWJlbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVsIGhhcyB0byBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3NQYXJhbXMubGFiZWwgPSBsYWJlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzSW50ZWdlcihjb3VudCkgfHwgY291bnQgPD0gMCB8fCBjb3VudCA+IDI1MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdW50IGhhcyB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDI1MCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQobG93UHJpb3JpdHkpKSB7XG4gICAgICAgIGlmICghXy5pc0Jvb2xlYW4obG93UHJpb3JpdHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb3dQcmlvcml0eSBoYXMgdG8gYmUgYSBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzc1BhcmFtcy5sb3dQcmlvcml0eSA9IGxvd1ByaW9yaXR5O1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQga2V5Y2hhaW5zIGZvciBhZGRyZXNzIHZlcmlmaWNhdGlvblxuICAgICAgY29uc3Qga2V5Y2hhaW5zID0geWllbGQgQmx1ZWJpcmQubWFwKHNlbGYuX3dhbGxldC5rZXlzIGFzIHN0cmluZ1tdLFxuICAgICAgICBrID0+IHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IGssIHJlcUlkIH0pXG4gICAgICApO1xuICAgICAgY29uc3Qgcm9vdEFkZHJlc3MgPSBfLmdldChzZWxmLl93YWxsZXQsICdyZWNlaXZlQWRkcmVzcy5hZGRyZXNzJyk7XG5cbiAgICAgIGNvbnN0IG5ld0FkZHJlc3NlcyA9IF8udGltZXMoY291bnQsIGNvKGZ1bmN0aW9uICpjcmVhdGVBbmRWZXJpZnlBZGRyZXNzKCkge1xuICAgICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgICBjb25zdCBuZXdBZGRyZXNzID0geWllbGQgc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLl93YWxsZXQuaWQgKyAnL2FkZHJlc3MnKSlcbiAgICAgICAgICAuc2VuZChhZGRyZXNzUGFyYW1zKVxuICAgICAgICAgIC5yZXN1bHQoKTtcblxuICAgICAgICAvLyBpbmZlciBpdHMgYWRkcmVzcyB0eXBlXG4gICAgICAgIGlmIChfLmlzT2JqZWN0KG5ld0FkZHJlc3MuY29pblNwZWNpZmljKSkge1xuICAgICAgICAgIC8vIG5lZWQgZHluYW1pYyBpbXBvcnQgdG8gYnJlYWsgY2lyY3VsYXIgZGVwZW5kZW5jeSwgdGhpcyBpcyB1Z2x5XG4gICAgICAgICAgY29uc3QgeyBBYnN0cmFjdFV0eG9Db2luIH0gPSByZXF1aXJlKCcuL2NvaW5zL2Fic3RyYWN0VXR4b0NvaW4nKTtcbiAgICAgICAgICBuZXdBZGRyZXNzLmFkZHJlc3NUeXBlID0gQWJzdHJhY3RVdHhvQ29pbi5pbmZlckFkZHJlc3NUeXBlKG5ld0FkZHJlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3QWRkcmVzcy5rZXljaGFpbnMgPSBrZXljaGFpbnM7XG4gICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbkRhdGEgPSBfLm1lcmdlKHt9LCBuZXdBZGRyZXNzLCB7IHJvb3RBZGRyZXNzIH0pO1xuXG4gICAgICAgIGlmICh2ZXJpZmljYXRpb25EYXRhLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFkZHJlc3NHZW5lcmF0aW9uRXJyb3IodmVyaWZpY2F0aW9uRGF0YS5lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJhc2VDb2luLnZlcmlmeUFkZHJlc3ModmVyaWZpY2F0aW9uRGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld0FkZHJlc3M7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgICAgaWYgKG5ld0FkZHJlc3Nlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld0FkZHJlc3Nlc1swXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzc2VzOiB5aWVsZCBQcm9taXNlLmFsbChuZXdBZGRyZXNzZXMpLFxuICAgICAgfTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwcm9wZXJ0aWVzIG9uIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICB1cGRhdGVBZGRyZXNzKHBhcmFtczogVXBkYXRlQWRkcmVzc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHBhcmFtcy5hZGRyZXNzO1xuXG4gICAgICBpZiAoIV8uaXNTdHJpbmcoYWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXJhbWV0ZXIgYWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwdXRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ2xhYmVsJ10pO1xuICAgICAgY29uc3QgdXJsID0gc2VsZi51cmwoJy9hZGRyZXNzLycgKyBlbmNvZGVVUklDb21wb25lbnQoYWRkcmVzcykpO1xuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5wdXQodXJsKS5zZW5kKHB1dFBhcmFtcykucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHdlYmhvb2tzIG9uIHRoaXMgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBsaXN0V2ViaG9va3MocGFyYW1zOiBQYWdpbmF0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3QgcXVlcnk6IFBhZ2luYXRpb25PcHRpb25zID0ge307XG4gICAgaWYgKHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvd2ViaG9va3MnKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIHdhbGxldCB3ZWJob29rLCBjdXJyZW50bHkgZm9yIHdlYmhvb2tzIG9mIHR5cGUgdHJhbnNmZXIgYW5kIHBlbmRpbmcgYXBwcm92YWxcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHdlYmhvb2tJZCAocmVxdWlyZWQpIGlkIG9mIHRoZSB3ZWJob29rIHRvIGJlIHNpbXVsYXRlZFxuICAgKiAtIHRyYW5zZmVySWQgKG9wdGlvbmFsIGJ1dCByZXF1aXJlZCBmb3IgdHJhbnNmZXIgd2ViaG9va3MpIGlkIG9mIHRoZSBzaW11bGF0ZWQgdHJhbnNmZXJcbiAgICogLSBwZW5kaW5nQXBwcm92YWxJZCAob3B0aW9uYWwgYnV0IHJlcXVpcmVkIGZvciBwZW5kaW5nIGFwcHJvdmFsIHdlYmhvb2tzKSBpZCBvZiB0aGUgc2ltdWxhdGVkIHBlbmRpbmcgYXBwcm92YWxcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc2ltdWxhdGVXZWJob29rKHBhcmFtczogU2ltdWxhdGVXZWJob29rT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3ZWJob29rSWQnXSwgWyd0cmFuc2ZlcklkJywgJ3BlbmRpbmdBcHByb3ZhbElkJ10sIGNhbGxiYWNrKTtcblxuICAgIGNvbnN0IGhhc1RyYW5zZmVySWQgPSAhIXBhcmFtcy50cmFuc2ZlcklkO1xuICAgIGNvbnN0IGhhc1BlbmRpbmdBcHByb3ZhbElkID0gISFwYXJhbXMucGVuZGluZ0FwcHJvdmFsSWQ7XG4gICAgaWYgKCFoYXNUcmFuc2ZlcklkICYmICFoYXNQZW5kaW5nQXBwcm92YWxJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHN1cHBseSBlaXRoZXIgdHJhbnNmZXJJZCBvciBwZW5kaW5nQXBwcm92YWxJZCcpO1xuICAgIH1cblxuICAgIGlmIChoYXNUcmFuc2ZlcklkICYmIGhhc1BlbmRpbmdBcHByb3ZhbElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3VwcGx5IGVpdGhlciB0cmFuc2ZlcklkIG9yIHBlbmRpbmdBcHByb3ZhbElkLCBidXQgbm90IGJvdGgnKTtcbiAgICB9XG5cbiAgICAvLyBkZXBlbmRpbmcgb24gdGhlIGNvaW4gdHlwZSBvZiB0aGUgd2FsbGV0LCB0aGUgdHhIYXNoIGhhcyB0byBhZGhlcmUgdG8gaXRzIHJlc3BlY3RpdmUgZm9ybWF0XG4gICAgLy8gYnV0IHRoZSBzZXJ2ZXIgdGFrZXMgY2FyZSBvZiB0aGF0XG5cbiAgICAvLyBvbmx5IHRha2UgdGhlIHRyYW5zZmVySWQgYW5kIHBlbmRpbmdBcHByb3ZhbElkIHByb3BlcnRpZXNcbiAgICBjb25zdCBmaWx0ZXJlZFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFsndHJhbnNmZXJJZCcsICdwZW5kaW5nQXBwcm92YWxJZCddKTtcblxuICAgIGNvbnN0IHdlYmhvb2tJZCA9IHBhcmFtcy53ZWJob29rSWQ7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL3dlYmhvb2tzLycgKyB3ZWJob29rSWQgKyAnL3NpbXVsYXRlJykpXG4gICAgICAuc2VuZChmaWx0ZXJlZFBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHdlYmhvb2sgdG8gdGhpcyB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGFkZFdlYmhvb2socGFyYW1zOiBNb2RpZnlXZWJob29rT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1cmwnLCAndHlwZSddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL3dlYmhvb2tzJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB3ZWJob29rIGZyb20gdGhpcyB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlbW92ZVdlYmhvb2socGFyYW1zOiBNb2RpZnlXZWJob29rT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1cmwnLCAndHlwZSddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMudXJsKCcvd2ViaG9va3MnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIga2V5IGNoYWluIGZvciB0aGlzIHdhbGxldFxuICAgKlxuICAgKiBUaGUgdXNlciBrZXkgY2hhaW4gaXMgdGhlIGZpcnN0IGtleWNoYWluIG9mIHRoZSB3YWxsZXQgYW5kIHVzdWFsbHkgaGFzIHRoZSBlbmNyeXB0ZWQgcHJ2IHN0b3JlZCBvbiBCaXRHby5cbiAgICogVXNlZnVsIHdoZW4gdHJ5aW5nIHRvIGdldCB0aGUgdXNlcnMnIGtleWNoYWluIGZyb20gdGhlIHNlcnZlciBiZWZvcmUgZGVjcnlwdGluZyB0byBzaWduIGEgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRFbmNyeXB0ZWRVc2VyS2V5Y2hhaW4ocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgdHJ5S2V5Q2hhaW4gPSBjbyhmdW5jdGlvbiAqKGluZGV4OiBudW1iZXIpIHtcbiAgICAgIGlmICghc2VsZi5fd2FsbGV0LmtleXMgfHwgaW5kZXggPj0gc2VsZi5fd2FsbGV0LmtleXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZW5jcnlwdGVkIGtleWNoYWlucyBvbiB0aGlzIHdhbGxldC4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyYW1zID0geyBpZDogc2VsZi5fd2FsbGV0LmtleXNbaW5kZXhdIH07XG5cbiAgICAgIGNvbnN0IGtleWNoYWluID0geWllbGQgc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXQocGFyYW1zKTtcbiAgICAgIC8vIElmIHdlIGZpbmQgdGhlIHBydiwgdGhlbiB0aGlzIGlzIHByb2JhYmx5IHRoZSB1c2VyIGtleWNoYWluIHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgICBpZiAoa2V5Y2hhaW4uZW5jcnlwdGVkUHJ2KSB7XG4gICAgICAgIHJldHVybiBrZXljaGFpbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnlLZXlDaGFpbihpbmRleCArIDEpO1xuICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gdHJ5S2V5Q2hhaW4oMCkubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW5lbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZm9yIHRoaXMgd2FsbGV0IChiZSBjYXJlZnVsISlcbiAgICogUmVxdWlyZXMgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldFBydihwYXJhbXM6IEdldFBydk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnd2FsbGV0UGFzc3BocmFzZScsICdwcnYnXSwgY2FsbGJhY2spO1xuXG4gICAgICAvLyBQcmVwYXJlIHNpZ25pbmcga2V5XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMucHJ2KSAmJiBfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgZWl0aGVyIHByb3ZpZGUgcHJ2IG9yIHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMucHJ2KSAmJiAhXy5pc1N0cmluZyhwYXJhbXMucHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BydiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkgJiYgIV8uaXNTdHJpbmcocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0UGFzc3BocmFzZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMucHJ2KSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMucHJ2O1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1c2VyS2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmdldEVuY3J5cHRlZFVzZXJLZXljaGFpbigpO1xuICAgICAgY29uc3QgdXNlckVuY3J5cHRlZFBydiA9IHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRQcnY7XG5cbiAgICAgIGxldCB1c2VyUHJ2O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXNlclBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7IGlucHV0OiB1c2VyRW5jcnlwdGVkUHJ2LCBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgZGVjcnlwdGluZyB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXNlclBydjtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYW4gZW5jcnlwdGVkIHdhbGxldCBzaGFyZSB0byBCaXRHby5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNyZWF0ZVNoYXJlKHBhcmFtczogQ3JlYXRlU2hhcmVPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3VzZXInLCAncGVybWlzc2lvbnMnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIGlmIChwYXJhbXMua2V5Y2hhaW4gJiYgIV8uaXNFbXB0eShwYXJhbXMua2V5Y2hhaW4pKSB7XG4gICAgICBpZiAoIXBhcmFtcy5rZXljaGFpbi5wdWIgfHwgIXBhcmFtcy5rZXljaGFpbi5lbmNyeXB0ZWRQcnYgfHwgIXBhcmFtcy5rZXljaGFpbi5mcm9tUHViS2V5IHx8ICFwYXJhbXMua2V5Y2hhaW4udG9QdWJLZXkgfHwgIXBhcmFtcy5rZXljaGFpbi5wYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMga2V5Y2hhaW4gcGFyYW1ldGVycyAtIHB1YiwgZW5jcnlwdGVkUHJ2LCBmcm9tUHViS2V5LCB0b1B1YktleSwgcGF0aCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy9zaGFyZScpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2hhcmUgdGhpcyB3YWxsZXQgd2l0aCBhbm90aGVyIEJpdEdvIHVzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc2hhcmVXYWxsZXQocGFyYW1zOiBTaGFyZVdhbGxldE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydlbWFpbCcsICdwZXJtaXNzaW9ucyddLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAnbWVzc2FnZSddLCBjYWxsYmFjayk7XG5cbiAgICAgIGlmIChwYXJhbXMucmVzaGFyZSAhPT0gdW5kZWZpbmVkICYmICFfLmlzQm9vbGVhbihwYXJhbXMucmVzaGFyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNoYXJlIHRvIGJlIGEgYm9vbGVhbi4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5za2lwS2V5Y2hhaW4gIT09IHVuZGVmaW5lZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnNraXBLZXljaGFpbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBza2lwS2V5Y2hhaW4gdG8gYmUgYSBib29sZWFuLiAnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lZWRzS2V5Y2hhaW4gPSAhcGFyYW1zLnNraXBLZXljaGFpbiAmJiBwYXJhbXMucGVybWlzc2lvbnMgJiYgcGFyYW1zLnBlcm1pc3Npb25zLmluZGV4T2YoJ3NwZW5kJykgIT09IC0xO1xuXG4gICAgICBpZiAocGFyYW1zLmRpc2FibGVFbWFpbCAhPT0gdW5kZWZpbmVkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZUVtYWlsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGRpc2FibGVFbWFpbCB0byBiZSBhIGJvb2xlYW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuZW1haWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIGVtYWlsJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNoYXJpbmcgPSB5aWVsZCBzZWxmLmJpdGdvLmdldFNoYXJpbmdLZXkoeyBlbWFpbDogcGFyYW1zLmVtYWlsLnRvTG93ZXJDYXNlKCkgfSk7XG4gICAgICBsZXQgc2hhcmVkS2V5Y2hhaW47XG4gICAgICBpZiAobmVlZHNLZXljaGFpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGtleWNoYWluID0geWllbGQgc2VsZi5nZXRFbmNyeXB0ZWRVc2VyS2V5Y2hhaW4oe30pO1xuICAgICAgICAgIC8vIERlY3J5cHQgdGhlIHVzZXIga2V5IHdpdGggYSBwYXNzcGhyYXNlXG4gICAgICAgICAgaWYgKGtleWNoYWluLmVuY3J5cHRlZFBydikge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgd2FsbGV0UGFzc3BocmFzZSBhcmd1bWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAga2V5Y2hhaW4ucHJ2ID0gc2VsZi5iaXRnby5kZWNyeXB0KHsgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLCBpbnB1dDoga2V5Y2hhaW4uZW5jcnlwdGVkUHJ2IH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNyeXB0IHVzZXIga2V5Y2hhaW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZWNrZXkgPSBtYWtlUmFuZG9tS2V5KCk7XG4gICAgICAgICAgICBjb25zdCBzZWNyZXQgPSBzZWxmLmJpdGdvLmdldEVDREhTZWNyZXQoeyBlY2tleTogZWNrZXksIG90aGVyUHViS2V5SGV4OiBzaGFyaW5nLnB1YmtleSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuY3J5cHRlZFBydiA9IHNlbGYuYml0Z28uZW5jcnlwdCh7IHBhc3N3b3JkOiBzZWNyZXQsIGlucHV0OiBrZXljaGFpbi5wcnYgfSk7XG5cbiAgICAgICAgICAgIHNoYXJlZEtleWNoYWluID0ge1xuICAgICAgICAgICAgICBwdWI6IGtleWNoYWluLnB1YixcbiAgICAgICAgICAgICAgZW5jcnlwdGVkUHJ2OiBuZXdFbmNyeXB0ZWRQcnYsXG4gICAgICAgICAgICAgIGZyb21QdWJLZXk6IGVja2V5LmdldFB1YmxpY0tleUJ1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgdG9QdWJLZXk6IHNoYXJpbmcucHVia2V5LFxuICAgICAgICAgICAgICBwYXRoOiBzaGFyaW5nLnBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlLm1lc3NhZ2UgPT09ICdObyBlbmNyeXB0ZWQga2V5Y2hhaW5zIG9uIHRoaXMgd2FsbGV0LicpIHtcbiAgICAgICAgICAgIHNoYXJlZEtleWNoYWluID0ge307XG4gICAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHRoaXMgbG9va3MgbGlrZSBhIGNvbGQgd2FsbGV0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdGlvbnM6IENyZWF0ZVNoYXJlT3B0aW9ucyA9IHtcbiAgICAgICAgdXNlcjogc2hhcmluZy51c2VySWQsXG4gICAgICAgIHBlcm1pc3Npb25zOiBwYXJhbXMucGVybWlzc2lvbnMsXG4gICAgICAgIHJlc2hhcmU6IHBhcmFtcy5yZXNoYXJlLFxuICAgICAgICBtZXNzYWdlOiBwYXJhbXMubWVzc2FnZSxcbiAgICAgICAgZGlzYWJsZUVtYWlsOiBwYXJhbXMuZGlzYWJsZUVtYWlsLFxuICAgICAgfTtcblxuICAgICAgaWYgKHNoYXJlZEtleWNoYWluKSB7XG4gICAgICAgIG9wdGlvbnMua2V5Y2hhaW4gPSBzaGFyZWRLZXljaGFpbjtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnNraXBLZXljaGFpbikge1xuICAgICAgICBvcHRpb25zLmtleWNoYWluID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNyZWF0ZVNoYXJlKG9wdGlvbnMpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVzZXIgZnJvbSB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHVzZXJJZCBJZCBvZiB0aGUgdXNlciB0byByZW1vdmVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICByZW1vdmVVc2VyKHBhcmFtczogUmVtb3ZlVXNlck9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXNlcklkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLnVybCgnL3VzZXIvJyArIHVzZXJJZCkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkICh1bnNpZ25lZCB0cmFuc2FjdGlvbikgZnJvbSBCaXRHb1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7e2FkZHJlc3M6IHN0cmluZywgYW1vdW50OiBzdHJpbmd9fSBwYXJhbXMucmVjaXBpZW50cyAtIGxpc3Qgb2YgcmVjaXBpZW50cyBhbmQgbmVjZXNzYXJ5IHJlY2lwaWVudCBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm51bUJsb2NrcyAtIEVzdGltYXRlcyB0aGUgYXBwcm94aW1hdGUgZmVlIHBlciBraWxvYnl0ZSBuZWNlc3NhcnkgZm9yIGEgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHdpdGhpbiBudW1CbG9ja3MgYmxvY2tzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIHRoZSBkZXNpcmVkIGZlZVJhdGUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBiYXNlIHVuaXRzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUmF0ZSAtIHVwcGVyIGxpbWl0IGZvciBmZWVSYXRlIGluIGJhc2UgdW5pdHMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIE1pbmltdW0gbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdW5zcGVudHMgZ29pbmcgaW50byB0aGlzIHRyYW5zYWN0aW9uIHNob3VsZCBoYXZlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAtIEVuZm9yY2UgbWluaW11bSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyBvbiBjaGFuZ2UgKGludGVybmFsKSBpbnB1dHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMgLSBUaGUgZGVzaXJlZCBjb3VudCBvZiB1bnNwZW50cyBpbiB0aGUgd2FsbGV0LiBJZiB0aGUgd2FsbGV04oCZcyBjdXJyZW50IHVuc3BlbnQgY291bnQgaXMgbG93ZXIgdGhhbiB0aGUgdGFyZ2V0LCB1cCB0byBmb3VyIGFkZGl0aW9uYWwgY2hhbmdlIG91dHB1dHMgd2lsbCBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluVmFsdWUgLSBJZ25vcmUgdW5zcGVudHMgc21hbGxlciB0aGFuIHRoaXMgYW1vdW50IG9mIGJhc2UgdW5pdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhWYWx1ZSAtIElnbm9yZSB1bnNwZW50cyBsYXJnZXIgdGhhbiB0aGlzIGFtb3VudCBvZiBiYXNlIHVuaXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuc2VxdWVuY2VJZCAtIFRoZSBzZXF1ZW5jZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5sYXN0TGVkZ2VyU2VxdWVuY2UgLSBBYnNvbHV0ZSBtYXggbGVkZ2VyIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWNjZXB0ZWQgaW4sIHdoZXJlYWZ0ZXIgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5sZWRnZXJTZXF1ZW5jZURlbHRhIC0gUmVsYXRpdmUgbGVkZ2VyIGhlaWdodCAoaW4gcmVsYXRpb24gdG8gdGhlIGN1cnJlbnQgbGVkZ2VyKSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWNjZXB0ZWQgaW4sIHdoZXJlYWZ0ZXIgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5nYXNQcmljZSAtIEN1c3RvbSBnYXMgcHJpY2UgdG8gYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5nYXNMaW1pdCAtIEN1c3RvbSBnYXMgbGltaXQgdG8gYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMubm9TcGxpdENoYW5nZSAtIFNldCB0byB0cnVlIHRvIGRpc2FibGUgYXV0b21hdGljIGNoYW5nZSBzcGxpdHRpbmcgZm9yIHB1cnBvc2VzIG9mIHVuc3BlbnQgbWFuYWdlbWVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMudW5zcGVudHMgLSBUaGUgdW5zcGVudHMgdG8gdXNlIGluIHRoZSB0cmFuc2FjdGlvbi4gRWFjaCB1bnNwZW50IHNob3VsZCBiZSBpbiB0aGUgZm9ybSBwcmV2VHhJZDpuT3V0cHV0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY2hhbmdlQWRkcmVzcyAtIFNwZWNpZmllcyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIGNoYW5nZSBvdXRwdXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy52YWxpZEZyb21CbG9jayAtIChBbGdvcmFuZCkgVGhlIG1pbmltdW0gcm91bmQgdGhpcyB3aWxsIHJ1biBvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnZhbGlkVG9CbG9jayAtIChBbGdvcmFuZCkgVGhlIG1heGltdW0gcm91bmQgdGhpcyB3aWxsIHJ1biBvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5pbnN0YW50IC0gQnVpbGQgdGhpcyB0cmFuc2FjdGlvbiB0byBjb25mb3JtIHdpdGggaW5zdGFudCBzZW5kaW5nIGNvaW4tc3BlY2lmaWMgbWV0aG9kIChpZiBhdmFpbGFibGUpXG4gICAqIEBwYXJhbSB7e3ZhbHVlOiBTdHJpbmcsIHR5cGU6IFN0cmluZ319IHBhcmFtcy5tZW1vIC0gTWVtbyB0byB1c2UgaW4gdHJhbnNhY3Rpb24gKHN1cHBvcnRlZCBieSBTdGVsbGFyKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmFkZHJlc3NUeXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzcyB0byBjcmVhdGUgZm9yIGNoYW5nZS4gT25lIG9mIGBwMnNoYCwgYHAyc2hQMndzaGAsIGFuZCBgcDJ3c2hgLiBDYXNlLXNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuaG9wIC0gQnVpbGQgdGhpcyBhcyBhbiBFdGhlcmV1bSBob3AgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5yZXNlcnZhdGlvbiAtIE9iamVjdCB0byByZXNlcnZlIHRoZSB1bnNwZW50cyB0aGF0IHRoaXMgdHggYnVpbGQgdXNlcy4gRm9ybWF0IGlzIHJlc2VydmF0aW9uID0geyBleHBpcmVUaW1lOiBJU09EYXRlU3RyaW5nLCBwZW5kaW5nQXBwcm92YWxJZDogU3RyaW5nIH1cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIFRoZSBwYXNzcGhyYXNlIHRvIHRoZSB3YWxsZXQgdXNlciBrZXksIHRvIHNpZ24gY29tbWl0bWVudCBkYXRhIGZvciBFdGhlcmV1bSBob3AgdHJhbnNhY3Rpb25zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHByZWJ1aWxkVHJhbnNhY3Rpb24ocGFyYW1zOiBQcmVidWlsZFRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0Pik6IEJsdWViaXJkPFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdD4oZnVuY3Rpb24gKigpIHtcbiAgICAgIC8vIFdoaXRlbGlzdCBwYXJhbXMgdG8gYnVpbGQgdHhcbiAgICAgIGNvbnN0IHdoaXRlbGlzdGVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgc2VsZi5wcmVidWlsZFdoaXRlbGlzdGVkUGFyYW1zKCkpO1xuICAgICAgZGVidWcoJ3ByZWJ1aWxkaW5nIHRyYW5zYWN0aW9uOiAlTycsIHdoaXRlbGlzdGVkUGFyYW1zKTtcblxuICAgICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0geWllbGQgc2VsZi5iYXNlQ29pbi5nZXRFeHRyYVByZWJ1aWxkUGFyYW1zKE9iamVjdC5hc3NpZ24ocGFyYW1zLCB7IHdhbGxldDogc2VsZiB9KSk7XG4gICAgICBPYmplY3QuYXNzaWduKHdoaXRlbGlzdGVkUGFyYW1zLCBleHRyYVBhcmFtcyk7XG4gICAgICBjb25zdCBidWlsZFF1ZXJ5ID0gc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLmlkKCkgKyAnL3R4L2J1aWxkJykpXG4gICAgICAgIC5zZW5kKHdoaXRlbGlzdGVkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBjb25zdCB1dHhvQ29pbiA9IHNlbGYuYmFzZUNvaW4gYXMgQWJzdHJhY3RVdHhvQ29pbjtcbiAgICAgIGNvbnN0IGJsb2NrSGVpZ2h0UXVlcnkgPSBfLmlzRnVuY3Rpb24odXR4b0NvaW4uZ2V0TGF0ZXN0QmxvY2tIZWlnaHQpID9cbiAgICAgICAgdXR4b0NvaW4uZ2V0TGF0ZXN0QmxvY2tIZWlnaHQocGFyYW1zLnJlcUlkKSA6XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgY29uc3QgcXVlcmllcyA9IFtidWlsZFF1ZXJ5LCBibG9ja0hlaWdodFF1ZXJ5XTtcbiAgICAgIGNvbnN0IFtidWlsZFJlc3BvbnNlLCBibG9ja0hlaWdodF0gPSB5aWVsZCBQcm9taXNlLmFsbChxdWVyaWVzKTtcbiAgICAgIGRlYnVnKCdwb3N0cHJvY2Vzc2luZyB0cmFuc2FjdGlvbiBwcmVidWlsZDogJU8nLCBidWlsZFJlc3BvbnNlKTtcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChibG9ja0hlaWdodCkpIHtcbiAgICAgICAgYnVpbGRSZXNwb25zZS5ibG9ja0hlaWdodCA9IGJsb2NrSGVpZ2h0O1xuICAgICAgfVxuICAgICAgbGV0IHByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkID0geWllbGQgc2VsZi5iYXNlQ29pbi5wb3N0UHJvY2Vzc1ByZWJ1aWxkKFxuICAgICAgICBPYmplY3QuYXNzaWduKGJ1aWxkUmVzcG9uc2UsIHsgd2FsbGV0OiBzZWxmLCBidWlsZFBhcmFtczogd2hpdGVsaXN0ZWRQYXJhbXMgfSlcbiAgICAgICk7XG4gICAgICBkZWxldGUgcHJlYnVpbGQud2FsbGV0O1xuICAgICAgZGVsZXRlIHByZWJ1aWxkLmJ1aWxkUGFyYW1zO1xuICAgICAgcHJlYnVpbGQgPSBfLmV4dGVuZCh7fSwgcHJlYnVpbGQsIHsgd2FsbGV0SWQ6IHNlbGYuaWQoKSB9KTtcbiAgICAgIGRlYnVnKCdmaW5hbCB0cmFuc2FjdGlvbiBwcmVidWlsZDogJU8nLCBwcmVidWlsZCk7XG4gICAgICByZXR1cm4gcHJlYnVpbGQgYXMgUHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdDtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIFtrZXljaGFpbiAvIGtleV0gKG9iamVjdCkgb3IgcHJ2IChzdHJpbmcpXG4gICAqIC0gd2FsbGV0UGFzc3BocmFzZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFdhbGxldFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxTaWduZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288U2lnbmVkVHJhbnNhY3Rpb24+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCB0eFByZWJ1aWxkID0gcGFyYW1zLnR4UHJlYnVpbGQ7XG4gICAgICBpZiAoIXR4UHJlYnVpbGQgfHwgdHlwZW9mIHR4UHJlYnVpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJlc2lnbiA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ucHJlc2lnblRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gICAgICBjb25zdCB1c2VyUHJ2ID0gc2VsZi5nZXRVc2VyUHJ2KHByZXNpZ24pO1xuICAgICAgY29uc3Qgc2lnbmluZ1BhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwcmVzaWduLCB7IHR4UHJlYnVpbGQ6IHR4UHJlYnVpbGQsIHBydjogdXNlclBydiB9KTtcbiAgICAgIHJldHVybiBzZWxmLmJhc2VDb2luLnNpZ25UcmFuc2FjdGlvbihzaWduaW5nUGFyYW1zKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlciBwcml2YXRlIGtleSBmcm9tIGVpdGhlciBhIGRlcml2YXRpb24gb3IgYW4gZW5jcnlwdGVkIGtleWNoYWluXG4gICAqIEBwYXJhbSBbcGFyYW1zLmtleWNoYWluIC8gcGFyYW1zLmtleV0gKG9iamVjdCkgb3IgcGFyYW1zLnBydiAoc3RyaW5nKVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgKHN0cmluZylcbiAgICovXG4gIGdldFVzZXJQcnYocGFyYW1zOiBHZXRVc2VyUHJ2T3B0aW9ucyA9IHt9KTogc3RyaW5nIHtcbiAgICBjb25zdCB1c2VyS2V5Y2hhaW4gPSBwYXJhbXMua2V5Y2hhaW4gfHwgcGFyYW1zLmtleTtcbiAgICBsZXQgdXNlclBydiA9IHBhcmFtcy5wcnY7XG4gICAgaWYgKHVzZXJQcnYgJiYgdHlwZW9mIHVzZXJQcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BydiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICh1c2VyUHJ2ICYmIHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQpIHtcbiAgICAgIC8vIHRoZSBkZXJpdmF0aW9uIG9ubHkgbWFrZXMgc2Vuc2Ugd2hlbiBhIGtleSBhbHJlYWR5IGV4aXN0c1xuICAgICAgY29uc3QgZGVyaXZhdGlvbiA9IHRoaXMuYmFzZUNvaW4uZGVyaXZlS2V5V2l0aFNlZWQoeyBrZXk6IHVzZXJQcnYsIHNlZWQ6IHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQgfSk7XG4gICAgICB1c2VyUHJ2ID0gZGVyaXZhdGlvbi5rZXk7XG4gICAgfSBlbHNlIGlmICghdXNlclBydikge1xuICAgICAgaWYgKCF1c2VyS2V5Y2hhaW4gfHwgdHlwZW9mIHVzZXJLZXljaGFpbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXljaGFpbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXNlckVuY3J5cHRlZFBydiA9IHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRQcnY7XG4gICAgICBpZiAoIXVzZXJFbmNyeXB0ZWRQcnYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXljaGFpbiBkb2VzIG5vdCBoYXZlIHByb3BlcnR5IGVuY3J5cHRlZFBydicpO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhbGxldFBhc3NwaHJhc2UgcHJvcGVydHkgbWlzc2luZycpO1xuICAgICAgfVxuXG4gICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHsgaW5wdXQ6IHVzZXJFbmNyeXB0ZWRQcnYsIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZXJQcnY7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgZnJvbSBCaXRHbywgdmFsaWRhdGUgaXQsIGFuZCB0aGVuIGRlY3J5cHQgdGhlIHVzZXIga2V5IGFuZCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBQcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8U2lnbmVkVHJhbnNhY3Rpb24+KTogQmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288U2lnbmVkVHJhbnNhY3Rpb24+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAocGFyYW1zLnByZWJ1aWxkVHggJiYgcGFyYW1zLnJlY2lwaWVudHMpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignT25seSBvbmUgb2YgcHJlYnVpbGRUeCBhbmQgcmVjaXBpZW50cyBtYXkgYmUgc3BlY2lmaWVkJyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnYm90aF9wcmVidWlsZHR4X2FuZF9yZWNpcGllbnRzX3NwZWNpZmllZCc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnJlY2lwaWVudHMgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zLnJlY2lwaWVudHMpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ2V4cGVjdGluZyByZWNpcGllbnRzIGFycmF5Jyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAncmVjaXBpZW50c19ub3RfYXJyYXknO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNBcnJheShzZWxmLl9wZXJtaXNzaW9ucykgJiYgIXNlbGYuX3Blcm1pc3Npb25zLmluY2x1ZGVzKCdzcGVuZCcpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ25vIHNwZW5kIHBlcm1pc3Npb24gb24gdGhpcyB3YWxsZXQnKTtcbiAgICAgICAgZXJyb3IuY29kZSA9ICd1c2VyX25vdF9hbGxvd2VkX3RvX3NwZW5kX2Zyb21fd2FsbGV0JztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGwgcHJlYnVpbGRUcmFuc2FjdGlvbiBhbmQga2V5Y2hhaW5zLWdldCBpbiBwYXJhbGxlbFxuICAgICAgLy8gdGhlIHByZWJ1aWxkIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBhbiBleHBsaWNpdCB0eFxuICAgICAgY29uc3QgdHhQcmVidWlsZFF1ZXJ5ID0gcGFyYW1zLnByZWJ1aWxkVHggPyBQcm9taXNlLnJlc29sdmUocGFyYW1zLnByZWJ1aWxkVHgpIDogc2VsZi5wcmVidWlsZFRyYW5zYWN0aW9uKHBhcmFtcyk7XG5cbiAgICAgIC8vIHJldHJpZXZlIG91ciBrZXljaGFpbnMgbmVlZGVkIHRvIHJ1biB0aGUgcHJlYnVpbGQgLSBzb21lIGNvaW5zIHVzZSBhbGwgcHVic1xuICAgICAgY29uc3Qga2V5Y2hhaW5zID0geWllbGQgc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXRLZXlzRm9yU2lnbmluZyh7IHdhbGxldDogc2VsZiwgcmVxSWQ6IHBhcmFtcy5yZXFJZCB9KTtcblxuICAgICAgY29uc3QgdHhQcmVidWlsZCA9IHlpZWxkIHR4UHJlYnVpbGRRdWVyeTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmVyaWZpY2F0aW9uUGFyYW1zID0gXy5waWNrKHBhcmFtcy52ZXJpZmljYXRpb24gfHwge30sIFsnZGlzYWJsZU5ldHdvcmtpbmcnLCAna2V5Y2hhaW5zJywgJ2FkZHJlc3NlcyddKTtcbiAgICAgICAgeWllbGQgc2VsZi5iYXNlQ29pbi52ZXJpZnlUcmFuc2FjdGlvbih7XG4gICAgICAgICAgdHhQYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICB0eFByZWJ1aWxkLFxuICAgICAgICAgIHdhbGxldDogc2VsZixcbiAgICAgICAgICB2ZXJpZmljYXRpb246IHZlcmlmaWNhdGlvblBhcmFtcyxcbiAgICAgICAgICByZXFJZDogcGFyYW1zLnJlcUlkLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ1RyYW5zYWN0aW9uIHByZWJ1aWxkIGZhaWx1cmU6JywgZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGZhaWxlZCBsb2NhbCB2YWxpZGF0aW9uOicpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXNzIG91ciB0aHJlZSBrZXlzXG4gICAgICBjb25zdCBzaWduaW5nUGFyYW1zID0gXy5leHRlbmQoe30sIHBhcmFtcywge1xuICAgICAgICB0eFByZWJ1aWxkOiB0eFByZWJ1aWxkLFxuICAgICAgICB3YWxsZXQ6IHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSB2ZXJzaW9uIG9mIHRoZSBtdWx0aXNpZyBhZGRyZXNzIGF0IHdhbGxldCBjcmVhdGlvbiB0aW1lXG4gICAgICAgICAgYWRkcmVzc1ZlcnNpb246IHNlbGYuX3dhbGxldC5jb2luU3BlY2lmaWMuYWRkcmVzc1ZlcnNpb25cbiAgICAgICAgfSxcbiAgICAgICAga2V5Y2hhaW46IGtleWNoYWluc1swXSxcbiAgICAgICAgYmFja3VwS2V5Y2hhaW46IChrZXljaGFpbnMubGVuZ3RoID4gMSkgPyBrZXljaGFpbnNbMV0gOiBudWxsLFxuICAgICAgICBiaXRnb0tleWNoYWluOiAoa2V5Y2hhaW5zLmxlbmd0aCA+IDIpID8ga2V5Y2hhaW5zWzJdIDogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4geWllbGQgc2VsZi5zaWduVHJhbnNhY3Rpb24oc2lnbmluZ1BhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcbiAgICAgICAgICBlcnJvci5jb2RlID0gJ2luc3VmZmljaWVudF9mdW5kcyc7XG4gICAgICAgICAgZXJyb3Iud2FsbGV0QmFsYW5jZXMgPSB7XG4gICAgICAgICAgICBiYWxhbmNlU3RyaW5nOiBzZWxmLmJhbGFuY2VTdHJpbmcoKSxcbiAgICAgICAgICAgIGNvbmZpcm1lZEJhbGFuY2VTdHJpbmc6IHNlbGYuY29uZmlybWVkQmFsYW5jZVN0cmluZygpLFxuICAgICAgICAgICAgc3BlbmRhYmxlQmFsYW5jZVN0cmluZzogc2VsZi5zcGVuZGFibGVCYWxhbmNlU3RyaW5nKCksXG4gICAgICAgICAgICBiYWxhbmNlOiBzZWxmLmJhbGFuY2UoKSxcbiAgICAgICAgICAgIGNvbmZpcm1lZEJhbGFuY2U6IHNlbGYuY29uZmlybWVkQmFsYW5jZSgpLFxuICAgICAgICAgICAgc3BlbmRhYmxlQmFsYW5jZTogc2VsZi5zcGVuZGFibGVCYWxhbmNlKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVycm9yLnR4UGFyYW1zID0gXy5vbWl0KHBhcmFtcywgWydrZXljaGFpbicsICdwcnYnLCAncGFzc3BocmFzZScsICd3YWxsZXRQYXNzcGhyYXNlJywgJ2tleSddKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VsZXJhdGUgYSB0cmFuc2FjdGlvbidzIGNvbmZpcm1hdGlvbiB1c2luZyBDaGlsZC1QYXlzLUZvci1QYXJlbnQgKENQRlApXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBhY2NlbGVyYXRlVHJhbnNhY3Rpb24ocGFyYW1zOiBBY2NlbGVyYXRlVHJhbnNhY3Rpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIC8vIFRPRE8oQkctOTM0OSk6IGNoYW5nZSB0aGUgbGFzdCBjaGVjayB0byA+IDAgYW5kIHRoZSBlcnJvciBtZXNzYWdlIG9uY2UgcGxhdGZvcm0gYWxsb3dzIG11bHRpcGxlIHRyYW5zYWN0aW9ucyB0b1xuICAgICAgLy8gICAgICAgICAgICAgICAgYmUgYnVtcGVkIGluIHRoZSBzYW1lIENQRlAgdHJhbnNhY3Rpb25cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5jcGZwVHhJZHMpIHx8ICFBcnJheS5pc0FycmF5KHBhcmFtcy5jcGZwVHhJZHMpIHx8IHBhcmFtcy5jcGZwVHhJZHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ2V4cGVjdGluZyBjcGZwVHhJZHMgdG8gYmUgYW4gYXJyYXkgb2YgbGVuZ3RoIDEnKTtcbiAgICAgICAgZXJyb3IuY29kZSA9ICdjcGZwdHhpZHNfbm90X2FycmF5JztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5jcGZwRmVlUmF0ZSkpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5ub0NwZnBGZWVSYXRlICE9PSB0cnVlKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignY3BmcEZlZVJhdGUgbXVzdCBiZSBzZXQgdW5sZXNzIG5vQ3BmcEZlZVJhdGUgaXMgc2V0Jyk7XG4gICAgICAgICAgZXJyb3IuY29kZSA9ICdjcGZwZmVlcmF0ZV9ub3Rfc2V0JztcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMuY3BmcEZlZVJhdGUpIHx8IHBhcmFtcy5jcGZwRmVlUmF0ZSA8IDApIHtcbiAgICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdjcGZwRmVlUmF0ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKTtcbiAgICAgICAgICBlcnJvci5jb2RlID0gJ2NwZnBmZWVyYXRlX25vdF9ub25uZWdhdGl2ZV9pbnRlZ2VyJztcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMubWF4RmVlKSkge1xuICAgICAgICBpZiAocGFyYW1zLm5vTWF4RmVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignbWF4RmVlIG11c3QgYmUgc2V0IHVubGVzcyBub01heEZlZSBpcyBzZXQnKTtcbiAgICAgICAgICBlcnJvci5jb2RlID0gJ21heGZlZV9ub3Rfc2V0JztcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMubWF4RmVlKSB8fCBwYXJhbXMubWF4RmVlIDwgMCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ21heEZlZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKTtcbiAgICAgICAgICBlcnJvci5jb2RlID0gJ21heGZlZV9ub3Rfbm9ubmVnYXRpdmVfaW50ZWdlcic7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5yZWNpcGllbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy5yZWNpcGllbnRzKSB8fCBwYXJhbXMucmVjaXBpZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yICdyZWNpcGllbnRzJzogbXVzdCBiZSBlbXB0eSBhcnJheSB3aGVuIHNldGApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhcmFtcy5yZWNpcGllbnRzID0gW107XG5cbiAgICAgIC8vIFdlIG11c3QgcGFzcyB0aGUgYnVpbGQgcGFyYW1zIHRocm91Z2ggdG8gc3VibWl0IGluIGNhc2UgdGhlIENQRlAgdHggZXZlciBoYXMgdG8gYmUgcmVidWlsdC5cbiAgICAgIGNvbnN0IHN1Ym1pdFBhcmFtcyA9IE9iamVjdC5hc3NpZ24ocGFyYW1zLCB5aWVsZCBzZWxmLnByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtcykpO1xuICAgICAgZGVsZXRlIHN1Ym1pdFBhcmFtcy53YWxsZXQ7XG4gICAgICByZXR1cm4geWllbGQgc2VsZi5zdWJtaXRUcmFuc2FjdGlvbihzdWJtaXRQYXJhbXMpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0IGEgaGFsZi1zaWduZWQgdHJhbnNhY3Rpb24gdG8gQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHR4SGV4OiB0cmFuc2FjdGlvbiBoZXggdG8gc3VibWl0XG4gICAqIC0gaGFsZlNpZ25lZDogb2JqZWN0IGNvbnRhaW5pbmcgdHJhbnNhY3Rpb24gKHR4SGV4IG9yIHR4QmFzZTY0KSB0byBzdWJtaXRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBzdWJtaXRUcmFuc2FjdGlvbihwYXJhbXM6IFN1Ym1pdFRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnb3RwJywgJ3R4SGV4J10sIGNhbGxiYWNrKTtcbiAgICBjb25zdCBoYXNUeEhleCA9ICEhcGFyYW1zLnR4SGV4O1xuICAgIGNvbnN0IGhhc0hhbGZTaWduZWQgPSAhIXBhcmFtcy5oYWxmU2lnbmVkO1xuXG4gICAgaWYgKChoYXNUeEhleCAmJiBoYXNIYWxmU2lnbmVkKSB8fCAoIWhhc1R4SGV4ICYmICFoYXNIYWxmU2lnbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHN1cHBseSBlaXRoZXIgdHhIZXggb3IgaGFsZlNpZ25lZCwgYnV0IG5vdCBib3RoJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMuaWQoKSArICcvdHgvc2VuZCcpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBjb2lucyB0byBhIHJlY2lwaWVudFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyAtIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzXG4gICAqIEBwYXJhbSBwYXJhbXMuYW1vdW50IC0gdGhlIGFtb3VudCBpbiBzYXRvc2hpcy93ZWkvYmFzZSB2YWx1ZSB0byBiZSBzZW50XG4gICAqIEBwYXJhbSBwYXJhbXMubWVzc2FnZSAtIG9wdGlvbmFsIG1lc3NhZ2UgdG8gYXR0YWNoIHRvIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YSAtIFtFdGhlcmV1bSBTcGVjaWZpY10gb3B0aW9uYWwgZGF0YSB0byBwYXNzIHRvIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHRoZSBwYXNzcGhyYXNlIHRvIGJlIHVzZWQgdG8gZGVjcnlwdCB0aGUgdXNlciBrZXkgb24gdGhpcyB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtcy5wcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0sIGlmIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gdGhlIG1pbmltdW0gY29uZmlybWF0aW9uIHRocmVzaG9sZCBmb3IgaW5wdXRzXG4gICAqIEBwYXJhbSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gd2hldGhlciB0byBlbmZvcmNlIG1pbkNvbmZpcm1zIGZvciBjaGFuZ2UgaW5wdXRzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHNlbmQocGFyYW1zOiBTZW5kT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFsnbWVzc2FnZScsICdkYXRhJ10sIGNhbGxiYWNrKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5hbW91bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGFtb3VudCcpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhbW91bnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb2luID0gdGhpcy5iYXNlQ29pbjtcblxuICAgIGNvbnN0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocGFyYW1zLmFtb3VudCk7XG4gICAgaWYgKGFtb3VudC5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgYW1vdW50IC0gcG9zaXRpdmUgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvIG9yIG51bWVyaWMgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFjb2luLnZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpICYmIGFtb3VudC5pc1plcm8oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBhbW91bnQgLSBwb3NpdGl2ZSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8gb3IgbnVtZXJpYyBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWNpcGllbnRzOiBTZW5kTWFueU9wdGlvbnNbJ3JlY2lwaWVudHMnXSA9IFt7XG4gICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgIGFtb3VudDogcGFyYW1zLmFtb3VudCxcbiAgICB9XTtcblxuICAgIGlmIChwYXJhbXMuZGF0YSAmJiBjb2luLnRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKSkge1xuICAgICAgcmVjaXBpZW50c1swXS5kYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VuZE1hbnlPcHRpb25zOiBTZW5kTWFueU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHsgcmVjaXBpZW50cyB9KTtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWFueShzZW5kTWFueU9wdGlvbnMpLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgbW9uZXkgdG8gbXVsdGlwbGUgcmVjaXBpZW50c1xuICAgKiAxLiBHZXRzIHRoZSB1c2VyIGtleWNoYWluIGJ5IGNoZWNraW5nIHRoZSB3YWxsZXQgZm9yIGEga2V5IHdoaWNoIGhhcyBhbiBlbmNyeXB0ZWQgcHJ2XG4gICAqIDIuIERlY3J5cHRzIHVzZXIga2V5XG4gICAqIDMuIENyZWF0ZXMgdGhlIHRyYW5zYWN0aW9uIHdpdGggZGVmYXVsdCBmZWVcbiAgICogNC4gU2lnbnMgdHJhbnNhY3Rpb24gd2l0aCBkZWNyeXB0ZWQgdXNlciBrZXlcbiAgICogNS4gU2VuZHMgdGhlIHRyYW5zYWN0aW9uIHRvIEJpdEdvXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHt7YWRkcmVzczogc3RyaW5nLCBhbW91bnQ6IHN0cmluZ319IHBhcmFtcy5yZWNpcGllbnRzIC0gbGlzdCBvZiByZWNpcGllbnRzIGFuZCBuZWNlc3NhcnkgcmVjaXBpZW50IGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubnVtQmxvY2tzIC0gRXN0aW1hdGVzIHRoZSBhcHByb3hpbWF0ZSBmZWUgcGVyIGtpbG9ieXRlIG5lY2Vzc2FyeSBmb3IgYSB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gd2l0aGluIG51bUJsb2NrcyBibG9ja3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVSYXRlIC0gdGhlIGRlc2lyZWQgZmVlUmF0ZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGluIHNhdG90aGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUmF0ZSAtIHVwcGVyIGxpbWl0IGZvciBmZWVSYXRlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluQ29uZmlybXMgLSBhbGwgc2VsZWN0ZWQgdW5zcGVudHMgd2lsbCBoYXZlIGF0IGxlYXN0IHRoaXMgbWFueSBjb25maXJtYXRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAtIEVuZm9yY2VzIG1pbkNvbmZpcm1zIG9uIGNoYW5nZSBpbnB1dHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cyAtIFRoZSBkZXNpcmVkIGNvdW50IG9mIHVuc3BlbnRzIGluIHRoZSB3YWxsZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5tZXNzYWdlIC0gb3B0aW9uYWwgbWVzc2FnZSB0byBhdHRhY2ggdG8gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIElnbm9yZSB1bnNwZW50cyBzbWFsbGVyIHRoYW4gdGhpcyBhbW91bnQgb2Ygc2F0b3NoaXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhWYWx1ZSAtIElnbm9yZSB1bnNwZW50cyBsYXJnZXIgdGhhbiB0aGlzIGFtb3VudCBvZiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnNlcXVlbmNlSWQgLSBUaGUgc2VxdWVuY2UgSUQgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGFzdExlZGdlclNlcXVlbmNlIC0gQWJzb2x1dGUgbWF4IGxlZGdlciB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFjY2VwdGVkIGluLCB3aGVyZWFmdGVyIGl0IHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubGVkZ2VyU2VxdWVuY2VEZWx0YSAtIFJlbGF0aXZlIGxlZGdlciBoZWlnaHQgKGluIHJlbGF0aW9uIHRvIHRoZSBjdXJyZW50IGxlZGdlcikgdGhhdCB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFjY2VwdGVkIGluLCB3aGVyZWFmdGVyIGl0IHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZ2FzUHJpY2UgLSBDdXN0b20gZ2FzIHByaWNlIHRvIGJlIHVzZWQgZm9yIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLm5vU3BsaXRDaGFuZ2UgLSBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBjaGFuZ2Ugc3BsaXR0aW5nIGZvciBwdXJwb3NlcyBvZiB1bnNwZW50IG1hbmFnZW1lbnRcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zLnVuc3BlbnRzIC0gVGhlIHVuc3BlbnRzIHRvIHVzZSBpbiB0aGUgdHJhbnNhY3Rpb24uIEVhY2ggdW5zcGVudCBzaG91bGQgYmUgaW4gdGhlIGZvcm0gcHJldlR4SWQ6bk91dHB1dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNvbW1lbnQgLSBBbnkgYWRkaXRpb25hbCBjb21tZW50IHRvIGF0dGFjaCB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5vdHAgLSBUd28gZmFjdG9yIGF1dGggY29kZSB0byBlbmFibGUgc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5jaGFuZ2VBZGRyZXNzIC0gU3BlY2lmaWVzIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgY2hhbmdlIG91dHB1dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5pbnN0YW50IC0gU2VuZCB0aGlzIHRyYW5zYWN0aW9uIHVzaW5nIGNvaW4tc3BlY2lmaWMgaW5zdGFudCBzZW5kaW5nIG1ldGhvZCAoaWYgYXZhaWxhYmxlKVxuICAgKiBAcGFyYW0ge3t2YWx1ZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9fSBwYXJhbXMubWVtbyAtIE1lbW8gdG8gdXNlIGluIHRyYW5zYWN0aW9uIChzdXBwb3J0ZWQgYnkgU3RlbGxhcilcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy50eXBlIC0gVHlwZSBvZiB0aGUgdHJhbnNhY3Rpb24gKGUuZy4gdHJ1c3RsaW5lKVxuICAgKiBAcGFyYW0ge3t0b2tlbjogcGFyYW1zLCBhY3Rpb246IFN0cmluZywgbGltaXQ6IFN0cmluZ31bXX0gb3B0aW9ucy50cnVzdGxpbmVzIC0gQXJyYXkgb2YgdHJ1c3RsaW5lcyB0byBtYW5hZ2UgKHN1cHBvcnRlZCBieSBTdGVsbGFyKVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzZW5kTWFueShwYXJhbXM6IFNlbmRNYW55T3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydjb21tZW50JywgJ290cCddLCBjYWxsYmFjayk7XG4gICAgICBkZWJ1Zygnc2VuZE1hbnkgY2FsbGVkJyk7XG4gICAgICBjb25zdCByZXFJZCA9IHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgICAgcGFyYW1zLnJlcUlkID0gcmVxSWQ7XG4gICAgICBjb25zdCBjb2luID0gc2VsZi5iYXNlQ29pbjtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgICAgICBwYXJhbXMucmVjaXBpZW50cy5tYXAoZnVuY3Rpb24ocmVjaXBpZW50KSB7XG4gICAgICAgICAgY29uc3QgYW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnQuYW1vdW50KTtcbiAgICAgICAgICBpZiAoYW1vdW50LmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBhbW91bnQgLSBwb3NpdGl2ZSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8gb3IgbnVtZXJpYyBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb2luLnZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpICYmIGFtb3VudC5pc1plcm8oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBhbW91bnQgLSBwb3NpdGl2ZSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8gb3IgbnVtZXJpYyBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoYWxmU2lnbmVkVHJhbnNhY3Rpb24gPSB5aWVsZCBzZWxmLnByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gICAgICBjb25zdCBzZWxlY3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbXG4gICAgICAgICdyZWNpcGllbnRzJywgJ251bUJsb2NrcycsICdmZWVSYXRlJywgJ21heEZlZVJhdGUnLCAnbWluQ29uZmlybXMnLFxuICAgICAgICAnZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlJywgJ3RhcmdldFdhbGxldFVuc3BlbnRzJyxcbiAgICAgICAgJ21lc3NhZ2UnLCAnbWluVmFsdWUnLCAnbWF4VmFsdWUnLCAnc2VxdWVuY2VJZCcsXG4gICAgICAgICdsYXN0TGVkZ2VyU2VxdWVuY2UnLCAnbGVkZ2VyU2VxdWVuY2VEZWx0YScsICdnYXNQcmljZScsXG4gICAgICAgICdub1NwbGl0Q2hhbmdlJywgJ3Vuc3BlbnRzJywgJ2NvbW1lbnQnLCAnb3RwJywgJ2NoYW5nZUFkZHJlc3MnLFxuICAgICAgICAnaW5zdGFudCcsICdtZW1vJywgJ3R5cGUnLCAndHJ1c3RsaW5lcycsXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IGZpbmFsVHhQYXJhbXMgPSBfLmV4dGVuZCh7fSwgaGFsZlNpZ25lZFRyYW5zYWN0aW9uLCBzZWxlY3RQYXJhbXMpO1xuICAgICAgc2VsZi5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLnBvc3Qoc2VsZi51cmwoJy90eC9zZW5kJykpXG4gICAgICAgIC5zZW5kKGZpbmFsVHhQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY292ZXIgYW4gdW5zdXBwb3J0ZWQgdG9rZW4gZnJvbSBhIEJpdEdvIG11bHRpc2lnIHdhbGxldFxuICAgKiBwYXJhbXMgYXJlIHZhbGlkYXRlZCBpbiBFdGgucHJvdG90eXBlLnJlY292ZXJUb2tlblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MgdGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHVuc3VwcG9ydGVkIHRva2VuXG4gICAqIEBwYXJhbSBwYXJhbXMucmVjaXBpZW50IHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzIHJlY292ZXJlZCB0b2tlbnMgc2hvdWxkIGJlIHNlbnQgdG9cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB0aGUgeHBydlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY292ZXJUb2tlbihwYXJhbXM6IFJlY292ZXJUb2tlbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKHNlbGYuYmFzZUNvaW4uZ2V0RmFtaWx5KCkgIT09ICdldGgnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW4gcmVjb3Zlcnkgb25seSBzdXBwb3J0ZWQgZm9yIGV0aCB3YWxsZXRzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9rZW5Db250cmFjdEFkZHJlc3MsXG4gICAgICAgIHJlY2lwaWVudCxcbiAgICAgIH0gPSBwYXJhbXM7XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHRva2VuQ29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciB0b2tlbkNvbnRyYWN0QWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChyZWNpcGllbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIHJlY2lwaWVudCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWNvdmVyVG9rZW5PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHRva2VuQ29udHJhY3RBZGRyZXNzLCByZWNpcGllbnQgfSwgcGFyYW1zLCB7IHdhbGxldDogc2VsZiB9KTtcbiAgICAgIHJldHVybiAoc2VsZi5iYXNlQ29pbiBhcyBFdGgpLnJlY292ZXJUb2tlbihyZWNvdmVyVG9rZW5PcHRpb25zKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2FjdGlvbiBtZXRhZGF0YSBmb3IgdGhlIG9sZGVzdCB0cmFuc2FjdGlvbiB0aGF0IGlzIHN0aWxsIHBlbmRpbmcgb3IgYXR0ZW1wdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIHR4aWQsIHdhbGxldElkLCB0eCwgYW5kIGZlZSAoaWYgc3VwcG9ydGVkIGZvciBjb2luKVxuICAgKi9cbiAgZ2V0Rmlyc3RQZW5kaW5nVHJhbnNhY3Rpb24ocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIGludGVybmFsLmdldEZpcnN0UGVuZGluZ1RyYW5zYWN0aW9uKHsgd2FsbGV0SWQ6IHRoaXMuaWQoKSB9LCB0aGlzLmJhc2VDb2luLCB0aGlzLmJpdGdvKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGZlZSBvbiB0aGUgcGVuZGluZyB0cmFuc2FjdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiB0eGlkIHRvIHRoZSBnaXZlbiBuZXcgZmVlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy50eGlkIFRoZSB0cmFuc2FjdGlvbiBJZCBjb3JyZXNwb25kaW5nIHRvIHRoZSB0cmFuc2FjdGlvbiB3aG9zZSBmZWUgaXMgdG8gYmUgY2hhbmdlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmZlZSBUaGUgbmV3IGZlZSB0byBhcHBseSB0byB0aGUgZGVub3RlZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRyYW5zYWN0aW9uIElEIG9mIHRoZSBuZXcgdHJhbnNhY3Rpb24gdGhhdCBjb250YWlucyB0aGUgbmV3IGZlZSByYXRlXG4gICAqL1xuICBjaGFuZ2VGZWUocGFyYW1zOiBDaGFuZ2VGZWVPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndHhpZCcsICdmZWUnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z28ucG9zdChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgc2VsZi5pZCgpICsgJy90eC9jaGFuZ2VGZWUnKSlcbiAgICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvIGZyb20gbWVyY2hhbnQgc2VydmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHBhcmFtcyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy51cmwgVGhlIFVybCB0byByZXRyaWV2ZSBpbmZvIGZyb21cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpbmZvIHJldHVybmVkIGZyb20gdGhlIG1lcmNoYW50IHNlcnZlclxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0UGF5bWVudEluZm8ocGFyYW1zOiB7IHVybD86IHN0cmluZzsgfSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICpjb0dldFBheW1lbnRJbmZvKCkge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1cmwnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z28uZ2V0KHNlbGYudXJsKCcvcGF5bWVudEluZm8nKSlcbiAgICAgICAgLnF1ZXJ5KHBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBqc29uIHBheW1lbnQgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1zIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnBheW1lbnRVcmwgLSBUaGUgdXJsIHRvIHNlbmQgdGhlIGZ1bGx5IHNpZ25lZCB0cmFuc2FjdGlvbiB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnR4SGV4IC0gVGhlIHRyYW5zYWN0aW9uIGhleCBvZiB0aGUgcGF5bWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1lbW8ge1N0cmluZ30gLSBBIG1lbW8gc3VwcGxpZWQgYnkgdGhlIG1lcmNoYW50LCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSB0cmFuc2ZlciBhcyB0aGUgY29tbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmV4cGlyZXMge1N0cmluZ30gLSBJU08gRGF0ZSBmb3JtYXQgb2Ygd2hlbiB0aGUgcGF5bWVudCByZXF1ZXN0IGV4cGlyZXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpbmZvIHJldHVybmVkIGZyb20gdGhlIG1lcmNoYW50IHNlcnZlciBQYXltZW50IEFja1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc2VuZFBheW1lbnRSZXNwb25zZShwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvc2VuZFBheW1lbnQnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBvbGljeSBydWxlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5jb25kaXRpb24gY29uZGl0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gcGFyYW1zLmFjdGlvbiBhY3Rpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGNyZWF0ZVBvbGljeVJ1bGUocGFyYW1zOiBDcmVhdGVQb2xpY3lSdWxlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lkJywgJ3R5cGUnXSwgWydtZXNzYWdlJ10sIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5jb25kaXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwYXJhbWV0ZXI6IGNvbmRpdGlvbnMgb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMuYWN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcGFyYW1ldGVyOiBhY3Rpb24gb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLnBvc3Qoc2VsZi51cmwoJy9wb2xpY3kvcnVsZScpKVxuICAgICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHBvbGljeSBydWxlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5jb25kaXRpb24gY29uZGl0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gcGFyYW1zLmFjdGlvbiBhY3Rpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHNldFBvbGljeVJ1bGUocGFyYW1zOiBhbnkgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCcsICd0eXBlJ10sIFsnbWVzc2FnZSddLCBjYWxsYmFjayk7XG5cbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMuY29uZGl0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcGFyYW1ldGVyOiBjb25kaXRpb25zIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmFjdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBhcmFtZXRlcjogYWN0aW9uIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5wdXQoc2VsZi51cmwoJy9wb2xpY3kvcnVsZScpKVxuICAgICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBQb2xpY3kgUnVsZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHJlbW92ZVBvbGljeVJ1bGUocGFyYW1zOiBSZW1vdmVQb2xpY3lSdWxlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lkJ10sIFsnbWVzc2FnZSddLCBjYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLmRlbChzZWxmLnVybCgnL3BvbGljeS9ydWxlJykpXG4gICAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoaXMgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcmVtb3ZlKHBhcmFtczoge30gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLnVybCgpKS5yZXN1bHQoKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0cmFkaW5nIGFjY291bnQgZnJvbSB0aGlzIHdhbGxldFxuICAgKi9cbiAgdG9UcmFkaW5nQWNjb3VudCgpOiBUcmFkaW5nQWNjb3VudCB7XG4gICAgaWYgKHRoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCkgIT09ICdvZmMnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IGNvbnZlcnQgYW4gT2ZmY2hhaW4gKE9GQykgd2FsbGV0IHRvIGEgdHJhZGluZyBhY2NvdW50Jyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhZGluZ0FjY291bnQodGhpcy5fd2FsbGV0LmVudGVycHJpc2UsIHRoaXMsIHRoaXMuYml0Z28pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGRvd25sb2FkcyBQREYga2V5Y2FyZCBmb3Igd2FsbGV0IChyZXF1aXJlcyByZXNwb25zZSBmcm9tIHdhbGxldHMuZ2VuZXJhdGVXYWxsZXQpXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgaXMgZXhhbXBsZSBjb2RlIGFuZCBpcyBub3QgdGhlIHZlcnNpb24gdXNlZCBvbiBiaXRnby5jb21cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAgICoganNQREYgLSBhbiBpbnN0YW5jZSBvZiB0aGUganNQREYgbGlicmFyeVxuICAgKiAgICogUVJDb2RlIC0gYW4gaW5zdGFuY2Ugb2YgdGhlIFFSaW91cyBsaWJyYXJ5XG4gICAqICAgKiB1c2VyS2V5Y2hhaW4gLSBhIHdhbGxldCdzIHByaXZhdGUgdXNlciBrZXljaGFpblxuICAgKiAgICogYmFja3VwS2V5Y2hhaW4gLSBhIHdhbGxldCdzIHByaXZhdGUgYmFja3VwIGtleWNoYWluXG4gICAqICAgKiBiaXRnb0tleWNoYWluIC0gYSB3YWxsZXQncyBwcml2YXRlIGJpdGdvIGtleWNoYWluXG4gICAqICAgKiBwYXNzcGhyYXNlIC0gdGhlIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqICAgKiBwYXNzY29kZUVuY3J5cHRpb25Db2RlIC0gdGhlIGVuY3J5cHRpb24gc2VjcmV0IHVzZWQgZm9yIEJveCBEXG4gICAqICAgKiBhY3RpdmF0aW9uQ29kZSAtIGEgcmFuZG9tbHkgZ2VuZXJhdGVkIHNpeC1kaWdpdCBhY3RpdmF0aW9uIGNvZGVcbiAgICogICAqIHdhbGxldEtleUlEIC0gdGhlIEtleSBJRCB1c2VkIGZvciBkZXJpdmluZyBhIGNvbGQgd2FsbGV0J3Mgc2lnbmluZyBrZXlcbiAgICogICAqIGJhY2t1cEtleUlEIC0gdGhlIEtleSBJRCB1c2VkIGZvciBkZXJpdmluZyBhIGNvbGQgd2FsbGV0J3MgYmFja3VwIGtleVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGRvd25sb2FkS2V5Y2FyZChwYXJhbXM6IERvd25sb2FkS2V5Y2FyZE9wdGlvbnMgPSB7fSk6IHZvaWQge1xuICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRvd25sb2FkS2V5Y2FyZCBmdW5jdGlvbiBpcyBvbmx5IGNhbGxhYmxlIHdpdGhpbiBhIGJyb3dzZXIuJyk7XG4gICAgfVxuXG4gICAgLy8gR3JhYiBwYXJhbWV0ZXJzIHdpdGggZGVmYXVsdCBmb3IgYWN0aXZhdGlvbkNvZGVcbiAgICBjb25zdCB7XG4gICAgICBqc1BERixcbiAgICAgIFFSQ29kZSxcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHBhc3NwaHJhc2UsXG4gICAgICBwYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgd2FsbGV0S2V5SUQsXG4gICAgICBiYWNrdXBLZXlJRCxcbiAgICAgIGFjdGl2YXRpb25Db2RlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTAwMDAwICsgMTAwMDAwKS50b1N0cmluZygpLFxuICAgIH0gPSBwYXJhbXM7XG5cbiAgICBpZiAoIWpzUERGIHx8IHR5cGVvZiBqc1BERiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBpbiBhIHZhbGlkIGpzUERGIGluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUga2V5Y2hhaW5zXG4gICAgaWYgKCF1c2VyS2V5Y2hhaW4gfHwgdHlwZW9mIHVzZXJLZXljaGFpbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV2FsbGV0IGtleWNoYWluIG11c3QgaGF2ZSBhICd1c2VyJyBwcm9wZXJ0eWApO1xuICAgIH1cblxuICAgIGlmICghYmFja3VwS2V5Y2hhaW4gfHwgdHlwZW9mIGJhY2t1cEtleWNoYWluICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWNrdXAga2V5Y2hhaW4gaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFiaXRnb0tleWNoYWluIHx8IHR5cGVvZiBiaXRnb0tleWNoYWluICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaXRnbyBrZXljaGFpbiBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAod2FsbGV0S2V5SUQgJiYgdHlwZW9mIHdhbGxldEtleUlEICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YWxsZXRLZXlJRCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKGJhY2t1cEtleUlEICYmIHR5cGVvZiBiYWNrdXBLZXlJRCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFja3VwS2V5SUQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGFjdGl2YXRpb24gY29kZSBpZiBwcm92aWRlZFxuICAgIGlmICh0eXBlb2YgYWN0aXZhdGlvbkNvZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2YXRpb24gQ29kZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2YXRpb25Db2RlLmxlbmd0aCAhPT0gNikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3RpdmF0aW9uIGNvZGUgbXVzdCBiZSBzaXggY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvaW5TaG9ydE5hbWUgPSB0aGlzLmJhc2VDb2luLnR5cGU7XG4gICAgY29uc3QgY29pbk5hbWUgPSB0aGlzLmJhc2VDb2luLmdldEZ1bGxOYW1lKCk7XG4gICAgY29uc3Qgd2FsbGV0TGFiZWwgPSB0aGlzLl93YWxsZXQubGFiZWw7XG5cbiAgICBjb25zdCBkb2MgPSBkcmF3S2V5Y2FyZCh7XG4gICAgICBqc1BERixcbiAgICAgIFFSQ29kZSxcbiAgICAgIGVuY3J5cHQ6IHRoaXMuYml0Z28uZW5jcnlwdCxcbiAgICAgIGNvaW5TaG9ydE5hbWUsXG4gICAgICBjb2luTmFtZSxcbiAgICAgIGFjdGl2YXRpb25Db2RlLFxuICAgICAgd2FsbGV0TGFiZWwsXG4gICAgICBwYXNzcGhyYXNlLFxuICAgICAgcGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHdhbGxldEtleUlELFxuICAgICAgYmFja3VwS2V5SUQsXG4gICAgfSk7XG5cbiAgICAvLyBTYXZlIHRoZSBQREYgb24gdGhlIHVzZXIncyBicm93c2VyXG4gICAgZG9jLnNhdmUoYEJpdEdvIEtleWNhcmQgZm9yICR7d2FsbGV0TGFiZWx9LnBkZmApO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHNldCBvZiBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9ucyBmb3IgYSB3YWxsZXQuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogICAgIGZyb21BZGRyZXNzZXMgLSB0aGVzZSBhcmUgdGhlIG9uLWNoYWluIHJlY2VpdmUgYWRkcmVzc2VzIHdlIHdhbnQgdG8gcGljayBhIGNvbnNvbGlkYXRpb24gYW1vdW50IGZyb21cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBidWlsZEFjY291bnRDb25zb2xpZGF0aW9ucyhwYXJhbXM6IEJ1aWxkQ29uc29saWRhdGlvblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0W10+KTogQmx1ZWJpcmQ8UHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdFtdPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHRbXT4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghc2VsZi5iYXNlQ29pbi5hbGxvd3NBY2NvdW50Q29uc29saWRhdGlvbnMoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2VsZi5iYXNlQ29pbi5nZXRGdWxsTmFtZSgpfSBkb2VzIG5vdCBhbGxvdyBhY2NvdW50IGNvbnNvbGlkYXRpb25zLmApO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGl0ZWxpc3QgcGFyYW1zIHRvIGJ1aWxkIHR4XG4gICAgICBjb25zdCB3aGl0ZWxpc3RlZFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIHNlbGYucHJlYnVpbGRDb25zb2xpZGF0ZVRyYW5zYWN0aW9uUGFyYW1zKCkpO1xuICAgICAgZGVidWcoJ3ByZWJ1aWxkaW5nIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb246ICVPJywgd2hpdGVsaXN0ZWRQYXJhbXMpO1xuXG4gICAgICBpZiAocGFyYW1zLnJlcUlkKSB7XG4gICAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGlzIGNvdWxkIHJldHVybiAxMDAgYnVpbGQgdHJhbnNhY3Rpb25zXG4gICAgICBjb25zdCBidWlsZFJlc3BvbnNlID0geWllbGQgc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLmlkKCkgKyAnL2NvbnNvbGlkYXRlQWNjb3VudC9idWlsZCcpKVxuICAgICAgICAuc2VuZCh3aGl0ZWxpc3RlZFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHN0ZXAgb3ZlciBlYWNoIHByZWJ1aWxkIG5vdyAtIHNob3VsZCBiZSBpbiBhbiBhcnJheSBpbiB0aGUgYm9keVxuICAgICAgY29uc3QgY29uc29saWRhdGlvbnM6VHJhbnNhY3Rpb25QcmVidWlsZFtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGNvbnNvbGlkYXRlQWNjb3VudEJ1aWxkIG9mIGJ1aWxkUmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkID0geWllbGQgc2VsZi5iYXNlQ29pbi5wb3N0UHJvY2Vzc1ByZWJ1aWxkKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29uc29saWRhdGVBY2NvdW50QnVpbGQsIHsgd2FsbGV0OiBzZWxmLCBidWlsZFBhcmFtczogd2hpdGVsaXN0ZWRQYXJhbXMgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBkZWxldGUgcHJlYnVpbGQud2FsbGV0O1xuICAgICAgICBkZWxldGUgcHJlYnVpbGQuYnVpbGRQYXJhbXM7XG5cbiAgICAgICAgcHJlYnVpbGQgPSBfLmV4dGVuZCh7fSwgcHJlYnVpbGQsIHsgd2FsbGV0SWQ6IHNlbGYuaWQoKSB9KTtcbiAgICAgICAgZGVidWcoJ2ZpbmFsIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb24gcHJlYnVpbGQ6ICVPJywgcHJlYnVpbGQpO1xuXG4gICAgICAgIGNvbnNvbGlkYXRpb25zLnB1c2gocHJlYnVpbGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uc29saWRhdGlvbnM7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW5kIHNlbmRzIGEgc2V0IG9mIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zIGZvciBhIHdhbGxldC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAgICAgZnJvbUFkZHJlc3NlcyAtIHRoZXNlIGFyZSB0aGUgb24tY2hhaW4gcmVjZWl2ZSBhZGRyZXNzZXMgd2Ugd2FudCB0byBwaWNrIGEgY29uc29saWRhdGlvbiBhbW91bnQgZnJvbVxuICAgKi9cbiAgc2VuZEFjY291bnRDb25zb2xpZGF0aW9uKHBhcmFtczogUHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288YW55PihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFzZWxmLmJhc2VDb2luLmFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzZWxmLmJhc2VDb2luLmdldEZ1bGxOYW1lKCl9IGRvZXMgbm90IGFsbG93IGFjY291bnQgY29uc29saWRhdGlvbnMuYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9uZSBvZiBhIHNldCBvZiBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uc1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMucHJlYnVpbGRUeCA9PT0gJ3N0cmluZycgfHwgcGFyYW1zLnByZWJ1aWxkVHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnVpbGQgb2YgYWNjb3VudCBjb25zb2xpZGF0aW9uLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmFtcy5wcmVidWlsZFR4LmNvbnNvbGlkYXRlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCBjb25zb2xpZGF0aW9uIGlkIG9uIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpZ25lZFByZWJ1aWxkID0geWllbGQgc2VsZi5wcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXMpO1xuXG4gICAgICAvLyBkZWNvcmF0ZSB3aXRoIG91ciBjb25zb2xpZGF0aW9uIGlkXG4gICAgICBzaWduZWRQcmVidWlsZC5jb25zb2xpZGF0ZUlkID0gcGFyYW1zLnByZWJ1aWxkVHguY29uc29saWRhdGVJZDtcblxuICAgICAgZGVsZXRlIHNpZ25lZFByZWJ1aWxkLndhbGxldDtcblxuICAgICAgcmV0dXJuIHlpZWxkIHNlbGYuc3VibWl0VHJhbnNhY3Rpb24oc2lnbmVkUHJlYnVpbGQpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuZCBzZW5kcyBhIHNldCBvZiBhY2NvdW50IGNvbnNvbGlkYXRpb25zLiBUaGlzIGlzIGludGVuZGVkIHRvIGZsdXNoIG1hbnkgYmFsYW5jZXMgdG8gdGhlIHJvb3Qgd2FsbGV0IGJhbGFuY2UuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBzZW5kQWNjb3VudENvbnNvbGlkYXRpb25zKHBhcmFtczogQnVpbGRDb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288YW55PihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFzZWxmLmJhc2VDb2luLmFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzZWxmLmJhc2VDb2luLmdldEZ1bGxOYW1lKCl9IGRvZXMgbm90IGFsbG93IGFjY291bnQgY29uc29saWRhdGlvbnMuYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgZ2l2ZXMgdXMgYSBzZXQgb2YgYWNjb3VudCBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uc1xuICAgICAgY29uc3QgdW5zaWduZWRCdWlsZHMgPSB5aWVsZCBzZWxmLmJ1aWxkQWNjb3VudENvbnNvbGlkYXRpb25zKHBhcmFtcyk7XG4gICAgICBpZiAodW5zaWduZWRCdWlsZHMgJiYgdW5zaWduZWRCdWlsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzdWNjZXNzZnVsVHhzOiBhbnlbXSA9IFtdO1xuICAgICAgICBjb25zdCBmYWlsZWRUeHMgPSBuZXcgQXJyYXk8RXJyb3I+KCk7XG4gICAgICAgIGZvciAoY29uc3QgdW5zaWduZWRCdWlsZCBvZiB1bnNpZ25lZEJ1aWxkcykge1xuICAgICAgICAgIC8vIGZvbGQgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIHdlIHVzZWQgdG8gYnVpbGQgdGhpcyB0cmFuc2FjdGlvbiBpbnRvIHRoZSB1bnNpZ25lZEJ1aWxkXG4gICAgICAgICAgY29uc3QgdW5zaWduZWRCdWlsZFdpdGhPcHRpb25zOiBQcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgIHVuc2lnbmVkQnVpbGRXaXRoT3B0aW9ucy5wcmVidWlsZFR4ID0gdW5zaWduZWRCdWlsZDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VuZFR4ID0geWllbGQgc2VsZi5zZW5kQWNjb3VudENvbnNvbGlkYXRpb24odW5zaWduZWRCdWlsZFdpdGhPcHRpb25zKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxUeHMucHVzaChzZW5kVHgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGZhaWxlZFR4cy5wdXNoKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2Vzczogc3VjY2Vzc2Z1bFR4cyxcbiAgICAgICAgICBmYWlsdXJlOiBmYWlsZWRUeHMsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19