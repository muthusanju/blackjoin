"use strict";
/**
 * @prettier
 * @hidden
 */
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
var bignumber_js_1 = require("bignumber.js");
var Bluebird = require("bluebird");
var tradingPartners_1 = require("./tradingPartners");
var affirmations_1 = require("./affirmations");
var settlements_1 = require("./settlements");
var co = Bluebird.coroutine;
var TRADE_PAYLOAD_VERSION = '1.1.1';
var TradingAccount = /** @class */ (function () {
    function TradingAccount(enterpriseId, wallet, bitgo) {
        this.enterpriseId = enterpriseId;
        this.wallet = wallet;
        this.bitgo = bitgo;
    }
    Object.defineProperty(TradingAccount.prototype, "id", {
        get: function () {
            return this.wallet.id();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Builds a payload authorizing a trade from this trading account. The currency and amount must be specified, as well as a list
     * of trade counterparties.
     * @param params
     * @param params.currency the currency this account will be sending as part of the trade
     * @param params.amount the amount of currency (in base units, such as cents, satoshis, or wei)
     * @param params.otherParties array of counterparties and reciprocal funds authorized to receive funds as part of this trade
     * @param callback
     * @returns unsigned trade payload for the given parameters. This object should be stringified with JSON.stringify() before being submitted
     */
    TradingAccount.prototype.buildPayload = function (params, callback) {
        return co(function buildTradePayload() {
            var url, body, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.bitgo.microservicesUrl("/api/trade/v1/enterprise/" + this.enterpriseId + "/account/" + this.id + "/payload");
                        body = {
                            version: TRADE_PAYLOAD_VERSION,
                            currency: params.currency,
                            amount: params.amount,
                            otherParties: params.otherParties,
                        };
                        return [4 /*yield*/, this.bitgo
                                .post(url)
                                .send(body)
                                .result()];
                    case 1:
                        response = _a.sent();
                        if (!this.verifyPayload(params, response.payload)) {
                            throw new Error('Unable to verify trade payload. You may need to update the BitGo SDK, or the payload may have been tampered with.');
                        }
                        return [2 /*return*/, JSON.parse(response.payload)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Verifies that a payload received from BitGo sufficiently matches the expected parameters. This is used to prevent
     * man-in-the-middle attacks which could maliciously alter the contents of a payload.
     * @param params parameters used to build the payload
     * @param payload payload received from the BitGo API
     * @returns true if the payload's sensitive fields match, false if the payload may have been tampered with
     */
    TradingAccount.prototype.verifyPayload = function (params, payload) {
        var payloadObj = JSON.parse(payload);
        var paramsCopy = JSON.parse(JSON.stringify(params)); // needs to be a deep copy
        // Verifies that for each party in the payload, we requested a matching party, only checking sensitive fields
        var partiesMatch = true;
        var _loop_1 = function (party) {
            var matchingExpectedParty = paramsCopy.otherParties.findIndex(function (expectedParty) {
                return party.accountId === expectedParty.accountId &&
                    party.currency === expectedParty.currency &&
                    party.amount === expectedParty.amount;
            });
            if (matchingExpectedParty === -1) {
                partiesMatch = false;
                return "break";
            }
            // delete so we ensure no duplicates
            paramsCopy.otherParties.splice(matchingExpectedParty, 1);
        };
        for (var _i = 0, _a = payloadObj.otherParties; _i < _a.length; _i++) {
            var party = _a[_i];
            var state_1 = _loop_1(party);
            if (state_1 === "break")
                break;
        }
        // the amount field will change if fees are present, but subtotal should always equal the requested send amount
        var expectedAmount = params.amount;
        if (payloadObj.fees) {
            var totalFees = payloadObj.fees.reduce(function (fees, feeObj) { return fees.plus(feeObj.feeAmount); }, new bignumber_js_1.BigNumber(0));
            expectedAmount = new bignumber_js_1.BigNumber(payloadObj.subtotal).plus(totalFees).toString();
        }
        return (payloadObj.accountId === this.id &&
            payloadObj.currency === params.currency &&
            payloadObj.subtotal === params.amount &&
            payloadObj.amount === expectedAmount &&
            payloadObj.otherParties.length === params.otherParties.length &&
            partiesMatch);
    };
    /**
     * Calculates the necessary fees to complete a settlement between two parties, based on the amounts and currencies of the settlement.
     * @param params
     * @param params.counterpartyAccountId Account ID of the counterparty of the settlement
     * @param params.sendCurrency Currency to be sent as part of the settlement
     * @param params.sendAmount Amount of currency (in base units such as cents, satoshis, or wei) to be sent
     * @param params.receiveCurrency Currency to be received as part of the settlement
     * @param params.receiveAmount Amount of currency (in base units such as cents, satoshis, or wei) to be received
     * @param callback
     * @returns Fee rate, currency, and total amount of the described settlement
     */
    TradingAccount.prototype.calculateSettlementFees = function (params, callback) {
        var url = this.bitgo.microservicesUrl("/api/trade/v1/enterprise/" + this.enterpriseId + "/account/" + this.id + "/calculatefees");
        return this.bitgo
            .post(url)
            .send(params)
            .result()
            .asCallback(callback);
    };
    /**
     * Signs a pre-built trade payload with the user key on this trading account
     * @param params
     * @param params.payload trade payload object from TradingAccount::buildPayload()
     * @param params.walletPassphrase passphrase on this trading account, used to unlock the account user key
     * @param callback
     * @returns hex-encoded signature of the payload
     */
    TradingAccount.prototype.signPayload = function (params, callback) {
        var self = this;
        return co(function signPayload() {
            var key, prv, payload;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.wallet.baseCoin.keychains().get({ id: self.wallet.keyIds()[0] })];
                    case 1:
                        key = _a.sent();
                        prv = self.wallet.bitgo.decrypt({
                            input: key.encryptedPrv,
                            password: params.walletPassphrase,
                        });
                        payload = JSON.stringify(params.payload);
                        return [2 /*return*/, self.wallet.baseCoin.signMessage({ prv: prv }, payload).toString('hex')];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    TradingAccount.prototype.affirmations = function () {
        return new affirmations_1.Affirmations(this.bitgo, this.enterpriseId, this);
    };
    TradingAccount.prototype.settlements = function () {
        return new settlements_1.Settlements(this.bitgo, this.enterpriseId, this);
    };
    TradingAccount.prototype.partners = function () {
        return new tradingPartners_1.TradingPartners(this.bitgo, this.enterpriseId, this);
    };
    return TradingAccount;
}());
exports.TradingAccount = TradingAccount;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhZGluZ0FjY291bnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvdHJhZGluZy90cmFkaW5nQWNjb3VudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVIO0dBQ0c7QUFDSCw2Q0FBeUM7QUFDekMsbUNBQXFDO0FBTXJDLHFEQUFvRDtBQUNwRCwrQ0FBOEM7QUFDOUMsNkNBQTRDO0FBRTVDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFFOUIsSUFBTSxxQkFBcUIsR0FBRyxPQUFPLENBQUM7QUEyQnRDO0lBTUUsd0JBQVksWUFBb0IsRUFBRSxNQUFjLEVBQUUsS0FBWTtRQUM1RCxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUNqQyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBRUQsc0JBQUksOEJBQUU7YUFBTjtZQUNFLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUMxQixDQUFDOzs7T0FBQTtJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILHFDQUFZLEdBQVosVUFBYSxNQUE4QixFQUFFLFFBQWdDO1FBQzNFLE9BQU8sRUFBRSxDQUFVLFNBQVUsaUJBQWlCOzs7Ozt3QkFDdEMsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQ3JDLDhCQUE0QixJQUFJLENBQUMsWUFBWSxpQkFBWSxJQUFJLENBQUMsRUFBRSxhQUFVLENBQzNFLENBQUM7d0JBRUksSUFBSSxHQUFHOzRCQUNYLE9BQU8sRUFBRSxxQkFBcUI7NEJBQzlCLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUTs0QkFDekIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNOzRCQUNyQixZQUFZLEVBQUUsTUFB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VixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELHFDQUFZLEdBQVo7UUFDRSxPQUFPLElBQUksMkJBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVELG9DQUFXLEdBQVg7UUFDRSxPQUFPLElBQUkseUJBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVELGlDQUFRLEdBQVI7UUFDRSxPQUFPLElBQUksaUNBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0FBQyxBQXRLRCxJQXNLQztBQXRLWSx3Q0FBYyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKi9cbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcblxuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnLi4vd2FsbGV0JztcbmltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuL3BheWxvYWQnO1xuaW1wb3J0IHsgVHJhZGluZ1BhcnRuZXJzIH0gZnJvbSAnLi90cmFkaW5nUGFydG5lcnMnO1xuaW1wb3J0IHsgQWZmaXJtYXRpb25zIH0gZnJvbSAnLi9hZmZpcm1hdGlvbnMnO1xuaW1wb3J0IHsgU2V0dGxlbWVudHMgfSBmcm9tICcuL3NldHRsZW1lbnRzJztcblxuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbmNvbnN0IFRSQURFX1BBWUxPQURfVkVSU0lPTiA9ICcxLjEuMSc7XG5cbmludGVyZmFjZSBCdWlsZFBheWxvYWRQYXJhbWV0ZXJzIHtcbiAgY3VycmVuY3k6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIG90aGVyUGFydGllczogeyBhY2NvdW50SWQ6IHN0cmluZzsgY3VycmVuY3k6IHN0cmluZzsgYW1vdW50OiBzdHJpbmcgfVtdO1xufVxuXG5pbnRlcmZhY2UgU2lnblBheWxvYWRQYXJhbWV0ZXJzIHtcbiAgcGF5bG9hZDogUGF5bG9hZDtcbiAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2V0dGxlbWVudEZlZXMge1xuICBmZWVSYXRlOiBzdHJpbmc7XG4gIGZlZUFtb3VudDogc3RyaW5nO1xuICBmZWVDdXJyZW5jeTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQ2FsY3VsYXRlU2V0dGxlbWVudEZlZXNQYXJhbXMge1xuICBjb3VudGVycGFydHlBY2NvdW50SWQ6IHN0cmluZztcbiAgc2VuZEN1cnJlbmN5OiBzdHJpbmc7XG4gIHNlbmRBbW91bnQ6IHN0cmluZztcbiAgcmVjZWl2ZUN1cnJlbmN5OiBzdHJpbmc7XG4gIHJlY2VpdmVBbW91bnQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFRyYWRpbmdBY2NvdW50IHtcbiAgcHJpdmF0ZSByZWFkb25seSBiaXRnbzogQml0R287XG4gIHByaXZhdGUgcmVhZG9ubHkgZW50ZXJwcmlzZUlkOiBzdHJpbmc7XG5cbiAgcHVibGljIHdhbGxldDogV2FsbGV0O1xuXG4gIGNvbnN0cnVjdG9yKGVudGVycHJpc2VJZDogc3RyaW5nLCB3YWxsZXQ6IFdhbGxldCwgYml0Z286IEJpdEdvKSB7XG4gICAgdGhpcy5lbnRlcnByaXNlSWQgPSBlbnRlcnByaXNlSWQ7XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICB9XG5cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLndhbGxldC5pZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHBheWxvYWQgYXV0aG9yaXppbmcgYSB0cmFkZSBmcm9tIHRoaXMgdHJhZGluZyBhY2NvdW50LiBUaGUgY3VycmVuY3kgYW5kIGFtb3VudCBtdXN0IGJlIHNwZWNpZmllZCwgYXMgd2VsbCBhcyBhIGxpc3RcbiAgICogb2YgdHJhZGUgY291bnRlcnBhcnRpZXMuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5jdXJyZW5jeSB0aGUgY3VycmVuY3kgdGhpcyBhY2NvdW50IHdpbGwgYmUgc2VuZGluZyBhcyBwYXJ0IG9mIHRoZSB0cmFkZVxuICAgKiBAcGFyYW0gcGFyYW1zLmFtb3VudCB0aGUgYW1vdW50IG9mIGN1cnJlbmN5IChpbiBiYXNlIHVuaXRzLCBzdWNoIGFzIGNlbnRzLCBzYXRvc2hpcywgb3Igd2VpKVxuICAgKiBAcGFyYW0gcGFyYW1zLm90aGVyUGFydGllcyBhcnJheSBvZiBjb3VudGVycGFydGllcyBhbmQgcmVjaXByb2NhbCBmdW5kcyBhdXRob3JpemVkIHRvIHJlY2VpdmUgZnVuZHMgYXMgcGFydCBvZiB0aGlzIHRyYWRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB1bnNpZ25lZCB0cmFkZSBwYXlsb2FkIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVycy4gVGhpcyBvYmplY3Qgc2hvdWxkIGJlIHN0cmluZ2lmaWVkIHdpdGggSlNPTi5zdHJpbmdpZnkoKSBiZWZvcmUgYmVpbmcgc3VibWl0dGVkXG4gICAqL1xuICBidWlsZFBheWxvYWQocGFyYW1zOiBCdWlsZFBheWxvYWRQYXJhbWV0ZXJzLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXlsb2FkPik6IEJsdWViaXJkPFBheWxvYWQ+IHtcbiAgICByZXR1cm4gY288UGF5bG9hZD4oZnVuY3Rpb24qIGJ1aWxkVHJhZGVQYXlsb2FkKCkge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy5iaXRnby5taWNyb3NlcnZpY2VzVXJsKFxuICAgICAgICBgL2FwaS90cmFkZS92MS9lbnRlcnByaXNlLyR7dGhpcy5lbnRlcnByaXNlSWR9L2FjY291bnQvJHt0aGlzLmlkfS9wYXlsb2FkYFxuICAgICAgKTtcblxuICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgdmVyc2lvbjogVFJBREVfUEFZTE9BRF9WRVJTSU9OLFxuICAgICAgICBjdXJyZW5jeTogcGFyYW1zLmN1cnJlbmN5LFxuICAgICAgICBhbW91bnQ6IHBhcmFtcy5hbW91bnQsXG4gICAgICAgIG90aGVyUGFydGllczogcGFyYW1zLm90aGVyUGFydGllcyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5iaXRnb1xuICAgICAgICAucG9zdCh1cmwpXG4gICAgICAgIC5zZW5kKGJvZHkpXG4gICAgICAgIC5yZXN1bHQoKTtcblxuICAgICAgaWYgKCF0aGlzLnZlcmlmeVBheWxvYWQocGFyYW1zLCByZXNwb25zZS5wYXlsb2FkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1VuYWJsZSB0byB2ZXJpZnkgdHJhZGUgcGF5bG9hZC4gWW91IG1heSBuZWVkIHRvIHVwZGF0ZSB0aGUgQml0R28gU0RLLCBvciB0aGUgcGF5bG9hZCBtYXkgaGF2ZSBiZWVuIHRhbXBlcmVkIHdpdGguJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS5wYXlsb2FkKSBhcyBQYXlsb2FkO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoYXQgYSBwYXlsb2FkIHJlY2VpdmVkIGZyb20gQml0R28gc3VmZmljaWVudGx5IG1hdGNoZXMgdGhlIGV4cGVjdGVkIHBhcmFtZXRlcnMuIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50XG4gICAqIG1hbi1pbi10aGUtbWlkZGxlIGF0dGFja3Mgd2hpY2ggY291bGQgbWFsaWNpb3VzbHkgYWx0ZXIgdGhlIGNvbnRlbnRzIG9mIGEgcGF5bG9hZC5cbiAgICogQHBhcmFtIHBhcmFtcyBwYXJhbWV0ZXJzIHVzZWQgdG8gYnVpbGQgdGhlIHBheWxvYWRcbiAgICogQHBhcmFtIHBheWxvYWQgcGF5bG9hZCByZWNlaXZlZCBmcm9tIHRoZSBCaXRHbyBBUElcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcGF5bG9hZCdzIHNlbnNpdGl2ZSBmaWVsZHMgbWF0Y2gsIGZhbHNlIGlmIHRoZSBwYXlsb2FkIG1heSBoYXZlIGJlZW4gdGFtcGVyZWQgd2l0aFxuICAgKi9cbiAgdmVyaWZ5UGF5bG9hZChwYXJhbXM6IEJ1aWxkUGF5bG9hZFBhcmFtZXRlcnMsIHBheWxvYWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBheWxvYWRPYmogPSBKU09OLnBhcnNlKHBheWxvYWQpO1xuICAgIGNvbnN0IHBhcmFtc0NvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhcmFtcykpOyAvLyBuZWVkcyB0byBiZSBhIGRlZXAgY29weVxuXG4gICAgLy8gVmVyaWZpZXMgdGhhdCBmb3IgZWFjaCBwYXJ0eSBpbiB0aGUgcGF5bG9hZCwgd2UgcmVxdWVzdGVkIGEgbWF0Y2hpbmcgcGFydHksIG9ubHkgY2hlY2tpbmcgc2Vuc2l0aXZlIGZpZWxkc1xuICAgIGxldCBwYXJ0aWVzTWF0Y2ggPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcGFydHkgb2YgcGF5bG9hZE9iai5vdGhlclBhcnRpZXMpIHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSA9IHBhcmFtc0NvcHkub3RoZXJQYXJ0aWVzLmZpbmRJbmRleChcbiAgICAgICAgZXhwZWN0ZWRQYXJ0eSA9PlxuICAgICAgICAgIHBhcnR5LmFjY291bnRJZCA9PT0gZXhwZWN0ZWRQYXJ0eS5hY2NvdW50SWQgJiZcbiAgICAgICAgICBwYXJ0eS5jdXJyZW5jeSA9PT0gZXhwZWN0ZWRQYXJ0eS5jdXJyZW5jeSAmJlxuICAgICAgICAgIHBhcnR5LmFtb3VudCA9PT0gZXhwZWN0ZWRQYXJ0eS5hbW91bnRcbiAgICAgICk7XG5cbiAgICAgIGlmIChtYXRjaGluZ0V4cGVjdGVkUGFydHkgPT09IC0xKSB7XG4gICAgICAgIHBhcnRpZXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gZGVsZXRlIHNvIHdlIGVuc3VyZSBubyBkdXBsaWNhdGVzXG4gICAgICBwYXJhbXNDb3B5Lm90aGVyUGFydGllcy5zcGxpY2UobWF0Y2hpbmdFeHBlY3RlZFBhcnR5LCAxKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgYW1vdW50IGZpZWxkIHdpbGwgY2hhbmdlIGlmIGZlZXMgYXJlIHByZXNlbnQsIGJ1dCBzdWJ0b3RhbCBzaG91bGQgYWx3YXlzIGVxdWFsIHRoZSByZXF1ZXN0ZWQgc2VuZCBhbW91bnRcbiAgICBsZXQgZXhwZWN0ZWRBbW91bnQ6IHN0cmluZyA9IHBhcmFtcy5hbW91bnQ7XG4gICAgaWYgKHBheWxvYWRPYmouZmVlcykge1xuICAgICAgY29uc3QgdG90YWxGZWVzID0gcGF5bG9hZE9iai5mZWVzLnJlZHVjZShcbiAgICAgICAgKGZlZXM6IEJpZ051bWJlciwgZmVlT2JqKSA9PiBmZWVzLnBsdXMoZmVlT2JqLmZlZUFtb3VudCksXG4gICAgICAgIG5ldyBCaWdOdW1iZXIoMClcbiAgICAgICk7XG4gICAgICBleHBlY3RlZEFtb3VudCA9IG5ldyBCaWdOdW1iZXIocGF5bG9hZE9iai5zdWJ0b3RhbCkucGx1cyh0b3RhbEZlZXMpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHBheWxvYWRPYmouYWNjb3VudElkID09PSB0aGlzLmlkICYmXG4gICAgICBwYXlsb2FkT2JqLmN1cnJlbmN5ID09PSBwYXJhbXMuY3VycmVuY3kgJiZcbiAgICAgIHBheWxvYWRPYmouc3VidG90YWwgPT09IHBhcmFtcy5hbW91bnQgJiZcbiAgICAgIHBheWxvYWRPYmouYW1vdW50ID09PSBleHBlY3RlZEFtb3VudCAmJlxuICAgICAgcGF5bG9hZE9iai5vdGhlclBhcnRpZXMubGVuZ3RoID09PSBwYXJhbXMub3RoZXJQYXJ0aWVzLmxlbmd0aCAmJlxuICAgICAgcGFydGllc01hdGNoXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBuZWNlc3NhcnkgZmVlcyB0byBjb21wbGV0ZSBhIHNldHRsZW1lbnQgYmV0d2VlbiB0d28gcGFydGllcywgYmFzZWQgb24gdGhlIGFtb3VudHMgYW5kIGN1cnJlbmNpZXMgb2YgdGhlIHNldHRsZW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5jb3VudGVycGFydHlBY2NvdW50SWQgQWNjb3VudCBJRCBvZiB0aGUgY291bnRlcnBhcnR5IG9mIHRoZSBzZXR0bGVtZW50XG4gICAqIEBwYXJhbSBwYXJhbXMuc2VuZEN1cnJlbmN5IEN1cnJlbmN5IHRvIGJlIHNlbnQgYXMgcGFydCBvZiB0aGUgc2V0dGxlbWVudFxuICAgKiBAcGFyYW0gcGFyYW1zLnNlbmRBbW91bnQgQW1vdW50IG9mIGN1cnJlbmN5IChpbiBiYXNlIHVuaXRzIHN1Y2ggYXMgY2VudHMsIHNhdG9zaGlzLCBvciB3ZWkpIHRvIGJlIHNlbnRcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNlaXZlQ3VycmVuY3kgQ3VycmVuY3kgdG8gYmUgcmVjZWl2ZWQgYXMgcGFydCBvZiB0aGUgc2V0dGxlbWVudFxuICAgKiBAcGFyYW0gcGFyYW1zLnJlY2VpdmVBbW91bnQgQW1vdW50IG9mIGN1cnJlbmN5IChpbiBiYXNlIHVuaXRzIHN1Y2ggYXMgY2VudHMsIHNhdG9zaGlzLCBvciB3ZWkpIHRvIGJlIHJlY2VpdmVkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyBGZWUgcmF0ZSwgY3VycmVuY3ksIGFuZCB0b3RhbCBhbW91bnQgb2YgdGhlIGRlc2NyaWJlZCBzZXR0bGVtZW50XG4gICAqL1xuICBjYWxjdWxhdGVTZXR0bGVtZW50RmVlcyhcbiAgICBwYXJhbXM6IENhbGN1bGF0ZVNldHRsZW1lbnRGZWVzUGFyYW1zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNldHRsZW1lbnRGZWVzPlxuICApOiBCbHVlYmlyZDxTZXR0bGVtZW50RmVlcz4ge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuYml0Z28ubWljcm9zZXJ2aWNlc1VybChcbiAgICAgIGAvYXBpL3RyYWRlL3YxL2VudGVycHJpc2UvJHt0aGlzLmVudGVycHJpc2VJZH0vYWNjb3VudC8ke3RoaXMuaWR9L2NhbGN1bGF0ZWZlZXNgXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh1cmwpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBhIHByZS1idWlsdCB0cmFkZSBwYXlsb2FkIHdpdGggdGhlIHVzZXIga2V5IG9uIHRoaXMgdHJhZGluZyBhY2NvdW50XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5wYXlsb2FkIHRyYWRlIHBheWxvYWQgb2JqZWN0IGZyb20gVHJhZGluZ0FjY291bnQ6OmJ1aWxkUGF5bG9hZCgpXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSBwYXNzcGhyYXNlIG9uIHRoaXMgdHJhZGluZyBhY2NvdW50LCB1c2VkIHRvIHVubG9jayB0aGUgYWNjb3VudCB1c2VyIGtleVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgaGV4LWVuY29kZWQgc2lnbmF0dXJlIG9mIHRoZSBwYXlsb2FkXG4gICAqL1xuICBzaWduUGF5bG9hZChwYXJhbXM6IFNpZ25QYXlsb2FkUGFyYW1ldGVycywgY2FsbGJhY2s/KTogQmx1ZWJpcmQ8c3RyaW5nPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHN0cmluZz4oZnVuY3Rpb24qIHNpZ25QYXlsb2FkKCkge1xuICAgICAgY29uc3Qga2V5ID0geWllbGQgc2VsZi53YWxsZXQuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHNlbGYud2FsbGV0LmtleUlkcygpWzBdIH0pO1xuICAgICAgY29uc3QgcHJ2ID0gc2VsZi53YWxsZXQuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgIGlucHV0OiBrZXkuZW5jcnlwdGVkUHJ2LFxuICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMucGF5bG9hZCk7XG4gICAgICByZXR1cm4gc2VsZi53YWxsZXQuYmFzZUNvaW4uc2lnbk1lc3NhZ2UoeyBwcnYgfSwgcGF5bG9hZCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgYWZmaXJtYXRpb25zKCk6IEFmZmlybWF0aW9ucyB7XG4gICAgcmV0dXJuIG5ldyBBZmZpcm1hdGlvbnModGhpcy5iaXRnbywgdGhpcy5lbnRlcnByaXNlSWQsIHRoaXMpO1xuICB9XG5cbiAgc2V0dGxlbWVudHMoKTogU2V0dGxlbWVudHMge1xuICAgIHJldHVybiBuZXcgU2V0dGxlbWVudHModGhpcy5iaXRnbywgdGhpcy5lbnRlcnByaXNlSWQsIHRoaXMpO1xuICB9XG5cbiAgcGFydG5lcnMoKTogVHJhZGluZ1BhcnRuZXJzIHtcbiAgICByZXR1cm4gbmV3IFRyYWRpbmdQYXJ0bmVycyh0aGlzLmJpdGdvLCB0aGlzLmVudGVycHJpc2VJZCwgdGhpcyk7XG4gIH1cbn1cbiJdfQ==