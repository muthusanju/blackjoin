"use strict";
/**
 * @prettier
 * @hidden
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var AffirmationStatus;
(function (AffirmationStatus) {
    AffirmationStatus["PENDING"] = "pending";
    AffirmationStatus["OVERDUE"] = "overdue";
    AffirmationStatus["REJECTED"] = "rejected";
    AffirmationStatus["AFFIRMED"] = "affirmed";
    AffirmationStatus["FAILED"] = "failed";
    AffirmationStatus["CANCELED"] = "canceled";
})(AffirmationStatus = exports.AffirmationStatus || (exports.AffirmationStatus = {}));
var Affirmation = /** @class */ (function () {
    function Affirmation(affirmationData, bitgo, enterpriseId) {
        this.bitgo = bitgo;
        this.enterpriseId = enterpriseId;
        this.updateAffirmationData(affirmationData);
    }
    /**
     * Affirms a pending affirmation, authorizing the settlement
     * @param payload payload authorizing the movement of funds from a trading account
     * @param signature signature of the payload with the user key of the trading account
     * @param callback
     */
    Affirmation.prototype.affirm = function (payload, signature, callback) {
        var body = {
            payload: JSON.stringify(payload),
            signature: signature,
        };
        return this.updateStatus(AffirmationStatus.AFFIRMED, body, callback);
    };
    /**
     * Rejects a pending affirmation, cancelling the settlement
     * @param callback
     */
    Affirmation.prototype.reject = function (callback) {
        return this.updateStatus(AffirmationStatus.REJECTED, null, callback);
    };
    /**
     * Cancels a pending affirmation, cancelling the settlement
     * @param callback
     */
    Affirmation.prototype.cancel = function (callback) {
        return this.updateStatus(AffirmationStatus.CANCELED, null, callback);
    };
    Affirmation.prototype.updateStatus = function (status, body, callback) {
        var self = this;
        return co(function updateStatus() {
            var bodyWithStatus, url, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bodyWithStatus = __assign({ status: status }, body);
                        url = self.bitgo.microservicesUrl("/api/trade/v1/enterprise/" + self.enterpriseId + "/account/" + self.partyAccountId + "/affirmations/" + self.id);
                        return [4 /*yield*/, self.bitgo
                                .put(url)
                                .send(bodyWithStatus)
                                .result()];
                    case 1:
                        response = _a.sent();
                        self.updateAffirmationData(response);
                        return [2 /*return*/];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Affirmation.prototype.updateAffirmationData = function (affirmationData) {
        this.id = affirmationData.id;
        this.partyAccountId = affirmationData.partyAccountId;
        this.status = affirmationData.status;
        this.settlement = affirmationData.settlement;
        this.lock = affirmationData.lock;
        this.payload = affirmationData.payload;
        this.createdAt = new Date(affirmationData.createdAt);
        this.expireAt = new Date(affirmationData.expireAt);
    };
    return Affirmation;
}());
exports.Affirmation = Affirmation;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWZmaXJtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvdHJhZGluZy9hZmZpcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUg7R0FDRztBQUNILG1DQUFxQztBQU9yQyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBRTlCLElBQVksaUJBT1g7QUFQRCxXQUFZLGlCQUFpQjtJQUMzQix3Q0FBbUIsQ0FBQTtJQUNuQix3Q0FBbUIsQ0FBQTtJQUNuQiwwQ0FBcUIsQ0FBQTtJQUNyQiwwQ0FBcUIsQ0FBQTtJQUNyQixzQ0FBaUIsQ0FBQTtJQUNqQiwwQ0FBcUIsQ0FBQTtBQUN2QixDQUFDLEVBUFcsaUJBQWlCLEdBQWpCLHlCQUFpQixLQUFqQix5QkFBaUIsUUFPNUI7QUFFRDtJQWFFLHFCQUFZLGVBQWUsRUFBRSxLQUFZLEVBQUUsWUFBb0I7UUFDN0QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFFakMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDRCQUFNLEdBQU4sVUFBTyxPQUFnQixFQUFFLFNBQWlCLEVBQUUsUUFBNkI7UUFDdkUsSUFBTSxJQUFJLEdBQUc7WUFDWCxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7WUFDaEMsU0FBUyxFQUFFLFNBQVM7U0FDckIsQ0FBQztRQUVGLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7O09BR0c7SUFDSCw0QkFBTSxHQUFOLFVBQU8sUUFBNkI7UUFDbEMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVEOzs7T0FHRztJQUNILDRCQUFNLEdBQU4sVUFBTyxRQUE2QjtRQUNsQyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRU8sa0NBQVksR0FBcEIsVUFBcUIsTUFBeUIsRUFBRSxJQUFLLEVBQUUsUUFBNkI7UUFDbEYsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFPLFNBQVUsWUFBWTs7Ozs7d0JBQzlCLGNBQWMsY0FBSyxNQUFNLFFBQUEsSUFBSyxJQUFJLENBQUUsQ0FBQzt3QkFDckMsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQ3JDLDhCQUE0QixJQUFJLENBQUMsWUFBWSxpQkFBWSxJQUFJLENBQUMsY0FBYyxzQkFBaUIsSUFBSSxDQUFDLEVBQUksQ0FDdkcsQ0FBQzt3QkFDZSxxQkFBTSxJQUFJLENBQUMsS0FBSztpQ0FDOUIsR0FBRyxDQUFDLEdBQUcsQ0FBQztpQ0FDUixJQUFJLENBQUMsY0FBYyxDQUFDO2lDQUNwQixNQUFNLEVBQUUsRUFBQTs7d0JBSEwsUUFBUSxHQUFHLFNBR047d0JBQ1gsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7O1NBQ3RDLENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFTywyQ0FBcUIsR0FBN0IsVUFBOEIsZUFBZTtRQUMzQyxJQUFJLENBQUMsRUFBRSxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUM7UUFDN0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxlQUFlLENBQUMsY0FBYyxDQUFDO1FBQ3JELElBQUksQ0FBQyxNQUFNLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQztRQUNyQyxJQUFJLENBQUMsVUFBVSxHQUFHLGVBQWUsQ0FBQyxVQUFVLENBQUM7UUFDN0MsSUFBSSxDQUFDLElBQUksR0FBRyxlQUFlLENBQUMsSUFBWSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxPQUFPLEdBQUcsZUFBZSxDQUFDLE9BQU8sQ0FBQztRQUN2QyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNyRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBQ0gsa0JBQUM7QUFBRCxDQUFDLEFBOUVELElBOEVDO0FBOUVZLGtDQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5cbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IExvY2sgfSBmcm9tICcuL2xvY2snO1xuaW1wb3J0IHsgUGF5bG9hZCB9IGZyb20gJy4vcGF5bG9hZCc7XG5cbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5leHBvcnQgZW51bSBBZmZpcm1hdGlvblN0YXR1cyB7XG4gIFBFTkRJTkcgPSAncGVuZGluZycsXG4gIE9WRVJEVUUgPSAnb3ZlcmR1ZScsXG4gIFJFSkVDVEVEID0gJ3JlamVjdGVkJyxcbiAgQUZGSVJNRUQgPSAnYWZmaXJtZWQnLFxuICBGQUlMRUQgPSAnZmFpbGVkJyxcbiAgQ0FOQ0VMRUQgPSAnY2FuY2VsZWQnLFxufVxuXG5leHBvcnQgY2xhc3MgQWZmaXJtYXRpb24ge1xuICBwcml2YXRlIGJpdGdvOiBCaXRHbztcbiAgcHJpdmF0ZSBlbnRlcnByaXNlSWQ6IHN0cmluZztcblxuICBwdWJsaWMgaWQ/OiBzdHJpbmc7XG4gIHB1YmxpYyBwYXJ0eUFjY291bnRJZD86IHN0cmluZztcbiAgcHVibGljIHN0YXR1cz86IEFmZmlybWF0aW9uU3RhdHVzO1xuICBwdWJsaWMgc2V0dGxlbWVudD86IHN0cmluZztcbiAgcHVibGljIGxvY2s/OiBMb2NrO1xuICBwdWJsaWMgcGF5bG9hZD86IHN0cmluZztcbiAgcHVibGljIGNyZWF0ZWRBdD86IERhdGU7XG4gIHB1YmxpYyBleHBpcmVBdD86IERhdGU7XG5cbiAgY29uc3RydWN0b3IoYWZmaXJtYXRpb25EYXRhLCBiaXRnbzogQml0R28sIGVudGVycHJpc2VJZDogc3RyaW5nKSB7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICAgIHRoaXMuZW50ZXJwcmlzZUlkID0gZW50ZXJwcmlzZUlkO1xuXG4gICAgdGhpcy51cGRhdGVBZmZpcm1hdGlvbkRhdGEoYWZmaXJtYXRpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZmZpcm1zIGEgcGVuZGluZyBhZmZpcm1hdGlvbiwgYXV0aG9yaXppbmcgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBheWxvYWQgcGF5bG9hZCBhdXRob3JpemluZyB0aGUgbW92ZW1lbnQgb2YgZnVuZHMgZnJvbSBhIHRyYWRpbmcgYWNjb3VudFxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIHNpZ25hdHVyZSBvZiB0aGUgcGF5bG9hZCB3aXRoIHRoZSB1c2VyIGtleSBvZiB0aGUgdHJhZGluZyBhY2NvdW50XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgYWZmaXJtKHBheWxvYWQ6IFBheWxvYWQsIHNpZ25hdHVyZTogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazx2b2lkPik6IEJsdWViaXJkPHZvaWQ+IHtcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgcGF5bG9hZDogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU3RhdHVzKEFmZmlybWF0aW9uU3RhdHVzLkFGRklSTUVELCBib2R5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVqZWN0cyBhIHBlbmRpbmcgYWZmaXJtYXRpb24sIGNhbmNlbGxpbmcgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWplY3QoY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8dm9pZD4pOiBCbHVlYmlyZDx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU3RhdHVzKEFmZmlybWF0aW9uU3RhdHVzLlJFSkVDVEVELCBudWxsLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhIHBlbmRpbmcgYWZmaXJtYXRpb24sIGNhbmNlbGxpbmcgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBjYW5jZWwoY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8dm9pZD4pOiBCbHVlYmlyZDx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU3RhdHVzKEFmZmlybWF0aW9uU3RhdHVzLkNBTkNFTEVELCBudWxsLCBjYWxsYmFjayk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVN0YXR1cyhzdGF0dXM6IEFmZmlybWF0aW9uU3RhdHVzLCBib2R5PywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8dm9pZD4pOiBCbHVlYmlyZDx2b2lkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHZvaWQ+KGZ1bmN0aW9uKiB1cGRhdGVTdGF0dXMoKSB7XG4gICAgICBjb25zdCBib2R5V2l0aFN0YXR1cyA9IHsgc3RhdHVzLCAuLi5ib2R5IH07XG4gICAgICBjb25zdCB1cmwgPSBzZWxmLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoXG4gICAgICAgIGAvYXBpL3RyYWRlL3YxL2VudGVycHJpc2UvJHtzZWxmLmVudGVycHJpc2VJZH0vYWNjb3VudC8ke3NlbGYucGFydHlBY2NvdW50SWR9L2FmZmlybWF0aW9ucy8ke3NlbGYuaWR9YFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgc2VsZi5iaXRnb1xuICAgICAgICAucHV0KHVybClcbiAgICAgICAgLnNlbmQoYm9keVdpdGhTdGF0dXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICAgIHNlbGYudXBkYXRlQWZmaXJtYXRpb25EYXRhKHJlc3BvbnNlKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQWZmaXJtYXRpb25EYXRhKGFmZmlybWF0aW9uRGF0YSkge1xuICAgIHRoaXMuaWQgPSBhZmZpcm1hdGlvbkRhdGEuaWQ7XG4gICAgdGhpcy5wYXJ0eUFjY291bnRJZCA9IGFmZmlybWF0aW9uRGF0YS5wYXJ0eUFjY291bnRJZDtcbiAgICB0aGlzLnN0YXR1cyA9IGFmZmlybWF0aW9uRGF0YS5zdGF0dXM7XG4gICAgdGhpcy5zZXR0bGVtZW50ID0gYWZmaXJtYXRpb25EYXRhLnNldHRsZW1lbnQ7XG4gICAgdGhpcy5sb2NrID0gYWZmaXJtYXRpb25EYXRhLmxvY2sgYXMgTG9jaztcbiAgICB0aGlzLnBheWxvYWQgPSBhZmZpcm1hdGlvbkRhdGEucGF5bG9hZDtcbiAgICB0aGlzLmNyZWF0ZWRBdCA9IG5ldyBEYXRlKGFmZmlybWF0aW9uRGF0YS5jcmVhdGVkQXQpO1xuICAgIHRoaXMuZXhwaXJlQXQgPSBuZXcgRGF0ZShhZmZpcm1hdGlvbkRhdGEuZXhwaXJlQXQpO1xuICB9XG59XG4iXX0=