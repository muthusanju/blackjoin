"use strict";
/**
 * @prettier
 * @hidden
 */
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var TradingPartnerStatus;
(function (TradingPartnerStatus) {
    TradingPartnerStatus["ACCEPTED"] = "accepted";
})(TradingPartnerStatus = exports.TradingPartnerStatus || (exports.TradingPartnerStatus = {}));
var TradingPartner = /** @class */ (function () {
    function TradingPartner(tradingPartnerData, bitgo, enterpriseId, currentAccount) {
        this.name = tradingPartnerData.name;
        this.accountId = tradingPartnerData.accountId;
        this.status = tradingPartnerData.status;
        this.bitgo = bitgo;
        this.enterpriseId = enterpriseId;
        this.currentAccount = currentAccount;
    }
    /**
     * Check if a trading partner has enough funds to cover the cost of a trade.
     * @param currency the currency to check
     * @param amount the amount of currency to check, represented in base units (such as cents, satoshi, or wei)
     * @param callback
     */
    TradingPartner.prototype.checkBalance = function (currency, amount, callback) {
        var self = this;
        return co(function checkBalance() {
            var url, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = self.bitgo.microservicesUrl("/api/trade/v1/enterprise/" + self.enterpriseId + "/account/" + self.currentAccount.id + "/tradingpartners/" + self.accountId + "/balance");
                        return [4 /*yield*/, self.bitgo
                                .get(url)
                                .query({ currency: currency, amount: amount })
                                .result()];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.check];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return TradingPartner;
}());
exports.TradingPartner = TradingPartner;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhZGluZ1BhcnRuZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvdHJhZGluZy90cmFkaW5nUGFydG5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVIO0dBQ0c7QUFDSCxtQ0FBcUM7QUFNckMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUU5QixJQUFZLG9CQUVYO0FBRkQsV0FBWSxvQkFBb0I7SUFDOUIsNkNBQXFCLENBQUE7QUFDdkIsQ0FBQyxFQUZXLG9CQUFvQixHQUFwQiw0QkFBb0IsS0FBcEIsNEJBQW9CLFFBRS9CO0FBRUQ7SUFTRSx3QkFBWSxrQkFBa0IsRUFBRSxLQUFZLEVBQUUsWUFBb0IsRUFBRSxjQUE4QjtRQUNoRyxJQUFJLENBQUMsSUFBSSxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQztRQUNwQyxJQUFJLENBQUMsU0FBUyxHQUFHLGtCQUFrQixDQUFDLFNBQVMsQ0FBQztRQUM5QyxJQUFJLENBQUMsTUFBTSxHQUFHLGtCQUFrQixDQUFDLE1BQU0sQ0FBQztRQUV4QyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUNqQyxJQUFJLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxxQ0FBWSxHQUFaLFVBQWEsUUFBZ0IsRUFBRSxNQUFjLEVBQUUsUUFBZ0M7UUFDN0UsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFVLFNBQVUsWUFBWTs7Ozs7d0JBQ2pDLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUNyQyw4QkFBNEIsSUFBSSxDQUFDLFlBQVksaUJBQVksSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLHlCQUFvQixJQUFJLENBQUMsU0FBUyxhQUFVLENBQzVILENBQUM7d0JBRWUscUJBQU0sSUFBSSxDQUFDLEtBQUs7aUNBQzlCLEdBQUcsQ0FBQyxHQUFHLENBQUM7aUNBQ1IsS0FBSyxDQUFDLEVBQUUsUUFBUSxVQUFBLEVBQUUsTUFBTSxRQUFBLEVBQUUsQ0FBQztpQ0FDM0IsTUFBTSxFQUFFLEVBQUE7O3dCQUhMLFFBQVEsR0FBRyxTQUdOO3dCQUVYLHNCQUFPLFFBQVEsQ0FBQyxLQUFLLEVBQUM7OztTQUN2QixDQUFDO2FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQzthQUNWLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBQ0gscUJBQUM7QUFBRCxDQUFDLEFBMUNELElBMENDO0FBMUNZLHdDQUFjIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5cbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFRyYWRpbmdBY2NvdW50IH0gZnJvbSAnLi90cmFkaW5nQWNjb3VudCc7XG5cbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5leHBvcnQgZW51bSBUcmFkaW5nUGFydG5lclN0YXR1cyB7XG4gIEFDQ0VQVEVEID0gJ2FjY2VwdGVkJyxcbn1cblxuZXhwb3J0IGNsYXNzIFRyYWRpbmdQYXJ0bmVyIHtcbiAgcHJpdmF0ZSBiaXRnbzogQml0R287XG4gIHByaXZhdGUgZW50ZXJwcmlzZUlkOiBzdHJpbmc7XG4gIHByaXZhdGUgY3VycmVudEFjY291bnQ6IFRyYWRpbmdBY2NvdW50OyAvLyBhY2NvdW50IG9mIHRoZSB1c2VyIHVzaW5nIHRoZSBTREssIG5lZWRlZCB0byBjb25zdHJ1Y3QgYmFsYW5jZSBjaGVjayBVUkxcblxuICBwdWJsaWMgbmFtZTogc3RyaW5nO1xuICBwdWJsaWMgYWNjb3VudElkOiBzdHJpbmc7XG4gIHB1YmxpYyBzdGF0dXM6IFRyYWRpbmdQYXJ0bmVyU3RhdHVzO1xuXG4gIGNvbnN0cnVjdG9yKHRyYWRpbmdQYXJ0bmVyRGF0YSwgYml0Z286IEJpdEdvLCBlbnRlcnByaXNlSWQ6IHN0cmluZywgY3VycmVudEFjY291bnQ6IFRyYWRpbmdBY2NvdW50KSB7XG4gICAgdGhpcy5uYW1lID0gdHJhZGluZ1BhcnRuZXJEYXRhLm5hbWU7XG4gICAgdGhpcy5hY2NvdW50SWQgPSB0cmFkaW5nUGFydG5lckRhdGEuYWNjb3VudElkO1xuICAgIHRoaXMuc3RhdHVzID0gdHJhZGluZ1BhcnRuZXJEYXRhLnN0YXR1cztcblxuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmVudGVycHJpc2VJZCA9IGVudGVycHJpc2VJZDtcbiAgICB0aGlzLmN1cnJlbnRBY2NvdW50ID0gY3VycmVudEFjY291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0cmFkaW5nIHBhcnRuZXIgaGFzIGVub3VnaCBmdW5kcyB0byBjb3ZlciB0aGUgY29zdCBvZiBhIHRyYWRlLlxuICAgKiBAcGFyYW0gY3VycmVuY3kgdGhlIGN1cnJlbmN5IHRvIGNoZWNrXG4gICAqIEBwYXJhbSBhbW91bnQgdGhlIGFtb3VudCBvZiBjdXJyZW5jeSB0byBjaGVjaywgcmVwcmVzZW50ZWQgaW4gYmFzZSB1bml0cyAoc3VjaCBhcyBjZW50cywgc2F0b3NoaSwgb3Igd2VpKVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNoZWNrQmFsYW5jZShjdXJyZW5jeTogc3RyaW5nLCBhbW91bnQ6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Ym9vbGVhbj4pOiBCbHVlYmlyZDxib29sZWFuPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPGJvb2xlYW4+KGZ1bmN0aW9uKiBjaGVja0JhbGFuY2UoKSB7XG4gICAgICBjb25zdCB1cmwgPSBzZWxmLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoXG4gICAgICAgIGAvYXBpL3RyYWRlL3YxL2VudGVycHJpc2UvJHtzZWxmLmVudGVycHJpc2VJZH0vYWNjb3VudC8ke3NlbGYuY3VycmVudEFjY291bnQuaWR9L3RyYWRpbmdwYXJ0bmVycy8ke3NlbGYuYWNjb3VudElkfS9iYWxhbmNlYFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBzZWxmLmJpdGdvXG4gICAgICAgIC5nZXQodXJsKVxuICAgICAgICAucXVlcnkoeyBjdXJyZW5jeSwgYW1vdW50IH0pXG4gICAgICAgIC5yZXN1bHQoKTtcblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmNoZWNrO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=