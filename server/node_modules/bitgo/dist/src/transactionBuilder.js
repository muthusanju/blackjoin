"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// TransactionBuilder
// A utility for building and signing transactions
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var Bluebird = require("bluebird");
var bitcoin = require("bitgo-utxo-lib");
var _ = require("lodash");
var unspents_1 = require("@bitgo/unspents");
var bitcoin_1 = require("./bitcoin");
var debugLib = require("debug");
var debug = debugLib('bitgo:v1:txb');
var common = require("./common");
//
// TransactionBuilder
// @params:
//   wallet:  a wallet object to send from
//   recipients: array of recipient objects and the amount to send to each e.g. [{address: '38BKDNZbPcLogvVbcx2ekJ9E6Vv94DqDqw', amount: 1500}, {address: '36eL8yQqCn1HMRmVFFo49t2PJ3pai8wQam', amount: 2000}]
//   fee: the fee to use with this transaction.  if not provided, a default, minimum fee will be used.
//   feeRate: the amount of fee per kilobyte - optional - specify either fee, feeRate, or feeTxConfirmTarget but not more than one
//   feeTxConfirmTarget: calculate the fees per kilobyte such that the transaction will be confirmed in this number of blocks
//   maxFeeRate: The maximum fee per kb to use in satoshis, for safety purposes when using dynamic fees
//   minConfirms: the minimum confirmations an output must have before spending
//   forceChangeAtEnd: force the change address to be the last output
//   changeAddress: specify the change address rather than generate a new one
//   noSplitChange: set to true to disable automatic change splitting for purposes of unspent management
//   targetWalletUnspents: specify a number of target unspents to maintain in the wallet (currently defaulted to 8 by the server)
//   validate: extra verification of the change addresses, which is always done server-side and is redundant client-side (defaults true)
//   minUnspentSize: The minimum size in satoshis of unspent to use (to prevent spending unspents worth less than fee added). Defaults to 0.
//   feeSingleKeySourceAddress: Use this single key address to pay fees
//   feeSingleKeyWIF: Use the address based on this private key to pay fees
//   unspentsFetchParams: Extra parameters to use for fetching unspents for this transaction
exports.createTransaction = function (params) {
    var minConfirms = params.minConfirms || 0;
    var validate = params.validate === undefined ? true : params.validate;
    var recipients = [];
    var opReturns = [];
    var extraChangeAmounts = [];
    var estTxSize;
    var travelInfos;
    // Sanity check the arguments passed in
    if (!_.isObject(params.wallet) ||
        (params.fee && !_.isNumber(params.fee)) ||
        (params.feeRate && !_.isNumber(params.feeRate)) ||
        !_.isInteger(minConfirms) ||
        (params.forceChangeAtEnd && !_.isBoolean(params.forceChangeAtEnd)) ||
        (params.changeAddress && !_.isString(params.changeAddress)) ||
        (params.noSplitChange && !_.isBoolean(params.noSplitChange)) ||
        (params.targetWalletUnspents && !_.isInteger(params.targetWalletUnspents)) ||
        (validate && !_.isBoolean(validate)) ||
        (params.enforceMinConfirmsForChange && !_.isBoolean(params.enforceMinConfirmsForChange)) ||
        (params.minUnspentSize && !_.isNumber(params.minUnspentSize)) ||
        (params.maxFeeRate && !_.isNumber(params.maxFeeRate)) ||
        // this should be an array and its length must be at least 1
        (params.unspents && (!Array.isArray(params.unspents) || params.unspents.length < 1)) ||
        (params.feeTxConfirmTarget && !_.isInteger(params.feeTxConfirmTarget)) ||
        (params.instant && !_.isBoolean(params.instant)) ||
        (params.bitgoFee && !_.isObject(params.bitgoFee)) ||
        (params.unspentsFetchParams && !_.isObject(params.unspentsFetchParams))) {
        throw new Error('invalid argument');
    }
    var bitgo = params.wallet.bitgo;
    var constants = bitgo.getConstants();
    var network = bitcoin_1.getNetwork(common.Environments[bitgo.getEnv()].network);
    // The user can specify a seperate, single-key wallet for the purposes of paying miner's fees
    // When creating a transaction this can be specified as an input address or the private key in WIF
    var feeSingleKeySourceAddress;
    var feeSingleKeyInputAmount = 0;
    if (params.feeSingleKeySourceAddress) {
        try {
            bitcoin.address.fromBase58Check(params.feeSingleKeySourceAddress);
            feeSingleKeySourceAddress = params.feeSingleKeySourceAddress;
        }
        catch (e) {
            throw new Error('invalid bitcoin address: ' + params.feeSingleKeySourceAddress);
        }
    }
    if (params.feeSingleKeyWIF) {
        var feeSingleKey = bitcoin.ECPair.fromWIF(params.feeSingleKeyWIF, network);
        feeSingleKeySourceAddress = feeSingleKey.getAddress();
        // If the user specifies both, check to make sure the feeSingleKeySourceAddress corresponds to the address of feeSingleKeyWIF
        if (params.feeSingleKeySourceAddress &&
            params.feeSingleKeySourceAddress !== feeSingleKeySourceAddress) {
            throw new Error('feeSingleKeySourceAddress: ' + params.feeSingleKeySourceAddress +
                ' did not correspond to address of feeSingleKeyWIF: ' + feeSingleKeySourceAddress);
        }
    }
    if (!_.isObject(params.recipients)) {
        throw new Error('recipients must be array of { address: abc, amount: 100000 } objects');
    }
    var feeParamsDefined = 0;
    if (!_.isUndefined(params.fee)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeRate)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeTxConfirmTarget)) {
        feeParamsDefined++;
    }
    if (feeParamsDefined > 1) {
        throw new Error('cannot specify more than one of fee, feeRate and feeTxConfirmTarget');
    }
    if (_.isUndefined(params.maxFeeRate)) {
        params.maxFeeRate = constants.maxFeeRate;
    }
    // Convert the old format of params.recipients (dictionary of address:amount) to new format: { destinationAddress, amount }
    if (!(params.recipients instanceof Array)) {
        recipients = [];
        Object.keys(params.recipients).forEach(function (destinationAddress) {
            var amount = params.recipients[destinationAddress];
            recipients.push({ address: destinationAddress, amount: amount });
        });
    }
    else {
        recipients = params.recipients;
    }
    if (params.opReturns) {
        if (!(params.opReturns instanceof Array)) {
            opReturns = [];
            Object.keys(params.opReturns).forEach(function (message) {
                var amount = params.opReturns[message];
                opReturns.push({ message: message, amount: amount });
            });
        }
        else {
            opReturns = params.opReturns;
        }
    }
    if (recipients.length === 0 && opReturns.length === 0) {
        throw new Error('must have at least one recipient');
    }
    var fee = params.fee;
    var feeRate = params.feeRate;
    // Flag indicating whether this class will compute the fee
    var shouldComputeBestFee = (_.isUndefined(fee));
    var totalOutputAmount = 0;
    recipients.forEach(function (recipient) {
        if (_.isString(recipient.address)) {
            try {
                bitcoin.address.fromBase58Check(recipient.address);
            }
            catch (e) {
                throw new Error('invalid bitcoin address: ' + recipient.address);
            }
            if (!!recipient.script) {
                // A script was provided as well - validate that the address corresponds to that
                if (bitcoin.address.toOutputScript(recipient.address, network).toString('hex') !== recipient.script) {
                    throw new Error('both script and address provided but they did not match: ' + recipient.address + ' ' + recipient.script);
                }
            }
        }
        if (!_.isInteger(recipient.amount) || recipient.amount < 0) {
            throw new Error('invalid amount for ' + recipient.address + ': ' + recipient.amount);
        }
        totalOutputAmount += recipient.amount;
    });
    opReturns.forEach(function (opReturn) {
        totalOutputAmount += opReturn.amount;
    });
    var bitgoFeeInfo = params.bitgoFee;
    if (bitgoFeeInfo &&
        (!_.isInteger(bitgoFeeInfo.amount) || !_.isString(bitgoFeeInfo.address))) {
        throw new Error('invalid bitgoFeeInfo');
    }
    // The total amount needed for this transaction.
    var totalAmount = totalOutputAmount + (fee || 0);
    // The list of unspent transactions being used in this transaction.
    var unspents;
    // the total number of unspents on this wallet
    var totalUnspentsCount;
    // the number of unspents we fetched from the server, before filtering
    var fetchedUnspentsCount;
    // The list of unspent transactions being used with zero-confirmations
    var zeroConfUnspentTxIds;
    // The sum of the input values for this transaction.
    var inputAmount;
    var changeOutputs = [];
    // The transaction.
    var transaction = new bitcoin.TransactionBuilder(network);
    var getBitGoFee = function () {
        return Bluebird.try(function () {
            if (bitgoFeeInfo) {
                return;
            }
            return params.wallet.getBitGoFee({ amount: totalOutputAmount, instant: params.instant })
                .then(function (result) {
                if (result && result.fee > 0) {
                    bitgoFeeInfo = {
                        amount: result.fee
                    };
                }
            });
        })
            .then(function () {
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                totalAmount += bitgoFeeInfo.amount;
            }
        });
    };
    var getBitGoFeeAddress = function () {
        return Bluebird.try(function () {
            // If we don't have bitgoFeeInfo, or address is already set, don't get a new one
            if (!bitgoFeeInfo || bitgoFeeInfo.address) {
                return;
            }
            return bitgo.getBitGoFeeAddress()
                .then(function (result) {
                bitgoFeeInfo.address = result.address;
            });
        });
    };
    // Get a dynamic fee estimate from the BitGo server if feeTxConfirmTarget
    // is specified or if no fee-related params are specified
    var getDynamicFeeRateEstimate = function () {
        if (params.feeTxConfirmTarget || !feeParamsDefined) {
            return bitgo.estimateFee({
                numBlocks: params.feeTxConfirmTarget,
                maxFee: params.maxFeeRate,
                inputs: zeroConfUnspentTxIds,
                txSize: estTxSize,
                cpfpAware: true
            })
                .then(function (result) {
                var estimatedFeeRate = result.cpfpFeePerKb;
                var minimum = params.instant ? Math.max(constants.minFeeRate, constants.minInstantFeeRate) : constants.minFeeRate;
                // 5 satoshis per byte
                // it is worth noting that the padding only applies when the threshold is crossed, but not when the delta is less than the padding
                var padding = 5000;
                if (estimatedFeeRate < minimum) {
                    console.log(new Date() + ': Error when estimating fee for send from ' + params.wallet.id() + ', it was too low - ' + estimatedFeeRate);
                    feeRate = minimum + padding;
                }
                else if (estimatedFeeRate > params.maxFeeRate) {
                    feeRate = params.maxFeeRate - padding;
                }
                else {
                    feeRate = estimatedFeeRate;
                }
                return feeRate;
            })
                .catch(function (e) {
                // sanity check failed on tx size
                if (_.includes(e.message, 'invalid txSize')) {
                    return Bluebird.reject(e);
                }
                else {
                    // couldn't estimate the fee, proceed using the default
                    feeRate = constants.fallbackFeeRate;
                    console.log('Error estimating fee for send from ' + params.wallet.id() + ': ' + e.message);
                    return Bluebird.resolve();
                }
            });
        }
    };
    // Get the unspents for the sending wallet.
    var getUnspents = function () {
        if (params.unspents) { // we just wanna use custom unspents
            unspents = params.unspents;
            return;
        }
        // Get enough unspents for the requested amount
        var options = _.merge({}, params.unspentsFetchParams || {}, {
            target: totalAmount,
            minSize: params.minUnspentSize || 0,
            instant: params.instant,
            targetWalletUnspents: params.targetWalletUnspents
        });
        if (params.instant) {
            options.instant = params.instant; // insist on instant unspents only
        }
        return params.wallet.unspentsPaged(options)
            .then(function (results) {
            totalUnspentsCount = results.total;
            fetchedUnspentsCount = results.count;
            unspents = results.unspents.filter(function (u) {
                var confirms = u.confirmations || 0;
                if (!params.enforceMinConfirmsForChange && u.isChange) {
                    return true;
                }
                return confirms >= minConfirms;
            });
            // abort early if there's no viable unspents, because it won't be possible to create the txn later
            if (unspents.length === 0) {
                throw Error('0 unspents available for transaction creation');
            }
            // create array of unconfirmed unspent ID strings of the form "txHash:outputIndex"
            zeroConfUnspentTxIds = _(results.unspents).filter(function (u) {
                return !u.confirmations;
            }).map(function (u) {
                return u.tx_hash + ':' + u.tx_output_n;
            }).value();
            if (_.isEmpty(zeroConfUnspentTxIds)) {
                // we don't want to pass an empty array of inputs to the server, because it assumes if the
                // inputs arguments exists, it contains values
                zeroConfUnspentTxIds = undefined;
            }
            // For backwards compatibility, respect the old splitChangeSize=0 parameter
            if (!params.noSplitChange && params.splitChangeSize !== 0) {
                extraChangeAmounts = results.extraChangeAmounts || [];
            }
        });
    };
    // Get the unspents for the single key fee address
    var feeSingleKeyUnspents = [];
    var getUnspentsForSingleKey = function () {
        if (feeSingleKeySourceAddress) {
            var feeTarget = 0.01e8;
            if (params.instant) {
                feeTarget += totalAmount * 0.001;
            }
            return bitgo.get(bitgo.url('/address/' + feeSingleKeySourceAddress + '/unspents?target=' + feeTarget))
                .then(function (response) {
                if (response.body.total <= 0) {
                    throw new Error('No unspents available in single key fee source');
                }
                feeSingleKeyUnspents = response.body.unspents;
            });
        }
    };
    var minerFeeInfo = {};
    var txInfo = {};
    // Iterate unspents, sum the inputs, and save _inputs with the total
    // input amount and final list of inputs to use with the transaction.
    var feeSingleKeyUnspentsUsed = [];
    var collectInputs = function () {
        if (!unspents.length) {
            throw new Error('no unspents available on wallet');
        }
        inputAmount = 0;
        // Calculate the cost of spending a single input, i.e. the smallest economical unspent value
        return Bluebird.try(function () {
            if (_.isNumber(params.feeRate) || _.isNumber(params.originalFeeRate)) {
                return (!_.isUndefined(params.feeRate) ? params.feeRate : params.originalFeeRate);
            }
            else {
                return bitgo.estimateFee({
                    numBlocks: params.feeTxConfirmTarget,
                    maxFee: params.maxFeeRate
                })
                    .then(function (feeRateEstimate) {
                    return feeRateEstimate.feePerKb;
                });
            }
        }).then(function (feeRate) {
            // Don't spend inputs that cannot pay for their own cost.
            var minInputValue = 0;
            if (_.isInteger(params.minUnspentSize)) {
                minInputValue = params.minUnspentSize;
            }
            var prunedUnspentCount = 0;
            var originalUnspentCount = unspents.length;
            unspents = _.filter(unspents, function (unspent) {
                var isSegwitInput = !!unspent.witnessScript;
                var currentInputSize = isSegwitInput ? unspents_1.VirtualSizes.txP2shP2wshInputSize : unspents_1.VirtualSizes.txP2shInputSize;
                var feeBasedMinInputValue = (feeRate * currentInputSize) / 1000;
                var currentMinInputValue = Math.max(minInputValue, feeBasedMinInputValue);
                if (currentMinInputValue > unspent.value) {
                    // pruning unspent
                    var pruneDetails = {
                        generalMinInputValue: minInputValue,
                        feeBasedMinInputValue: feeBasedMinInputValue,
                        currentMinInputValue: currentMinInputValue,
                        feeRate: feeRate,
                        inputSize: currentInputSize,
                        unspent: unspent
                    };
                    console.log("pruning unspent: " + JSON.stringify(pruneDetails, null, 4));
                    prunedUnspentCount++;
                    return false;
                }
                return true;
            });
            if (prunedUnspentCount > 0) {
                console.log("pruned " + prunedUnspentCount + " out of " + originalUnspentCount + " unspents");
            }
            if (unspents.length === 0) {
                throw new Error('insufficient funds');
            }
            var segwitInputCount = 0;
            unspents.every(function (unspent) {
                if (unspent.witnessScript) {
                    segwitInputCount++;
                }
                inputAmount += unspent.value;
                transaction.addInput(unspent.tx_hash, unspent.tx_output_n, 0xffffffff);
                return (inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount));
            });
            // if paying fees from an external single key wallet, add the inputs
            if (feeSingleKeySourceAddress) {
                // collect the amount used in the fee inputs so we can get change later
                feeSingleKeyInputAmount = 0;
                feeSingleKeyUnspentsUsed = [];
                feeSingleKeyUnspents.every(function (unspent) {
                    feeSingleKeyInputAmount += unspent.value;
                    inputAmount += unspent.value;
                    transaction.addInput(unspent.tx_hash, unspent.tx_output_n);
                    feeSingleKeyUnspentsUsed.push(unspent);
                    // use the fee wallet to pay miner fees and potentially instant fees
                    return (feeSingleKeyInputAmount < (fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0)));
                });
            }
            txInfo = {
                nP2shInputs: transaction.tx.ins.length - (feeSingleKeySourceAddress ? 1 : 0) - segwitInputCount,
                nP2shP2wshInputs: segwitInputCount,
                nP2pkhInputs: feeSingleKeySourceAddress ? 1 : 0,
                nOutputs: (recipients.length + 1 + // recipients and change
                    extraChangeAmounts.length + // extra change splitting
                    (bitgoFeeInfo && bitgoFeeInfo.amount > 0 ? 1 : 0) + // add output for bitgo fee
                    (feeSingleKeySourceAddress ? 1 : 0) // add single key source address change
                )
            };
            estTxSize = estimateTransactionSize({
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs
            });
        }).then(getDynamicFeeRateEstimate)
            .then(function () {
            minerFeeInfo = exports.calculateMinerFeeInfo({
                bitgo: params.wallet.bitgo,
                feeRate: feeRate,
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs
            });
            if (shouldComputeBestFee) {
                var approximateFee = minerFeeInfo.fee;
                var shouldRecurse = _.isUndefined(fee) || approximateFee > fee;
                fee = approximateFee;
                // Recompute totalAmount from scratch
                totalAmount = fee + totalOutputAmount;
                if (bitgoFeeInfo) {
                    totalAmount += bitgoFeeInfo.amount;
                }
                if (shouldRecurse) {
                    // if fee changed, re-collect inputs
                    inputAmount = 0;
                    transaction = new bitcoin.TransactionBuilder(network);
                    return collectInputs();
                }
            }
            var totalFee = fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0);
            if (feeSingleKeySourceAddress) {
                var summedSingleKeyUnspents = _.sumBy(feeSingleKeyUnspents, 'value');
                if (totalFee > summedSingleKeyUnspents) {
                    var err = new Error('Insufficient fee amount available in single key fee source: ' + summedSingleKeyUnspents);
                    err.result = {
                        fee: fee,
                        feeRate: feeRate,
                        estimatedSize: minerFeeInfo.size,
                        available: inputAmount,
                        bitgoFee: bitgoFeeInfo,
                        txInfo: txInfo
                    };
                    return Bluebird.reject(err);
                }
            }
            if (inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount)) {
                // The unspents we're using for inputs do not have sufficient value on them to
                // satisfy the user's requested spend amount. That may be because the wallet's balance
                // is simply too low, or it might be that the wallet's balance is sufficient but
                // we didn't fetch enough unspents. Too few unspents could result from the wallet
                // having many small unspents and we hit our limit on the number of inputs we can use
                // in a txn, or it might have been that the filters the user passed in (like minConfirms)
                // disqualified too many of the unspents
                var err = void 0;
                if (totalUnspentsCount === fetchedUnspentsCount) {
                    // we fetched every unspent the wallet had, but it still wasn't enough
                    err = new Error('Insufficient funds');
                }
                else {
                    // we weren't able to fetch all the unspents on the wallet
                    err = new Error("Transaction size too large due to too many unspents. Can send only " + inputAmount + " satoshis in this transaction");
                }
                err.result = {
                    fee: fee,
                    feeRate: feeRate,
                    estimatedSize: minerFeeInfo.size,
                    available: inputAmount,
                    bitgoFee: bitgoFeeInfo,
                    txInfo: txInfo
                };
                return Bluebird.reject(err);
            }
        });
    };
    // Add the outputs for this transaction.
    var collectOutputs = function () {
        if (minerFeeInfo.size >= 90000) {
            throw new Error('transaction too large: estimated size ' + minerFeeInfo.size + ' bytes');
        }
        var outputs = [];
        recipients.forEach(function (recipient) {
            var script;
            if (_.isString(recipient.address)) {
                script = bitcoin.address.toOutputScript(recipient.address, network);
            }
            else if (_.isObject(recipient.script)) {
                script = recipient.script;
            }
            else {
                throw new Error('neither recipient address nor script was provided');
            }
            // validate travelInfo if it exists
            var travelInfo;
            if (!_.isEmpty(recipient.travelInfo)) {
                travelInfo = recipient.travelInfo;
                // Better to avoid trouble now, before tx is created
                bitgo.travelRule().validateTravelInfo(travelInfo);
            }
            outputs.push({
                script: script,
                amount: recipient.amount,
                travelInfo: travelInfo
            });
        });
        opReturns.forEach(function (_a) {
            var message = _a.message, amount = _a.amount;
            var script = bitcoin.script.fromASM('OP_RETURN ' + Buffer.from(message).toString('hex'));
            outputs.push({ script: script, amount: amount });
        });
        var getChangeOutputs = function (changeAmount) {
            if (changeAmount < 0) {
                throw new Error('negative change amount: ' + changeAmount);
            }
            var result = [];
            // if we paid fees from a single key wallet, return the fee change first
            if (feeSingleKeySourceAddress) {
                var feeSingleKeyWalletChangeAmount = feeSingleKeyInputAmount - (fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0));
                if (feeSingleKeyWalletChangeAmount >= constants.minOutputSize) {
                    result.push({ address: feeSingleKeySourceAddress, amount: feeSingleKeyWalletChangeAmount });
                    changeAmount = changeAmount - feeSingleKeyWalletChangeAmount;
                }
            }
            if (changeAmount < constants.minOutputSize) {
                // Give it to the miners
                return result;
            }
            if (params.wallet.type() === 'safe') {
                return params.wallet.addresses()
                    .then(function (response) {
                    result.push({ address: response.addresses[0].address, amount: changeAmount });
                    return result;
                });
            }
            var extraChangeTotal = _.sum(extraChangeAmounts);
            // Sanity check
            if (extraChangeTotal > changeAmount) {
                extraChangeAmounts = [];
                extraChangeTotal = 0;
            }
            // copy and add remaining change amount
            var allChangeAmounts = extraChangeAmounts.slice(0);
            allChangeAmounts.push(changeAmount - extraChangeTotal);
            // Recursive async func to add all change outputs
            var addChangeOutputs = function () {
                var thisAmount = allChangeAmounts.shift();
                if (!thisAmount) {
                    return result;
                }
                return Bluebird.try(function () {
                    if (params.changeAddress) {
                        // If user passed a change address, use it for all outputs
                        return params.changeAddress;
                    }
                    else {
                        // Otherwise create a new address per output, for privacy
                        // determine if segwit or not
                        var changeChain = params.wallet.getChangeChain(params);
                        return params.wallet.createAddress({ chain: changeChain, validate: validate })
                            .then(function (result) {
                            return result.address;
                        });
                    }
                })
                    .then(function (address) {
                    result.push({ address: address, amount: thisAmount });
                    return addChangeOutputs();
                });
            };
            return addChangeOutputs();
        };
        // Add change output(s) and instant fee output if applicable
        return Bluebird.try(function () {
            return getChangeOutputs(inputAmount - totalAmount);
        })
            .then(function (result) {
            changeOutputs = result;
            var extraOutputs = changeOutputs.concat([]); // copy the array
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                extraOutputs.push(bitgoFeeInfo);
            }
            extraOutputs.forEach(function (output) {
                if (output.address) {
                    output.script =
                        bitcoin.address.toOutputScript(output.address, network);
                }
                // decide where to put the outputs - default is to randomize unless forced to end
                var outputIndex = params.forceChangeAtEnd ? outputs.length : _.random(0, outputs.length);
                outputs.splice(outputIndex, 0, output);
            });
            // Add all outputs to the transaction
            outputs.forEach(function (output) {
                transaction.addOutput(output.script, output.amount);
            });
            travelInfos = _(outputs).map(function (output, index) {
                var result = output.travelInfo;
                if (!result) {
                    return undefined;
                }
                result.outputIndex = index;
                return result;
            })
                .filter()
                .value();
        });
    };
    // Serialize the transaction, returning what is needed to sign it
    var serialize = function () {
        // only need to return the unspents that were used and just the chainPath, redeemScript, and instant flag
        var pickedUnspents = _.map(unspents, function (unspent) {
            return _.pick(unspent, ['chainPath', 'redeemScript', 'instant', 'witnessScript', 'script', 'value']);
        });
        var prunedUnspents = _.slice(pickedUnspents, 0, transaction.tx.ins.length - feeSingleKeyUnspentsUsed.length);
        _.each(feeSingleKeyUnspentsUsed, function (feeUnspent) {
            prunedUnspents.push({ redeemScript: false, chainPath: false }); // mark as false to signify a non-multisig address
        });
        var result = {
            transactionHex: transaction.buildIncomplete().toHex(),
            unspents: prunedUnspents,
            fee: fee,
            changeAddresses: changeOutputs.map(function (co) {
                return _.pick(co, ['address', 'path', 'amount']);
            }),
            walletId: params.wallet.id(),
            walletKeychains: params.wallet.keychains,
            feeRate: feeRate,
            instant: params.instant,
            bitgoFee: bitgoFeeInfo,
            estimatedSize: minerFeeInfo.size,
            txInfo: txInfo,
            travelInfos: travelInfos
        };
        // Add for backwards compatibility
        if (result.instant && bitgoFeeInfo) {
            result.instantFee = _.pick(bitgoFeeInfo, ['amount', 'address']);
        }
        return result;
    };
    return Bluebird.try(function () {
        return getBitGoFee();
    })
        .then(function () {
        return Bluebird.all([getBitGoFeeAddress(), getUnspents(), getUnspentsForSingleKey()]);
    })
        .then(collectInputs)
        .then(collectOutputs)
        .then(serialize);
};
/**
 * Estimate the size of a transaction in bytes based on the number of
 * inputs and outputs present.
 * @params params {
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns size: estimated size of the transaction in bytes
 */
var estimateTransactionSize = function (params) {
    if (!_.isInteger(params.nP2shInputs) || params.nP2shInputs < 0) {
        throw new Error('expecting positive nP2shInputs');
    }
    if (!_.isInteger(params.nP2pkhInputs) || params.nP2pkhInputs < 0) {
        throw new Error('expecting positive nP2pkhInputs to be numeric');
    }
    if (!_.isInteger(params.nP2shP2wshInputs) || params.nP2shP2wshInputs < 0) {
        throw new Error('expecting positive nP2shP2wshInputs to be numeric');
    }
    if ((params.nP2shInputs + params.nP2shP2wshInputs) < 1) {
        throw new Error('expecting at least one nP2shInputs or nP2shP2wshInputs');
    }
    if (!_.isInteger(params.nOutputs) || params.nOutputs < 1) {
        throw new Error('expecting positive nOutputs');
    }
    var estimatedSize = unspents_1.VirtualSizes.txP2shInputSize * params.nP2shInputs +
        unspents_1.VirtualSizes.txP2shP2wshInputSize * (params.nP2shP2wshInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhInputSizeUncompressedKey * (params.nP2pkhInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhOutputSize * params.nOutputs +
        // if the tx contains at least one segwit input, the tx overhead is increased by 1
        unspents_1.VirtualSizes.txOverheadSize + (params.nP2shP2wshInputs > 0 ? 1 : 0);
    return estimatedSize;
};
/**
 * Calculate the fee and estimated size in bytes for a transaction.
 * @params params {
 *   bitgo: bitgo object
 *   feeRate: satoshis per kilobyte
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns {
 *   size: estimated size of the transaction in bytes
 *   fee: estimated fee in satoshis for the transaction
 *   feeRate: fee rate that was used to estimate the fee for the transaction
 * }
 */
exports.calculateMinerFeeInfo = function (params) {
    var feeRateToUse = params.feeRate || params.bitgo.getConstants().fallbackFeeRate;
    var estimatedSize = estimateTransactionSize(params);
    return {
        size: estimatedSize,
        fee: Math.ceil(estimatedSize * feeRateToUse / 1000),
        feeRate: feeRateToUse
    };
};
/*
 * Given a transaction hex, unspent information (chain path and redeem scripts), and the keychain xprv,
 * perform key derivation and sign the inputs in the transaction based on the unspent information provided
 *
 * @params:
 *  transactionHex serialized form of the transaction in hex
 *  unspents array of unspent information, where each unspent is a chainPath and redeemScript with the same
 *  index as the inputs in the transactionHex
 *  keychain Keychain containing the xprv to sign with. For legacy support of safe wallets, keychain can
 also be a WIF private key.
 *  signingKey private key in WIF for safe wallets, when keychain is unavailable
 *  validate client-side signature verification - can be disabled for improved performance (signatures
 *           are still validated server-side).
 *  feeSingleKeyWIF Use the address based on this private key to pay fees
 * @returns {*}
 */
exports.signTransaction = function (params) {
    var keychain = params.keychain; // duplicate so as to not mutate below
    var validate = (params.validate === undefined) ? true : params.validate;
    var privKey;
    if (!_.isString(params.transactionHex)) {
        throw new Error('expecting the transaction hex as a string');
    }
    if (!Array.isArray(params.unspents)) {
        throw new Error('expecting the unspents array');
    }
    if (!_.isBoolean(validate)) {
        throw new Error('expecting validate to be a boolean');
    }
    var network = bitcoin_1.getNetwork();
    var enableBCH = (_.isBoolean(params.forceBCH) && params.forceBCH === true);
    if (!_.isObject(keychain) || !_.isString(keychain.xprv)) {
        if (_.isString(params.signingKey)) {
            privKey = bitcoin.ECPair.fromWIF(params.signingKey, network);
            keychain = undefined;
        }
        else {
            throw new Error('expecting the keychain object with xprv');
        }
    }
    var feeSingleKey;
    if (params.feeSingleKeyWIF) {
        feeSingleKey = bitcoin.ECPair.fromWIF(params.feeSingleKeyWIF, network);
    }
    debug('Network: %O', network);
    if (enableBCH) {
        debug('Enabling BCHâ€¦');
        network = _.extend({}, network, { coin: 'bch' });
        debug('New network: %O', network);
    }
    var transaction = bitcoin.Transaction.fromHex(params.transactionHex, network);
    if (transaction.ins.length !== params.unspents.length) {
        throw new Error('length of unspents array should equal to the number of transaction inputs');
    }
    // decorate transaction with input values for TransactionBuilder instantiation
    var isUtxoTx = _.isObject(transaction) && Array.isArray(transaction.ins);
    var areValidUnspents = _.isObject(params) && Array.isArray(params.unspents);
    if (isUtxoTx && areValidUnspents) {
        // extend the transaction inputs with the values
        var inputValues_1 = _.map(params.unspents, (function (u) { return _.pick(u, 'value'); }));
        transaction.ins.map(function (currentItem, index) { return _.extend(currentItem, inputValues_1[index]); });
    }
    var rootExtKeyPath;
    var rootExtKey;
    if (keychain) {
        rootExtKey = bitcoin.HDNode.fromBase58(keychain.xprv);
        rootExtKeyPath = bitcoin_1.hdPath(rootExtKey);
    }
    var txb = bitcoin.TransactionBuilder.fromTransaction(transaction, network);
    for (var index = 0; index < txb.tx.ins.length; ++index) {
        var currentUnspent = params.unspents[index];
        if (currentUnspent.redeemScript === false) {
            // this is the input from a single key fee address
            if (!feeSingleKey) {
                throw new Error('single key address used in input but feeSingleKeyWIF not provided');
            }
            if (enableBCH) {
                feeSingleKey.network = network;
            }
            txb.sign(index, feeSingleKey);
            continue;
        }
        var chainPath = currentUnspent.chainPath;
        if (rootExtKeyPath) {
            var subPath = keychain.walletSubPath || '/0/0';
            var path = keychain.path + subPath + chainPath;
            privKey = rootExtKeyPath.deriveKey(path);
        }
        privKey.network = network;
        var isSegwitInput = !!currentUnspent.witnessScript;
        // subscript is the part of the output script after the OP_CODESEPARATOR.
        // Since we are only ever signing p2sh outputs, which do not have
        // OP_CODESEPARATORS, it is always the output script.
        var subscript = new Buffer(currentUnspent.redeemScript, 'hex');
        currentUnspent.validationScript = subscript;
        // In order to sign with bitcoinjs-lib, we must use its transaction
        // builder, confusingly named the same exact thing as our transaction
        // builder, but with inequivalent behavior.
        try {
            if (isSegwitInput) {
                debug('Signing segwit input #%d', index);
                if (enableBCH) {
                    throw new Error('BCH does not support segwit inputs');
                }
                var signatures = _.cloneDeep(txb.inputs[index].signatures);
                var witnessScript = new Buffer(currentUnspent.witnessScript, 'hex');
                currentUnspent.validationScript = witnessScript;
                debug('Current unspent value: %d', currentUnspent.value);
                txb.sign(index, privKey, subscript, bitcoin.Transaction.SIGHASH_ALL, currentUnspent.value, witnessScript);
                if (Array.isArray(signatures)) {
                    // for segwit inputs, if they are partially signed, bitcoinjs-lib overrides previous signatures
                    // this workaround forces them to be preserved
                    signatures = signatures.filter(function (sig) { return !!sig; });
                    // Last, override builder's signatures property to an array including previous signatures, if there are any.
                    var builderSignatures = txb.inputs[index].signatures;
                    var nonEmptySignatures = _.remove(builderSignatures, function (sig) { return !!sig; });
                    signatures.push.apply(signatures, nonEmptySignatures);
                    txb.inputs[index].signatures = signatures;
                }
            }
            else {
                debug('Signing non-segwit input #%d', index);
                // only if bitcoin cash is enabled, which should only be in unit tests anyway
                var bchParameter = enableBCH ? currentUnspent.value : undefined;
                var sigHashType = bitcoin.Transaction.SIGHASH_ALL;
                if (enableBCH) {
                    sigHashType |= bitcoin.Transaction.SIGHASH_BITCOINCASHBIP143;
                }
                debug('BCH parameter: %d', bchParameter);
                debug('Sighash type: %d', sigHashType);
                txb.sign(index, privKey, subscript, sigHashType, bchParameter);
            }
        }
        catch (e) {
            // we need to know what's causing this
            e.result = {
                unspent: currentUnspent
            };
            e.message = "Failed to sign input #" + index + " - " + e.message + " - " + JSON.stringify(e.result, null, 4) + " - \n" + e.stack;
            debug('input sign failed: %s', e.message);
            return Bluebird.reject(e);
        }
    }
    // reserialize transaction
    transaction = txb.build();
    for (var index = 0; index < transaction.ins.length; ++index) {
        // bitcoinjs-lib adds one more OP_0 than we need. It creates one OP_0 for
        // every n public keys in an m-of-n multisig, and replaces the OP_0s with
        // the signature of the nth public key, then removes any remaining OP_0s
        // at the end. This behavior is not incorrect and valid for some use
        // cases, particularly if you do not know which keys will be signing the
        // transaction and the signatures may be added to the transaction in any
        // chronological order, but is not compatible with the BitGo API, which
        // assumes m OP_0s for m-of-n multisig (or m-1 after the first signature
        // is created). Thus we need to remove the superfluous OP_0.
        var currentUnspent = params.unspents[index];
        // The signatures are validated server side and on the bitcoin network, so
        // the signature validation is optional and can be disabled by setting:
        // validate = false
        if (validate) {
            var signatureCount = exports.verifyInputSignatures(transaction, index, currentUnspent.validationScript, false, currentUnspent.value, enableBCH);
            // TODO: figure out something smarter for half-signed
            // if params.fullLocalSigning is set to true, we allow custom non-zero values
            // otherwise, the signature count has to be -1
            var fullLocalSigning = !!params.fullLocalSigning;
            if (signatureCount === 0 || (!fullLocalSigning && signatureCount !== -1)) {
                // if the signature count is positive, we do not want to throw the error, because it is expected
                throw new Error('number of signatures is invalid - something went wrong when signing');
            }
        }
    }
    return Bluebird.resolve({
        transactionHex: transaction.toHex()
    });
};
/**
 * Verify the signature on an input.
 *
 * If the transaction is fully signed, returns a positive number representing the number of valid signatures.
 * If the transaction is partially signed, returns a negative number representing the number of valid signatures.
 * @param transaction The bitcoinjs-lib transaction object
 * @param inputIndex the input index to verify
 * @param pubScript the redeem script to verify with
 * @param ignoreKeyIndices array of multisig keys indexes (in order of keychains on the wallet). e.g. [1] to ignore backup keys
 * @param amount
 * @returns {number}
 */
exports.verifyInputSignatures = function (transaction, inputIndex, pubScript, ignoreKeyIndices, amount, isBCH) {
    if (isBCH === void 0) { isBCH = false; }
    if (inputIndex < 0 || inputIndex >= transaction.ins.length) {
        throw new Error('illegal index');
    }
    ignoreKeyIndices = ignoreKeyIndices || [];
    var currentTransactionInput = transaction.ins[inputIndex];
    var sigScript = currentTransactionInput.script;
    var sigsNeeded = 1;
    var sigs = [];
    var pubKeys = [];
    var decompiledSigScript = bitcoin.script.decompile(sigScript);
    var isSegwitInput = currentTransactionInput.witness.length > 0;
    if (isSegwitInput) {
        decompiledSigScript = currentTransactionInput.witness;
        sigScript = bitcoin.script.compile(decompiledSigScript);
        if (!amount) {
            return 0;
        }
    }
    // Check the script type to determine number of signatures, the pub keys, and the script to hash.
    var inputClassification = bitcoin.script.classifyInput(sigScript, true);
    switch (inputClassification) {
        case 'scripthash':
            // Replace the pubScript with the P2SH Script.
            pubScript = decompiledSigScript[decompiledSigScript.length - 1];
            var decompiledPubScript = bitcoin.script.decompile(pubScript);
            sigsNeeded = decompiledPubScript[0] - bitcoin.opcodes.OP_1 + 1;
            for (var index = 1; index < decompiledSigScript.length - 1; ++index) {
                sigs.push(decompiledSigScript[index]);
            }
            for (var index = 1; index < decompiledPubScript.length - 2; ++index) {
                // we minus 1 because the key indexes start from the second chunk (first chunk is used for total keys)
                if (_.includes(ignoreKeyIndices, index - 1)) {
                    // ignore this public key (do not treat it as valid for a signature)
                    continue;
                }
                pubKeys.push(decompiledPubScript[index]);
            }
            break;
        case 'pubkeyhash':
            sigsNeeded = 1;
            sigs.push(decompiledSigScript[0]);
            pubKeys.push(decompiledSigScript[1]);
            break;
        default:
            return 0;
    }
    var numVerifiedSignatures = 0;
    for (var sigIndex = 0; sigIndex < sigs.length; ++sigIndex) {
        // If this is an OP_0, then its been left as a placeholder for a future sig.
        if (sigs[sigIndex] === bitcoin.opcodes.OP_0) {
            continue;
        }
        var hashType = sigs[sigIndex][sigs[sigIndex].length - 1];
        sigs[sigIndex] = sigs[sigIndex].slice(0, sigs[sigIndex].length - 1); // pop hash type from end
        var signatureHash = void 0;
        if (isSegwitInput) {
            signatureHash = transaction.hashForWitnessV0(inputIndex, pubScript, amount, hashType);
        }
        else if (isBCH) {
            signatureHash = transaction.hashForCashSignature(inputIndex, pubScript, amount, hashType);
        }
        else {
            signatureHash = transaction.hashForSignature(inputIndex, pubScript, hashType);
        }
        var validSig = false;
        // Enumerate the possible public keys
        for (var pubKeyIndex = 0; pubKeyIndex < pubKeys.length; ++pubKeyIndex) {
            var pubKey = bitcoin.ECPair.fromPublicKeyBuffer(pubKeys[pubKeyIndex]);
            var signature = bitcoin.ECSignature.fromDER(sigs[sigIndex]);
            validSig = pubKey.verify(signatureHash, signature);
            if (validSig) {
                pubKeys.splice(pubKeyIndex, 1); // remove the pubkey so we can't match 2 sigs against the same pubkey
                break;
            }
        }
        if (!validSig) {
            throw new Error('invalid signature for index ' + inputIndex);
        }
        numVerifiedSignatures++;
    }
    if (numVerifiedSignatures < sigsNeeded) {
        numVerifiedSignatures = -numVerifiedSignatures;
    }
    return numVerifiedSignatures;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUg7R0FDRztBQUNILEVBQUU7QUFDRixxQkFBcUI7QUFDckIsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUVGLG1DQUFxQztBQUNyQyx3Q0FBMEM7QUFDMUMsMEJBQTRCO0FBQzVCLDRDQUErQztBQUMvQyxxQ0FBK0M7QUFDL0MsZ0NBQW1DO0FBQ25DLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN2QyxpQ0FBbUM7QUF1Qm5DLEVBQUU7QUFDRixxQkFBcUI7QUFDckIsV0FBVztBQUNYLDBDQUEwQztBQUMxQyw4TUFBOE07QUFDOU0sc0dBQXNHO0FBQ3RHLGtJQUFrSTtBQUNsSSw2SEFBNkg7QUFDN0gsdUdBQXVHO0FBQ3ZHLCtFQUErRTtBQUMvRSxxRUFBcUU7QUFDckUsNkVBQTZFO0FBQzdFLHdHQUF3RztBQUN4RyxpSUFBaUk7QUFDakksd0lBQXdJO0FBQ3hJLDRJQUE0STtBQUM1SSx1RUFBdUU7QUFDdkUsMkVBQTJFO0FBQzNFLDRGQUE0RjtBQUM1RixPQUFPLENBQUMsaUJBQWlCLEdBQUcsVUFBUyxNQUFNO0lBQ3pDLElBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDO0lBQzVDLElBQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7SUFDeEUsSUFBSSxVQUFVLEdBQThFLEVBQUUsQ0FBQztJQUMvRixJQUFJLFNBQVMsR0FBMkMsRUFBRSxDQUFDO0lBQzNELElBQUksa0JBQWtCLEdBQWEsRUFBRSxDQUFDO0lBQ3RDLElBQUksU0FB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LEdBQUcsVUFBVSxFQUFFO1FBQ3RDLHFCQUFxQixHQUFHLENBQUMscUJBQXFCLENBQUM7S0FDaEQ7SUFDRCxPQUFPLHFCQUFxQixDQUFDO0FBQy9CLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGhpZGRlblxuICovXG5cbi8qKlxuICovXG4vL1xuLy8gVHJhbnNhY3Rpb25CdWlsZGVyXG4vLyBBIHV0aWxpdHkgZm9yIGJ1aWxkaW5nIGFuZCBzaWduaW5nIHRyYW5zYWN0aW9uc1xuLy9cbi8vIENvcHlyaWdodCAyMDE0LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5cbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIGJpdGNvaW4gZnJvbSAnYml0Z28tdXR4by1saWInO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVmlydHVhbFNpemVzIH0gZnJvbSAnQGJpdGdvL3Vuc3BlbnRzJztcbmltcG9ydCB7IGdldE5ldHdvcmssIGhkUGF0aCB9IGZyb20gJy4vYml0Y29pbic7XG5pbXBvcnQgZGVidWdMaWIgPSByZXF1aXJlKCdkZWJ1ZycpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286djE6dHhiJyk7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi9jb21tb24nO1xuXG5pbnRlcmZhY2UgQmFzZU91dHB1dCB7XG4gIGFtb3VudDogbnVtYmVyO1xuICB0cmF2ZWxJbmZvPzogYW55O1xufVxuXG5pbnRlcmZhY2UgQWRkcmVzc091dHB1dCBleHRlbmRzIEJhc2VPdXRwdXQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTY3JpcHRPdXRwdXQgZXh0ZW5kcyBCYXNlT3V0cHV0IHtcbiAgc2NyaXB0OiBCdWZmZXI7XG59XG5cbnR5cGUgT3V0cHV0ID0gQWRkcmVzc091dHB1dCB8IFNjcmlwdE91dHB1dDtcblxuaW50ZXJmYWNlIEJpdEdvVW5zcGVudCB7XG4gIHZhbHVlOiBudW1iZXI7XG4gIHR4X2hhc2g6IEJ1ZmZlcjtcbiAgdHhfb3V0cHV0X246IG51bWJlcjtcbn1cblxuLy9cbi8vIFRyYW5zYWN0aW9uQnVpbGRlclxuLy8gQHBhcmFtczpcbi8vICAgd2FsbGV0OiAgYSB3YWxsZXQgb2JqZWN0IHRvIHNlbmQgZnJvbVxuLy8gICByZWNpcGllbnRzOiBhcnJheSBvZiByZWNpcGllbnQgb2JqZWN0cyBhbmQgdGhlIGFtb3VudCB0byBzZW5kIHRvIGVhY2ggZS5nLiBbe2FkZHJlc3M6ICczOEJLRE5aYlBjTG9ndlZiY3gyZWtKOUU2VnY5NERxRHF3JywgYW1vdW50OiAxNTAwfSwge2FkZHJlc3M6ICczNmVMOHlRcUNuMUhNUm1WRkZvNDl0MlBKM3BhaTh3UWFtJywgYW1vdW50OiAyMDAwfV1cbi8vICAgZmVlOiB0aGUgZmVlIHRvIHVzZSB3aXRoIHRoaXMgdHJhbnNhY3Rpb24uICBpZiBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCwgbWluaW11bSBmZWUgd2lsbCBiZSB1c2VkLlxuLy8gICBmZWVSYXRlOiB0aGUgYW1vdW50IG9mIGZlZSBwZXIga2lsb2J5dGUgLSBvcHRpb25hbCAtIHNwZWNpZnkgZWl0aGVyIGZlZSwgZmVlUmF0ZSwgb3IgZmVlVHhDb25maXJtVGFyZ2V0IGJ1dCBub3QgbW9yZSB0aGFuIG9uZVxuLy8gICBmZWVUeENvbmZpcm1UYXJnZXQ6IGNhbGN1bGF0ZSB0aGUgZmVlcyBwZXIga2lsb2J5dGUgc3VjaCB0aGF0IHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIGNvbmZpcm1lZCBpbiB0aGlzIG51bWJlciBvZiBibG9ja3Ncbi8vICAgbWF4RmVlUmF0ZTogVGhlIG1heGltdW0gZmVlIHBlciBrYiB0byB1c2UgaW4gc2F0b3NoaXMsIGZvciBzYWZldHkgcHVycG9zZXMgd2hlbiB1c2luZyBkeW5hbWljIGZlZXNcbi8vICAgbWluQ29uZmlybXM6IHRoZSBtaW5pbXVtIGNvbmZpcm1hdGlvbnMgYW4gb3V0cHV0IG11c3QgaGF2ZSBiZWZvcmUgc3BlbmRpbmdcbi8vICAgZm9yY2VDaGFuZ2VBdEVuZDogZm9yY2UgdGhlIGNoYW5nZSBhZGRyZXNzIHRvIGJlIHRoZSBsYXN0IG91dHB1dFxuLy8gICBjaGFuZ2VBZGRyZXNzOiBzcGVjaWZ5IHRoZSBjaGFuZ2UgYWRkcmVzcyByYXRoZXIgdGhhbiBnZW5lcmF0ZSBhIG5ldyBvbmVcbi8vICAgbm9TcGxpdENoYW5nZTogc2V0IHRvIHRydWUgdG8gZGlzYWJsZSBhdXRvbWF0aWMgY2hhbmdlIHNwbGl0dGluZyBmb3IgcHVycG9zZXMgb2YgdW5zcGVudCBtYW5hZ2VtZW50XG4vLyAgIHRhcmdldFdhbGxldFVuc3BlbnRzOiBzcGVjaWZ5IGEgbnVtYmVyIG9mIHRhcmdldCB1bnNwZW50cyB0byBtYWludGFpbiBpbiB0aGUgd2FsbGV0IChjdXJyZW50bHkgZGVmYXVsdGVkIHRvIDggYnkgdGhlIHNlcnZlcilcbi8vICAgdmFsaWRhdGU6IGV4dHJhIHZlcmlmaWNhdGlvbiBvZiB0aGUgY2hhbmdlIGFkZHJlc3Nlcywgd2hpY2ggaXMgYWx3YXlzIGRvbmUgc2VydmVyLXNpZGUgYW5kIGlzIHJlZHVuZGFudCBjbGllbnQtc2lkZSAoZGVmYXVsdHMgdHJ1ZSlcbi8vICAgbWluVW5zcGVudFNpemU6IFRoZSBtaW5pbXVtIHNpemUgaW4gc2F0b3NoaXMgb2YgdW5zcGVudCB0byB1c2UgKHRvIHByZXZlbnQgc3BlbmRpbmcgdW5zcGVudHMgd29ydGggbGVzcyB0aGFuIGZlZSBhZGRlZCkuIERlZmF1bHRzIHRvIDAuXG4vLyAgIGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3M6IFVzZSB0aGlzIHNpbmdsZSBrZXkgYWRkcmVzcyB0byBwYXkgZmVlc1xuLy8gICBmZWVTaW5nbGVLZXlXSUY6IFVzZSB0aGUgYWRkcmVzcyBiYXNlZCBvbiB0aGlzIHByaXZhdGUga2V5IHRvIHBheSBmZWVzXG4vLyAgIHVuc3BlbnRzRmV0Y2hQYXJhbXM6IEV4dHJhIHBhcmFtZXRlcnMgdG8gdXNlIGZvciBmZXRjaGluZyB1bnNwZW50cyBmb3IgdGhpcyB0cmFuc2FjdGlvblxuZXhwb3J0cy5jcmVhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBjb25zdCBtaW5Db25maXJtcyA9IHBhcmFtcy5taW5Db25maXJtcyB8fCAwO1xuICBjb25zdCB2YWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy52YWxpZGF0ZTtcbiAgbGV0IHJlY2lwaWVudHM6IHsgYWRkcmVzczogc3RyaW5nOyBhbW91bnQ6IG51bWJlcjsgc2NyaXB0Pzogc3RyaW5nOyB0cmF2ZWxJbmZvPzogYW55OyB9W10gPSBbXTtcbiAgbGV0IG9wUmV0dXJuczogeyBtZXNzYWdlOiBzdHJpbmc7IGFtb3VudDogbnVtYmVyOyB9W10gPSBbXTtcbiAgbGV0IGV4dHJhQ2hhbmdlQW1vdW50czogbnVtYmVyW10gPSBbXTtcbiAgbGV0IGVzdFR4U2l6ZTogbnVtYmVyO1xuICBsZXQgdHJhdmVsSW5mb3M7XG5cbiAgLy8gU2FuaXR5IGNoZWNrIHRoZSBhcmd1bWVudHMgcGFzc2VkIGluXG4gIGlmICghXy5pc09iamVjdChwYXJhbXMud2FsbGV0KSB8fFxuICAocGFyYW1zLmZlZSAmJiAhXy5pc051bWJlcihwYXJhbXMuZmVlKSkgfHxcbiAgKHBhcmFtcy5mZWVSYXRlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5mZWVSYXRlKSkgfHxcbiAgIV8uaXNJbnRlZ2VyKG1pbkNvbmZpcm1zKSB8fFxuICAocGFyYW1zLmZvcmNlQ2hhbmdlQXRFbmQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5mb3JjZUNoYW5nZUF0RW5kKSkgfHxcbiAgKHBhcmFtcy5jaGFuZ2VBZGRyZXNzICYmICFfLmlzU3RyaW5nKHBhcmFtcy5jaGFuZ2VBZGRyZXNzKSkgfHxcbiAgKHBhcmFtcy5ub1NwbGl0Q2hhbmdlICYmICFfLmlzQm9vbGVhbihwYXJhbXMubm9TcGxpdENoYW5nZSkpIHx8XG4gIChwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMgJiYgIV8uaXNJbnRlZ2VyKHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cykpIHx8XG4gICh2YWxpZGF0ZSAmJiAhXy5pc0Jvb2xlYW4odmFsaWRhdGUpKSB8fFxuICAocGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSkpIHx8XG4gIChwYXJhbXMubWluVW5zcGVudFNpemUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLm1pblVuc3BlbnRTaXplKSkgfHxcbiAgKHBhcmFtcy5tYXhGZWVSYXRlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5tYXhGZWVSYXRlKSkgfHxcbiAgLy8gdGhpcyBzaG91bGQgYmUgYW4gYXJyYXkgYW5kIGl0cyBsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAxXG4gIChwYXJhbXMudW5zcGVudHMgJiYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy51bnNwZW50cykgfHwgcGFyYW1zLnVuc3BlbnRzLmxlbmd0aCA8IDEpKSB8fFxuICAocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCAmJiAhXy5pc0ludGVnZXIocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCkpIHx8XG4gIChwYXJhbXMuaW5zdGFudCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmluc3RhbnQpKSB8fFxuICAocGFyYW1zLmJpdGdvRmVlICYmICFfLmlzT2JqZWN0KHBhcmFtcy5iaXRnb0ZlZSkpIHx8XG4gIChwYXJhbXMudW5zcGVudHNGZXRjaFBhcmFtcyAmJiAhXy5pc09iamVjdChwYXJhbXMudW5zcGVudHNGZXRjaFBhcmFtcykpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgY29uc3QgYml0Z28gPSBwYXJhbXMud2FsbGV0LmJpdGdvO1xuICBjb25zdCBjb25zdGFudHMgPSBiaXRnby5nZXRDb25zdGFudHMoKTtcbiAgY29uc3QgbmV0d29yayA9IGdldE5ldHdvcmsoY29tbW9uLkVudmlyb25tZW50c1tiaXRnby5nZXRFbnYoKV0ubmV0d29yayk7XG5cbiAgLy8gVGhlIHVzZXIgY2FuIHNwZWNpZnkgYSBzZXBlcmF0ZSwgc2luZ2xlLWtleSB3YWxsZXQgZm9yIHRoZSBwdXJwb3NlcyBvZiBwYXlpbmcgbWluZXIncyBmZWVzXG4gIC8vIFdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiB0aGlzIGNhbiBiZSBzcGVjaWZpZWQgYXMgYW4gaW5wdXQgYWRkcmVzcyBvciB0aGUgcHJpdmF0ZSBrZXkgaW4gV0lGXG4gIGxldCBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzO1xuICBsZXQgZmVlU2luZ2xlS2V5SW5wdXRBbW91bnQgPSAwO1xuICBpZiAocGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgYml0Y29pbi5hZGRyZXNzLmZyb21CYXNlNThDaGVjayhwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyk7XG4gICAgICBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID0gcGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3M7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpdGNvaW4gYWRkcmVzczogJyArIHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyYW1zLmZlZVNpbmdsZUtleVdJRikge1xuICAgIGNvbnN0IGZlZVNpbmdsZUtleSA9IGJpdGNvaW4uRUNQYWlyLmZyb21XSUYocGFyYW1zLmZlZVNpbmdsZUtleVdJRiwgbmV0d29yayk7XG4gICAgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA9IGZlZVNpbmdsZUtleS5nZXRBZGRyZXNzKCk7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVzIGJvdGgsIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyBjb3JyZXNwb25kcyB0byB0aGUgYWRkcmVzcyBvZiBmZWVTaW5nbGVLZXlXSUZcbiAgICBpZiAocGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgJiZcbiAgICBwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyAhPT0gZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzOiAnICsgcGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgK1xuICAgICAgJyBkaWQgbm90IGNvcnJlc3BvbmQgdG8gYWRkcmVzcyBvZiBmZWVTaW5nbGVLZXlXSUY6ICcgKyBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLnJlY2lwaWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWNpcGllbnRzIG11c3QgYmUgYXJyYXkgb2YgeyBhZGRyZXNzOiBhYmMsIGFtb3VudDogMTAwMDAwIH0gb2JqZWN0cycpO1xuICB9XG5cbiAgbGV0IGZlZVBhcmFtc0RlZmluZWQgPSAwO1xuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZSkpIHtcbiAgICBmZWVQYXJhbXNEZWZpbmVkKys7XG4gIH1cblxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZVJhdGUpKSB7XG4gICAgZmVlUGFyYW1zRGVmaW5lZCsrO1xuICB9XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQpKSB7XG4gICAgZmVlUGFyYW1zRGVmaW5lZCsrO1xuICB9XG5cbiAgaWYgKGZlZVBhcmFtc0RlZmluZWQgPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBtb3JlIHRoYW4gb25lIG9mIGZlZSwgZmVlUmF0ZSBhbmQgZmVlVHhDb25maXJtVGFyZ2V0Jyk7XG4gIH1cblxuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMubWF4RmVlUmF0ZSkpIHtcbiAgICBwYXJhbXMubWF4RmVlUmF0ZSA9IGNvbnN0YW50cy5tYXhGZWVSYXRlO1xuICB9XG5cbiAgLy8gQ29udmVydCB0aGUgb2xkIGZvcm1hdCBvZiBwYXJhbXMucmVjaXBpZW50cyAoZGljdGlvbmFyeSBvZiBhZGRyZXNzOmFtb3VudCkgdG8gbmV3IGZvcm1hdDogeyBkZXN0aW5hdGlvbkFkZHJlc3MsIGFtb3VudCB9XG4gIGlmICghKHBhcmFtcy5yZWNpcGllbnRzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgcmVjaXBpZW50cyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcy5yZWNpcGllbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGRlc3RpbmF0aW9uQWRkcmVzcykge1xuICAgICAgY29uc3QgYW1vdW50ID0gcGFyYW1zLnJlY2lwaWVudHNbZGVzdGluYXRpb25BZGRyZXNzXTtcbiAgICAgIHJlY2lwaWVudHMucHVzaCh7IGFkZHJlc3M6IGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50OiBhbW91bnQgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVjaXBpZW50cyA9IHBhcmFtcy5yZWNpcGllbnRzO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5vcFJldHVybnMpIHtcbiAgICBpZiAoIShwYXJhbXMub3BSZXR1cm5zIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBvcFJldHVybnMgPSBbXTtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy5vcFJldHVybnMpLmZvckVhY2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJhbXMub3BSZXR1cm5zW21lc3NhZ2VdO1xuICAgICAgICBvcFJldHVybnMucHVzaCh7IG1lc3NhZ2UsIGFtb3VudCB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcFJldHVybnMgPSBwYXJhbXMub3BSZXR1cm5zO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZWNpcGllbnRzLmxlbmd0aCA9PT0gMCAmJiBvcFJldHVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHJlY2lwaWVudCcpO1xuICB9XG5cbiAgbGV0IGZlZSA9IHBhcmFtcy5mZWU7XG4gIGxldCBmZWVSYXRlID0gcGFyYW1zLmZlZVJhdGU7XG5cbiAgLy8gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBjbGFzcyB3aWxsIGNvbXB1dGUgdGhlIGZlZVxuICBjb25zdCBzaG91bGRDb21wdXRlQmVzdEZlZSA9IChfLmlzVW5kZWZpbmVkKGZlZSkpO1xuXG4gIGxldCB0b3RhbE91dHB1dEFtb3VudCA9IDA7XG5cbiAgcmVjaXBpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHJlY2lwaWVudCkge1xuICAgIGlmIChfLmlzU3RyaW5nKHJlY2lwaWVudC5hZGRyZXNzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYml0Y29pbi5hZGRyZXNzLmZyb21CYXNlNThDaGVjayhyZWNpcGllbnQuYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaXRjb2luIGFkZHJlc3M6ICcgKyByZWNpcGllbnQuYWRkcmVzcyk7XG4gICAgICB9XG4gICAgICBpZiAoISFyZWNpcGllbnQuc2NyaXB0KSB7XG4gICAgICAgIC8vIEEgc2NyaXB0IHdhcyBwcm92aWRlZCBhcyB3ZWxsIC0gdmFsaWRhdGUgdGhhdCB0aGUgYWRkcmVzcyBjb3JyZXNwb25kcyB0byB0aGF0XG4gICAgICAgIGlmIChiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQocmVjaXBpZW50LmFkZHJlc3MsIG5ldHdvcmspLnRvU3RyaW5nKCdoZXgnKSAhPT0gcmVjaXBpZW50LnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBzY3JpcHQgYW5kIGFkZHJlc3MgcHJvdmlkZWQgYnV0IHRoZXkgZGlkIG5vdCBtYXRjaDogJyArIHJlY2lwaWVudC5hZGRyZXNzICsgJyAnICsgcmVjaXBpZW50LnNjcmlwdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFfLmlzSW50ZWdlcihyZWNpcGllbnQuYW1vdW50KSB8fCByZWNpcGllbnQuYW1vdW50IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFtb3VudCBmb3IgJyArIHJlY2lwaWVudC5hZGRyZXNzICsgJzogJyArIHJlY2lwaWVudC5hbW91bnQpO1xuICAgIH1cbiAgICB0b3RhbE91dHB1dEFtb3VudCArPSByZWNpcGllbnQuYW1vdW50O1xuICB9KTtcblxuICBvcFJldHVybnMuZm9yRWFjaChmdW5jdGlvbihvcFJldHVybikge1xuICAgIHRvdGFsT3V0cHV0QW1vdW50ICs9IG9wUmV0dXJuLmFtb3VudDtcbiAgfSk7XG5cbiAgbGV0IGJpdGdvRmVlSW5mbyA9IHBhcmFtcy5iaXRnb0ZlZTtcbiAgaWYgKGJpdGdvRmVlSW5mbyAmJlxuICAoIV8uaXNJbnRlZ2VyKGJpdGdvRmVlSW5mby5hbW91bnQpIHx8ICFfLmlzU3RyaW5nKGJpdGdvRmVlSW5mby5hZGRyZXNzKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYml0Z29GZWVJbmZvJyk7XG4gIH1cblxuICAvLyBUaGUgdG90YWwgYW1vdW50IG5lZWRlZCBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgbGV0IHRvdGFsQW1vdW50ID0gdG90YWxPdXRwdXRBbW91bnQgKyAoZmVlIHx8IDApO1xuXG4gIC8vIFRoZSBsaXN0IG9mIHVuc3BlbnQgdHJhbnNhY3Rpb25zIGJlaW5nIHVzZWQgaW4gdGhpcyB0cmFuc2FjdGlvbi5cbiAgbGV0IHVuc3BlbnRzO1xuXG4gIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgdW5zcGVudHMgb24gdGhpcyB3YWxsZXRcbiAgbGV0IHRvdGFsVW5zcGVudHNDb3VudDtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHVuc3BlbnRzIHdlIGZldGNoZWQgZnJvbSB0aGUgc2VydmVyLCBiZWZvcmUgZmlsdGVyaW5nXG4gIGxldCBmZXRjaGVkVW5zcGVudHNDb3VudDtcblxuICAvLyBUaGUgbGlzdCBvZiB1bnNwZW50IHRyYW5zYWN0aW9ucyBiZWluZyB1c2VkIHdpdGggemVyby1jb25maXJtYXRpb25zXG4gIGxldCB6ZXJvQ29uZlVuc3BlbnRUeElkcztcblxuICAvLyBUaGUgc3VtIG9mIHRoZSBpbnB1dCB2YWx1ZXMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gIGxldCBpbnB1dEFtb3VudDtcblxuICBsZXQgY2hhbmdlT3V0cHV0czogT3V0cHV0W10gPSBbXTtcblxuICAvLyBUaGUgdHJhbnNhY3Rpb24uXG4gIGxldCB0cmFuc2FjdGlvbiA9IG5ldyBiaXRjb2luLlRyYW5zYWN0aW9uQnVpbGRlcihuZXR3b3JrKTtcblxuICBjb25zdCBnZXRCaXRHb0ZlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoYml0Z29GZWVJbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXMud2FsbGV0LmdldEJpdEdvRmVlKHsgYW1vdW50OiB0b3RhbE91dHB1dEFtb3VudCwgaW5zdGFudDogcGFyYW1zLmluc3RhbnQgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5mZWUgPiAwKSB7XG4gICAgICAgICAgYml0Z29GZWVJbmZvID0ge1xuICAgICAgICAgICAgYW1vdW50OiByZXN1bHQuZmVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChiaXRnb0ZlZUluZm8gJiYgYml0Z29GZWVJbmZvLmFtb3VudCA+IDApIHtcbiAgICAgICAgdG90YWxBbW91bnQgKz0gYml0Z29GZWVJbmZvLmFtb3VudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBnZXRCaXRHb0ZlZUFkZHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBiaXRnb0ZlZUluZm8sIG9yIGFkZHJlc3MgaXMgYWxyZWFkeSBzZXQsIGRvbid0IGdldCBhIG5ldyBvbmVcbiAgICAgIGlmICghYml0Z29GZWVJbmZvIHx8IGJpdGdvRmVlSW5mby5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaXRnby5nZXRCaXRHb0ZlZUFkZHJlc3MoKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIGJpdGdvRmVlSW5mby5hZGRyZXNzID0gcmVzdWx0LmFkZHJlc3M7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZXQgYSBkeW5hbWljIGZlZSBlc3RpbWF0ZSBmcm9tIHRoZSBCaXRHbyBzZXJ2ZXIgaWYgZmVlVHhDb25maXJtVGFyZ2V0XG4gIC8vIGlzIHNwZWNpZmllZCBvciBpZiBubyBmZWUtcmVsYXRlZCBwYXJhbXMgYXJlIHNwZWNpZmllZFxuICBjb25zdCBnZXREeW5hbWljRmVlUmF0ZUVzdGltYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQgfHwgIWZlZVBhcmFtc0RlZmluZWQpIHtcbiAgICAgIHJldHVybiBiaXRnby5lc3RpbWF0ZUZlZSh7XG4gICAgICAgIG51bUJsb2NrczogcGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCxcbiAgICAgICAgbWF4RmVlOiBwYXJhbXMubWF4RmVlUmF0ZSxcbiAgICAgICAgaW5wdXRzOiB6ZXJvQ29uZlVuc3BlbnRUeElkcyxcbiAgICAgICAgdHhTaXplOiBlc3RUeFNpemUsXG4gICAgICAgIGNwZnBBd2FyZTogdHJ1ZVxuICAgICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBlc3RpbWF0ZWRGZWVSYXRlID0gcmVzdWx0LmNwZnBGZWVQZXJLYjtcbiAgICAgICAgY29uc3QgbWluaW11bSA9IHBhcmFtcy5pbnN0YW50ID8gTWF0aC5tYXgoY29uc3RhbnRzLm1pbkZlZVJhdGUsIGNvbnN0YW50cy5taW5JbnN0YW50RmVlUmF0ZSkgOiBjb25zdGFudHMubWluRmVlUmF0ZTtcbiAgICAgICAgLy8gNSBzYXRvc2hpcyBwZXIgYnl0ZVxuICAgICAgICAvLyBpdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB0aGUgcGFkZGluZyBvbmx5IGFwcGxpZXMgd2hlbiB0aGUgdGhyZXNob2xkIGlzIGNyb3NzZWQsIGJ1dCBub3Qgd2hlbiB0aGUgZGVsdGEgaXMgbGVzcyB0aGFuIHRoZSBwYWRkaW5nXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSA1MDAwO1xuICAgICAgICBpZiAoZXN0aW1hdGVkRmVlUmF0ZSA8IG1pbmltdW0pIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhuZXcgRGF0ZSgpICsgJzogRXJyb3Igd2hlbiBlc3RpbWF0aW5nIGZlZSBmb3Igc2VuZCBmcm9tICcgKyBwYXJhbXMud2FsbGV0LmlkKCkgKyAnLCBpdCB3YXMgdG9vIGxvdyAtICcgKyBlc3RpbWF0ZWRGZWVSYXRlKTtcbiAgICAgICAgICBmZWVSYXRlID0gbWluaW11bSArIHBhZGRpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXN0aW1hdGVkRmVlUmF0ZSA+IHBhcmFtcy5tYXhGZWVSYXRlKSB7XG4gICAgICAgICAgZmVlUmF0ZSA9IHBhcmFtcy5tYXhGZWVSYXRlIC0gcGFkZGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZWVSYXRlID0gZXN0aW1hdGVkRmVlUmF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmVlUmF0ZTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBzYW5pdHkgY2hlY2sgZmFpbGVkIG9uIHR4IHNpemVcbiAgICAgICAgaWYgKF8uaW5jbHVkZXMoZS5tZXNzYWdlLCAnaW52YWxpZCB0eFNpemUnKSkge1xuICAgICAgICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY291bGRuJ3QgZXN0aW1hdGUgdGhlIGZlZSwgcHJvY2VlZCB1c2luZyB0aGUgZGVmYXVsdFxuICAgICAgICAgIGZlZVJhdGUgPSBjb25zdGFudHMuZmFsbGJhY2tGZWVSYXRlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBlc3RpbWF0aW5nIGZlZSBmb3Igc2VuZCBmcm9tICcgKyBwYXJhbXMud2FsbGV0LmlkKCkgKyAnOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cblxuICAvLyBHZXQgdGhlIHVuc3BlbnRzIGZvciB0aGUgc2VuZGluZyB3YWxsZXQuXG4gIGNvbnN0IGdldFVuc3BlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAocGFyYW1zLnVuc3BlbnRzKSB7IC8vIHdlIGp1c3Qgd2FubmEgdXNlIGN1c3RvbSB1bnNwZW50c1xuICAgICAgdW5zcGVudHMgPSBwYXJhbXMudW5zcGVudHM7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IGVub3VnaCB1bnNwZW50cyBmb3IgdGhlIHJlcXVlc3RlZCBhbW91bnRcbiAgICBjb25zdCBvcHRpb25zID0gXy5tZXJnZSh7fSwgcGFyYW1zLnVuc3BlbnRzRmV0Y2hQYXJhbXMgfHwge30sIHtcbiAgICAgIHRhcmdldDogdG90YWxBbW91bnQsXG4gICAgICBtaW5TaXplOiBwYXJhbXMubWluVW5zcGVudFNpemUgfHwgMCxcbiAgICAgIGluc3RhbnQ6IHBhcmFtcy5pbnN0YW50LCAvLyBpbnNpc3Qgb24gaW5zdGFudCB1bnNwZW50cyBvbmx5XG4gICAgICB0YXJnZXRXYWxsZXRVbnNwZW50czogcGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzXG4gICAgfSk7XG4gICAgaWYgKHBhcmFtcy5pbnN0YW50KSB7XG4gICAgICBvcHRpb25zLmluc3RhbnQgPSBwYXJhbXMuaW5zdGFudDsgLy8gaW5zaXN0IG9uIGluc3RhbnQgdW5zcGVudHMgb25seVxuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXMud2FsbGV0LnVuc3BlbnRzUGFnZWQob3B0aW9ucylcbiAgICAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICB0b3RhbFVuc3BlbnRzQ291bnQgPSByZXN1bHRzLnRvdGFsO1xuICAgICAgZmV0Y2hlZFVuc3BlbnRzQ291bnQgPSByZXN1bHRzLmNvdW50O1xuICAgICAgdW5zcGVudHMgPSByZXN1bHRzLnVuc3BlbnRzLmZpbHRlcihmdW5jdGlvbih1KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gdS5jb25maXJtYXRpb25zIHx8IDA7XG4gICAgICAgIGlmICghcGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAmJiB1LmlzQ2hhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpcm1zID49IG1pbkNvbmZpcm1zO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFib3J0IGVhcmx5IGlmIHRoZXJlJ3Mgbm8gdmlhYmxlIHVuc3BlbnRzLCBiZWNhdXNlIGl0IHdvbid0IGJlIHBvc3NpYmxlIHRvIGNyZWF0ZSB0aGUgdHhuIGxhdGVyXG4gICAgICBpZiAodW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IEVycm9yKCcwIHVuc3BlbnRzIGF2YWlsYWJsZSBmb3IgdHJhbnNhY3Rpb24gY3JlYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIGFycmF5IG9mIHVuY29uZmlybWVkIHVuc3BlbnQgSUQgc3RyaW5ncyBvZiB0aGUgZm9ybSBcInR4SGFzaDpvdXRwdXRJbmRleFwiXG4gICAgICB6ZXJvQ29uZlVuc3BlbnRUeElkcyA9IF8ocmVzdWx0cy51bnNwZW50cykuZmlsdGVyKGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuICF1LmNvbmZpcm1hdGlvbnM7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gdS50eF9oYXNoICsgJzonICsgdS50eF9vdXRwdXRfbjtcbiAgICAgIH0pLnZhbHVlKCk7XG4gICAgICBpZiAoXy5pc0VtcHR5KHplcm9Db25mVW5zcGVudFR4SWRzKSkge1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgYW4gZW1wdHkgYXJyYXkgb2YgaW5wdXRzIHRvIHRoZSBzZXJ2ZXIsIGJlY2F1c2UgaXQgYXNzdW1lcyBpZiB0aGVcbiAgICAgICAgLy8gaW5wdXRzIGFyZ3VtZW50cyBleGlzdHMsIGl0IGNvbnRhaW5zIHZhbHVlc1xuICAgICAgICB6ZXJvQ29uZlVuc3BlbnRUeElkcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCByZXNwZWN0IHRoZSBvbGQgc3BsaXRDaGFuZ2VTaXplPTAgcGFyYW1ldGVyXG4gICAgICBpZiAoIXBhcmFtcy5ub1NwbGl0Q2hhbmdlICYmIHBhcmFtcy5zcGxpdENoYW5nZVNpemUgIT09IDApIHtcbiAgICAgICAgZXh0cmFDaGFuZ2VBbW91bnRzID0gcmVzdWx0cy5leHRyYUNoYW5nZUFtb3VudHMgfHwgW107XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSB1bnNwZW50cyBmb3IgdGhlIHNpbmdsZSBrZXkgZmVlIGFkZHJlc3NcbiAgbGV0IGZlZVNpbmdsZUtleVVuc3BlbnRzOiBCaXRHb1Vuc3BlbnRbXSA9IFtdO1xuICBjb25zdCBnZXRVbnNwZW50c0ZvclNpbmdsZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICBsZXQgZmVlVGFyZ2V0ID0gMC4wMWU4O1xuICAgICAgaWYgKHBhcmFtcy5pbnN0YW50KSB7XG4gICAgICAgIGZlZVRhcmdldCArPSB0b3RhbEFtb3VudCAqIDAuMDAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpdGdvLmdldChiaXRnby51cmwoJy9hZGRyZXNzLycgKyBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzICsgJy91bnNwZW50cz90YXJnZXQ9JyArIGZlZVRhcmdldCkpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UuYm9keS50b3RhbCA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB1bnNwZW50cyBhdmFpbGFibGUgaW4gc2luZ2xlIGtleSBmZWUgc291cmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmVlU2luZ2xlS2V5VW5zcGVudHMgPSByZXNwb25zZS5ib2R5LnVuc3BlbnRzO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGxldCBtaW5lckZlZUluZm86IGFueSA9IHt9O1xuICBsZXQgdHhJbmZvOiBhbnkgPSB7fTtcblxuICAvLyBJdGVyYXRlIHVuc3BlbnRzLCBzdW0gdGhlIGlucHV0cywgYW5kIHNhdmUgX2lucHV0cyB3aXRoIHRoZSB0b3RhbFxuICAvLyBpbnB1dCBhbW91bnQgYW5kIGZpbmFsIGxpc3Qgb2YgaW5wdXRzIHRvIHVzZSB3aXRoIHRoZSB0cmFuc2FjdGlvbi5cbiAgbGV0IGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZDogQml0R29VbnNwZW50W10gPSBbXTtcblxuICBjb25zdCBjb2xsZWN0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF1bnNwZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gdW5zcGVudHMgYXZhaWxhYmxlIG9uIHdhbGxldCcpO1xuICAgIH1cbiAgICBpbnB1dEFtb3VudCA9IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNvc3Qgb2Ygc3BlbmRpbmcgYSBzaW5nbGUgaW5wdXQsIGkuZS4gdGhlIHNtYWxsZXN0IGVjb25vbWljYWwgdW5zcGVudCB2YWx1ZVxuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmIChfLmlzTnVtYmVyKHBhcmFtcy5mZWVSYXRlKSB8fCBfLmlzTnVtYmVyKHBhcmFtcy5vcmlnaW5hbEZlZVJhdGUpKSB7XG4gICAgICAgIHJldHVybiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZVJhdGUpID8gcGFyYW1zLmZlZVJhdGUgOiBwYXJhbXMub3JpZ2luYWxGZWVSYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiaXRnby5lc3RpbWF0ZUZlZSh7XG4gICAgICAgICAgbnVtQmxvY2tzOiBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0LFxuICAgICAgICAgIG1heEZlZTogcGFyYW1zLm1heEZlZVJhdGVcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZmVlUmF0ZUVzdGltYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGZlZVJhdGVFc3RpbWF0ZS5mZWVQZXJLYjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbihmZWVSYXRlKSB7XG4gICAgICAvLyBEb24ndCBzcGVuZCBpbnB1dHMgdGhhdCBjYW5ub3QgcGF5IGZvciB0aGVpciBvd24gY29zdC5cbiAgICAgIGxldCBtaW5JbnB1dFZhbHVlID0gMDtcbiAgICAgIGlmIChfLmlzSW50ZWdlcihwYXJhbXMubWluVW5zcGVudFNpemUpKSB7XG4gICAgICAgIG1pbklucHV0VmFsdWUgPSBwYXJhbXMubWluVW5zcGVudFNpemU7XG4gICAgICB9XG5cbiAgICAgIGxldCBwcnVuZWRVbnNwZW50Q291bnQgPSAwO1xuICAgICAgY29uc3Qgb3JpZ2luYWxVbnNwZW50Q291bnQgPSB1bnNwZW50cy5sZW5ndGg7XG4gICAgICB1bnNwZW50cyA9IF8uZmlsdGVyKHVuc3BlbnRzLCBmdW5jdGlvbih1bnNwZW50KSB7XG4gICAgICAgIGNvbnN0IGlzU2Vnd2l0SW5wdXQgPSAhIXVuc3BlbnQud2l0bmVzc1NjcmlwdDtcbiAgICAgICAgY29uc3QgY3VycmVudElucHV0U2l6ZSA9IGlzU2Vnd2l0SW5wdXQgPyBWaXJ0dWFsU2l6ZXMudHhQMnNoUDJ3c2hJbnB1dFNpemUgOiBWaXJ0dWFsU2l6ZXMudHhQMnNoSW5wdXRTaXplO1xuICAgICAgICBjb25zdCBmZWVCYXNlZE1pbklucHV0VmFsdWUgPSAoZmVlUmF0ZSAqIGN1cnJlbnRJbnB1dFNpemUpIC8gMTAwMDtcbiAgICAgICAgY29uc3QgY3VycmVudE1pbklucHV0VmFsdWUgPSBNYXRoLm1heChtaW5JbnB1dFZhbHVlLCBmZWVCYXNlZE1pbklucHV0VmFsdWUpO1xuICAgICAgICBpZiAoY3VycmVudE1pbklucHV0VmFsdWUgPiB1bnNwZW50LnZhbHVlKSB7XG4gICAgICAgICAgLy8gcHJ1bmluZyB1bnNwZW50XG4gICAgICAgICAgY29uc3QgcHJ1bmVEZXRhaWxzID0ge1xuICAgICAgICAgICAgZ2VuZXJhbE1pbklucHV0VmFsdWU6IG1pbklucHV0VmFsdWUsXG4gICAgICAgICAgICBmZWVCYXNlZE1pbklucHV0VmFsdWUsXG4gICAgICAgICAgICBjdXJyZW50TWluSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIGZlZVJhdGUsXG4gICAgICAgICAgICBpbnB1dFNpemU6IGN1cnJlbnRJbnB1dFNpemUsXG4gICAgICAgICAgICB1bnNwZW50OiB1bnNwZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgcHJ1bmluZyB1bnNwZW50OiAke0pTT04uc3RyaW5naWZ5KHBydW5lRGV0YWlscywgbnVsbCwgNCl9YCk7XG4gICAgICAgICAgcHJ1bmVkVW5zcGVudENvdW50Kys7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcnVuZWRVbnNwZW50Q291bnQgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBwcnVuZWQgJHtwcnVuZWRVbnNwZW50Q291bnR9IG91dCBvZiAke29yaWdpbmFsVW5zcGVudENvdW50fSB1bnNwZW50c2ApO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5zdWZmaWNpZW50IGZ1bmRzJyk7XG4gICAgICB9XG4gICAgICBsZXQgc2Vnd2l0SW5wdXRDb3VudCA9IDA7XG4gICAgICB1bnNwZW50cy5ldmVyeShmdW5jdGlvbih1bnNwZW50KSB7XG4gICAgICAgIGlmICh1bnNwZW50LndpdG5lc3NTY3JpcHQpIHtcbiAgICAgICAgICBzZWd3aXRJbnB1dENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRBbW91bnQgKz0gdW5zcGVudC52YWx1ZTtcbiAgICAgICAgdHJhbnNhY3Rpb24uYWRkSW5wdXQodW5zcGVudC50eF9oYXNoLCB1bnNwZW50LnR4X291dHB1dF9uLCAweGZmZmZmZmZmKTtcblxuICAgICAgICByZXR1cm4gKGlucHV0QW1vdW50IDwgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyB0b3RhbE91dHB1dEFtb3VudCA6IHRvdGFsQW1vdW50KSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgcGF5aW5nIGZlZXMgZnJvbSBhbiBleHRlcm5hbCBzaW5nbGUga2V5IHdhbGxldCwgYWRkIHRoZSBpbnB1dHNcbiAgICAgIGlmIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgdGhlIGFtb3VudCB1c2VkIGluIHRoZSBmZWUgaW5wdXRzIHNvIHdlIGNhbiBnZXQgY2hhbmdlIGxhdGVyXG4gICAgICAgIGZlZVNpbmdsZUtleUlucHV0QW1vdW50ID0gMDtcbiAgICAgICAgZmVlU2luZ2xlS2V5VW5zcGVudHNVc2VkID0gW107XG4gICAgICAgIGZlZVNpbmdsZUtleVVuc3BlbnRzLmV2ZXJ5KGZ1bmN0aW9uKHVuc3BlbnQpIHtcbiAgICAgICAgICBmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCArPSB1bnNwZW50LnZhbHVlO1xuICAgICAgICAgIGlucHV0QW1vdW50ICs9IHVuc3BlbnQudmFsdWU7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkSW5wdXQodW5zcGVudC50eF9oYXNoLCB1bnNwZW50LnR4X291dHB1dF9uKTtcbiAgICAgICAgICBmZWVTaW5nbGVLZXlVbnNwZW50c1VzZWQucHVzaCh1bnNwZW50KTtcbiAgICAgICAgICAvLyB1c2UgdGhlIGZlZSB3YWxsZXQgdG8gcGF5IG1pbmVyIGZlZXMgYW5kIHBvdGVudGlhbGx5IGluc3RhbnQgZmVlc1xuICAgICAgICAgIHJldHVybiAoZmVlU2luZ2xlS2V5SW5wdXRBbW91bnQgPCAoZmVlICsgKGJpdGdvRmVlSW5mbyA/IGJpdGdvRmVlSW5mby5hbW91bnQgOiAwKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdHhJbmZvID0ge1xuICAgICAgICBuUDJzaElucHV0czogdHJhbnNhY3Rpb24udHguaW5zLmxlbmd0aCAtIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID8gMSA6IDApIC0gc2Vnd2l0SW5wdXRDb3VudCxcbiAgICAgICAgblAyc2hQMndzaElucHV0czogc2Vnd2l0SW5wdXRDb3VudCxcbiAgICAgICAgblAycGtoSW5wdXRzOiBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID8gMSA6IDAsXG4gICAgICAgIG5PdXRwdXRzOiAoXG4gICAgICAgICAgcmVjaXBpZW50cy5sZW5ndGggKyAxICsgLy8gcmVjaXBpZW50cyBhbmQgY2hhbmdlXG4gICAgICAgIGV4dHJhQ2hhbmdlQW1vdW50cy5sZW5ndGggKyAvLyBleHRyYSBjaGFuZ2Ugc3BsaXR0aW5nXG4gICAgICAgIChiaXRnb0ZlZUluZm8gJiYgYml0Z29GZWVJbmZvLmFtb3VudCA+IDAgPyAxIDogMCkgKyAvLyBhZGQgb3V0cHV0IGZvciBiaXRnbyBmZWVcbiAgICAgICAgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyAxIDogMCkgLy8gYWRkIHNpbmdsZSBrZXkgc291cmNlIGFkZHJlc3MgY2hhbmdlXG4gICAgICAgIClcbiAgICAgIH07XG5cbiAgICAgIGVzdFR4U2l6ZSA9IGVzdGltYXRlVHJhbnNhY3Rpb25TaXplKHtcbiAgICAgICAgblAyc2hJbnB1dHM6IHR4SW5mby5uUDJzaElucHV0cyxcbiAgICAgICAgblAyc2hQMndzaElucHV0czogdHhJbmZvLm5QMnNoUDJ3c2hJbnB1dHMsXG4gICAgICAgIG5QMnBraElucHV0czogdHhJbmZvLm5QMnBraElucHV0cyxcbiAgICAgICAgbk91dHB1dHM6IHR4SW5mby5uT3V0cHV0c1xuICAgICAgfSk7XG4gICAgfSkudGhlbihnZXREeW5hbWljRmVlUmF0ZUVzdGltYXRlKVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgbWluZXJGZWVJbmZvID0gZXhwb3J0cy5jYWxjdWxhdGVNaW5lckZlZUluZm8oe1xuICAgICAgICBiaXRnbzogcGFyYW1zLndhbGxldC5iaXRnbyxcbiAgICAgICAgZmVlUmF0ZTogZmVlUmF0ZSxcbiAgICAgICAgblAyc2hJbnB1dHM6IHR4SW5mby5uUDJzaElucHV0cyxcbiAgICAgICAgblAyc2hQMndzaElucHV0czogdHhJbmZvLm5QMnNoUDJ3c2hJbnB1dHMsXG4gICAgICAgIG5QMnBraElucHV0czogdHhJbmZvLm5QMnBraElucHV0cyxcbiAgICAgICAgbk91dHB1dHM6IHR4SW5mby5uT3V0cHV0c1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaG91bGRDb21wdXRlQmVzdEZlZSkge1xuICAgICAgICBjb25zdCBhcHByb3hpbWF0ZUZlZSA9IG1pbmVyRmVlSW5mby5mZWU7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlY3Vyc2UgPSBfLmlzVW5kZWZpbmVkKGZlZSkgfHwgYXBwcm94aW1hdGVGZWUgPiBmZWU7XG4gICAgICAgIGZlZSA9IGFwcHJveGltYXRlRmVlO1xuICAgICAgICAvLyBSZWNvbXB1dGUgdG90YWxBbW91bnQgZnJvbSBzY3JhdGNoXG4gICAgICAgIHRvdGFsQW1vdW50ID0gZmVlICsgdG90YWxPdXRwdXRBbW91bnQ7XG4gICAgICAgIGlmIChiaXRnb0ZlZUluZm8pIHtcbiAgICAgICAgICB0b3RhbEFtb3VudCArPSBiaXRnb0ZlZUluZm8uYW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZWN1cnNlKSB7XG4gICAgICAgICAgLy8gaWYgZmVlIGNoYW5nZWQsIHJlLWNvbGxlY3QgaW5wdXRzXG4gICAgICAgICAgaW5wdXRBbW91bnQgPSAwO1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IGJpdGNvaW4uVHJhbnNhY3Rpb25CdWlsZGVyKG5ldHdvcmspO1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0SW5wdXRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdG90YWxGZWUgPSBmZWUgKyAoYml0Z29GZWVJbmZvID8gYml0Z29GZWVJbmZvLmFtb3VudCA6IDApO1xuXG4gICAgICBpZiAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgICBjb25zdCBzdW1tZWRTaW5nbGVLZXlVbnNwZW50cyA9IF8uc3VtQnkoZmVlU2luZ2xlS2V5VW5zcGVudHMsICd2YWx1ZScpO1xuICAgICAgICBpZiAodG90YWxGZWUgPiBzdW1tZWRTaW5nbGVLZXlVbnNwZW50cykge1xuICAgICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgZmVlIGFtb3VudCBhdmFpbGFibGUgaW4gc2luZ2xlIGtleSBmZWUgc291cmNlOiAnICsgc3VtbWVkU2luZ2xlS2V5VW5zcGVudHMpO1xuICAgICAgICAgIGVyci5yZXN1bHQgPSB7XG4gICAgICAgICAgICBmZWU6IGZlZSxcbiAgICAgICAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplOiBtaW5lckZlZUluZm8uc2l6ZSxcbiAgICAgICAgICAgIGF2YWlsYWJsZTogaW5wdXRBbW91bnQsXG4gICAgICAgICAgICBiaXRnb0ZlZTogYml0Z29GZWVJbmZvLFxuICAgICAgICAgICAgdHhJbmZvOiB0eEluZm9cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5wdXRBbW91bnQgPCAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA/IHRvdGFsT3V0cHV0QW1vdW50IDogdG90YWxBbW91bnQpKSB7XG4gICAgICAgIC8vIFRoZSB1bnNwZW50cyB3ZSdyZSB1c2luZyBmb3IgaW5wdXRzIGRvIG5vdCBoYXZlIHN1ZmZpY2llbnQgdmFsdWUgb24gdGhlbSB0b1xuICAgICAgICAvLyBzYXRpc2Z5IHRoZSB1c2VyJ3MgcmVxdWVzdGVkIHNwZW5kIGFtb3VudC4gVGhhdCBtYXkgYmUgYmVjYXVzZSB0aGUgd2FsbGV0J3MgYmFsYW5jZVxuICAgICAgICAvLyBpcyBzaW1wbHkgdG9vIGxvdywgb3IgaXQgbWlnaHQgYmUgdGhhdCB0aGUgd2FsbGV0J3MgYmFsYW5jZSBpcyBzdWZmaWNpZW50IGJ1dFxuICAgICAgICAvLyB3ZSBkaWRuJ3QgZmV0Y2ggZW5vdWdoIHVuc3BlbnRzLiBUb28gZmV3IHVuc3BlbnRzIGNvdWxkIHJlc3VsdCBmcm9tIHRoZSB3YWxsZXRcbiAgICAgICAgLy8gaGF2aW5nIG1hbnkgc21hbGwgdW5zcGVudHMgYW5kIHdlIGhpdCBvdXIgbGltaXQgb24gdGhlIG51bWJlciBvZiBpbnB1dHMgd2UgY2FuIHVzZVxuICAgICAgICAvLyBpbiBhIHR4biwgb3IgaXQgbWlnaHQgaGF2ZSBiZWVuIHRoYXQgdGhlIGZpbHRlcnMgdGhlIHVzZXIgcGFzc2VkIGluIChsaWtlIG1pbkNvbmZpcm1zKVxuICAgICAgICAvLyBkaXNxdWFsaWZpZWQgdG9vIG1hbnkgb2YgdGhlIHVuc3BlbnRzXG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICh0b3RhbFVuc3BlbnRzQ291bnQgPT09IGZldGNoZWRVbnNwZW50c0NvdW50KSB7XG4gICAgICAgICAgLy8gd2UgZmV0Y2hlZCBldmVyeSB1bnNwZW50IHRoZSB3YWxsZXQgaGFkLCBidXQgaXQgc3RpbGwgd2Fzbid0IGVub3VnaFxuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcignSW5zdWZmaWNpZW50IGZ1bmRzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2Ugd2VyZW4ndCBhYmxlIHRvIGZldGNoIGFsbCB0aGUgdW5zcGVudHMgb24gdGhlIHdhbGxldFxuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2l6ZSB0b28gbGFyZ2UgZHVlIHRvIHRvbyBtYW55IHVuc3BlbnRzLiBDYW4gc2VuZCBvbmx5ICR7aW5wdXRBbW91bnR9IHNhdG9zaGlzIGluIHRoaXMgdHJhbnNhY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgICBlcnIucmVzdWx0ID0ge1xuICAgICAgICAgIGZlZTogZmVlLFxuICAgICAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICAgICAgZXN0aW1hdGVkU2l6ZTogbWluZXJGZWVJbmZvLnNpemUsXG4gICAgICAgICAgYXZhaWxhYmxlOiBpbnB1dEFtb3VudCxcbiAgICAgICAgICBiaXRnb0ZlZTogYml0Z29GZWVJbmZvLFxuICAgICAgICAgIHR4SW5mbzogdHhJbmZvXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgdGhlIG91dHB1dHMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gIGNvbnN0IGNvbGxlY3RPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKG1pbmVyRmVlSW5mby5zaXplID49IDkwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHRvbyBsYXJnZTogZXN0aW1hdGVkIHNpemUgJyArIG1pbmVyRmVlSW5mby5zaXplICsgJyBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dHM6IE91dHB1dFtdID0gW107XG5cbiAgICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24ocmVjaXBpZW50KSB7XG4gICAgICBsZXQgc2NyaXB0O1xuICAgICAgaWYgKF8uaXNTdHJpbmcocmVjaXBpZW50LmFkZHJlc3MpKSB7XG4gICAgICAgIHNjcmlwdCA9IGJpdGNvaW4uYWRkcmVzcy50b091dHB1dFNjcmlwdChyZWNpcGllbnQuYWRkcmVzcywgbmV0d29yayk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocmVjaXBpZW50LnNjcmlwdCkpIHtcbiAgICAgICAgc2NyaXB0ID0gcmVjaXBpZW50LnNjcmlwdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVpdGhlciByZWNpcGllbnQgYWRkcmVzcyBub3Igc2NyaXB0IHdhcyBwcm92aWRlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZGF0ZSB0cmF2ZWxJbmZvIGlmIGl0IGV4aXN0c1xuICAgICAgbGV0IHRyYXZlbEluZm87XG4gICAgICBpZiAoIV8uaXNFbXB0eShyZWNpcGllbnQudHJhdmVsSW5mbykpIHtcbiAgICAgICAgdHJhdmVsSW5mbyA9IHJlY2lwaWVudC50cmF2ZWxJbmZvO1xuICAgICAgICAvLyBCZXR0ZXIgdG8gYXZvaWQgdHJvdWJsZSBub3csIGJlZm9yZSB0eCBpcyBjcmVhdGVkXG4gICAgICAgIGJpdGdvLnRyYXZlbFJ1bGUoKS52YWxpZGF0ZVRyYXZlbEluZm8odHJhdmVsSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgIHNjcmlwdDogc2NyaXB0LFxuICAgICAgICBhbW91bnQ6IHJlY2lwaWVudC5hbW91bnQsXG4gICAgICAgIHRyYXZlbEluZm86IHRyYXZlbEluZm9cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgb3BSZXR1cm5zLmZvckVhY2goZnVuY3Rpb24oeyBtZXNzYWdlLCBhbW91bnQgfSkge1xuICAgICAgY29uc3Qgc2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuZnJvbUFTTSgnT1BfUkVUVVJOICcgKyBCdWZmZXIuZnJvbShtZXNzYWdlKS50b1N0cmluZygnaGV4JykpO1xuICAgICAgb3V0cHV0cy5wdXNoKHsgc2NyaXB0LCBhbW91bnQgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGFuZ2VPdXRwdXRzID0gZnVuY3Rpb24oY2hhbmdlQW1vdW50OiBudW1iZXIpOiBPdXRwdXRbXSB8IEJsdWViaXJkPE91dHB1dFtdPiB7XG4gICAgICBpZiAoY2hhbmdlQW1vdW50IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZ2F0aXZlIGNoYW5nZSBhbW91bnQ6ICcgKyBjaGFuZ2VBbW91bnQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQ6IE91dHB1dFtdID0gW107XG4gICAgICAvLyBpZiB3ZSBwYWlkIGZlZXMgZnJvbSBhIHNpbmdsZSBrZXkgd2FsbGV0LCByZXR1cm4gdGhlIGZlZSBjaGFuZ2UgZmlyc3RcbiAgICAgIGlmIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGZlZVNpbmdsZUtleVdhbGxldENoYW5nZUFtb3VudCA9IGZlZVNpbmdsZUtleUlucHV0QW1vdW50IC0gKGZlZSArIChiaXRnb0ZlZUluZm8gPyBiaXRnb0ZlZUluZm8uYW1vdW50IDogMCkpO1xuICAgICAgICBpZiAoZmVlU2luZ2xlS2V5V2FsbGV0Q2hhbmdlQW1vdW50ID49IGNvbnN0YW50cy5taW5PdXRwdXRTaXplKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goeyBhZGRyZXNzOiBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzLCBhbW91bnQ6IGZlZVNpbmdsZUtleVdhbGxldENoYW5nZUFtb3VudCB9KTtcbiAgICAgICAgICBjaGFuZ2VBbW91bnQgPSBjaGFuZ2VBbW91bnQgLSBmZWVTaW5nbGVLZXlXYWxsZXRDaGFuZ2VBbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUFtb3VudCA8IGNvbnN0YW50cy5taW5PdXRwdXRTaXplKSB7XG4gICAgICAgIC8vIEdpdmUgaXQgdG8gdGhlIG1pbmVyc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLndhbGxldC50eXBlKCkgPT09ICdzYWZlJykge1xuICAgICAgICByZXR1cm4gcGFyYW1zLndhbGxldC5hZGRyZXNzZXMoKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHsgYWRkcmVzczogcmVzcG9uc2UuYWRkcmVzc2VzWzBdLmFkZHJlc3MsIGFtb3VudDogY2hhbmdlQW1vdW50IH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0cmFDaGFuZ2VUb3RhbCA9IF8uc3VtKGV4dHJhQ2hhbmdlQW1vdW50cyk7XG4gICAgICAvLyBTYW5pdHkgY2hlY2tcbiAgICAgIGlmIChleHRyYUNoYW5nZVRvdGFsID4gY2hhbmdlQW1vdW50KSB7XG4gICAgICAgIGV4dHJhQ2hhbmdlQW1vdW50cyA9IFtdO1xuICAgICAgICBleHRyYUNoYW5nZVRvdGFsID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gY29weSBhbmQgYWRkIHJlbWFpbmluZyBjaGFuZ2UgYW1vdW50XG4gICAgICBjb25zdCBhbGxDaGFuZ2VBbW91bnRzID0gZXh0cmFDaGFuZ2VBbW91bnRzLnNsaWNlKDApO1xuICAgICAgYWxsQ2hhbmdlQW1vdW50cy5wdXNoKGNoYW5nZUFtb3VudCAtIGV4dHJhQ2hhbmdlVG90YWwpO1xuXG4gICAgICAvLyBSZWN1cnNpdmUgYXN5bmMgZnVuYyB0byBhZGQgYWxsIGNoYW5nZSBvdXRwdXRzXG4gICAgICBjb25zdCBhZGRDaGFuZ2VPdXRwdXRzID0gZnVuY3Rpb24oKTogT3V0cHV0W10gfCBCbHVlYmlyZDxPdXRwdXRbXT4ge1xuICAgICAgICBjb25zdCB0aGlzQW1vdW50ID0gYWxsQ2hhbmdlQW1vdW50cy5zaGlmdCgpO1xuICAgICAgICBpZiAoIXRoaXNBbW91bnQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5jaGFuZ2VBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBJZiB1c2VyIHBhc3NlZCBhIGNoYW5nZSBhZGRyZXNzLCB1c2UgaXQgZm9yIGFsbCBvdXRwdXRzXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmNoYW5nZUFkZHJlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgYWRkcmVzcyBwZXIgb3V0cHV0LCBmb3IgcHJpdmFjeVxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHNlZ3dpdCBvciBub3RcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZUNoYWluID0gcGFyYW1zLndhbGxldC5nZXRDaGFuZ2VDaGFpbihwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy53YWxsZXQuY3JlYXRlQWRkcmVzcyh7IGNoYWluOiBjaGFuZ2VDaGFpbiwgdmFsaWRhdGU6IHZhbGlkYXRlIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRyZXNzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbihhZGRyZXNzKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goeyBhZGRyZXNzOiBhZGRyZXNzLCBhbW91bnQ6IHRoaXNBbW91bnQgfSk7XG4gICAgICAgICAgcmV0dXJuIGFkZENoYW5nZU91dHB1dHMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYWRkQ2hhbmdlT3V0cHV0cygpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgY2hhbmdlIG91dHB1dChzKSBhbmQgaW5zdGFudCBmZWUgb3V0cHV0IGlmIGFwcGxpY2FibGVcbiAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldENoYW5nZU91dHB1dHMoaW5wdXRBbW91bnQgLSB0b3RhbEFtb3VudCk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIGNoYW5nZU91dHB1dHMgPSByZXN1bHQ7XG4gICAgICBjb25zdCBleHRyYU91dHB1dHMgPSBjaGFuZ2VPdXRwdXRzLmNvbmNhdChbXSk7IC8vIGNvcHkgdGhlIGFycmF5XG4gICAgICBpZiAoYml0Z29GZWVJbmZvICYmIGJpdGdvRmVlSW5mby5hbW91bnQgPiAwKSB7XG4gICAgICAgIGV4dHJhT3V0cHV0cy5wdXNoKGJpdGdvRmVlSW5mbyk7XG4gICAgICB9XG4gICAgICBleHRyYU91dHB1dHMuZm9yRWFjaChmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgaWYgKChvdXRwdXQgYXMgQWRkcmVzc091dHB1dCkuYWRkcmVzcykge1xuICAgICAgICAgIChvdXRwdXQgYXMgU2NyaXB0T3V0cHV0KS5zY3JpcHQgPVxuICAgICAgICAgICAgYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KChvdXRwdXQgYXMgQWRkcmVzc091dHB1dCkuYWRkcmVzcywgbmV0d29yayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWNpZGUgd2hlcmUgdG8gcHV0IHRoZSBvdXRwdXRzIC0gZGVmYXVsdCBpcyB0byByYW5kb21pemUgdW5sZXNzIGZvcmNlZCB0byBlbmRcbiAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCA/IG91dHB1dHMubGVuZ3RoIDogXy5yYW5kb20oMCwgb3V0cHV0cy5sZW5ndGgpO1xuICAgICAgICBvdXRwdXRzLnNwbGljZShvdXRwdXRJbmRleCwgMCwgb3V0cHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgYWxsIG91dHB1dHMgdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmFkZE91dHB1dCgob3V0cHV0IGFzIFNjcmlwdE91dHB1dCkuc2NyaXB0LCBvdXRwdXQuYW1vdW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB0cmF2ZWxJbmZvcyA9IF8ob3V0cHV0cykubWFwKGZ1bmN0aW9uKG91dHB1dCwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3V0cHV0LnRyYXZlbEluZm87XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQub3V0cHV0SW5kZXggPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKClcbiAgICAgIC52YWx1ZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFNlcmlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24sIHJldHVybmluZyB3aGF0IGlzIG5lZWRlZCB0byBzaWduIGl0XG4gIGNvbnN0IHNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIG9ubHkgbmVlZCB0byByZXR1cm4gdGhlIHVuc3BlbnRzIHRoYXQgd2VyZSB1c2VkIGFuZCBqdXN0IHRoZSBjaGFpblBhdGgsIHJlZGVlbVNjcmlwdCwgYW5kIGluc3RhbnQgZmxhZ1xuICAgIGNvbnN0IHBpY2tlZFVuc3BlbnRzOiBhbnkgPSBfLm1hcCh1bnNwZW50cywgZnVuY3Rpb24odW5zcGVudCkge1xuICAgICAgcmV0dXJuIF8ucGljayh1bnNwZW50LCBbJ2NoYWluUGF0aCcsICdyZWRlZW1TY3JpcHQnLCAnaW5zdGFudCcsICd3aXRuZXNzU2NyaXB0JywgJ3NjcmlwdCcsICd2YWx1ZSddKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcnVuZWRVbnNwZW50cyA9IF8uc2xpY2UocGlja2VkVW5zcGVudHMsIDAsIHRyYW5zYWN0aW9uLnR4Lmlucy5sZW5ndGggLSBmZWVTaW5nbGVLZXlVbnNwZW50c1VzZWQubGVuZ3RoKTtcbiAgICBfLmVhY2goZmVlU2luZ2xlS2V5VW5zcGVudHNVc2VkLCBmdW5jdGlvbihmZWVVbnNwZW50KSB7XG4gICAgICBwcnVuZWRVbnNwZW50cy5wdXNoKHsgcmVkZWVtU2NyaXB0OiBmYWxzZSwgY2hhaW5QYXRoOiBmYWxzZSB9KTsgLy8gbWFyayBhcyBmYWxzZSB0byBzaWduaWZ5IGEgbm9uLW11bHRpc2lnIGFkZHJlc3NcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQ6IGFueSA9IHtcbiAgICAgIHRyYW5zYWN0aW9uSGV4OiB0cmFuc2FjdGlvbi5idWlsZEluY29tcGxldGUoKS50b0hleCgpLFxuICAgICAgdW5zcGVudHM6IHBydW5lZFVuc3BlbnRzLFxuICAgICAgZmVlOiBmZWUsXG4gICAgICBjaGFuZ2VBZGRyZXNzZXM6IGNoYW5nZU91dHB1dHMubWFwKGZ1bmN0aW9uKGNvKSB7XG4gICAgICAgIHJldHVybiBfLnBpY2soY28sIFsnYWRkcmVzcycsICdwYXRoJywgJ2Ftb3VudCddKTtcbiAgICAgIH0pLFxuICAgICAgd2FsbGV0SWQ6IHBhcmFtcy53YWxsZXQuaWQoKSxcbiAgICAgIHdhbGxldEtleWNoYWluczogcGFyYW1zLndhbGxldC5rZXljaGFpbnMsXG4gICAgICBmZWVSYXRlOiBmZWVSYXRlLFxuICAgICAgaW5zdGFudDogcGFyYW1zLmluc3RhbnQsXG4gICAgICBiaXRnb0ZlZTogYml0Z29GZWVJbmZvLFxuICAgICAgZXN0aW1hdGVkU2l6ZTogbWluZXJGZWVJbmZvLnNpemUsXG4gICAgICB0eEluZm86IHR4SW5mbyxcbiAgICAgIHRyYXZlbEluZm9zOiB0cmF2ZWxJbmZvc1xuICAgIH07XG5cbiAgICAvLyBBZGQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKHJlc3VsdC5pbnN0YW50ICYmIGJpdGdvRmVlSW5mbykge1xuICAgICAgcmVzdWx0Lmluc3RhbnRGZWUgPSBfLnBpY2soYml0Z29GZWVJbmZvLCBbJ2Ftb3VudCcsICdhZGRyZXNzJ10pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0Qml0R29GZWUoKTtcbiAgfSlcbiAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJsdWViaXJkLmFsbChbZ2V0Qml0R29GZWVBZGRyZXNzKCksIGdldFVuc3BlbnRzKCksIGdldFVuc3BlbnRzRm9yU2luZ2xlS2V5KCldKTtcbiAgfSlcbiAgLnRoZW4oY29sbGVjdElucHV0cylcbiAgLnRoZW4oY29sbGVjdE91dHB1dHMpXG4gIC50aGVuKHNlcmlhbGl6ZSk7XG59O1xuXG5cbi8qKlxuICogRXN0aW1hdGUgdGhlIHNpemUgb2YgYSB0cmFuc2FjdGlvbiBpbiBieXRlcyBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mXG4gKiBpbnB1dHMgYW5kIG91dHB1dHMgcHJlc2VudC5cbiAqIEBwYXJhbXMgcGFyYW1zIHtcbiAqICAgblAyc2hJbnB1dHM6IG51bWJlciBvZiBQMlNIIChtdWx0aXNpZykgaW5wdXRzXG4gKiAgIG5QMnBraElucHV0czogbnVtYmVyIG9mIFAyUEtIIChzaW5nbGUgc2lnKSBpbnB1dHNcbiAqICAgbk91dHB1dHM6IG51bWJlciBvZiBvdXRwdXRzXG4gKiB9XG4gKlxuICogQHJldHVybnMgc2l6ZTogZXN0aW1hdGVkIHNpemUgb2YgdGhlIHRyYW5zYWN0aW9uIGluIGJ5dGVzXG4gKi9cbmNvbnN0IGVzdGltYXRlVHJhbnNhY3Rpb25TaXplID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm5QMnNoSW5wdXRzKSB8fCBwYXJhbXMublAyc2hJbnB1dHMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgblAyc2hJbnB1dHMnKTtcbiAgfVxuICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5uUDJwa2hJbnB1dHMpIHx8IHBhcmFtcy5uUDJwa2hJbnB1dHMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgblAycGtoSW5wdXRzIHRvIGJlIG51bWVyaWMnKTtcbiAgfVxuICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5uUDJzaFAyd3NoSW5wdXRzKSB8fCBwYXJhbXMublAyc2hQMndzaElucHV0cyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBwb3NpdGl2ZSBuUDJzaFAyd3NoSW5wdXRzIHRvIGJlIG51bWVyaWMnKTtcbiAgfVxuICBpZiAoKHBhcmFtcy5uUDJzaElucHV0cyArIHBhcmFtcy5uUDJzaFAyd3NoSW5wdXRzKSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBhdCBsZWFzdCBvbmUgblAyc2hJbnB1dHMgb3IgblAyc2hQMndzaElucHV0cycpO1xuICB9XG4gIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm5PdXRwdXRzKSB8fCBwYXJhbXMubk91dHB1dHMgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgbk91dHB1dHMnKTtcbiAgfVxuXG5cbiAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgKiBwYXJhbXMublAyc2hJbnB1dHMgK1xuICBWaXJ0dWFsU2l6ZXMudHhQMnNoUDJ3c2hJbnB1dFNpemUgKiAocGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMgfHwgMCkgK1xuICBWaXJ0dWFsU2l6ZXMudHhQMnBraElucHV0U2l6ZVVuY29tcHJlc3NlZEtleSAqIChwYXJhbXMublAycGtoSW5wdXRzIHx8IDApICtcbiAgVmlydHVhbFNpemVzLnR4UDJwa2hPdXRwdXRTaXplICogcGFyYW1zLm5PdXRwdXRzICtcbiAgLy8gaWYgdGhlIHR4IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBzZWd3aXQgaW5wdXQsIHRoZSB0eCBvdmVyaGVhZCBpcyBpbmNyZWFzZWQgYnkgMVxuICBWaXJ0dWFsU2l6ZXMudHhPdmVyaGVhZFNpemUgKyAocGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMgPiAwID8gMSA6IDApO1xuXG4gIHJldHVybiBlc3RpbWF0ZWRTaXplO1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZmVlIGFuZCBlc3RpbWF0ZWQgc2l6ZSBpbiBieXRlcyBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqIEBwYXJhbXMgcGFyYW1zIHtcbiAqICAgYml0Z286IGJpdGdvIG9iamVjdFxuICogICBmZWVSYXRlOiBzYXRvc2hpcyBwZXIga2lsb2J5dGVcbiAqICAgblAyc2hJbnB1dHM6IG51bWJlciBvZiBQMlNIIChtdWx0aXNpZykgaW5wdXRzXG4gKiAgIG5QMnBraElucHV0czogbnVtYmVyIG9mIFAyUEtIIChzaW5nbGUgc2lnKSBpbnB1dHNcbiAqICAgbk91dHB1dHM6IG51bWJlciBvZiBvdXRwdXRzXG4gKiB9XG4gKlxuICogQHJldHVybnMge1xuICogICBzaXplOiBlc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gYnl0ZXNcbiAqICAgZmVlOiBlc3RpbWF0ZWQgZmVlIGluIHNhdG9zaGlzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqICAgZmVlUmF0ZTogZmVlIHJhdGUgdGhhdCB3YXMgdXNlZCB0byBlc3RpbWF0ZSB0aGUgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIH1cbiAqL1xuZXhwb3J0cy5jYWxjdWxhdGVNaW5lckZlZUluZm8gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgY29uc3QgZmVlUmF0ZVRvVXNlID0gcGFyYW1zLmZlZVJhdGUgfHwgcGFyYW1zLmJpdGdvLmdldENvbnN0YW50cygpLmZhbGxiYWNrRmVlUmF0ZTtcbiAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IGVzdGltYXRlVHJhbnNhY3Rpb25TaXplKHBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzaXplOiBlc3RpbWF0ZWRTaXplLFxuICAgIGZlZTogTWF0aC5jZWlsKGVzdGltYXRlZFNpemUgKiBmZWVSYXRlVG9Vc2UgLyAxMDAwKSxcbiAgICBmZWVSYXRlOiBmZWVSYXRlVG9Vc2VcbiAgfTtcbn07XG5cbi8qXG4gKiBHaXZlbiBhIHRyYW5zYWN0aW9uIGhleCwgdW5zcGVudCBpbmZvcm1hdGlvbiAoY2hhaW4gcGF0aCBhbmQgcmVkZWVtIHNjcmlwdHMpLCBhbmQgdGhlIGtleWNoYWluIHhwcnYsXG4gKiBwZXJmb3JtIGtleSBkZXJpdmF0aW9uIGFuZCBzaWduIHRoZSBpbnB1dHMgaW4gdGhlIHRyYW5zYWN0aW9uIGJhc2VkIG9uIHRoZSB1bnNwZW50IGluZm9ybWF0aW9uIHByb3ZpZGVkXG4gKlxuICogQHBhcmFtczpcbiAqICB0cmFuc2FjdGlvbkhleCBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHRyYW5zYWN0aW9uIGluIGhleFxuICogIHVuc3BlbnRzIGFycmF5IG9mIHVuc3BlbnQgaW5mb3JtYXRpb24sIHdoZXJlIGVhY2ggdW5zcGVudCBpcyBhIGNoYWluUGF0aCBhbmQgcmVkZWVtU2NyaXB0IHdpdGggdGhlIHNhbWVcbiAqICBpbmRleCBhcyB0aGUgaW5wdXRzIGluIHRoZSB0cmFuc2FjdGlvbkhleFxuICogIGtleWNoYWluIEtleWNoYWluIGNvbnRhaW5pbmcgdGhlIHhwcnYgdG8gc2lnbiB3aXRoLiBGb3IgbGVnYWN5IHN1cHBvcnQgb2Ygc2FmZSB3YWxsZXRzLCBrZXljaGFpbiBjYW5cbiBhbHNvIGJlIGEgV0lGIHByaXZhdGUga2V5LlxuICogIHNpZ25pbmdLZXkgcHJpdmF0ZSBrZXkgaW4gV0lGIGZvciBzYWZlIHdhbGxldHMsIHdoZW4ga2V5Y2hhaW4gaXMgdW5hdmFpbGFibGVcbiAqICB2YWxpZGF0ZSBjbGllbnQtc2lkZSBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIC0gY2FuIGJlIGRpc2FibGVkIGZvciBpbXByb3ZlZCBwZXJmb3JtYW5jZSAoc2lnbmF0dXJlc1xuICogICAgICAgICAgIGFyZSBzdGlsbCB2YWxpZGF0ZWQgc2VydmVyLXNpZGUpLlxuICogIGZlZVNpbmdsZUtleVdJRiBVc2UgdGhlIGFkZHJlc3MgYmFzZWQgb24gdGhpcyBwcml2YXRlIGtleSB0byBwYXkgZmVlc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuc2lnblRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGxldCBrZXljaGFpbiA9IHBhcmFtcy5rZXljaGFpbjsgLy8gZHVwbGljYXRlIHNvIGFzIHRvIG5vdCBtdXRhdGUgYmVsb3dcblxuICBjb25zdCB2YWxpZGF0ZSA9IChwYXJhbXMudmFsaWRhdGUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuICBsZXQgcHJpdktleTtcbiAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy50cmFuc2FjdGlvbkhleCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUgdHJhbnNhY3Rpb24gaGV4IGFzIGEgc3RyaW5nJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy51bnNwZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUgdW5zcGVudHMgYXJyYXknKTtcbiAgfVxuICBpZiAoIV8uaXNCb29sZWFuKHZhbGlkYXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHZhbGlkYXRlIHRvIGJlIGEgYm9vbGVhbicpO1xuICB9XG4gIGxldCBuZXR3b3JrID0gZ2V0TmV0d29yaygpO1xuICBjb25zdCBlbmFibGVCQ0ggPSAoXy5pc0Jvb2xlYW4ocGFyYW1zLmZvcmNlQkNIKSAmJiBwYXJhbXMuZm9yY2VCQ0ggPT09IHRydWUpO1xuXG4gIGlmICghXy5pc09iamVjdChrZXljaGFpbikgfHwgIV8uaXNTdHJpbmcoKGtleWNoYWluIGFzIGFueSkueHBydikpIHtcbiAgICBpZiAoXy5pc1N0cmluZyhwYXJhbXMuc2lnbmluZ0tleSkpIHtcbiAgICAgIHByaXZLZXkgPSBiaXRjb2luLkVDUGFpci5mcm9tV0lGKHBhcmFtcy5zaWduaW5nS2V5LCBuZXR3b3JrKTtcbiAgICAgIGtleWNoYWluID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUga2V5Y2hhaW4gb2JqZWN0IHdpdGggeHBydicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBmZWVTaW5nbGVLZXk7XG4gIGlmIChwYXJhbXMuZmVlU2luZ2xlS2V5V0lGKSB7XG4gICAgZmVlU2luZ2xlS2V5ID0gYml0Y29pbi5FQ1BhaXIuZnJvbVdJRihwYXJhbXMuZmVlU2luZ2xlS2V5V0lGLCBuZXR3b3JrKTtcbiAgfVxuXG4gIGRlYnVnKCdOZXR3b3JrOiAlTycsIG5ldHdvcmspO1xuXG4gIGlmIChlbmFibGVCQ0gpIHtcbiAgICBkZWJ1ZygnRW5hYmxpbmcgQkNI4oCmJyk7XG4gICAgbmV0d29yayA9IF8uZXh0ZW5kKHt9LCBuZXR3b3JrLCB7IGNvaW46ICdiY2gnIH0pO1xuICAgIGRlYnVnKCdOZXcgbmV0d29yazogJU8nLCBuZXR3b3JrKTtcbiAgfVxuXG4gIGxldCB0cmFuc2FjdGlvbiA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleChwYXJhbXMudHJhbnNhY3Rpb25IZXgsIG5ldHdvcmspO1xuICBpZiAodHJhbnNhY3Rpb24uaW5zLmxlbmd0aCAhPT0gcGFyYW1zLnVuc3BlbnRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHVuc3BlbnRzIGFycmF5IHNob3VsZCBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9uIGlucHV0cycpO1xuICB9XG5cbiAgLy8gZGVjb3JhdGUgdHJhbnNhY3Rpb24gd2l0aCBpbnB1dCB2YWx1ZXMgZm9yIFRyYW5zYWN0aW9uQnVpbGRlciBpbnN0YW50aWF0aW9uXG4gIGNvbnN0IGlzVXR4b1R4ID0gXy5pc09iamVjdCh0cmFuc2FjdGlvbikgJiYgQXJyYXkuaXNBcnJheSgodHJhbnNhY3Rpb24gYXMgYW55KS5pbnMpO1xuICBjb25zdCBhcmVWYWxpZFVuc3BlbnRzID0gXy5pc09iamVjdChwYXJhbXMpICYmIEFycmF5LmlzQXJyYXkoKHBhcmFtcyBhcyBhbnkpLnVuc3BlbnRzKTtcbiAgaWYgKGlzVXR4b1R4ICYmIGFyZVZhbGlkVW5zcGVudHMpIHtcbiAgICAvLyBleHRlbmQgdGhlIHRyYW5zYWN0aW9uIGlucHV0cyB3aXRoIHRoZSB2YWx1ZXNcbiAgICBjb25zdCBpbnB1dFZhbHVlcyA9IF8ubWFwKHBhcmFtcy51bnNwZW50cywgKHUgPT4gXy5waWNrKHUsICd2YWx1ZScpKSk7XG4gICAgdHJhbnNhY3Rpb24uaW5zLm1hcCgoY3VycmVudEl0ZW0sIGluZGV4KSA9PiBfLmV4dGVuZChjdXJyZW50SXRlbSwgaW5wdXRWYWx1ZXNbaW5kZXhdKSk7XG4gIH1cblxuICBsZXQgcm9vdEV4dEtleVBhdGg7XG4gIGxldCByb290RXh0S2V5O1xuICBpZiAoa2V5Y2hhaW4pIHtcbiAgICByb290RXh0S2V5ID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChrZXljaGFpbi54cHJ2KTtcbiAgICByb290RXh0S2V5UGF0aCA9IGhkUGF0aChyb290RXh0S2V5KTtcbiAgfVxuXG4gIGNvbnN0IHR4YiA9IGJpdGNvaW4uVHJhbnNhY3Rpb25CdWlsZGVyLmZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgbmV0d29yayk7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHR4Yi50eC5pbnMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgY29uc3QgY3VycmVudFVuc3BlbnQgPSBwYXJhbXMudW5zcGVudHNbaW5kZXhdO1xuICAgIGlmIChjdXJyZW50VW5zcGVudC5yZWRlZW1TY3JpcHQgPT09IGZhbHNlKSB7XG4gICAgICAvLyB0aGlzIGlzIHRoZSBpbnB1dCBmcm9tIGEgc2luZ2xlIGtleSBmZWUgYWRkcmVzc1xuICAgICAgaWYgKCFmZWVTaW5nbGVLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW5nbGUga2V5IGFkZHJlc3MgdXNlZCBpbiBpbnB1dCBidXQgZmVlU2luZ2xlS2V5V0lGIG5vdCBwcm92aWRlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlQkNIKSB7XG4gICAgICAgIGZlZVNpbmdsZUtleS5uZXR3b3JrID0gbmV0d29yaztcbiAgICAgIH1cblxuICAgICAgdHhiLnNpZ24oaW5kZXgsIGZlZVNpbmdsZUtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFpblBhdGggPSBjdXJyZW50VW5zcGVudC5jaGFpblBhdGg7XG4gICAgaWYgKHJvb3RFeHRLZXlQYXRoKSB7XG4gICAgICBjb25zdCBzdWJQYXRoID0ga2V5Y2hhaW4ud2FsbGV0U3ViUGF0aCB8fCAnLzAvMCc7XG4gICAgICBjb25zdCBwYXRoID0ga2V5Y2hhaW4ucGF0aCArIHN1YlBhdGggKyBjaGFpblBhdGg7XG4gICAgICBwcml2S2V5ID0gcm9vdEV4dEtleVBhdGguZGVyaXZlS2V5KHBhdGgpO1xuICAgIH1cblxuICAgIHByaXZLZXkubmV0d29yayA9IG5ldHdvcms7XG5cbiAgICBjb25zdCBpc1NlZ3dpdElucHV0ID0gISFjdXJyZW50VW5zcGVudC53aXRuZXNzU2NyaXB0O1xuXG4gICAgLy8gc3Vic2NyaXB0IGlzIHRoZSBwYXJ0IG9mIHRoZSBvdXRwdXQgc2NyaXB0IGFmdGVyIHRoZSBPUF9DT0RFU0VQQVJBVE9SLlxuICAgIC8vIFNpbmNlIHdlIGFyZSBvbmx5IGV2ZXIgc2lnbmluZyBwMnNoIG91dHB1dHMsIHdoaWNoIGRvIG5vdCBoYXZlXG4gICAgLy8gT1BfQ09ERVNFUEFSQVRPUlMsIGl0IGlzIGFsd2F5cyB0aGUgb3V0cHV0IHNjcmlwdC5cbiAgICBjb25zdCBzdWJzY3JpcHQgPSBuZXcgQnVmZmVyKGN1cnJlbnRVbnNwZW50LnJlZGVlbVNjcmlwdCwgJ2hleCcpO1xuICAgIGN1cnJlbnRVbnNwZW50LnZhbGlkYXRpb25TY3JpcHQgPSBzdWJzY3JpcHQ7XG5cbiAgICAvLyBJbiBvcmRlciB0byBzaWduIHdpdGggYml0Y29pbmpzLWxpYiwgd2UgbXVzdCB1c2UgaXRzIHRyYW5zYWN0aW9uXG4gICAgLy8gYnVpbGRlciwgY29uZnVzaW5nbHkgbmFtZWQgdGhlIHNhbWUgZXhhY3QgdGhpbmcgYXMgb3VyIHRyYW5zYWN0aW9uXG4gICAgLy8gYnVpbGRlciwgYnV0IHdpdGggaW5lcXVpdmFsZW50IGJlaGF2aW9yLlxuICAgIHRyeSB7XG5cbiAgICAgIGlmIChpc1NlZ3dpdElucHV0KSB7XG4gICAgICAgIGRlYnVnKCdTaWduaW5nIHNlZ3dpdCBpbnB1dCAjJWQnLCBpbmRleCk7XG4gICAgICAgIGlmIChlbmFibGVCQ0gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JDSCBkb2VzIG5vdCBzdXBwb3J0IHNlZ3dpdCBpbnB1dHMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmF0dXJlcyA9IF8uY2xvbmVEZWVwKHR4Yi5pbnB1dHNbaW5kZXhdLnNpZ25hdHVyZXMpO1xuICAgICAgICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gbmV3IEJ1ZmZlcihjdXJyZW50VW5zcGVudC53aXRuZXNzU2NyaXB0LCAnaGV4Jyk7XG4gICAgICAgIGN1cnJlbnRVbnNwZW50LnZhbGlkYXRpb25TY3JpcHQgPSB3aXRuZXNzU2NyaXB0O1xuXG4gICAgICAgIGRlYnVnKCdDdXJyZW50IHVuc3BlbnQgdmFsdWU6ICVkJywgY3VycmVudFVuc3BlbnQudmFsdWUpO1xuXG4gICAgICAgIHR4Yi5zaWduKGluZGV4LCBwcml2S2V5LCBzdWJzY3JpcHQsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwsIGN1cnJlbnRVbnNwZW50LnZhbHVlLCB3aXRuZXNzU2NyaXB0KTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzaWduYXR1cmVzKSkge1xuICAgICAgICAgIC8vIGZvciBzZWd3aXQgaW5wdXRzLCBpZiB0aGV5IGFyZSBwYXJ0aWFsbHkgc2lnbmVkLCBiaXRjb2luanMtbGliIG92ZXJyaWRlcyBwcmV2aW91cyBzaWduYXR1cmVzXG4gICAgICAgICAgLy8gdGhpcyB3b3JrYXJvdW5kIGZvcmNlcyB0aGVtIHRvIGJlIHByZXNlcnZlZFxuICAgICAgICAgIHNpZ25hdHVyZXMgPSBzaWduYXR1cmVzLmZpbHRlcihzaWcgPT4gISFzaWcpO1xuICAgICAgICAgIC8vIExhc3QsIG92ZXJyaWRlIGJ1aWxkZXIncyBzaWduYXR1cmVzIHByb3BlcnR5IHRvIGFuIGFycmF5IGluY2x1ZGluZyBwcmV2aW91cyBzaWduYXR1cmVzLCBpZiB0aGVyZSBhcmUgYW55LlxuICAgICAgICAgIGNvbnN0IGJ1aWxkZXJTaWduYXR1cmVzID0gdHhiLmlucHV0c1tpbmRleF0uc2lnbmF0dXJlcztcbiAgICAgICAgICBjb25zdCBub25FbXB0eVNpZ25hdHVyZXMgPSBfLnJlbW92ZShidWlsZGVyU2lnbmF0dXJlcywgc2lnID0+ICEhc2lnKTtcbiAgICAgICAgICBzaWduYXR1cmVzLnB1c2guYXBwbHkoc2lnbmF0dXJlcywgbm9uRW1wdHlTaWduYXR1cmVzKTtcbiAgICAgICAgICB0eGIuaW5wdXRzW2luZGV4XS5zaWduYXR1cmVzID0gc2lnbmF0dXJlcztcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnU2lnbmluZyBub24tc2Vnd2l0IGlucHV0ICMlZCcsIGluZGV4KTtcblxuICAgICAgICAvLyBvbmx5IGlmIGJpdGNvaW4gY2FzaCBpcyBlbmFibGVkLCB3aGljaCBzaG91bGQgb25seSBiZSBpbiB1bml0IHRlc3RzIGFueXdheVxuICAgICAgICBjb25zdCBiY2hQYXJhbWV0ZXIgPSBlbmFibGVCQ0ggPyBjdXJyZW50VW5zcGVudC52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHNpZ0hhc2hUeXBlID0gYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDtcbiAgICAgICAgaWYgKGVuYWJsZUJDSCkge1xuICAgICAgICAgIHNpZ0hhc2hUeXBlIHw9IGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9CSVRDT0lOQ0FTSEJJUDE0MztcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnQkNIIHBhcmFtZXRlcjogJWQnLCBiY2hQYXJhbWV0ZXIpO1xuICAgICAgICBkZWJ1ZygnU2lnaGFzaCB0eXBlOiAlZCcsIHNpZ0hhc2hUeXBlKTtcbiAgICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHN1YnNjcmlwdCwgc2lnSGFzaFR5cGUsIGJjaFBhcmFtZXRlcik7XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyB3ZSBuZWVkIHRvIGtub3cgd2hhdCdzIGNhdXNpbmcgdGhpc1xuICAgICAgZS5yZXN1bHQgPSB7XG4gICAgICAgIHVuc3BlbnQ6IGN1cnJlbnRVbnNwZW50XG4gICAgICB9O1xuICAgICAgZS5tZXNzYWdlID0gYEZhaWxlZCB0byBzaWduIGlucHV0ICMke2luZGV4fSAtICR7ZS5tZXNzYWdlfSAtICR7SlNPTi5zdHJpbmdpZnkoZS5yZXN1bHQsIG51bGwsIDQpfSAtIFxcbiR7ZS5zdGFja31gO1xuICAgICAgZGVidWcoJ2lucHV0IHNpZ24gZmFpbGVkOiAlcycsIGUubWVzc2FnZSk7XG4gICAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KGUpO1xuICAgIH1cblxuICB9XG5cbiAgLy8gcmVzZXJpYWxpemUgdHJhbnNhY3Rpb25cbiAgdHJhbnNhY3Rpb24gPSB0eGIuYnVpbGQoKTtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aDsgKytpbmRleCkge1xuICAgIC8vIGJpdGNvaW5qcy1saWIgYWRkcyBvbmUgbW9yZSBPUF8wIHRoYW4gd2UgbmVlZC4gSXQgY3JlYXRlcyBvbmUgT1BfMCBmb3JcbiAgICAvLyBldmVyeSBuIHB1YmxpYyBrZXlzIGluIGFuIG0tb2YtbiBtdWx0aXNpZywgYW5kIHJlcGxhY2VzIHRoZSBPUF8wcyB3aXRoXG4gICAgLy8gdGhlIHNpZ25hdHVyZSBvZiB0aGUgbnRoIHB1YmxpYyBrZXksIHRoZW4gcmVtb3ZlcyBhbnkgcmVtYWluaW5nIE9QXzBzXG4gICAgLy8gYXQgdGhlIGVuZC4gVGhpcyBiZWhhdmlvciBpcyBub3QgaW5jb3JyZWN0IGFuZCB2YWxpZCBmb3Igc29tZSB1c2VcbiAgICAvLyBjYXNlcywgcGFydGljdWxhcmx5IGlmIHlvdSBkbyBub3Qga25vdyB3aGljaCBrZXlzIHdpbGwgYmUgc2lnbmluZyB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBhbmQgdGhlIHNpZ25hdHVyZXMgbWF5IGJlIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbiBpbiBhbnlcbiAgICAvLyBjaHJvbm9sb2dpY2FsIG9yZGVyLCBidXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgQml0R28gQVBJLCB3aGljaFxuICAgIC8vIGFzc3VtZXMgbSBPUF8wcyBmb3IgbS1vZi1uIG11bHRpc2lnIChvciBtLTEgYWZ0ZXIgdGhlIGZpcnN0IHNpZ25hdHVyZVxuICAgIC8vIGlzIGNyZWF0ZWQpLiBUaHVzIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBzdXBlcmZsdW91cyBPUF8wLlxuXG4gICAgY29uc3QgY3VycmVudFVuc3BlbnQgPSBwYXJhbXMudW5zcGVudHNbaW5kZXhdO1xuXG4gICAgLy8gVGhlIHNpZ25hdHVyZXMgYXJlIHZhbGlkYXRlZCBzZXJ2ZXIgc2lkZSBhbmQgb24gdGhlIGJpdGNvaW4gbmV0d29yaywgc29cbiAgICAvLyB0aGUgc2lnbmF0dXJlIHZhbGlkYXRpb24gaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSBkaXNhYmxlZCBieSBzZXR0aW5nOlxuICAgIC8vIHZhbGlkYXRlID0gZmFsc2VcbiAgICBpZiAodmFsaWRhdGUpIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gZXhwb3J0cy52ZXJpZnlJbnB1dFNpZ25hdHVyZXModHJhbnNhY3Rpb24sIGluZGV4LCBjdXJyZW50VW5zcGVudC52YWxpZGF0aW9uU2NyaXB0LCBmYWxzZSwgY3VycmVudFVuc3BlbnQudmFsdWUsIGVuYWJsZUJDSCk7XG4gICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IHNvbWV0aGluZyBzbWFydGVyIGZvciBoYWxmLXNpZ25lZFxuXG4gICAgICAvLyBpZiBwYXJhbXMuZnVsbExvY2FsU2lnbmluZyBpcyBzZXQgdG8gdHJ1ZSwgd2UgYWxsb3cgY3VzdG9tIG5vbi16ZXJvIHZhbHVlc1xuICAgICAgLy8gb3RoZXJ3aXNlLCB0aGUgc2lnbmF0dXJlIGNvdW50IGhhcyB0byBiZSAtMVxuXG4gICAgICBjb25zdCBmdWxsTG9jYWxTaWduaW5nID0gISFwYXJhbXMuZnVsbExvY2FsU2lnbmluZztcbiAgICAgIGlmIChzaWduYXR1cmVDb3VudCA9PT0gMCB8fCAoIWZ1bGxMb2NhbFNpZ25pbmcgJiYgc2lnbmF0dXJlQ291bnQgIT09IC0xKSkge1xuICAgICAgICAvLyBpZiB0aGUgc2lnbmF0dXJlIGNvdW50IGlzIHBvc2l0aXZlLCB3ZSBkbyBub3Qgd2FudCB0byB0aHJvdyB0aGUgZXJyb3IsIGJlY2F1c2UgaXQgaXMgZXhwZWN0ZWRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgb2Ygc2lnbmF0dXJlcyBpcyBpbnZhbGlkIC0gc29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hlbiBzaWduaW5nJyk7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7XG4gICAgdHJhbnNhY3Rpb25IZXg6IHRyYW5zYWN0aW9uLnRvSGV4KClcbiAgfSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSB0aGUgc2lnbmF0dXJlIG9uIGFuIGlucHV0LlxuICpcbiAqIElmIHRoZSB0cmFuc2FjdGlvbiBpcyBmdWxseSBzaWduZWQsIHJldHVybnMgYSBwb3NpdGl2ZSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgdmFsaWQgc2lnbmF0dXJlcy5cbiAqIElmIHRoZSB0cmFuc2FjdGlvbiBpcyBwYXJ0aWFsbHkgc2lnbmVkLCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHZhbGlkIHNpZ25hdHVyZXMuXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIGJpdGNvaW5qcy1saWIgdHJhbnNhY3Rpb24gb2JqZWN0XG4gKiBAcGFyYW0gaW5wdXRJbmRleCB0aGUgaW5wdXQgaW5kZXggdG8gdmVyaWZ5XG4gKiBAcGFyYW0gcHViU2NyaXB0IHRoZSByZWRlZW0gc2NyaXB0IHRvIHZlcmlmeSB3aXRoXG4gKiBAcGFyYW0gaWdub3JlS2V5SW5kaWNlcyBhcnJheSBvZiBtdWx0aXNpZyBrZXlzIGluZGV4ZXMgKGluIG9yZGVyIG9mIGtleWNoYWlucyBvbiB0aGUgd2FsbGV0KS4gZS5nLiBbMV0gdG8gaWdub3JlIGJhY2t1cCBrZXlzXG4gKiBAcGFyYW0gYW1vdW50XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLnZlcmlmeUlucHV0U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBpbnB1dEluZGV4LCBwdWJTY3JpcHQsIGlnbm9yZUtleUluZGljZXMsIGFtb3VudCwgaXNCQ0ggPSBmYWxzZSkge1xuICBpZiAoaW5wdXRJbmRleCA8IDAgfHwgaW5wdXRJbmRleCA+PSB0cmFuc2FjdGlvbi5pbnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGluZGV4Jyk7XG4gIH1cblxuICBpZ25vcmVLZXlJbmRpY2VzID0gaWdub3JlS2V5SW5kaWNlcyB8fCBbXTtcbiAgY29uc3QgY3VycmVudFRyYW5zYWN0aW9uSW5wdXQgPSB0cmFuc2FjdGlvbi5pbnNbaW5wdXRJbmRleF07XG4gIGxldCBzaWdTY3JpcHQgPSBjdXJyZW50VHJhbnNhY3Rpb25JbnB1dC5zY3JpcHQ7XG4gIGxldCBzaWdzTmVlZGVkID0gMTtcbiAgY29uc3Qgc2lnczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgcHViS2V5czogc3RyaW5nW10gPSBbXTtcbiAgbGV0IGRlY29tcGlsZWRTaWdTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5kZWNvbXBpbGUoc2lnU2NyaXB0KTtcblxuICBjb25zdCBpc1NlZ3dpdElucHV0ID0gY3VycmVudFRyYW5zYWN0aW9uSW5wdXQud2l0bmVzcy5sZW5ndGggPiAwO1xuICBpZiAoaXNTZWd3aXRJbnB1dCkge1xuICAgIGRlY29tcGlsZWRTaWdTY3JpcHQgPSBjdXJyZW50VHJhbnNhY3Rpb25JbnB1dC53aXRuZXNzO1xuICAgIHNpZ1NjcmlwdCA9IGJpdGNvaW4uc2NyaXB0LmNvbXBpbGUoZGVjb21waWxlZFNpZ1NjcmlwdCk7XG4gICAgaWYgKCFhbW91bnQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIHRoZSBzY3JpcHQgdHlwZSB0byBkZXRlcm1pbmUgbnVtYmVyIG9mIHNpZ25hdHVyZXMsIHRoZSBwdWIga2V5cywgYW5kIHRoZSBzY3JpcHQgdG8gaGFzaC5cbiAgY29uc3QgaW5wdXRDbGFzc2lmaWNhdGlvbiA9IGJpdGNvaW4uc2NyaXB0LmNsYXNzaWZ5SW5wdXQoc2lnU2NyaXB0LCB0cnVlKTtcbiAgc3dpdGNoIChpbnB1dENsYXNzaWZpY2F0aW9uKSB7XG4gICAgY2FzZSAnc2NyaXB0aGFzaCc6XG4gICAgICAvLyBSZXBsYWNlIHRoZSBwdWJTY3JpcHQgd2l0aCB0aGUgUDJTSCBTY3JpcHQuXG4gICAgICBwdWJTY3JpcHQgPSBkZWNvbXBpbGVkU2lnU2NyaXB0W2RlY29tcGlsZWRTaWdTY3JpcHQubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBkZWNvbXBpbGVkUHViU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuZGVjb21waWxlKHB1YlNjcmlwdCk7XG4gICAgICBzaWdzTmVlZGVkID0gZGVjb21waWxlZFB1YlNjcmlwdFswXSAtIGJpdGNvaW4ub3Bjb2Rlcy5PUF8xICsgMTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBkZWNvbXBpbGVkU2lnU2NyaXB0Lmxlbmd0aCAtIDE7ICsraW5kZXgpIHtcbiAgICAgICAgc2lncy5wdXNoKGRlY29tcGlsZWRTaWdTY3JpcHRbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBkZWNvbXBpbGVkUHViU2NyaXB0Lmxlbmd0aCAtIDI7ICsraW5kZXgpIHtcbiAgICAgICAgLy8gd2UgbWludXMgMSBiZWNhdXNlIHRoZSBrZXkgaW5kZXhlcyBzdGFydCBmcm9tIHRoZSBzZWNvbmQgY2h1bmsgKGZpcnN0IGNodW5rIGlzIHVzZWQgZm9yIHRvdGFsIGtleXMpXG4gICAgICAgIGlmIChfLmluY2x1ZGVzKGlnbm9yZUtleUluZGljZXMsIGluZGV4IC0gMSkpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBwdWJsaWMga2V5IChkbyBub3QgdHJlYXQgaXQgYXMgdmFsaWQgZm9yIGEgc2lnbmF0dXJlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1YktleXMucHVzaChkZWNvbXBpbGVkUHViU2NyaXB0W2luZGV4XSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwdWJrZXloYXNoJzpcbiAgICAgIHNpZ3NOZWVkZWQgPSAxO1xuICAgICAgc2lncy5wdXNoKGRlY29tcGlsZWRTaWdTY3JpcHRbMF0pO1xuICAgICAgcHViS2V5cy5wdXNoKGRlY29tcGlsZWRTaWdTY3JpcHRbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwO1xuICB9XG5cbiAgbGV0IG51bVZlcmlmaWVkU2lnbmF0dXJlcyA9IDA7XG4gIGZvciAobGV0IHNpZ0luZGV4ID0gMDsgc2lnSW5kZXggPCBzaWdzLmxlbmd0aDsgKytzaWdJbmRleCkge1xuICAgIC8vIElmIHRoaXMgaXMgYW4gT1BfMCwgdGhlbiBpdHMgYmVlbiBsZWZ0IGFzIGEgcGxhY2Vob2xkZXIgZm9yIGEgZnV0dXJlIHNpZy5cbiAgICBpZiAoc2lnc1tzaWdJbmRleF0gPT09IGJpdGNvaW4ub3Bjb2Rlcy5PUF8wKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNoVHlwZSA9IHNpZ3Nbc2lnSW5kZXhdW3NpZ3Nbc2lnSW5kZXhdLmxlbmd0aCAtIDFdO1xuICAgIHNpZ3Nbc2lnSW5kZXhdID0gc2lnc1tzaWdJbmRleF0uc2xpY2UoMCwgc2lnc1tzaWdJbmRleF0ubGVuZ3RoIC0gMSk7IC8vIHBvcCBoYXNoIHR5cGUgZnJvbSBlbmRcbiAgICBsZXQgc2lnbmF0dXJlSGFzaDtcbiAgICBpZiAoaXNTZWd3aXRJbnB1dCkge1xuICAgICAgc2lnbmF0dXJlSGFzaCA9IHRyYW5zYWN0aW9uLmhhc2hGb3JXaXRuZXNzVjAoaW5wdXRJbmRleCwgcHViU2NyaXB0LCBhbW91bnQsIGhhc2hUeXBlKTtcbiAgICB9IGVsc2UgaWYgKGlzQkNIKSB7XG4gICAgICBzaWduYXR1cmVIYXNoID0gdHJhbnNhY3Rpb24uaGFzaEZvckNhc2hTaWduYXR1cmUoaW5wdXRJbmRleCwgcHViU2NyaXB0LCBhbW91bnQsIGhhc2hUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmF0dXJlSGFzaCA9IHRyYW5zYWN0aW9uLmhhc2hGb3JTaWduYXR1cmUoaW5wdXRJbmRleCwgcHViU2NyaXB0LCBoYXNoVHlwZSk7XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkU2lnID0gZmFsc2U7XG5cbiAgICAvLyBFbnVtZXJhdGUgdGhlIHBvc3NpYmxlIHB1YmxpYyBrZXlzXG4gICAgZm9yIChsZXQgcHViS2V5SW5kZXggPSAwOyBwdWJLZXlJbmRleCA8IHB1YktleXMubGVuZ3RoOyArK3B1YktleUluZGV4KSB7XG4gICAgICBjb25zdCBwdWJLZXkgPSBiaXRjb2luLkVDUGFpci5mcm9tUHVibGljS2V5QnVmZmVyKHB1YktleXNbcHViS2V5SW5kZXhdKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJpdGNvaW4uRUNTaWduYXR1cmUuZnJvbURFUihzaWdzW3NpZ0luZGV4XSk7XG4gICAgICB2YWxpZFNpZyA9IHB1YktleS52ZXJpZnkoc2lnbmF0dXJlSGFzaCwgc2lnbmF0dXJlKTtcbiAgICAgIGlmICh2YWxpZFNpZykge1xuICAgICAgICBwdWJLZXlzLnNwbGljZShwdWJLZXlJbmRleCwgMSk7ICAvLyByZW1vdmUgdGhlIHB1YmtleSBzbyB3ZSBjYW4ndCBtYXRjaCAyIHNpZ3MgYWdhaW5zdCB0aGUgc2FtZSBwdWJrZXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdmFsaWRTaWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUgZm9yIGluZGV4ICcgKyBpbnB1dEluZGV4KTtcbiAgICB9XG4gICAgbnVtVmVyaWZpZWRTaWduYXR1cmVzKys7XG4gIH1cblxuICBpZiAobnVtVmVyaWZpZWRTaWduYXR1cmVzIDwgc2lnc05lZWRlZCkge1xuICAgIG51bVZlcmlmaWVkU2lnbmF0dXJlcyA9IC1udW1WZXJpZmllZFNpZ25hdHVyZXM7XG4gIH1cbiAgcmV0dXJuIG51bVZlcmlmaWVkU2lnbmF0dXJlcztcbn07XG4iXX0=