"use strict";
/**
 * @hidden
 */
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// Wallets Object
// BitGo accessor to a user's wallets.
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var bitcoin = require("bitgo-utxo-lib");
var bitcoin_1 = require("./bitcoin");
var common = require("./common");
var _ = require("lodash");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var Wallet = require('./wallet');
//
// Constructor
//
var Wallets = function (bitgo) {
    this.bitgo = bitgo;
};
//
// list
// List the user's wallets
//
Wallets.prototype.list = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var args = [];
    if (params.skip && params.prevId) {
        throw new Error('cannot specify both skip and prevId');
    }
    if (params.limit) {
        if (!_.isNumber(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        args.push('limit=' + params.limit);
    }
    if (params.getbalances) {
        if (!_.isBoolean(params.getbalances)) {
            throw new Error('invalid getbalances argument, expecting boolean');
        }
        args.push('getbalances=' + params.getbalances);
    }
    if (params.skip) {
        if (!_.isNumber(params.skip)) {
            throw new Error('invalid skip argument, expecting number');
        }
        args.push('skip=' + params.skip);
    }
    else if (params.prevId) {
        args.push('prevId=' + params.prevId);
    }
    var query = '';
    if (args.length) {
        query = '?' + args.join('&');
    }
    var self = this;
    return this.bitgo.get(this.bitgo.url('/wallet' + query))
        .result()
        .then(function (body) {
        body.wallets = body.wallets.map(function (w) { return new Wallet(self.bitgo, w); });
        return body;
    })
        .nodeify(callback);
};
Wallets.prototype.getWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    var self = this;
    var query = '';
    if (params.gpk) {
        query = '?gpk=1';
    }
    return this.bitgo.get(this.bitgo.url('/wallet/' + params.id + query))
        .result()
        .then(function (wallet) {
        return new Wallet(self.bitgo, wallet);
    })
        .nodeify(callback);
};
//
// listInvites
// List the invites on a user
//
Wallets.prototype.listInvites = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.bitgo.url('/walletinvite'))
        .result()
        .nodeify(callback);
};
//
// cancelInvite
// cancel a wallet invite that a user initiated
//
Wallets.prototype.cancelInvite = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletInviteId'], [], callback);
    return this.bitgo.del(this.bitgo.url('/walletinvite/' + params.walletInviteId))
        .result()
        .nodeify(callback);
};
//
// listShares
// List the user's wallet shares
//
Wallets.prototype.listShares = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.bitgo.url('/walletshare'))
        .result()
        .nodeify(callback);
};
//
// resendShareInvite
// Resend the invitation email which shares a wallet with another user
// Params:
//    walletShareId - the wallet share to get information on
//
Wallets.prototype.resendShareInvite = function (params, callback) {
    return co(function () {
        var urlParts;
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, ['walletShareId'], [], callback);
            urlParts = params.walletShareId + '/resendemail';
            return [2 /*return*/, this.bitgo.post(this.bitgo.url('/walletshare/' + urlParts))
                    .result()];
        });
    }).call(this).asCallback(callback);
};
//
// getShare
// Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
// Params:
//    walletShareId - the wallet share to get information on
//
Wallets.prototype.getShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.get(this.bitgo.url('/walletshare/' + params.walletShareId))
        .result()
        .nodeify(callback);
};
//
// updateShare
// updates a wallet share
// Params:
//    walletShareId - the wallet share to update
//    state - the new state of the wallet share
//
Wallets.prototype.updateShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.post(this.bitgo.url('/walletshare/' + params.walletShareId))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// cancelShare
// cancels a wallet share
// Params:
//    walletShareId - the wallet share to update
//
Wallets.prototype.cancelShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.del(this.bitgo.url('/walletshare/' + params.walletShareId))
        .send()
        .result()
        .nodeify(callback);
};
//
// acceptShare
// Accepts a wallet share, adding the wallet to the user's list
// Needs a user's password to decrypt the shared key
// Params:
//    walletShareId - the wallet share to accept
//    userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
//    newWalletPassphrase - new wallet passphrase for saving the shared wallet xprv.
//                          If left blank and a wallet with more than view permissions was shared, then the userpassword is used.
//    overrideEncryptedXprv - set only if the xprv was received out-of-band.
//
Wallets.prototype.acceptShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], ['overrideEncryptedXprv'], callback);
    var self = this;
    var encryptedXprv = params.overrideEncryptedXprv;
    return this.getShare({ walletShareId: params.walletShareId })
        .then(function (walletShare) {
        // Return right away if there is no keychain to decrypt, or if explicit encryptedXprv was provided
        if (!walletShare.keychain || !walletShare.keychain.encryptedXprv || encryptedXprv) {
            return walletShare;
        }
        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
        if (!params.userPassword) {
            throw new Error('userPassword param must be provided to decrypt shared key');
        }
        return self.bitgo.getECDHSharingKeychain()
            .then(function (sharingKeychain) {
            if (!sharingKeychain.encryptedXprv) {
                throw new Error('EncryptedXprv was not found on sharing keychain');
            }
            // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
            sharingKeychain.xprv = self.bitgo.decrypt({ password: params.userPassword, input: sharingKeychain.encryptedXprv });
            var rootExtKey = bitcoin.HDNode.fromBase58(sharingKeychain.xprv);
            // Derive key by path (which is used between these 2 users only)
            var privKey = bitcoin_1.hdPath(rootExtKey).deriveKey(walletShare.keychain.path);
            var secret = self.bitgo.getECDHSecret({ eckey: privKey, otherPubKeyHex: walletShare.keychain.fromPubKey });
            // Yes! We got the secret successfully here, now decrypt the shared wallet xprv
            var decryptedSharedWalletXprv = self.bitgo.decrypt({ password: secret, input: walletShare.keychain.encryptedXprv });
            // We will now re-encrypt the wallet with our own password
            var newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
            encryptedXprv = self.bitgo.encrypt({ password: newWalletPassphrase, input: decryptedSharedWalletXprv });
            // Carry on to the next block where we will post the acceptance of the share with the encrypted xprv
            return walletShare;
        });
    })
        .then(function (walletShare) {
        var updateParams = {
            walletShareId: params.walletShareId,
            state: 'accepted'
        };
        if (encryptedXprv) {
            updateParams.encryptedXprv = encryptedXprv;
        }
        return self.updateShare(updateParams);
    })
        .nodeify(callback);
};
//
// createKey
// Create a single bitcoin key.  This runs locally.
// Returns: {
//   address: <address>
//   key: <key, in WIF format>
// }
Wallets.prototype.createKey = function (params) {
    var key = bitcoin_1.makeRandomKey();
    return {
        address: key.getAddress(),
        key: key.toWIF()
    };
};
//
// createWalletWithKeychains
// Create a new 2-of-3 wallet and it's associated keychains.
// Returns the locally created keys with their encrypted xprvs.
// **WARNING: BE SURE TO BACKUP! NOT DOING SO CAN RESULT IN LOSS OF FUNDS!**
//
// 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
// 2. If no xpub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
// 3. Uploads the encrypted user and backup keychains to BitGo
// 4. Creates the BitGo key on the service
// 5. Creates the wallet on BitGo with the 3 public keys above
//
// Parameters include:
//   "passphrase": wallet passphrase to encrypt user and backup keys with
//   "label": wallet label, is shown in BitGo UI
//   "backupXpub": backup keychain xpub, it is HIGHLY RECOMMENDED you generate this on a separate machine!
//                 BITGO DOES NOT GUARANTEE SAFETY OF WALLETS WITH MULTIPLE KEYS CREATED ON THE SAME MACHINE **
//   "backupXpubProvider": Provision backup key from this provider (KRS), e.g. "keyternal".
//                         Setting this value will create an instant-capable wallet.
//   "passcodeEncryptionCode": the code used to encrypt the wallet passcode used in the recovery process
// Returns: {
//   wallet: newly created wallet model object
//   userKeychain: the newly created user keychain, which has an encrypted xprv stored on BitGo
//   backupKeychain: the newly created backup keychain
//
// ** BE SURE TO BACK UP THE ENCRYPTED USER AND BACKUP KEYCHAINS!**
//
// }
Wallets.prototype.createWalletWithKeychains = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['passphrase'], ['label', 'backupXpub', 'enterprise', 'passcodeEncryptionCode'], callback);
    var self = this;
    var label = params.label;
    // Create the user and backup key.
    var userKeychain = this.bitgo.keychains().create();
    userKeychain.encryptedXprv = this.bitgo.encrypt({ password: params.passphrase, input: userKeychain.xprv });
    var keychainData = {
        xpub: userKeychain.xpub,
        encryptedXprv: userKeychain.encryptedXprv
    };
    if (params.passcodeEncryptionCode) {
        keychainData.originalPasscodeEncryptionCode = params.passcodeEncryptionCode;
    }
    var hasBackupXpub = !!params.backupXpub;
    var hasBackupXpubProvider = !!params.backupXpubProvider;
    if (hasBackupXpub && hasBackupXpubProvider) {
        throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
    }
    if (params.disableTransactionNotifications !== undefined && !_.isBoolean(params.disableTransactionNotifications)) {
        throw new Error('Expected disableTransactionNotifications to be a boolean. ');
    }
    var backupKeychain;
    var bitgoKeychain;
    // Add the user keychain
    return self.bitgo.keychains().add(keychainData)
        .then(function () {
        // Add the backup keychain
        if (params.backupXpubProvider) {
            // If requested, use a KRS or backup key provider
            return self.bitgo.keychains().createBackup({
                provider: params.backupXpubProvider,
                disableKRSEmail: params.disableKRSEmail
            })
                .then(function (keychain) {
                backupKeychain = keychain;
            });
        }
        if (params.backupXpub) {
            // user provided backup xpub
            backupKeychain = { xpub: params.backupXpub };
        }
        else {
            // no provided xpub, so default to creating one here
            backupKeychain = self.bitgo.keychains().create();
        }
        return self.bitgo.keychains().add(backupKeychain);
    })
        .then(function () {
        return self.bitgo.keychains().createBitGo();
    })
        .then(function (keychain) {
        bitgoKeychain = keychain;
        var walletParams = {
            label: label,
            m: 2,
            n: 3,
            keychains: [
                { xpub: userKeychain.xpub },
                { xpub: backupKeychain.xpub },
                { xpub: bitgoKeychain.xpub }
            ]
        };
        if (params.enterprise) {
            walletParams.enterprise = params.enterprise;
        }
        if (params.disableTransactionNotifications) {
            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
        }
        return self.add(walletParams);
    })
        .then(function (newWallet) {
        var result = {
            wallet: newWallet,
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain
        };
        if (backupKeychain.xprv) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        return result;
    })
        .nodeify(callback);
};
//
// createForwardWallet
// Creates a forward wallet from a single private key.
// BitGo will watch the wallet and send any incoming transactions to a destination multi-sig wallet
// WARNING: THE PRIVATE KEY WILL BE SENT TO BITGO. YOU MUST CONTACT BITGO BEFORE USING THIS FEATURE!
// WE CANNOT GUARANTEE THE SECURITY OF SINGLE-SIG WALLETS AS CUSTODY IS UNCLEAR.
//
// Params:
//    privKey - the private key on a legacy single-signature wallet to be watched (WIF format)
//    sourceAddress - the bitcoin address to forward from (corresponds to the private key)
//    destinationWallet - the wallet object to send the destination coins to (when incoming transactions are detected)
//    label - label for the wallet
//
Wallets.prototype.createForwardWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['privKey', 'sourceAddress'], ['label'], callback);
    if (!_.isObject(params.destinationWallet) || !params.destinationWallet.id) {
        throw new Error('expecting destinationWallet object');
    }
    var self = this;
    var newDestinationAddress;
    var addressFromPrivKey;
    try {
        var key = bitcoin.ECPair.fromWIF(params.privKey, bitcoin_1.getNetwork());
        addressFromPrivKey = key.getAddress();
    }
    catch (e) {
        throw new Error('expecting a valid privKey');
    }
    if (addressFromPrivKey !== params.sourceAddress) {
        throw new Error('privKey does not match source address - got ' + addressFromPrivKey + ' expected ' + params.sourceAddress);
    }
    return params.destinationWallet.createAddress()
        .then(function (result) {
        // Create new address on the destination wallet to receive coins
        newDestinationAddress = result.address;
        var walletParams = {
            type: 'forward',
            sourceAddress: params.sourceAddress,
            destinationAddress: newDestinationAddress,
            privKey: params.privKey,
            label: params.label
        };
        if (params.enterprise) {
            walletParams.enterprise = params.enterprise;
        }
        return self.bitgo.post(self.bitgo.url('/wallet'))
            .send(walletParams)
            .result()
            .nodeify(callback);
    });
};
/**
* Add a new wallet (advanced mode).
* This allows you to manually submit the keychains, type, m and n of the wallet
* @param {string} label label of the wallet to be shown in UI
* @param {number} m number of keys required to unlock wallet (2)
* @param {number} n number of keys available on the wallet (3)
* @param {array} keychains array of keychain xpubs
* @param {string} enterprise ID of the enterprise entity to create this wallet under.
* @param {boolean} disableTransactionNotifications When set to true disables notifications for transactions on this wallet.
*/
Wallets.prototype.add = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['label', 'enterprise'], callback);
    if (Array.isArray(params.keychains) === false || !_.isNumber(params.m) ||
        !_.isNumber(params.n)) {
        throw new Error('invalid argument');
    }
    // TODO: support more types of multisig
    if (params.m !== 2 || params.n !== 3) {
        throw new Error('unsupported multi-sig type');
    }
    var self = this;
    var keychains = params.keychains.map(function (k) { return { xpub: k.xpub }; });
    var walletParams = {
        label: params.label,
        m: params.m,
        n: params.n,
        keychains: keychains
    };
    if (params.enterprise) {
        walletParams.enterprise = params.enterprise;
    }
    if (params.disableTransactionNotifications) {
        walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
    }
    return this.bitgo.post(this.bitgo.url('/wallet'))
        .send(walletParams)
        .result()
        .then(function (body) {
        return new Wallet(self.bitgo, body);
    })
        .nodeify(callback);
};
//
// get
// Shorthand to getWallet
// Parameters include:
//   id: the id of the wallet
//
Wallets.prototype.get = function (params, callback) {
    return this.getWallet(params, callback);
};
//
// remove
// Remove an existing wallet.
// Parameters include:
//   id: the id of the wallet
//
Wallets.prototype.remove = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    return this.bitgo.del(this.bitgo.url('/wallet/' + params.id))
        .result()
        .nodeify(callback);
};
module.exports = Wallets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93YWxsZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFSDtHQUNHO0FBQ0gsRUFBRTtBQUNGLGlCQUFpQjtBQUNqQixzQ0FBc0M7QUFDdEMsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFO0FBRUYsd0NBQTBDO0FBQzFDLHFDQUE4RDtBQUM5RCxpQ0FBbUM7QUFDbkMsMEJBQTRCO0FBQzVCLG1DQUFxQztBQUNyQyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBQzlCLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUVuQyxFQUFFO0FBQ0YsY0FBYztBQUNkLEVBQUU7QUFDRixJQUFNLE9BQU8sR0FBRyxVQUFTLEtBQUs7SUFDNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDckIsQ0FBQyxDQUFDO0FBRUYsRUFBRTtBQUNGLE9BQU87QUFDUCwwQkFBMEI7QUFDMUIsRUFBRTtBQUNGLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDaEQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUVoRCxJQUFNLElBQUksR0FBYSxFQUFFLENBQUM7SUFFMUIsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7UUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0tBQ3hEO0lBRUQsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1FBQ2hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FB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QztBQUVGLEVBQUU7QUFDRixNQUFNO0FBQ04seUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0IsRUFBRTtBQUNGLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDL0MsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUMxQyxDQUFDLENBQUM7QUFFRixFQUFFO0FBQ0YsU0FBUztBQUNULDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCLEVBQUU7QUFDRixPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFTLE1BQU0sRUFBRSxRQUFRO0lBQ2xELE1BQU0sR0FBRyxNQUFNLElBQUksRUFBRSxDQUFDO0lBQ3RCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRXBELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUM1RCxNQUFNLEVBQUU7U0FDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuLy9cbi8vIFdhbGxldHMgT2JqZWN0XG4vLyBCaXRHbyBhY2Nlc3NvciB0byBhIHVzZXIncyB3YWxsZXRzLlxuLy9cbi8vIENvcHlyaWdodCAyMDE0LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5cbmltcG9ydCAqIGFzIGJpdGNvaW4gZnJvbSAnYml0Z28tdXR4by1saWInO1xuaW1wb3J0IHsgbWFrZVJhbmRvbUtleSwgaGRQYXRoLCBnZXROZXR3b3JrIH0gZnJvbSAnLi9iaXRjb2luJztcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcbmNvbnN0IFdhbGxldCA9IHJlcXVpcmUoJy4vd2FsbGV0Jyk7XG5cbi8vXG4vLyBDb25zdHJ1Y3RvclxuLy9cbmNvbnN0IFdhbGxldHMgPSBmdW5jdGlvbihiaXRnbykge1xuICB0aGlzLmJpdGdvID0gYml0Z287XG59O1xuXG4vL1xuLy8gbGlzdFxuLy8gTGlzdCB0aGUgdXNlcidzIHdhbGxldHNcbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IGFyZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgaWYgKHBhcmFtcy5za2lwICYmIHBhcmFtcy5wcmV2SWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IGJvdGggc2tpcCBhbmQgcHJldklkJyk7XG4gIH1cblxuICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH1cbiAgICBhcmdzLnB1c2goJ2xpbWl0PScgKyBwYXJhbXMubGltaXQpO1xuICB9XG4gIGlmIChwYXJhbXMuZ2V0YmFsYW5jZXMpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5nZXRiYWxhbmNlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBnZXRiYWxhbmNlcyBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKCdnZXRiYWxhbmNlcz0nICsgcGFyYW1zLmdldGJhbGFuY2VzKTtcbiAgfVxuICBpZiAocGFyYW1zLnNraXApIHtcbiAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnNraXApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2tpcCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH1cbiAgICBhcmdzLnB1c2goJ3NraXA9JyArIHBhcmFtcy5za2lwKTtcbiAgfSBlbHNlIGlmIChwYXJhbXMucHJldklkKSB7XG4gICAgYXJncy5wdXNoKCdwcmV2SWQ9JyArIHBhcmFtcy5wcmV2SWQpO1xuICB9XG5cbiAgbGV0IHF1ZXJ5ID0gJyc7XG4gIGlmIChhcmdzLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgYXJncy5qb2luKCcmJyk7XG4gIH1cblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYml0Z28udXJsKCcvd2FsbGV0JyArIHF1ZXJ5KSlcbiAgLnJlc3VsdCgpXG4gIC50aGVuKGZ1bmN0aW9uKGJvZHkpIHtcbiAgICBib2R5LndhbGxldHMgPSBib2R5LndhbGxldHMubWFwKGZ1bmN0aW9uKHcpIHsgcmV0dXJuIG5ldyBXYWxsZXQoc2VsZi5iaXRnbywgdyk7IH0pO1xuICAgIHJldHVybiBib2R5O1xuICB9KVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXRzLnByb3RvdHlwZS5nZXRXYWxsZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIGxldCBxdWVyeSA9ICcnO1xuICBpZiAocGFyYW1zLmdwaykge1xuICAgIHF1ZXJ5ID0gJz9ncGs9MSc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy5iaXRnby51cmwoJy93YWxsZXQvJyArIHBhcmFtcy5pZCArIHF1ZXJ5KSlcbiAgLnJlc3VsdCgpXG4gIC50aGVuKGZ1bmN0aW9uKHdhbGxldCkge1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHNlbGYuYml0Z28sIHdhbGxldCk7XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBsaXN0SW52aXRlc1xuLy8gTGlzdCB0aGUgaW52aXRlcyBvbiBhIHVzZXJcbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5saXN0SW52aXRlcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy5iaXRnby51cmwoJy93YWxsZXRpbnZpdGUnKSlcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBjYW5jZWxJbnZpdGVcbi8vIGNhbmNlbCBhIHdhbGxldCBpbnZpdGUgdGhhdCBhIHVzZXIgaW5pdGlhdGVkXG4vL1xuV2FsbGV0cy5wcm90b3R5cGUuY2FuY2VsSW52aXRlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0SW52aXRlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy5iaXRnby51cmwoJy93YWxsZXRpbnZpdGUvJyArIHBhcmFtcy53YWxsZXRJbnZpdGVJZCkpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gbGlzdFNoYXJlc1xuLy8gTGlzdCB0aGUgdXNlcidzIHdhbGxldCBzaGFyZXNcbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5saXN0U2hhcmVzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldHNoYXJlJykpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gcmVzZW5kU2hhcmVJbnZpdGVcbi8vIFJlc2VuZCB0aGUgaW52aXRhdGlvbiBlbWFpbCB3aGljaCBzaGFyZXMgYSB3YWxsZXQgd2l0aCBhbm90aGVyIHVzZXJcbi8vIFBhcmFtczpcbi8vICAgIHdhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIGdldCBpbmZvcm1hdGlvbiBvblxuLy9cbldhbGxldHMucHJvdG90eXBlLnJlc2VuZFNoYXJlSW52aXRlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICBjb25zdCB1cmxQYXJ0cyA9IHBhcmFtcy53YWxsZXRTaGFyZUlkICsgJy9yZXNlbmRlbWFpbCc7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldHNoYXJlLycgKyB1cmxQYXJ0cykpXG4gICAgLnJlc3VsdCgpO1xuICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGdldFNoYXJlXG4vLyBHZXRzIGEgd2FsbGV0IHNoYXJlIGluZm9ybWF0aW9uLCBpbmNsdWRpbmcgdGhlIGVuY3J5cHRlZCBzaGFyaW5nIGtleWNoYWluLiByZXF1aXJlcyB1bmxvY2sgaWYga2V5Y2hhaW4gaXMgcHJlc2VudC5cbi8vIFBhcmFtczpcbi8vICAgIHdhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIGdldCBpbmZvcm1hdGlvbiBvblxuLy9cbldhbGxldHMucHJvdG90eXBlLmdldFNoYXJlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldHNoYXJlLycgKyBwYXJhbXMud2FsbGV0U2hhcmVJZCkpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gdXBkYXRlU2hhcmVcbi8vIHVwZGF0ZXMgYSB3YWxsZXQgc2hhcmVcbi8vIFBhcmFtczpcbi8vICAgIHdhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIHVwZGF0ZVxuLy8gICAgc3RhdGUgLSB0aGUgbmV3IHN0YXRlIG9mIHRoZSB3YWxsZXQgc2hhcmVcbi8vXG5XYWxsZXRzLnByb3RvdHlwZS51cGRhdGVTaGFyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMuYml0Z28udXJsKCcvd2FsbGV0c2hhcmUvJyArIHBhcmFtcy53YWxsZXRTaGFyZUlkKSlcbiAgLnNlbmQocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGNhbmNlbFNoYXJlXG4vLyBjYW5jZWxzIGEgd2FsbGV0IHNoYXJlXG4vLyBQYXJhbXM6XG4vLyAgICB3YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byB1cGRhdGVcbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5jYW5jZWxTaGFyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy5iaXRnby51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKVxuICAuc2VuZCgpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gYWNjZXB0U2hhcmVcbi8vIEFjY2VwdHMgYSB3YWxsZXQgc2hhcmUsIGFkZGluZyB0aGUgd2FsbGV0IHRvIHRoZSB1c2VyJ3MgbGlzdFxuLy8gTmVlZHMgYSB1c2VyJ3MgcGFzc3dvcmQgdG8gZGVjcnlwdCB0aGUgc2hhcmVkIGtleVxuLy8gUGFyYW1zOlxuLy8gICAgd2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gYWNjZXB0XG4vLyAgICB1c2VyUGFzc3dvcmQgLSAocmVxdWlyZWQgaWYgbW9yZSBhIGtleWNoYWluIHdhcyBzaGFyZWQpIHVzZXIncyBwYXNzd29yZCB0byBkZWNyeXB0IHRoZSBzaGFyZWQgd2FsbGV0XG4vLyAgICBuZXdXYWxsZXRQYXNzcGhyYXNlIC0gbmV3IHdhbGxldCBwYXNzcGhyYXNlIGZvciBzYXZpbmcgdGhlIHNoYXJlZCB3YWxsZXQgeHBydi5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBsZWZ0IGJsYW5rIGFuZCBhIHdhbGxldCB3aXRoIG1vcmUgdGhhbiB2aWV3IHBlcm1pc3Npb25zIHdhcyBzaGFyZWQsIHRoZW4gdGhlIHVzZXJwYXNzd29yZCBpcyB1c2VkLlxuLy8gICAgb3ZlcnJpZGVFbmNyeXB0ZWRYcHJ2IC0gc2V0IG9ubHkgaWYgdGhlIHhwcnYgd2FzIHJlY2VpdmVkIG91dC1vZi1iYW5kLlxuLy9cbldhbGxldHMucHJvdG90eXBlLmFjY2VwdFNoYXJlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbJ292ZXJyaWRlRW5jcnlwdGVkWHBydiddLCBjYWxsYmFjayk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGxldCBlbmNyeXB0ZWRYcHJ2ID0gcGFyYW1zLm92ZXJyaWRlRW5jcnlwdGVkWHBydjtcblxuICByZXR1cm4gdGhpcy5nZXRTaGFyZSh7IHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkIH0pXG4gIC50aGVuKGZ1bmN0aW9uKHdhbGxldFNoYXJlKSB7XG4gICAgLy8gUmV0dXJuIHJpZ2h0IGF3YXkgaWYgdGhlcmUgaXMgbm8ga2V5Y2hhaW4gdG8gZGVjcnlwdCwgb3IgaWYgZXhwbGljaXQgZW5jcnlwdGVkWHBydiB3YXMgcHJvdmlkZWRcbiAgICBpZiAoIXdhbGxldFNoYXJlLmtleWNoYWluIHx8ICF3YWxsZXRTaGFyZS5rZXljaGFpbi5lbmNyeXB0ZWRYcHJ2IHx8IGVuY3J5cHRlZFhwcnYpIHtcbiAgICAgIHJldHVybiB3YWxsZXRTaGFyZTtcbiAgICB9XG5cbiAgICAvLyBNb3JlIHRoYW4gdmlld2luZyB3YXMgcmVxdWVzdGVkLCBzbyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIHdhbGxldCBrZXlzIHVzaW5nIHRoZSBzaGFyZWQgZWNkaCBzY2hlbWVcbiAgICBpZiAoIXBhcmFtcy51c2VyUGFzc3dvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXNlclBhc3N3b3JkIHBhcmFtIG11c3QgYmUgcHJvdmlkZWQgdG8gZGVjcnlwdCBzaGFyZWQga2V5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuYml0Z28uZ2V0RUNESFNoYXJpbmdLZXljaGFpbigpXG4gICAgLnRoZW4oZnVuY3Rpb24oc2hhcmluZ0tleWNoYWluKSB7XG4gICAgICBpZiAoIXNoYXJpbmdLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkWHBydiB3YXMgbm90IGZvdW5kIG9uIHNoYXJpbmcga2V5Y2hhaW4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IHdlIGhhdmUgdGhlIHNoYXJpbmcga2V5Y2hhaW4sIHdlIGNhbiB3b3JrIG91dCB0aGUgc2VjcmV0IHVzZWQgZm9yIHNoYXJpbmcgdGhlIHdhbGxldCB3aXRoIHVzXG4gICAgICBzaGFyaW5nS2V5Y2hhaW4ueHBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7IHBhc3N3b3JkOiBwYXJhbXMudXNlclBhc3N3b3JkLCBpbnB1dDogc2hhcmluZ0tleWNoYWluLmVuY3J5cHRlZFhwcnYgfSk7XG4gICAgICBjb25zdCByb290RXh0S2V5ID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChzaGFyaW5nS2V5Y2hhaW4ueHBydik7XG5cbiAgICAgIC8vIERlcml2ZSBrZXkgYnkgcGF0aCAod2hpY2ggaXMgdXNlZCBiZXR3ZWVuIHRoZXNlIDIgdXNlcnMgb25seSlcbiAgICAgIGNvbnN0IHByaXZLZXkgPSBoZFBhdGgocm9vdEV4dEtleSkuZGVyaXZlS2V5KHdhbGxldFNoYXJlLmtleWNoYWluLnBhdGgpO1xuICAgICAgY29uc3Qgc2VjcmV0ID0gc2VsZi5iaXRnby5nZXRFQ0RIU2VjcmV0KHsgZWNrZXk6IHByaXZLZXksIG90aGVyUHViS2V5SGV4OiB3YWxsZXRTaGFyZS5rZXljaGFpbi5mcm9tUHViS2V5IH0pO1xuXG4gICAgICAvLyBZZXMhIFdlIGdvdCB0aGUgc2VjcmV0IHN1Y2Nlc3NmdWxseSBoZXJlLCBub3cgZGVjcnlwdCB0aGUgc2hhcmVkIHdhbGxldCB4cHJ2XG4gICAgICBjb25zdCBkZWNyeXB0ZWRTaGFyZWRXYWxsZXRYcHJ2ID0gc2VsZi5iaXRnby5kZWNyeXB0KHsgcGFzc3dvcmQ6IHNlY3JldCwgaW5wdXQ6IHdhbGxldFNoYXJlLmtleWNoYWluLmVuY3J5cHRlZFhwcnYgfSk7XG5cbiAgICAgIC8vIFdlIHdpbGwgbm93IHJlLWVuY3J5cHQgdGhlIHdhbGxldCB3aXRoIG91ciBvd24gcGFzc3dvcmRcbiAgICAgIGNvbnN0IG5ld1dhbGxldFBhc3NwaHJhc2UgPSBwYXJhbXMubmV3V2FsbGV0UGFzc3BocmFzZSB8fCBwYXJhbXMudXNlclBhc3N3b3JkO1xuICAgICAgZW5jcnlwdGVkWHBydiA9IHNlbGYuYml0Z28uZW5jcnlwdCh7IHBhc3N3b3JkOiBuZXdXYWxsZXRQYXNzcGhyYXNlLCBpbnB1dDogZGVjcnlwdGVkU2hhcmVkV2FsbGV0WHBydiB9KTtcblxuICAgICAgLy8gQ2Fycnkgb24gdG8gdGhlIG5leHQgYmxvY2sgd2hlcmUgd2Ugd2lsbCBwb3N0IHRoZSBhY2NlcHRhbmNlIG9mIHRoZSBzaGFyZSB3aXRoIHRoZSBlbmNyeXB0ZWQgeHBydlxuICAgICAgcmV0dXJuIHdhbGxldFNoYXJlO1xuICAgIH0pO1xuICB9KVxuICAudGhlbihmdW5jdGlvbih3YWxsZXRTaGFyZSkge1xuICAgIGNvbnN0IHVwZGF0ZVBhcmFtczogYW55ID0ge1xuICAgICAgd2FsbGV0U2hhcmVJZDogcGFyYW1zLndhbGxldFNoYXJlSWQsXG4gICAgICBzdGF0ZTogJ2FjY2VwdGVkJ1xuICAgIH07XG5cbiAgICBpZiAoZW5jcnlwdGVkWHBydikge1xuICAgICAgdXBkYXRlUGFyYW1zLmVuY3J5cHRlZFhwcnYgPSBlbmNyeXB0ZWRYcHJ2O1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnVwZGF0ZVNoYXJlKHVwZGF0ZVBhcmFtcyk7XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBjcmVhdGVLZXlcbi8vIENyZWF0ZSBhIHNpbmdsZSBiaXRjb2luIGtleS4gIFRoaXMgcnVucyBsb2NhbGx5LlxuLy8gUmV0dXJuczoge1xuLy8gICBhZGRyZXNzOiA8YWRkcmVzcz5cbi8vICAga2V5OiA8a2V5LCBpbiBXSUYgZm9ybWF0PlxuLy8gfVxuV2FsbGV0cy5wcm90b3R5cGUuY3JlYXRlS2V5ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGNvbnN0IGtleSA9IG1ha2VSYW5kb21LZXkoKTtcbiAgcmV0dXJuIHtcbiAgICBhZGRyZXNzOiBrZXkuZ2V0QWRkcmVzcygpLFxuICAgIGtleToga2V5LnRvV0lGKClcbiAgfTtcbn07XG5cbi8vXG4vLyBjcmVhdGVXYWxsZXRXaXRoS2V5Y2hhaW5zXG4vLyBDcmVhdGUgYSBuZXcgMi1vZi0zIHdhbGxldCBhbmQgaXQncyBhc3NvY2lhdGVkIGtleWNoYWlucy5cbi8vIFJldHVybnMgdGhlIGxvY2FsbHkgY3JlYXRlZCBrZXlzIHdpdGggdGhlaXIgZW5jcnlwdGVkIHhwcnZzLlxuLy8gKipXQVJOSU5HOiBCRSBTVVJFIFRPIEJBQ0tVUCEgTk9UIERPSU5HIFNPIENBTiBSRVNVTFQgSU4gTE9TUyBPRiBGVU5EUyEqKlxuLy9cbi8vIDEuIENyZWF0ZXMgdGhlIHVzZXIga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuLy8gMi4gSWYgbm8geHB1YiB3YXMgcHJvdmlkZWQsIGNyZWF0ZXMgdGhlIGJhY2t1cCBrZXljaGFpbiBsb2NhbGx5IG9uIHRoZSBjbGllbnQsIGFuZCBlbmNyeXB0cyBpdCB3aXRoIHRoZSBwcm92aWRlZCBwYXNzcGhyYXNlXG4vLyAzLiBVcGxvYWRzIHRoZSBlbmNyeXB0ZWQgdXNlciBhbmQgYmFja3VwIGtleWNoYWlucyB0byBCaXRHb1xuLy8gNC4gQ3JlYXRlcyB0aGUgQml0R28ga2V5IG9uIHRoZSBzZXJ2aWNlXG4vLyA1LiBDcmVhdGVzIHRoZSB3YWxsZXQgb24gQml0R28gd2l0aCB0aGUgMyBwdWJsaWMga2V5cyBhYm92ZVxuLy9cbi8vIFBhcmFtZXRlcnMgaW5jbHVkZTpcbi8vICAgXCJwYXNzcGhyYXNlXCI6IHdhbGxldCBwYXNzcGhyYXNlIHRvIGVuY3J5cHQgdXNlciBhbmQgYmFja3VwIGtleXMgd2l0aFxuLy8gICBcImxhYmVsXCI6IHdhbGxldCBsYWJlbCwgaXMgc2hvd24gaW4gQml0R28gVUlcbi8vICAgXCJiYWNrdXBYcHViXCI6IGJhY2t1cCBrZXljaGFpbiB4cHViLCBpdCBpcyBISUdITFkgUkVDT01NRU5ERUQgeW91IGdlbmVyYXRlIHRoaXMgb24gYSBzZXBhcmF0ZSBtYWNoaW5lIVxuLy8gICAgICAgICAgICAgICAgIEJJVEdPIERPRVMgTk9UIEdVQVJBTlRFRSBTQUZFVFkgT0YgV0FMTEVUUyBXSVRIIE1VTFRJUExFIEtFWVMgQ1JFQVRFRCBPTiBUSEUgU0FNRSBNQUNISU5FICoqXG4vLyAgIFwiYmFja3VwWHB1YlByb3ZpZGVyXCI6IFByb3Zpc2lvbiBiYWNrdXAga2V5IGZyb20gdGhpcyBwcm92aWRlciAoS1JTKSwgZS5nLiBcImtleXRlcm5hbFwiLlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgY3JlYXRlIGFuIGluc3RhbnQtY2FwYWJsZSB3YWxsZXQuXG4vLyAgIFwicGFzc2NvZGVFbmNyeXB0aW9uQ29kZVwiOiB0aGUgY29kZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHdhbGxldCBwYXNzY29kZSB1c2VkIGluIHRoZSByZWNvdmVyeSBwcm9jZXNzXG4vLyBSZXR1cm5zOiB7XG4vLyAgIHdhbGxldDogbmV3bHkgY3JlYXRlZCB3YWxsZXQgbW9kZWwgb2JqZWN0XG4vLyAgIHVzZXJLZXljaGFpbjogdGhlIG5ld2x5IGNyZWF0ZWQgdXNlciBrZXljaGFpbiwgd2hpY2ggaGFzIGFuIGVuY3J5cHRlZCB4cHJ2IHN0b3JlZCBvbiBCaXRHb1xuLy8gICBiYWNrdXBLZXljaGFpbjogdGhlIG5ld2x5IGNyZWF0ZWQgYmFja3VwIGtleWNoYWluXG4vL1xuLy8gKiogQkUgU1VSRSBUTyBCQUNLIFVQIFRIRSBFTkNSWVBURUQgVVNFUiBBTkQgQkFDS1VQIEtFWUNIQUlOUyEqKlxuLy9cbi8vIH1cbldhbGxldHMucHJvdG90eXBlLmNyZWF0ZVdhbGxldFdpdGhLZXljaGFpbnMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydwYXNzcGhyYXNlJ10sIFsnbGFiZWwnLCAnYmFja3VwWHB1YicsICdlbnRlcnByaXNlJywgJ3Bhc3Njb2RlRW5jcnlwdGlvbkNvZGUnXSwgY2FsbGJhY2spO1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3QgbGFiZWwgPSBwYXJhbXMubGFiZWw7XG5cbiAgLy8gQ3JlYXRlIHRoZSB1c2VyIGFuZCBiYWNrdXAga2V5LlxuICBjb25zdCB1c2VyS2V5Y2hhaW4gPSB0aGlzLmJpdGdvLmtleWNoYWlucygpLmNyZWF0ZSgpO1xuICB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkWHBydiA9IHRoaXMuYml0Z28uZW5jcnlwdCh7IHBhc3N3b3JkOiBwYXJhbXMucGFzc3BocmFzZSwgaW5wdXQ6IHVzZXJLZXljaGFpbi54cHJ2IH0pO1xuXG4gIGNvbnN0IGtleWNoYWluRGF0YTogYW55ID0ge1xuICAgIHhwdWI6IHVzZXJLZXljaGFpbi54cHViLFxuICAgIGVuY3J5cHRlZFhwcnY6IHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2XG4gIH07XG5cbiAgaWYgKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSB7XG4gICAga2V5Y2hhaW5EYXRhLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSA9IHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlO1xuICB9XG5cbiAgY29uc3QgaGFzQmFja3VwWHB1YiA9ICEhcGFyYW1zLmJhY2t1cFhwdWI7XG4gIGNvbnN0IGhhc0JhY2t1cFhwdWJQcm92aWRlciA9ICEhcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlcjtcbiAgaWYgKGhhc0JhY2t1cFhwdWIgJiYgaGFzQmFja3VwWHB1YlByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcHJvdmlkZSBtb3JlIHRoYW4gb25lIGJhY2t1cFhwdWIgb3IgYmFja3VwWHB1YlByb3ZpZGVyIGZsYWcnKTtcbiAgfVxuXG4gIGlmIChwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucyAhPT0gdW5kZWZpbmVkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMgdG8gYmUgYSBib29sZWFuLiAnKTtcbiAgfVxuXG4gIGxldCBiYWNrdXBLZXljaGFpbjtcbiAgbGV0IGJpdGdvS2V5Y2hhaW47XG5cbiAgLy8gQWRkIHRoZSB1c2VyIGtleWNoYWluXG4gIHJldHVybiBzZWxmLmJpdGdvLmtleWNoYWlucygpLmFkZChrZXljaGFpbkRhdGEpXG4gIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgIC8vIEFkZCB0aGUgYmFja3VwIGtleWNoYWluXG4gICAgaWYgKHBhcmFtcy5iYWNrdXBYcHViUHJvdmlkZXIpIHtcbiAgICAgIC8vIElmIHJlcXVlc3RlZCwgdXNlIGEgS1JTIG9yIGJhY2t1cCBrZXkgcHJvdmlkZXJcbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLmtleWNoYWlucygpLmNyZWF0ZUJhY2t1cCh7XG4gICAgICAgIHByb3ZpZGVyOiBwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyLFxuICAgICAgICBkaXNhYmxlS1JTRW1haWw6IHBhcmFtcy5kaXNhYmxlS1JTRW1haWxcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbihrZXljaGFpbikge1xuICAgICAgICBiYWNrdXBLZXljaGFpbiA9IGtleWNoYWluO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5iYWNrdXBYcHViKSB7XG4gICAgICAvLyB1c2VyIHByb3ZpZGVkIGJhY2t1cCB4cHViXG4gICAgICBiYWNrdXBLZXljaGFpbiA9IHsgeHB1YjogcGFyYW1zLmJhY2t1cFhwdWIgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gcHJvdmlkZWQgeHB1Yiwgc28gZGVmYXVsdCB0byBjcmVhdGluZyBvbmUgaGVyZVxuICAgICAgYmFja3VwS2V5Y2hhaW4gPSBzZWxmLmJpdGdvLmtleWNoYWlucygpLmNyZWF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLmJpdGdvLmtleWNoYWlucygpLmFkZChiYWNrdXBLZXljaGFpbik7XG4gIH0pXG4gIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmJpdGdvLmtleWNoYWlucygpLmNyZWF0ZUJpdEdvKCk7XG4gIH0pXG4gIC50aGVuKGZ1bmN0aW9uKGtleWNoYWluKSB7XG4gICAgYml0Z29LZXljaGFpbiA9IGtleWNoYWluO1xuICAgIGNvbnN0IHdhbGxldFBhcmFtczogYW55ID0ge1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgbTogMixcbiAgICAgIG46IDMsXG4gICAgICBrZXljaGFpbnM6IFtcbiAgICAgICAgeyB4cHViOiB1c2VyS2V5Y2hhaW4ueHB1YiB9LFxuICAgICAgICB7IHhwdWI6IGJhY2t1cEtleWNoYWluLnhwdWIgfSxcbiAgICAgICAgeyB4cHViOiBiaXRnb0tleWNoYWluLnhwdWIgfV1cbiAgICB9O1xuXG4gICAgaWYgKHBhcmFtcy5lbnRlcnByaXNlKSB7XG4gICAgICB3YWxsZXRQYXJhbXMuZW50ZXJwcmlzZSA9IHBhcmFtcy5lbnRlcnByaXNlO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucykge1xuICAgICAgd2FsbGV0UGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMgPSBwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5hZGQod2FsbGV0UGFyYW1zKTtcbiAgfSlcbiAgLnRoZW4oZnVuY3Rpb24obmV3V2FsbGV0KSB7XG4gICAgY29uc3QgcmVzdWx0OiBhbnkgPSB7XG4gICAgICB3YWxsZXQ6IG5ld1dhbGxldCxcbiAgICAgIHVzZXJLZXljaGFpbjogdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW46IGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbjogYml0Z29LZXljaGFpblxuICAgIH07XG5cbiAgICBpZiAoYmFja3VwS2V5Y2hhaW4ueHBydikge1xuICAgICAgcmVzdWx0Lndhcm5pbmcgPSAnQmUgc3VyZSB0byBiYWNrdXAgdGhlIGJhY2t1cCBrZXljaGFpbiAtLSBpdCBpcyBub3Qgc3RvcmVkIGFueXdoZXJlIGVsc2UhJztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gY3JlYXRlRm9yd2FyZFdhbGxldFxuLy8gQ3JlYXRlcyBhIGZvcndhcmQgd2FsbGV0IGZyb20gYSBzaW5nbGUgcHJpdmF0ZSBrZXkuXG4vLyBCaXRHbyB3aWxsIHdhdGNoIHRoZSB3YWxsZXQgYW5kIHNlbmQgYW55IGluY29taW5nIHRyYW5zYWN0aW9ucyB0byBhIGRlc3RpbmF0aW9uIG11bHRpLXNpZyB3YWxsZXRcbi8vIFdBUk5JTkc6IFRIRSBQUklWQVRFIEtFWSBXSUxMIEJFIFNFTlQgVE8gQklUR08uIFlPVSBNVVNUIENPTlRBQ1QgQklUR08gQkVGT1JFIFVTSU5HIFRISVMgRkVBVFVSRSFcbi8vIFdFIENBTk5PVCBHVUFSQU5URUUgVEhFIFNFQ1VSSVRZIE9GIFNJTkdMRS1TSUcgV0FMTEVUUyBBUyBDVVNUT0RZIElTIFVOQ0xFQVIuXG4vL1xuLy8gUGFyYW1zOlxuLy8gICAgcHJpdktleSAtIHRoZSBwcml2YXRlIGtleSBvbiBhIGxlZ2FjeSBzaW5nbGUtc2lnbmF0dXJlIHdhbGxldCB0byBiZSB3YXRjaGVkIChXSUYgZm9ybWF0KVxuLy8gICAgc291cmNlQWRkcmVzcyAtIHRoZSBiaXRjb2luIGFkZHJlc3MgdG8gZm9yd2FyZCBmcm9tIChjb3JyZXNwb25kcyB0byB0aGUgcHJpdmF0ZSBrZXkpXG4vLyAgICBkZXN0aW5hdGlvbldhbGxldCAtIHRoZSB3YWxsZXQgb2JqZWN0IHRvIHNlbmQgdGhlIGRlc3RpbmF0aW9uIGNvaW5zIHRvICh3aGVuIGluY29taW5nIHRyYW5zYWN0aW9ucyBhcmUgZGV0ZWN0ZWQpXG4vLyAgICBsYWJlbCAtIGxhYmVsIGZvciB0aGUgd2FsbGV0XG4vL1xuV2FsbGV0cy5wcm90b3R5cGUuY3JlYXRlRm9yd2FyZFdhbGxldCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3ByaXZLZXknLCAnc291cmNlQWRkcmVzcyddLCBbJ2xhYmVsJ10sIGNhbGxiYWNrKTtcblxuICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmRlc3RpbmF0aW9uV2FsbGV0KSB8fCAhcGFyYW1zLmRlc3RpbmF0aW9uV2FsbGV0LmlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgZGVzdGluYXRpb25XYWxsZXQgb2JqZWN0Jyk7XG4gIH1cblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICBsZXQgbmV3RGVzdGluYXRpb25BZGRyZXNzO1xuICBsZXQgYWRkcmVzc0Zyb21Qcml2S2V5O1xuXG4gIHRyeSB7XG4gICAgY29uc3Qga2V5ID0gYml0Y29pbi5FQ1BhaXIuZnJvbVdJRihwYXJhbXMucHJpdktleSwgZ2V0TmV0d29yaygpKTtcbiAgICBhZGRyZXNzRnJvbVByaXZLZXkgPSBrZXkuZ2V0QWRkcmVzcygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgYSB2YWxpZCBwcml2S2V5Jyk7XG4gIH1cblxuICBpZiAoYWRkcmVzc0Zyb21Qcml2S2V5ICE9PSBwYXJhbXMuc291cmNlQWRkcmVzcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdktleSBkb2VzIG5vdCBtYXRjaCBzb3VyY2UgYWRkcmVzcyAtIGdvdCAnICsgYWRkcmVzc0Zyb21Qcml2S2V5ICsgJyBleHBlY3RlZCAnICsgcGFyYW1zLnNvdXJjZUFkZHJlc3MpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcy5kZXN0aW5hdGlvbldhbGxldC5jcmVhdGVBZGRyZXNzKClcbiAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgLy8gQ3JlYXRlIG5ldyBhZGRyZXNzIG9uIHRoZSBkZXN0aW5hdGlvbiB3YWxsZXQgdG8gcmVjZWl2ZSBjb2luc1xuICAgIG5ld0Rlc3RpbmF0aW9uQWRkcmVzcyA9IHJlc3VsdC5hZGRyZXNzO1xuXG4gICAgY29uc3Qgd2FsbGV0UGFyYW1zOiBhbnkgPSB7XG4gICAgICB0eXBlOiAnZm9yd2FyZCcsXG4gICAgICBzb3VyY2VBZGRyZXNzOiBwYXJhbXMuc291cmNlQWRkcmVzcyxcbiAgICAgIGRlc3RpbmF0aW9uQWRkcmVzczogbmV3RGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgcHJpdktleTogcGFyYW1zLnByaXZLZXksXG4gICAgICBsYWJlbDogcGFyYW1zLmxhYmVsXG4gICAgfTtcblxuICAgIGlmIChwYXJhbXMuZW50ZXJwcmlzZSkge1xuICAgICAgd2FsbGV0UGFyYW1zLmVudGVycHJpc2UgPSBwYXJhbXMuZW50ZXJwcmlzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5iaXRnby5wb3N0KHNlbGYuYml0Z28udXJsKCcvd2FsbGV0JykpXG4gICAgLnNlbmQod2FsbGV0UGFyYW1zKVxuICAgIC5yZXN1bHQoKVxuICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfSk7XG59O1xuXG4vKipcbiogQWRkIGEgbmV3IHdhbGxldCAoYWR2YW5jZWQgbW9kZSkuXG4qIFRoaXMgYWxsb3dzIHlvdSB0byBtYW51YWxseSBzdWJtaXQgdGhlIGtleWNoYWlucywgdHlwZSwgbSBhbmQgbiBvZiB0aGUgd2FsbGV0XG4qIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbCBvZiB0aGUgd2FsbGV0IHRvIGJlIHNob3duIGluIFVJXG4qIEBwYXJhbSB7bnVtYmVyfSBtIG51bWJlciBvZiBrZXlzIHJlcXVpcmVkIHRvIHVubG9jayB3YWxsZXQgKDIpXG4qIEBwYXJhbSB7bnVtYmVyfSBuIG51bWJlciBvZiBrZXlzIGF2YWlsYWJsZSBvbiB0aGUgd2FsbGV0ICgzKVxuKiBAcGFyYW0ge2FycmF5fSBrZXljaGFpbnMgYXJyYXkgb2Yga2V5Y2hhaW4geHB1YnNcbiogQHBhcmFtIHtzdHJpbmd9IGVudGVycHJpc2UgSUQgb2YgdGhlIGVudGVycHJpc2UgZW50aXR5IHRvIGNyZWF0ZSB0aGlzIHdhbGxldCB1bmRlci5cbiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zIFdoZW4gc2V0IHRvIHRydWUgZGlzYWJsZXMgbm90aWZpY2F0aW9ucyBmb3IgdHJhbnNhY3Rpb25zIG9uIHRoaXMgd2FsbGV0LlxuKi9cbldhbGxldHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydsYWJlbCcsICdlbnRlcnByaXNlJ10sIGNhbGxiYWNrKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMua2V5Y2hhaW5zKSA9PT0gZmFsc2UgfHwgIV8uaXNOdW1iZXIocGFyYW1zLm0pIHx8XG4gICAgIV8uaXNOdW1iZXIocGFyYW1zLm4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICAvLyBUT0RPOiBzdXBwb3J0IG1vcmUgdHlwZXMgb2YgbXVsdGlzaWdcbiAgaWYgKHBhcmFtcy5tICE9PSAyIHx8IHBhcmFtcy5uICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBtdWx0aS1zaWcgdHlwZScpO1xuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IGtleWNoYWlucyA9IHBhcmFtcy5rZXljaGFpbnMubWFwKGZ1bmN0aW9uKGspIHsgcmV0dXJuIHsgeHB1Yjogay54cHViIH07IH0pO1xuICBjb25zdCB3YWxsZXRQYXJhbXM6IGFueSA9IHtcbiAgICBsYWJlbDogcGFyYW1zLmxhYmVsLFxuICAgIG06IHBhcmFtcy5tLFxuICAgIG46IHBhcmFtcy5uLFxuICAgIGtleWNoYWluczoga2V5Y2hhaW5zXG4gIH07XG5cbiAgaWYgKHBhcmFtcy5lbnRlcnByaXNlKSB7XG4gICAgd2FsbGV0UGFyYW1zLmVudGVycHJpc2UgPSBwYXJhbXMuZW50ZXJwcmlzZTtcbiAgfVxuXG4gIGlmIChwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucykge1xuICAgIHdhbGxldFBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zID0gcGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMuYml0Z28udXJsKCcvd2FsbGV0JykpXG4gIC5zZW5kKHdhbGxldFBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC50aGVuKGZ1bmN0aW9uKGJvZHkpIHtcbiAgICByZXR1cm4gbmV3IFdhbGxldChzZWxmLmJpdGdvLCBib2R5KTtcbiAgfSlcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGdldFxuLy8gU2hvcnRoYW5kIHRvIGdldFdhbGxldFxuLy8gUGFyYW1ldGVycyBpbmNsdWRlOlxuLy8gICBpZDogdGhlIGlkIG9mIHRoZSB3YWxsZXRcbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmdldFdhbGxldChwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyByZW1vdmVcbi8vIFJlbW92ZSBhbiBleGlzdGluZyB3YWxsZXQuXG4vLyBQYXJhbWV0ZXJzIGluY2x1ZGU6XG4vLyAgIGlkOiB0aGUgaWQgb2YgdGhlIHdhbGxldFxuLy9cbldhbGxldHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMuYml0Z28udXJsKCcvd2FsbGV0LycgKyBwYXJhbXMuaWQpKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXYWxsZXRzO1xuIl19