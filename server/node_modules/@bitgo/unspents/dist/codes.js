"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const tcomb = __importStar(require("tcomb"));
class ErrorInvalidCode extends Error {
    constructor(code) {
        super(`invalid code ${code}`);
    }
}
exports.ErrorInvalidCode = ErrorInvalidCode;
var UnspentType;
(function (UnspentType) {
    UnspentType["p2pkh"] = "p2pkh";
    UnspentType["p2sh"] = "p2sh";
    UnspentType["p2shP2wsh"] = "p2shP2wsh";
    UnspentType["p2wpkh"] = "p2wpkh";
    UnspentType["p2wsh"] = "p2wsh";
})(UnspentType = exports.UnspentType || (exports.UnspentType = {}));
const UnspentTypeTcomb = tcomb.enums.of(Object.keys(UnspentType));
var Purpose;
(function (Purpose) {
    Purpose["internal"] = "internal";
    Purpose["external"] = "external";
})(Purpose = exports.Purpose || (exports.Purpose = {}));
const PurposeTcomb = tcomb.enums.of(Object.keys(Purpose));
const codeList = Object.freeze([
    [0, UnspentType.p2sh, Purpose.external],
    [10, UnspentType.p2shP2wsh, Purpose.external],
    [20, UnspentType.p2wsh, Purpose.external],
    [1, UnspentType.p2sh, Purpose.internal],
    [11, UnspentType.p2shP2wsh, Purpose.internal],
    [21, UnspentType.p2wsh, Purpose.internal],
].map(([id, type, purpose]) => Object.freeze({ id, type, purpose })));
exports.ChainType = tcomb.irreducible('ChainType', (n) => exports.isValid(n));
const forType = (u) => {
    // Do tcomb type checking in js projects that use this lib
    if (!UnspentTypeTcomb.is(u)) {
        throw new Error(`invalid unspent type: ${u}`);
    }
    return new CodesByPurpose(u);
};
const typeForCode = (c) => {
    const code = codeList.find(({ id }) => id === c);
    if (!code) {
        throw new ErrorInvalidCode(c);
    }
    return code.type;
};
exports.isValid = (c) => codeList.some(({ id }) => id === c);
const throwIfUndefined = (v) => {
    if (v === undefined) {
        throw new Error(`expected value to be defined`);
    }
    return v;
};
class CodeGroup {
    constructor(values) {
        this.values = Object.freeze([...values]);
    }
    has(code) {
        if (!exports.isValid(code)) {
            throw new ErrorInvalidCode(code);
        }
        return this.values.includes(code);
    }
}
exports.CodeGroup = CodeGroup;
class CodesByPurpose extends CodeGroup {
    constructor(t) {
        const codeMap = new Map(codeList
            .filter(({ type }) => type === t)
            .map(({ purpose, id }) => [purpose, id]));
        if (codeMap.size !== 2) {
            throw new Error(`unexpected number of codes for type ${t}`);
        }
        super(codeMap.values());
        this.internal = throwIfUndefined(codeMap.get(Purpose.internal));
        this.external = throwIfUndefined(codeMap.get(Purpose.external));
    }
}
exports.CodesByPurpose = CodesByPurpose;
class CodesByType extends CodeGroup {
    constructor(p) {
        const codeMap = new Map(codeList
            .filter(({ purpose }) => purpose === p)
            .map(({ type, id }) => [type, id]));
        if (codeMap.size !== 3) {
            throw new Error(`unexpected result`);
        }
        super(codeMap.values());
        this.p2sh = throwIfUndefined(codeMap.get(UnspentType.p2sh));
        this.p2shP2wsh = throwIfUndefined(codeMap.get(UnspentType.p2shP2wsh));
        this.p2wsh = throwIfUndefined(codeMap.get(UnspentType.p2wsh));
    }
}
exports.CodesByType = CodesByType;
const boundHas = (instance) => instance.has.bind(instance);
const p2sh = Object.freeze(new CodesByPurpose(UnspentType.p2sh));
const p2shP2wsh = Object.freeze(new CodesByPurpose(UnspentType.p2shP2wsh));
const p2wsh = Object.freeze(new CodesByPurpose(UnspentType.p2wsh));
const external = Object.freeze(new CodesByType(Purpose.external));
const internal = Object.freeze(new CodesByType(Purpose.internal));
const all = Object.freeze(codeList.map(({ id }) => id));
exports.default = Object.freeze({
    /* @deprecated: use ChainCodeTcomb */
    ChainType: exports.ChainType,
    ChainCodeTcomb: exports.ChainType,
    PurposeTcomb,
    UnspentTypeTcomb,
    p2sh,
    p2shP2wsh,
    p2wsh,
    external,
    internal,
    all,
    isP2sh: boundHas(p2sh),
    isP2shP2wsh: boundHas(p2shP2wsh),
    isP2wsh: boundHas(p2wsh),
    isExternal: boundHas(external),
    isInternal: boundHas(internal),
    isValid: exports.isValid,
    forType,
    typeForCode,
});
//# sourceMappingURL=codes.js.map