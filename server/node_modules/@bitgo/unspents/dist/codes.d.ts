import * as tcomb from 'tcomb';
export declare type ChainCode = number;
export declare class ErrorInvalidCode extends Error {
    constructor(code: ChainCode);
}
export declare enum UnspentType {
    p2pkh = "p2pkh",
    p2sh = "p2sh",
    p2shP2wsh = "p2shP2wsh",
    p2wpkh = "p2wpkh",
    p2wsh = "p2wsh"
}
export declare enum Purpose {
    internal = "internal",
    external = "external"
}
export declare const ChainType: tcomb.Irreducible<{}>;
export declare const isValid: (c: number) => boolean;
export declare class CodeGroup {
    values: ReadonlyArray<ChainCode>;
    constructor(values: Iterable<ChainCode>);
    has(code: ChainCode): boolean;
}
export declare class CodesByPurpose extends CodeGroup {
    internal: ChainCode;
    external: ChainCode;
    constructor(t: UnspentType);
}
export declare class CodesByType extends CodeGroup {
    p2sh: ChainCode;
    p2shP2wsh: ChainCode;
    p2wsh: ChainCode;
    constructor(p: Purpose);
}
declare const _default: Readonly<{
    ChainType: tcomb.Irreducible<{}>;
    ChainCodeTcomb: tcomb.Irreducible<{}>;
    PurposeTcomb: tcomb.Enums;
    UnspentTypeTcomb: tcomb.Enums;
    p2sh: Readonly<CodesByPurpose>;
    p2shP2wsh: Readonly<CodesByPurpose>;
    p2wsh: Readonly<CodesByPurpose>;
    external: Readonly<CodesByType>;
    internal: Readonly<CodesByType>;
    all: ReadonlyArray<number>;
    isP2sh: (code: number) => boolean;
    isP2shP2wsh: (code: number) => boolean;
    isP2wsh: (code: number) => boolean;
    isExternal: (code: number) => boolean;
    isInternal: (code: number) => boolean;
    isValid: (c: number) => boolean;
    forType: (u: UnspentType) => CodesByPurpose;
    typeForCode: (c: number) => UnspentType;
}>;
export default _default;
