/// <reference types="node" />
import * as t from 'tcomb';
import { ChainCode } from './codes';
export declare const VirtualSizes: Readonly<{
    txP2pkhInputSizeCompressedKey: number;
    txP2pkhInputSizeUncompressedKey: number;
    txP2shInputSize: number;
    txP2shP2wshInputSize: number;
    txP2wshInputSize: number;
    txOutputAmountSize: number;
    txP2shOutputSize: number;
    txP2shP2wshOutputSize: number;
    txP2wshOutputSize: number;
    txP2pkhOutputSize: number;
    txP2wpkhOutputSize: number;
    /** @deprecated - use txP2pkhOutputSize instead */
    txOutputSize: number;
    txOverheadSize: number;
    txSegOverheadVSize: number;
}>;
export interface IOutputDimensions {
    count: number;
    size: number;
}
/**
 * A collection of outputs is represented as their count and aggregate vsize
 */
export declare const OutputDimensions: t.Refinement<IOutputDimensions>;
interface IOutput {
    index: number;
    script: Buffer;
    witness: Buffer;
}
interface IBitcoinTx {
    ins: IOutput[];
    outs: IOutput[];
}
export interface IBaseDimensions {
    nP2shInputs: number;
    nP2shP2wshInputs: number;
    nP2wshInputs: number;
    outputs: IOutputDimensions;
}
export interface IDimensions extends IBaseDimensions {
    nInputs: number;
    nOutputs: number;
    plus(v: Partial<IDimensions>): IDimensions;
    times(n: number): IDimensions;
    isSegwit(): boolean;
    getOverheadVSize(): number;
    getInputsVSize(): number;
    getOutputsVSize(): number;
    getVSize(): number;
}
export interface IDimensionsStruct extends t.Struct<IDimensions> {
    (v: IBaseDimensions): IDimensions;
    ASSUME_P2SH: symbol;
    ASSUME_P2SH_P2WSH: symbol;
    ASSUME_P2WSH: symbol;
    SingleOutput: {
        p2sh: IDimensions;
        p2shP2wsh: IDimensions;
        p2wsh: IDimensions;
        p2pkh: IDimensions;
        p2wpkh: IDimensions;
    };
    new (v: IBaseDimensions): IDimensions;
    zero(): IDimensions;
    sum(...args: Array<Partial<IDimensions>>): IDimensions;
    getOutputScriptLengthForChain(chain: ChainCode): number;
    getVSizeForOutputWithScriptLength(length: number): number;
    fromInput(input: IOutput, params?: {
        assumeUnsigned?: symbol;
    }): IDimensions;
    fromInputs(input: IOutput[], params?: {
        assumeUnsigned?: symbol;
    }): IDimensions;
    fromOutputScriptLength(scriptLength: number): IDimensions;
    fromOutput(output: {
        script: Buffer;
    }): IDimensions;
    fromOutputs(outputs: Array<{
        script: Buffer;
    }>): IDimensions;
    fromOutputOnChain(chain: ChainCode): IDimensions;
    fromUnspent(unspent: {
        chain: ChainCode;
    }): IDimensions;
    fromUnspents(unspents: Array<{
        chain: ChainCode;
    }>): IDimensions;
    fromTransaction(tx: IBitcoinTx, params?: {
        assumeUnsigned?: symbol;
    }): IDimensions;
}
/**
 * The transaction parameters required for vsize estimation.
 * The total vsize of a transaction (`getVSize()`) is the sum of:
 * - the overhead vsize (`getOverheadVSize()`),
 * - the inputs vsize (`getInputsVSize()`)
 * - the outputs vsize (`getOutputsVSize()`)
 * See https://bitcoincore.org/en/segwit_wallet_dev/#transaction-serialization
 * for explanation of the different components.
 */
export declare const Dimensions: IDimensionsStruct;
export {};
