"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tron_1 = require("../../../resources/trx/protobuf/tron");
var crypto = require('crypto');
var transaction_1 = require("../../transaction");
var utils_1 = require("./utils");
var enum_1 = require("./enum");
var bignumber_js_1 = require("bignumber.js");
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin/");
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    function Transaction(coinConfig, rawTransaction) {
        var _this = _super.call(this, coinConfig) || this;
        if (rawTransaction) {
            if (!rawTransaction.txID) {
                throw new errors_1.ParseTransactionError('Transaction has no id');
            }
            _this._id = rawTransaction.txID;
            _this._transaction = rawTransaction;
            _this._decodedRawDataHex = utils_1.decodeTransaction(rawTransaction.raw_data_hex);
            // Destination depends on the contract type
            _this.recordRawDataFields(_this._decodedRawDataHex);
        }
        return _this;
    }
    /**
     * Parse the transaction raw data and record the most important fields.
     * @param rawData Object from a tron transaction
     */
    Transaction.prototype.recordRawDataFields = function (rawData) {
        // Contract-agnostic fields
        this._validFrom = rawData.timestamp;
        this._validTo = rawData.expiration;
        var destination, senderAddress;
        // Contract-specific fields
        switch (rawData.contractType) {
            case enum_1.ContractType.Transfer:
                this._type = baseCoin_1.TransactionType.Send;
                destination = {
                    address: rawData.contract[0].parameter.value.to_address,
                    value: new bignumber_js_1.default(rawData.contract[0].parameter.value.amount),
                };
                senderAddress = {
                    address: rawData.contract[0].parameter.value.owner_address
                };
                break;
            case enum_1.ContractType.AccountPermissionUpdate:
                destination = {
                    address: rawData.contract.owner_address,
                    value: new bignumber_js_1.default(0)
                };
                senderAddress = {
                    address: rawData.contract.owner_address,
                };
                break;
            default:
                throw new errors_1.ParseTransactionError('Unsupported contract type');
        }
        this._fromAddresses = [senderAddress];
        this._destination = [destination];
    };
    /**
     * Updates the txid of this transaction after a protobuf update
     * Every time protobuf is updated, we need to update the txid
     */
    Transaction.prototype.updateTxid = function () {
        if (!this._transaction) {
            throw new errors_1.ParseTransactionError('Empty transaction');
        }
        var hexBuffer = Buffer.from(this._transaction.raw_data_hex, 'hex');
        var newTxid = crypto.createHash('sha256').update(hexBuffer).digest('hex');
        this._transaction.txID = newTxid;
        this._id = newTxid;
    };
    /**
     * Extends this transaction's expiration date by the given number of milliseconds
     * @param extensionMs The number of milliseconds to extend the expiration by
     */
    Transaction.prototype.extendExpiration = function (extensionMs) {
        if (!this._transaction) {
            throw new errors_1.ExtendTransactionError('Empty transaction');
        }
        if (this._transaction.signature && this._transaction.signature.length > 0) {
            throw new errors_1.ExtendTransactionError('Cannot extend a signed transaction');
        }
        var rawDataHex = this._transaction.raw_data_hex;
        var bytes = Buffer.from(rawDataHex, 'hex');
        var raw;
        try {
            raw = tron_1.protocol.Transaction.raw.decode(bytes);
            var newExpiration = (new bignumber_js_1.default(raw.expiration).plus(extensionMs)).toNumber();
            raw.expiration = newExpiration;
            var newRawDataHex = Buffer.from(tron_1.protocol.Transaction.raw.encode(raw).finish()).toString('hex');
            // Set the internal variables to account for the new expiration date
            this._transaction.raw_data_hex = newRawDataHex;
            this._transaction.raw_data.expiration = newExpiration;
            this._decodedRawDataHex = utils_1.decodeTransaction(newRawDataHex);
            this.recordRawDataFields(this._decodedRawDataHex);
            this.updateTxid();
        }
        catch (e) {
            throw new errors_1.ExtendTransactionError('There was an error decoding the initial raw_data_hex from the serialized tx.');
        }
    };
    /**
     * Tron transaction do not contain the owners account address so it is not possible to check the
     * private key with any but the account main address. This is not enough to fail this check, so it
     * is a no-op.
     */
    Transaction.prototype.canSign = function (key) {
        return true;
    };
    Transaction.prototype.toJson = function () {
        if (!this._transaction) {
            throw new errors_1.ParseTransactionError('Empty transaction');
        }
        return this._transaction;
    };
    return Transaction;
}(transaction_1.BaseTransaction));
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map