"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var transaction_1 = require("../transaction");
var errors_1 = require("../../baseCoin/errors");
var utils_1 = require("../utils");
var TrxBase = /** @class */ (function () {
    function TrxBase(_coinConfig) {
        this._coinConfig = _coinConfig;
    }
    TrxBase.prototype.buildTransaction = function (transaction) {
        // This is a no-op since Tron transactions are built from
        if (!transaction.id) {
            throw new errors_1.BuildTransactionError('A valid transaction must have an id');
        }
        return transaction;
    };
    /**
     * Helper function for parsing a transaction's raw_data field.
     * @param rawDataHex Raw data field encoded as hex in tron.proto
     */
    TrxBase.prototype.createRawTransaction = function (rawDataHex) {
        var parsedTx;
        try {
            parsedTx = utils_1.decodeTransaction(rawDataHex);
        }
        catch (e) {
            throw new errors_1.ParseTransactionError('Failed to decode transaction: ' + e);
        }
        return parsedTx;
    };
    /**
     * Helper function for parsing a transaction.
     * @param rawTransaction Transaction from the node
     */
    TrxBase.prototype.createTransactionReceipt = function (rawTransaction) {
        var raw = JSON.parse(rawTransaction);
        var txID;
        // TODO: need a more specific validation method for txID
        if (raw.txID && utils_1.isValidHex(raw.txID)) {
            txID = raw.txID;
        }
        else {
            throw new errors_1.ParseTransactionError('Raw transaction needs to have a valid txID.');
        }
        // this is an optional field - its possible signature is an empty array
        var signature = new Array();
        if (raw.signature && Array.isArray(raw.signature)) {
            signature = raw.signature;
        }
        var rawData;
        if (raw.raw_data_hex && utils_1.isValidHex(raw.raw_data_hex)) {
            rawData = this.createRawTransaction(raw.raw_data_hex);
        }
        else {
            throw new errors_1.ParseTransactionError('Raw transaction needs to have a valid state.');
        }
        return {
            txID: txID,
            raw_data: rawData,
            raw_data_hex: raw.raw_data_hex,
            signature: signature,
        };
    };
    /**
     * Extends transaction's expiration date by the given number of milliseconds
     * @param transaction The transaction to update
     * @param extensionMs The number of milliseconds to extend the expiration by
     */
    TrxBase.prototype.extendTransaction = function (transaction, extensionMs) {
        transaction.extendExpiration(extensionMs);
        return transaction;
    };
    /**
     * Parse transaction takes in raw JSON directly from the node.
     * @param rawTransaction The Tron transaction in JSON format as returned by the Tron lib or a
     *     stringifyed version of such JSON.
     */
    TrxBase.prototype.parseTransaction = function (rawTransaction) {
        // TODO: add checks to ensure the raw_data, raw_data_hex, and txID are from the same transaction
        if (typeof rawTransaction === 'string') {
            var transaction = JSON.parse(rawTransaction);
            return new transaction_1.Transaction(this._coinConfig, transaction);
        }
        return new transaction_1.Transaction(this._coinConfig, rawTransaction);
    };
    TrxBase.prototype.sign = function (privateKey, transaction) {
        if (!transaction.senders) {
            throw new errors_1.SigningError('transaction has no sender');
        }
        if (!transaction.destinations) {
            throw new errors_1.SigningError('transaction has no receiver');
        }
        var oldTransaction = transaction.toJson();
        // store our signatures, since we want to compare the new sig to another in a later step
        var oldSignatureCount = oldTransaction.signature ? oldTransaction.signature.length : 0;
        var signedTx;
        try {
            signedTx = utils_1.signTransaction(privateKey.key, transaction.toJson());
        }
        catch (e) {
            throw new errors_1.SigningError('Failed to sign transaction via helper.');
        }
        // ensure that we have more signatures than what we started with
        if (!signedTx.signature || oldSignatureCount >= signedTx.signature.length) {
            throw new errors_1.SigningError('Transaction signing did not return an additional signature.');
        }
        return new transaction_1.Transaction(this._coinConfig, signedTx);
    };
    /**
     * Validates a passed value. This is TRX units.
     */
    TrxBase.prototype.validateValue = function (value) {
        if (value.isLessThanOrEqualTo(0)) {
            throw new Error('Value cannot be below zero.');
        }
        // max long in Java - assumed upper limit for a TRX transaction
        if (value.isGreaterThan(new bignumber_js_1.default("9223372036854775807"))) {
            throw new Error('Value cannot be greater than handled by the javatron node.');
        }
    };
    TrxBase.prototype.validateAddress = function (address) {
        // assumes a base 58 address for our addresses
        if (!utils_1.isBase58Address(address.address)) {
            throw new Error(address + ' is not a valid base58 address.');
        }
    };
    TrxBase.prototype.validateKey = function (key) {
        // TODO: determine format for key
        return true;
    };
    TrxBase.prototype.displayName = function () {
        return this._coinConfig.fullName;
    };
    return TrxBase;
}());
exports.TrxBase = TrxBase;
//# sourceMappingURL=coin.js.map