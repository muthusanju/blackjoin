"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var crypto = require('crypto');
var tronweb = require('tronweb');
var tron_1 = require("../../../resources/trx/protobuf/tron");
var bitgo_utxo_lib_1 = require("bitgo-utxo-lib");
var assert = require("assert");
var enum_1 = require("./enum");
var errors_1 = require("../baseCoin/errors");
/**
 * Generate a Tron account offline using known bitcoin libraries
 * @param seed Optional random seed
 * @return {Account}
 */
function generateAccount(seed) {
    if (!seed) {
        seed = crypto.randomBytes(512 / 8);
    }
    var extendedKey = bitgo_utxo_lib_1.HDNode.fromSeedBuffer(seed);
    // convert our prv, pub
    var prv = extendedKey.keyPair.getPrivateKeyBuffer().toString('hex').toUpperCase();
    var keyPair = bitgo_utxo_lib_1.ECPair.fromPrivateKeyBuffer(Buffer.from(prv, 'hex'));
    var priKeyBytes = getByteArrayFromHexAddress(keyPair.getPrivateKeyBuffer().toString('hex'));
    var pubKeyBytes = getPubKeyFromPriKey(priKeyBytes);
    var publicKey = getHexAddressFromByteArray(pubKeyBytes);
    // used for meaningful address conversion
    var addressBytes = getAddressFromPriKey(priKeyBytes);
    return {
        privateKey: prv,
        publicKey: publicKey,
        address: {
            base58: getBase58AddressFromByteArray(addressBytes),
            hex: getHexAddressFromByteArray(addressBytes),
        },
    };
}
exports.generateAccount = generateAccount;
function isBase58Address(address) {
    return tronweb.utils.crypto.isAddressValid(address);
}
exports.isBase58Address = isBase58Address;
function getByteArrayFromHexAddress(str) {
    return tronweb.utils.code.hexStr2byteArray(str);
}
exports.getByteArrayFromHexAddress = getByteArrayFromHexAddress;
function getHexAddressFromByteArray(arr) {
    return tronweb.utils.code.byteArray2hexStr(arr);
}
exports.getHexAddressFromByteArray = getHexAddressFromByteArray;
function verifySignature(messageToVerify, base58Address, sigHex, useTronHeader) {
    if (useTronHeader === void 0) { useTronHeader = true; }
    if (!isValidHex(sigHex)) {
        throw new errors_1.UtilsError('signature is not in a valid format, needs to be hexadecimal');
    }
    if (!isValidHex(messageToVerify)) {
        throw new errors_1.UtilsError('message is not in a valid format, needs to be hexadecimal');
    }
    if (!isBase58Address(base58Address)) {
        throw new errors_1.UtilsError('address needs to be base58 encoded');
    }
    return tronweb.Trx.verifySignature(messageToVerify, base58Address, sigHex, useTronHeader);
}
exports.verifySignature = verifySignature;
function getHexAddressFromBase58Address(base58) {
    // pulled from: https://github.com/TRON-US/tronweb/blob/dcb8efa36a5ebb65c4dab3626e90256a453f3b0d/src/utils/help.js#L17
    // but they don't surface this call in index.js
    var bytes = tronweb.utils.crypto.decodeBase58Address(base58);
    return getHexAddressFromByteArray(bytes);
}
exports.getHexAddressFromBase58Address = getHexAddressFromBase58Address;
function getPubKeyFromPriKey(privateKey) {
    return tronweb.utils.crypto.getPubKeyFromPriKey(privateKey);
}
exports.getPubKeyFromPriKey = getPubKeyFromPriKey;
function getAddressFromPriKey(privateKey) {
    return tronweb.utils.crypto.getAddressFromPriKey(privateKey);
}
exports.getAddressFromPriKey = getAddressFromPriKey;
function getBase58AddressFromByteArray(address) {
    return tronweb.utils.crypto.getBase58CheckAddress(address);
}
exports.getBase58AddressFromByteArray = getBase58AddressFromByteArray;
function getBase58AddressFromHex(hex) {
    var arr = getByteArrayFromHexAddress(hex);
    return getBase58AddressFromByteArray(arr);
}
exports.getBase58AddressFromHex = getBase58AddressFromHex;
function signTransaction(privateKey, transaction) {
    return tronweb.utils.crypto.signTransaction(privateKey, transaction);
}
exports.signTransaction = signTransaction;
function signString(message, privateKey, useTronHeader) {
    if (useTronHeader === void 0) { useTronHeader = true; }
    return tronweb.Trx.signString(message, privateKey, useTronHeader);
}
exports.signString = signString;
function getRawAddressFromPubKey(pubBytes) {
    return tronweb.utils.crypto.computeAddress(pubBytes);
}
exports.getRawAddressFromPubKey = getRawAddressFromPubKey;
/**
 * Decodes a hex encoded transaction in its protobuf representation.
 * @param hexString raw_data_hex field from tron transactions
 */
function decodeTransaction(hexString) {
    var rawTransaction = decodeRawTransaction(hexString);
    // there should not be multiple contracts in this data
    if (rawTransaction.contracts.length !== 1) {
        throw new errors_1.UtilsError('Number of contracts is greater than 1.');
    }
    var contract;
    var contractType;
    // ensure the contract type is supported
    switch (rawTransaction.contracts[0].parameter.type_url) {
        case 'type.googleapis.com/protocol.TransferContract':
            contractType = enum_1.ContractType.Transfer;
            contract = this.decodeTransferContract(rawTransaction.contracts[0].parameter.value);
            break;
        case 'type.googleapis.com/protocol.AccountPermissionUpdateContract':
            contractType = enum_1.ContractType.AccountPermissionUpdate;
            contract = this.decodeAccountPermissionUpdateContract(rawTransaction.contracts[0].parameter.value);
            break;
        default:
            throw new errors_1.UtilsError('Unsupported contract type');
    }
    return {
        contractType: contractType,
        contract: contract,
        expiration: rawTransaction.expiration,
        timestamp: rawTransaction.timestamp,
    };
}
exports.decodeTransaction = decodeTransaction;
/**
 * Decodes a transaction's raw field from a base64 encoded string. This is a protobuf representation.
 * @param hexString this is the raw hexadecimal encoded string. Doc found in the following link.
 * @example
 * @see {@link https://github.com/BitGo/bitgo-account-lib/blob/5f282588701778a4421c75fa61f42713f56e95b9/resources/trx/protobuf/tron.proto#L319}
 */
function decodeRawTransaction(hexString) {
    var bytes = Buffer.from(hexString, 'hex');
    var raw;
    try {
        // we need to decode our raw_data_hex field first
        raw = tron_1.protocol.Transaction.raw.decode(bytes);
    }
    catch (e) {
        throw new errors_1.UtilsError('There was an error decoding the initial raw_data_hex from the serialized tx.');
    }
    return {
        expiration: Number(raw.expiration),
        timestamp: Number(raw.timestamp),
        contracts: raw.contract,
    };
}
exports.decodeRawTransaction = decodeRawTransaction;
/**
 * Indicates whether the passed string is a safe hex string for tron's purposes.
 * @param hex A valid hex string must be a string made of numbers and characters and has an even length.
 */
function isValidHex(hex) {
    return /^(0x)?([0-9a-f]{2})+$/i.test(hex);
}
exports.isValidHex = isValidHex;
/** Deserialize the segment of the txHex which corresponds with the details of the transfer
 * @param transferHex is the value property of the "parameter" field of contractList[0]
 * */
function decodeTransferContract(transferHex) {
    var contractBytes = Buffer.from(transferHex, 'base64');
    var transferContract;
    try {
        transferContract = tron_1.protocol.TransferContract.decode(contractBytes);
    }
    catch (e) {
        throw new errors_1.UtilsError('There was an error decoding the transfer contract in the transaction.');
    }
    if (!transferContract.ownerAddress) {
        throw new errors_1.UtilsError('Owner address does not exist in this transfer contract.');
    }
    if (!transferContract.toAddress) {
        throw new errors_1.UtilsError('Destination address does not exist in this transfer contract.');
    }
    if (!transferContract.hasOwnProperty('amount')) {
        throw new errors_1.UtilsError('Amount does not exist in this transfer contract.');
    }
    // deserialize attributes
    var owner_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.ownerAddress, 'base64').toString('hex')));
    var to_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.toAddress, 'base64').toString('hex')));
    var amount = transferContract.amount;
    return [{
            parameter: {
                value: {
                    amount: Number(amount),
                    owner_address: owner_address,
                    to_address: to_address,
                }
            }
        }];
}
exports.decodeTransferContract = decodeTransferContract;
/**
 * Deserialize the segment of the txHex corresponding with the details of the contract which updates
 * account permission
 * @param {string} base64
 * @returns {AccountPermissionUpdateContract}
 */
function decodeAccountPermissionUpdateContract(base64) {
    var accountUpdateContract = tron_1.protocol.AccountPermissionUpdateContract.decode(Buffer.from(base64, 'base64')).toJSON();
    assert(accountUpdateContract.ownerAddress);
    assert(accountUpdateContract.owner);
    assert(accountUpdateContract.hasOwnProperty('actives'));
    var ownerAddress = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(accountUpdateContract.ownerAddress, 'base64').toString('hex')));
    var owner = createPermission((accountUpdateContract.owner));
    var witness = undefined;
    if (accountUpdateContract.witness) {
        witness = createPermission(accountUpdateContract.witness);
    }
    var activeList = accountUpdateContract.actives.map(function (active) { return createPermission(active); });
    return {
        ownerAddress: ownerAddress,
        owner: owner,
        witness: witness,
        actives: activeList,
    };
}
exports.decodeAccountPermissionUpdateContract = decodeAccountPermissionUpdateContract;
function createPermission(raw) {
    var permissionType;
    var permission = raw.permissionName.toLowerCase().trim();
    if (permission === 'owner') {
        permissionType = enum_1.PermissionType.Owner;
    }
    else if (permission === "witness") {
        permissionType = enum_1.PermissionType.Witness;
    }
    else if (permission.substr(0, 6) === "active") {
        permissionType = enum_1.PermissionType.Active;
    }
    else {
        throw new errors_1.UtilsError('Permission type not parseable.');
    }
    return { type: permissionType, threshold: raw.threshold };
}
//# sourceMappingURL=utils.js.map