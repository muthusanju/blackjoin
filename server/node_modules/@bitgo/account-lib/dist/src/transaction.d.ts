import { BaseAddress, BaseKey, Destination } from "./coin/baseCoin/iface";
import { BaseCoin as CoinConfig } from "@bitgo/statics";
import { TransactionType } from "./coin/baseCoin";
/**
 * Specifies the members expected for a Transaction
 */
export declare abstract class BaseTransaction {
    protected _coinConfig: Readonly<CoinConfig>;
    protected _id: string;
    protected _fromAddresses: BaseAddress[];
    protected _destination: Destination[];
    protected _type: TransactionType;
    protected _validFrom: number;
    protected _validTo: number;
    protected constructor(_coinConfig: Readonly<CoinConfig>);
    readonly id: string;
    readonly type: TransactionType;
    readonly destinations: Destination[];
    readonly senders: BaseAddress[];
    readonly validFrom: number;
    readonly validTo: number;
    /**
     * Whether the private key can sign this transaction in its current state or not. it is possible
     * some transactions can only enforce this check after some other fields have been filled already
     * or even during build time.
     * @param key to verify permissions on
     * @return false if the key cannot sign the transaction without a doubt, true otherwise
     */
    abstract canSign(key: BaseKey): boolean;
    abstract toJson(): any;
}
