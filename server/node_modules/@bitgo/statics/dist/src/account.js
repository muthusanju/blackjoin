"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var base_1 = require("./base");
var errors_1 = require("./errors");
var networks_1 = require("./networks");
/**
 * Account based coins, such as Ethereum, Stellar, or XRP.
 *
 * These types of coins maintain an "account balance" for each address on the network,
 * as opposed to the unspent transaction output model which maintains a record of all
 * "pieces" of coin which belong to an address.
 */
var AccountCoin = /** @class */ (function (_super) {
    __extends(AccountCoin, _super);
    function AccountCoin(options) {
        var _this = _super.call(this, __assign(__assign({ isToken: false }, options), { kind: "crypto" /* CRYPTO */ })) || this;
        _this.network = options.network;
        return _this;
    }
    AccountCoin.prototype.requiredFeatures = function () {
        return new Set(["account-model" /* ACCOUNT_MODEL */]);
    };
    AccountCoin.prototype.disallowedFeatures = function () {
        return new Set(["unspent-model" /* UNSPENT_MODEL */]);
    };
    AccountCoin.DEFAULT_FEATURES = [
        "account-model" /* ACCOUNT_MODEL */,
        "requires-big-number" /* REQUIRES_BIG_NUMBER */,
        "valueless-transfer" /* VALUELESS_TRANSFER */,
        "transaction-data" /* TRANSACTION_DATA */,
    ];
    return AccountCoin;
}(base_1.BaseCoin));
exports.AccountCoin = AccountCoin;
var AccountCoinToken = /** @class */ (function (_super) {
    __extends(AccountCoinToken, _super);
    function AccountCoinToken(options) {
        return _super.call(this, __assign(__assign({}, options), { isToken: true })) || this;
    }
    return AccountCoinToken;
}(AccountCoin));
exports.AccountCoinToken = AccountCoinToken;
/**
 * ERC 20 is a token standard for the Ethereum blockchain. They are similar to other account coins, but have a
 * contract address property which identifies the smart contract which defines the token.
 */
var Erc20Coin = /** @class */ (function (_super) {
    __extends(Erc20Coin, _super);
    function Erc20Coin(options) {
        var _this = _super.call(this, __assign({}, options)) || this;
        // valid ERC 20 contract addresses are "0x" followed by 40 lowercase hex characters
        if (!options.contractAddress.match(/^0x[a-f0-9]{40}$/)) {
            throw new errors_1.InvalidContractAddressError(options.name, options.contractAddress);
        }
        _this.contractAddress = options.contractAddress;
        return _this;
    }
    return Erc20Coin;
}(AccountCoinToken));
exports.Erc20Coin = Erc20Coin;
/**
 * The Stellar network supports tokens (non-native assets)
 * XLM is also known as the native asset.
 * Stellar tokens work similar to XLM, but the token name is determined by the chain,
 * the token code and the issuer account in the form: (t)xlm:<token>-<issuer>
 */
var StellarCoin = /** @class */ (function (_super) {
    __extends(StellarCoin, _super);
    function StellarCoin(options) {
        var _this = _super.call(this, __assign({}, options)) || this;
        var domainPattern = /^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$/;
        if (options.domain !== '' && !options.domain.match(domainPattern)) {
            throw new errors_1.InvalidDomainError(options.name, options.domain);
        }
        _this.domain = options.domain;
        return _this;
    }
    return StellarCoin;
}(AccountCoinToken));
exports.StellarCoin = StellarCoin;
/**
 * Factory function for account coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function account(name, fullName, network, decimalPlaces, asset, features, prefix, suffix, isToken) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (isToken === void 0) { isToken = false; }
    return Object.freeze(new AccountCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
    }));
}
exports.account = account;
/**
 * Factory function for erc20 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function erc20(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.ethereum; }
    return Object.freeze(new Erc20Coin({
        name: name,
        fullName: fullName,
        network: network,
        contractAddress: contractAddress,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        asset: asset,
        isToken: true,
    }));
}
exports.erc20 = erc20;
/**
 * Factory function for testnet erc20 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Kovan test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function terc20(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.kovan; }
    return erc20(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.terc20 = terc20;
/**
 * Factory function for Stellar token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function stellarToken(name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network) {
    if (domain === void 0) { domain = ''; }
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.stellar; }
    return Object.freeze(new StellarCoin({
        name: name,
        fullName: fullName,
        decimalPlaces: decimalPlaces,
        asset: asset,
        domain: domain,
        features: features,
        prefix: prefix,
        suffix: suffix,
        network: network,
        isToken: true,
    }));
}
exports.stellarToken = stellarToken;
/**
 * Factory function for testnet Stellar token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar testnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tstellarToken(name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network) {
    if (domain === void 0) { domain = ''; }
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.stellar; }
    return stellarToken(name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network);
}
exports.tstellarToken = tstellarToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY2NvdW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0JBQTBFO0FBQzFFLG1DQUEyRTtBQUMzRSx1Q0FBc0Q7QUFjdEQ7Ozs7OztHQU1HO0FBQ0g7SUFBaUMsK0JBQVE7SUFVdkMscUJBQVksT0FBa0M7UUFBOUMsWUFDRSxzQ0FDRSxPQUFPLEVBQUUsS0FBSyxJQUNYLE9BQU8sS0FDVixJQUFJLDJCQUNKLFNBR0g7UUFEQyxLQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7O0lBQ2pDLENBQUM7SUFFUyxzQ0FBZ0IsR0FBMUI7UUFDRSxPQUFPLElBQUksR0FBRyxDQUFjLHFDQUEyQixDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVTLHdDQUFrQixHQUE1QjtRQUNFLE9BQU8sSUFBSSxHQUFHLENBQWMscUNBQTJCLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBekJzQiw0QkFBZ0IsR0FBRzs7Ozs7S0FLekMsQ0FBQztJQXFCSixrQkFBQztDQUFBLEFBM0JELENBQWlDLGVBQVEsR0EyQnhDO0FBM0JZLGtDQUFXO0FBeUN4QjtJQUFzQyxvQ0FBVztJQUMvQywwQkFBWSxPQUFrQztlQUM1Qyx3Q0FDSyxPQUFPLEtBQ1YsT0FBTyxFQUFFLElBQUksSUFDYjtJQUNKLENBQUM7SUFDSCx1QkFBQztBQUFELENBQUMsQUFQRCxDQUFzQyxXQUFXLEdBT2hEO0FBUFksNENBQWdCO0FBUzdCOzs7R0FHRztBQUNIO0lBQStCLDZCQUFnQjtJQUc3QyxtQkFBWSxPQUFnQztRQUE1QyxZQUNFLCtCQUNLLE9BQU8sRUFDVixTQVFIO1FBTkMsbUZBQW1GO1FBQ25GLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ3RELE1BQU0sSUFBSSxvQ0FBMkIsQ0FBQyxP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TUFBbUIsRUFDbkIsUUFBc0QsRUFDdEQsTUFBbUIsRUFDbkIsTUFBbUMsRUFDbkMsT0FBK0M7SUFKL0MsdUJBQUEsRUFBQSxXQUFtQjtJQUNuQix5QkFBQSxFQUFBLFdBQTBCLFdBQVcsQ0FBQyxnQkFBZ0I7SUFDdEQsdUJBQUEsRUFBQSxXQUFtQjtJQUNuQix1QkFBQSxFQUFBLFNBQWlCLElBQUksQ0FBQyxXQUFXLEVBQUU7SUFDbkMsd0JBQUEsRUFBQSxVQUEwQixtQkFBUSxDQUFDLElBQUksQ0FBQyxPQUFPO0lBRS9DLE9BQU8sWUFBWSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDdkcsQ0FBQztBQVpELHNDQVlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4sIENvaW5GZWF0dXJlLCBDb2luS2luZCwgVW5kZXJseWluZ0Fzc2V0IH0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvciwgSW52YWxpZERvbWFpbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgQWNjb3VudE5ldHdvcmssIE5ldHdvcmtzIH0gZnJvbSAnLi9uZXR3b3Jrcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIGZ1bGxOYW1lOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcms7XG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQ7XG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdO1xuICBkZWNpbWFsUGxhY2VzOiBudW1iZXI7XG4gIGlzVG9rZW46IGJvb2xlYW47XG4gIHByZWZpeD86IHN0cmluZztcbiAgc3VmZml4Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFjY291bnQgYmFzZWQgY29pbnMsIHN1Y2ggYXMgRXRoZXJldW0sIFN0ZWxsYXIsIG9yIFhSUC5cbiAqXG4gKiBUaGVzZSB0eXBlcyBvZiBjb2lucyBtYWludGFpbiBhbiBcImFjY291bnQgYmFsYW5jZVwiIGZvciBlYWNoIGFkZHJlc3Mgb24gdGhlIG5ldHdvcmssXG4gKiBhcyBvcHBvc2VkIHRvIHRoZSB1bnNwZW50IHRyYW5zYWN0aW9uIG91dHB1dCBtb2RlbCB3aGljaCBtYWludGFpbnMgYSByZWNvcmQgb2YgYWxsXG4gKiBcInBpZWNlc1wiIG9mIGNvaW4gd2hpY2ggYmVsb25nIHRvIGFuIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBBY2NvdW50Q29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0ZFQVRVUkVTID0gW1xuICAgIENvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUwsXG4gICAgQ29pbkZlYXR1cmUuUkVRVUlSRVNfQklHX05VTUJFUixcbiAgICBDb2luRmVhdHVyZS5WQUxVRUxFU1NfVFJBTlNGRVIsXG4gICAgQ29pbkZlYXR1cmUuVFJBTlNBQ1RJT05fREFUQSxcbiAgXTtcblxuICBwdWJsaWMgcmVhZG9ubHkgbmV0d29yazogQWNjb3VudE5ldHdvcms7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGlzVG9rZW46IGZhbHNlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGtpbmQ6IENvaW5LaW5kLkNSWVBUTyxcbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29yayA9IG9wdGlvbnMubmV0d29yaztcbiAgfVxuXG4gIHByb3RlY3RlZCByZXF1aXJlZEZlYXR1cmVzKCk6IFNldDxDb2luRmVhdHVyZT4ge1xuICAgIHJldHVybiBuZXcgU2V0PENvaW5GZWF0dXJlPihbQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTF0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRpc2FsbG93ZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLlVOU1BFTlRfTU9ERUxdKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVyYzIwQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0ZWxsYXJDb2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIGRvbWFpbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0QWRkcmVzcyBleHRlbmRzIFN0cmluZyB7XG4gIF9fY29udHJhY3RhZGRyZXNzX3BoYW50b21fXzogbmV2ZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBBY2NvdW50Q29pblRva2VuIGV4dGVuZHMgQWNjb3VudENvaW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFUkMgMjAgaXMgYSB0b2tlbiBzdGFuZGFyZCBmb3IgdGhlIEV0aGVyZXVtIGJsb2NrY2hhaW4uIFRoZXkgYXJlIHNpbWlsYXIgdG8gb3RoZXIgYWNjb3VudCBjb2lucywgYnV0IGhhdmUgYVxuICogY29udHJhY3QgYWRkcmVzcyBwcm9wZXJ0eSB3aGljaCBpZGVudGlmaWVzIHRoZSBzbWFydCBjb250cmFjdCB3aGljaCBkZWZpbmVzIHRoZSB0b2tlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEVyYzIwQ29pbiBleHRlbmRzIEFjY291bnRDb2luVG9rZW4ge1xuICBwdWJsaWMgY29udHJhY3RBZGRyZXNzOiBDb250cmFjdEFkZHJlc3M7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogRXJjMjBDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuXG4gICAgLy8gdmFsaWQgRVJDIDIwIGNvbnRyYWN0IGFkZHJlc3NlcyBhcmUgXCIweFwiIGZvbGxvd2VkIGJ5IDQwIGxvd2VyY2FzZSBoZXggY2hhcmFjdGVyc1xuICAgIGlmICghb3B0aW9ucy5jb250cmFjdEFkZHJlc3MubWF0Y2goL14weFthLWYwLTldezQwfSQvKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvcihvcHRpb25zLm5hbWUsIG9wdGlvbnMuY29udHJhY3RBZGRyZXNzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyYWN0QWRkcmVzcyA9IChvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyBhcyB1bmtub3duKSBhcyBDb250cmFjdEFkZHJlc3M7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgU3RlbGxhciBuZXR3b3JrIHN1cHBvcnRzIHRva2VucyAobm9uLW5hdGl2ZSBhc3NldHMpXG4gKiBYTE0gaXMgYWxzbyBrbm93biBhcyB0aGUgbmF0aXZlIGFzc2V0LlxuICogU3RlbGxhciB0b2tlbnMgd29yayBzaW1pbGFyIHRvIFhMTSwgYnV0IHRoZSB0b2tlbiBuYW1lIGlzIGRldGVybWluZWQgYnkgdGhlIGNoYWluLFxuICogdGhlIHRva2VuIGNvZGUgYW5kIHRoZSBpc3N1ZXIgYWNjb3VudCBpbiB0aGUgZm9ybTogKHQpeGxtOjx0b2tlbj4tPGlzc3Vlcj5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ZWxsYXJDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBkb21haW46IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTdGVsbGFyQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBjb25zdCBkb21haW5QYXR0ZXJuID0gL14oPzpbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT9cXC4pK1thLXowLTldW2EtejAtOS1dezAsNjF9W2EtejAtOV0kLztcbiAgICBpZiAob3B0aW9ucy5kb21haW4gIT09ICcnICYmICFvcHRpb25zLmRvbWFpbi5tYXRjaChkb21haW5QYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREb21haW5FcnJvcihvcHRpb25zLm5hbWUsIG9wdGlvbnMuZG9tYWluKTtcbiAgICB9XG5cbiAgICB0aGlzLmRvbWFpbiA9IG9wdGlvbnMuZG9tYWluIGFzIHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGFjY291bnQgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhY2NvdW50KFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIGlzVG9rZW46IGJvb2xlYW4gPSBmYWxzZVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBBY2NvdW50Q29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgZXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRXRoZXJldW0gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJjMjAoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXg6IHN0cmluZyA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmV0aGVyZXVtXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzIwQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBlcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgS292YW4gdGVzdCBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVyYzIwKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5rb3ZhblxuKSB7XG4gIHJldHVybiBlcmMyMChuYW1lLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgY29udHJhY3RBZGRyZXNzLCBhc3NldCwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBTdGVsbGFyIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBkb21haW4gRG9tYWluIG9mIHRoZSB0b2tlbiBpc3N1ZXIgKHVzZWQgdG8gYWNjZXNzIHRva2VuIGluZm9ybWF0aW9uIGZyb20gdGhlIGlzc3VlcidzIHN0ZWxsYXIudG9tbCBmaWxlKVxuICogU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3N0ZWxsYXItdG9tbC5odG1sXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFN0ZWxsYXIgbWFpbm5ldC5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZWxsYXJUb2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGRvbWFpbjogc3RyaW5nID0gJycsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MubWFpbi5zdGVsbGFyXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IFN0ZWxsYXJDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGRvbWFpbixcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgbmV0d29yayxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IFN0ZWxsYXIgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGRvbWFpbiBEb21haW4gb2YgdGhlIHRva2VuIGlzc3VlciAodXNlZCB0byBhY2Nlc3MgdG9rZW4gaW5mb3JtYXRpb24gZnJvbSB0aGUgaXNzdWVyJ3Mgc3RlbGxhci50b21sIGZpbGUpXG4gKiBTZWUgaHR0cHM6Ly93d3cuc3RlbGxhci5vcmcvZGV2ZWxvcGVycy9ndWlkZXMvY29uY2VwdHMvc3RlbGxhci10b21sLmh0bWxcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gU3RlbGxhciB0ZXN0bmV0LlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHN0ZWxsYXJUb2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGRvbWFpbjogc3RyaW5nID0gJycsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5zdGVsbGFyXG4pIHtcbiAgcmV0dXJuIHN0ZWxsYXJUb2tlbihuYW1lLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgYXNzZXQsIGRvbWFpbiwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cbiJdfQ==