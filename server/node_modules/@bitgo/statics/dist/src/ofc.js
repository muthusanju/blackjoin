"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var base_1 = require("./base");
var networks_1 = require("./networks");
/**
 * OFC (off chain) coins. These are virtual coins used to represent off chain assets on the BitGo platform.
 */
var OfcCoin = /** @class */ (function (_super) {
    __extends(OfcCoin, _super);
    function OfcCoin(options) {
        var _this = this;
        var addressCoin = options.addressCoin, baseOptions = __rest(options, ["addressCoin"]);
        _this = _super.call(this, baseOptions) || this;
        _this.addressCoin = addressCoin;
        return _this;
    }
    OfcCoin.prototype.requiredFeatures = function () {
        return new Set(["account-model" /* ACCOUNT_MODEL */, "requires-big-number" /* REQUIRES_BIG_NUMBER */]);
    };
    OfcCoin.prototype.disallowedFeatures = function () {
        return new Set([
            "unspent-model" /* UNSPENT_MODEL */,
            "cpfp" /* CHILD_PAYS_FOR_PARENT */,
            "native-segwit" /* NATIVE_SEGWIT */,
            "paygo" /* PAYGO */,
            "wrapped-segwit" /* WRAPPED_SEGWIT */,
            "supports-tokens" /* SUPPORTS_TOKENS */,
        ]);
    };
    OfcCoin.DEFAULT_FEATURES = ["account-model" /* ACCOUNT_MODEL */, "requires-big-number" /* REQUIRES_BIG_NUMBER */];
    return OfcCoin;
}(base_1.BaseCoin));
exports.OfcCoin = OfcCoin;
/**
 * Factory function for ofc coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 */
function ofc(name, fullName, decimalPlaces, asset, kind, features, prefix, suffix, network, isToken) {
    if (kind === void 0) { kind = "crypto" /* CRYPTO */; }
    if (features === void 0) { features = OfcCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.replace(/^ofc/, '').toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.ofc; }
    if (isToken === void 0) { isToken = true; }
    return Object.freeze(new OfcCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        kind: kind,
    }));
}
exports.ofc = ofc;
/**
 * Factory function for testnet ofc coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 */
function tofc(name, fullName, decimalPlaces, asset, kind, features, prefix, suffix, network, isToken) {
    if (kind === void 0) { kind = "crypto" /* CRYPTO */; }
    if (features === void 0) { features = OfcCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.replace(/^ofc/, '').toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.ofc; }
    if (isToken === void 0) { isToken = true; }
    return Object.freeze(new OfcCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        kind: kind,
    }));
}
exports.tofc = tofc;
/**
 * Factory function for ofc erc20 coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 */
function ofcerc20(name, fullName, decimalPlaces, asset, kind, features, prefix, suffix, network, isToken, addressCoin) {
    if (kind === void 0) { kind = "crypto" /* CRYPTO */; }
    if (features === void 0) { features = OfcCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.replace(/^ofc/, '').toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.ofc; }
    if (isToken === void 0) { isToken = true; }
    if (addressCoin === void 0) { addressCoin = 'eth'; }
    return Object.freeze(new OfcCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        kind: kind,
        addressCoin: addressCoin,
    }));
}
exports.ofcerc20 = ofcerc20;
/**
 * Factory function for testnet ofc erc20 coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 */
function tofcerc20(name, fullName, decimalPlaces, asset, kind, features, prefix, suffix, network, isToken, addressCoin) {
    if (kind === void 0) { kind = "crypto" /* CRYPTO */; }
    if (features === void 0) { features = OfcCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.replace(/^ofc/, '').toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.ofc; }
    if (isToken === void 0) { isToken = true; }
    if (addressCoin === void 0) { addressCoin = 'teth'; }
    return Object.freeze(new OfcCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        kind: kind,
        addressCoin: addressCoin,
    }));
}
exports.tofcerc20 = tofcerc20;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29mYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtCQUEwRTtBQUMxRSx1Q0FBK0Q7QUFnQi9EOztHQUVHO0FBQ0g7SUFBNkIsMkJBQVE7SUFNbkMsaUJBQVksT0FBOEI7UUFBMUMsaUJBSUM7UUFIUyxJQUFBLGlDQUFXLEVBQUUsOENBQWMsQ0FBYTtRQUNoRCxRQUFBLGtCQUFNLFdBQVcsQ0FBQyxTQUFDO1FBQ25CLEtBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDOztJQUNqQyxDQUFDO0lBRVMsa0NBQWdCLEdBQTFCO1FBQ0UsT0FBTyxJQUFJLEdBQUcsQ0FBYyxzRkFBNEQsQ0FBQyxDQUFDO0lBQzVGLENBQUM7SUFFUyxvQ0FBa0IsR0FBNUI7UUFDRSxPQUFPLElBQUksR0FBRyxDQUFjOzs7Ozs7O1NBTzNCLENBQUMsQ0FBQztJQUNMLENBQUM7SUF4QnNCLHdCQUFnQixHQUFHLHNGQUE0RCxDQUFDO0lBeUJ6RyxjQUFDO0NBQUEsQUExQkQsQ0FBNkIsZUFBUSxHQTBCcEM7QUExQlksMEJBQU87QUE0QnBCOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxTQUFnQixHQUFHLENBQ2pCLElBQVksRUFDWixRQUFnQixFQUNoQixhQUFxQixFQUNyQixLQUFzQixFQUN0QixJQUFnQyxFQUNoQyxRQUFrRCxFQUNsRCxNQUFtQixFQUNuQixNQUF1RCxFQUN2RCxPQUF1QyxFQUN2QyxPQUF1QjtJQUx2QixxQkFBQSxFQUFBLDRCQUFnQztJQUNoQyx5QkFBQSxFQUFBLFdBQTBCLE9BQU8sQ0FBQyxnQkFBZ0I7SUFDbEQsdUJBQUEsRUFBQSxXQUFtQjtJQUNuQix1QkFBQSxFQUFBLFNBQWlCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRTtJQUN2RCx3QkFBQSxFQUFBLFVBQXNCLG1C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Qyx5QkFBQSxFQUFBLFdBQTBCLE9BQU8sQ0FBQyxnQkFBZ0I7SUFDbEQsdUJBQUEsRUFBQSxXQUFtQjtJQUNuQix1QkFBQSxFQUFBLFNBQWlCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRTtJQUN2RCx3QkFBQSxFQUFBLFVBQXNCLG1CQUFRLENBQUMsSUFBSSxDQUFDLEdBQUc7SUFDdkMsd0JBQUEsRUFBQSxjQUF1QjtJQUN2Qiw0QkFBQSxFQUFBLG9CQUE0QjtJQUU1QixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQ2xCLElBQUksT0FBTyxDQUFDO1FBQ1YsSUFBSSxNQUFBO1FBQ0osUUFBUSxVQUFBO1FBQ1IsT0FBTyxTQUFBO1FBQ1AsTUFBTSxRQUFBO1FBQ04sTUFBTSxRQUFBO1FBQ04sUUFBUSxVQUFBO1FBQ1IsYUFBYSxlQUFBO1FBQ2IsT0FBTyxTQUFBO1FBQ1AsS0FBSyxPQUFBO1FBQ0wsSUFBSSxNQUFBO1FBQ0osV0FBVyxhQUFBO0tBQ1osQ0FBQyxDQUNILENBQUM7QUFDSixDQUFDO0FBNUJELDhCQTRCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luLCBDb2luRmVhdHVyZSwgQ29pbktpbmQsIFVuZGVybHlpbmdBc3NldCB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBCYXNlTmV0d29yaywgTmV0d29ya3MsIE9mY05ldHdvcmsgfSBmcm9tICcuL25ldHdvcmtzJztcblxuZXhwb3J0IGludGVyZmFjZSBPZmNDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBmdWxsTmFtZTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIG5ldHdvcms6IEJhc2VOZXR3b3JrO1xuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0O1xuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXTtcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyO1xuICBpc1Rva2VuOiBib29sZWFuO1xuICBraW5kOiBDb2luS2luZDtcbiAgcHJlZml4Pzogc3RyaW5nO1xuICBzdWZmaXg/OiBzdHJpbmc7XG4gIGFkZHJlc3NDb2luPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIE9GQyAob2ZmIGNoYWluKSBjb2lucy4gVGhlc2UgYXJlIHZpcnR1YWwgY29pbnMgdXNlZCB0byByZXByZXNlbnQgb2ZmIGNoYWluIGFzc2V0cyBvbiB0aGUgQml0R28gcGxhdGZvcm0uXG4gKi9cbmV4cG9ydCBjbGFzcyBPZmNDb2luIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfRkVBVFVSRVMgPSBbQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTCwgQ29pbkZlYXR1cmUuUkVRVUlSRVNfQklHX05VTUJFUl07XG5cbiAgLy8gSWYgc2V0LCB0aGlzIGNvaW4gaXMgdGhlIG5hdGl2ZSBhZGRyZXNzIGZvcm1hdCBmb3IgdGhpcyB0b2tlbi5cbiAgcHVibGljIHJlYWRvbmx5IGFkZHJlc3NDb2luPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE9mY0NvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWRkcmVzc0NvaW4sIC4uLmJhc2VPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3NDb2luID0gYWRkcmVzc0NvaW47XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVxdWlyZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUwsIENvaW5GZWF0dXJlLlJFUVVJUkVTX0JJR19OVU1CRVJdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXNhbGxvd2VkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtcbiAgICAgIENvaW5GZWF0dXJlLlVOU1BFTlRfTU9ERUwsXG4gICAgICBDb2luRmVhdHVyZS5DSElMRF9QQVlTX0ZPUl9QQVJFTlQsXG4gICAgICBDb2luRmVhdHVyZS5OQVRJVkVfU0VHV0lULFxuICAgICAgQ29pbkZlYXR1cmUuUEFZR08sXG4gICAgICBDb2luRmVhdHVyZS5XUkFQUEVEX1NFR1dJVCxcbiAgICAgIENvaW5GZWF0dXJlLlNVUFBPUlRTX1RPS0VOUyxcbiAgICBdKTtcbiAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mYyhcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuOiBib29sZWFuID0gdHJ1ZVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXg6IHN0cmluZyA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW46IGJvb2xlYW4gPSB0cnVlXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgZXJjMjAgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNlcmMyMChcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuOiBib29sZWFuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW46IHN0cmluZyA9ICdldGgnXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICB9KVxuICApO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBlcmMyMCBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmNlcmMyMChcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuOiBib29sZWFuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW46IHN0cmluZyA9ICd0ZXRoJ1xuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgfSlcbiAgKTtcbn1cbiJdfQ==